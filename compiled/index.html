<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trading App</title>
    <link
      rel="icon"
      type="image/png"
      href="https://raw.githubusercontent.com/KipCrossing/P2PTRADE/main/public/favicon.png"
    />
  </head>
  <body>
    <div id="app"></div>
    <script>
      
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function append(target, node) {
        target.appendChild(node);
    }
    function append_styles(target, style_sheet_id, styles) {
        const append_styles_to = get_root_for_style(target);
        if (!append_styles_to.getElementById(style_sheet_id)) {
            const style = element('style');
            style.id = style_sheet_id;
            style.textContent = styles;
            append_stylesheet(append_styles_to, style);
        }
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    /**
     * List of attributes that should always be set through the attr method,
     * because updating them through the property setter doesn't work reliably.
     * In the example of `width`/`height`, the problem is that the setter only
     * accepts numeric values, but the attribute can also be set to a string like `50%`.
     * If this list becomes too big, rethink this approach.
     */
    const always_set_through_set_attribute = ['width', 'height'];
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function set_custom_element_data_map(node, data_map) {
        Object.keys(data_map).forEach((key) => {
            set_custom_element_data(node, key, data_map[key]);
        });
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function set_dynamic_element_data(tag) {
        return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        if (value == null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                /** #7364  target for <template> may be provided as #document-fragment(11) */
                else
                    this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));
                this.t = target.tagName !== 'TEMPLATE' ? target : target.content;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash$2(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash$2(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * Schedules a callback to run immediately before the component is updated after any state change.
     *
     * The first time the callback runs will be before the initial `onMount`
     *
     * https://svelte.dev/docs#run-time-svelte-beforeupdate
     */
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    /**
     * Associates an arbitrary `context` object with the current component and the specified `key`
     * and returns that object. The context is then available to children of the component
     * (including slotted content) with `getContext`.
     *
     * Like lifecycle functions, this must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-setcontext
     */
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
        return context;
    }
    /**
     * Retrieves the context that belongs to the closest parent component with the specified `key`.
     * Must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-getcontext
     */
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     */
    function flush_render_callbacks(fns) {
        const filtered = [];
        const targets = [];
        render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
        targets.forEach((c) => c());
        render_callbacks = filtered;
    }

    let promise;
    function wait$1() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        const options = { direction: 'both' };
        let config = fn(node, params, options);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait$1().then(() => {
                        // @ts-ignore
                        config = config(options);
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    /** regex of all html void element names */
    const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    function is_void(name) {
        return void_element_names.test(name) || name.toLowerCase() === '!doctype';
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            flush_render_callbacks($$.after_update);
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        if (has_stop_immediate_propagation)
            modifiers.push('stopImmediatePropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    function validate_dynamic_element(tag) {
        const is_string = typeof tag === 'string';
        if (tag && !is_string) {
            throw new Error('<svelte:element> expects "this" attribute to be a string.');
        }
    }
    function validate_void_dynamic_element(tag) {
        if (tag && is_void(tag)) {
            console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
        }
    }
    function construct_svelte_component_dev(component, props) {
        const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
        try {
            const instance = new component(props);
            if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
                throw new Error(error_message);
            }
            return instance;
        }
        catch (err) {
            const { message } = err;
            if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
                throw new Error(error_message);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* node_modules/@svelteuidev/core/dist/internal/errors/Error.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1$5 } = globals;

    // (7:0) {#if observable}
    function create_if_block$l(ctx) {
    	let html_tag;
    	let raw_value = exception(/*component*/ ctx[1], /*code*/ ctx[2]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*component, code*/ 6 && raw_value !== (raw_value = exception(/*component*/ ctx[1], /*code*/ ctx[2]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(7:0) {#if observable}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let if_block_anchor;
    	let if_block = /*observable*/ ctx[0] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1$5("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*observable*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Error', slots, []);
    	let { observable = false } = $$props;
    	let { component } = $$props;
    	let { code } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (component === undefined && !('component' in $$props || $$self.$$.bound[$$self.$$.props['component']])) {
    			console.warn("<Error> was created without expected prop 'component'");
    		}

    		if (code === undefined && !('code' in $$props || $$self.$$.bound[$$self.$$.props['code']])) {
    			console.warn("<Error> was created without expected prop 'code'");
    		}
    	});

    	const writable_props = ['observable', 'component', 'code'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Error> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('observable' in $$props) $$invalidate(0, observable = $$props.observable);
    		if ('component' in $$props) $$invalidate(1, component = $$props.component);
    		if ('code' in $$props) $$invalidate(2, code = $$props.code);
    	};

    	$$self.$capture_state = () => ({ exception, observable, component, code });

    	$$self.$inject_state = $$props => {
    		if ('observable' in $$props) $$invalidate(0, observable = $$props.observable);
    		if ('component' in $$props) $$invalidate(1, component = $$props.component);
    		if ('code' in $$props) $$invalidate(2, code = $$props.code);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [observable, component, code];
    }

    let Error$1 = class Error extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { observable: 0, component: 1, code: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Error",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get observable() {
    		throw new Error_1$5("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set observable(value) {
    		throw new Error_1$5("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error_1$5("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error_1$5("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get code() {
    		throw new Error_1$5("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set code(value) {
    		throw new Error_1$5("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    var Error$2 = Error$1;

    const isBrowser$1 = () => typeof window !== 'undefined';
    /** Determines whether the app is running in the browser or on the server. */
    const browser = isBrowser$1();

    const minifiedCss = '.modal-header{padding: 2px 16px;background-color: #339af0;color: white;}.modal-body{padding: 2px 16px;}.modal-footer{padding: 2px 16px;background-color: #339af0;color: white;}.modal-content{position: relative;background-color: #fefefe;margin: auto;padding: 0;border: 1px solid #888;width: 80%;box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);animation-name: animateTop;animation-duration: 0.4s;}@keyframes animateTop {from {top: -300px; opacity: 0}to {top: 0; opacity: 1}}';

    const style = browser ? document.createElement('style') : undefined;
    if (browser) {
        const s = style;
        s.textContent = minifiedCss;
        s.id = 'svelteui-inject';
    }
    /**
     * The UserException function is used to help consumers of the library better navigate through potential errors.
     *
     *
     * It **does not** throw any errors because crashing the user's application is undesirable
     *
     * @param component the component the error is bound to
     * @param message the error message for the consumer
     * @param solution the potential solution for the consumer
     */
    function UserException(component, message, solution) {
        if (browser)
            document.head.appendChild(style);
        const html = `
    <div class="modal-content">
        <div class="modal-header">
            <h2>[${component} Component Error]:</h2>
            <h3>${message}</h3>
        </div>
        <div class="modal-body">
            <pre>
                ${solution ? solution : ''}
            </pre>
        </div>
        <div class="modal-footer">
            <h3>Fix the code to dismiss this error.</h3>
        </div>
    </div>        
    `;
        return html;
    }

    function exception(component, code) {
        const { message, solution } = code;
        if (solution) {
            return UserException(component, message, solution);
        }
        return UserException(component, message);
    }

    /* eslint-disable @typescript-eslint/no-explicit-any */
    // This file taken from rgossiaux/svelte-headlessui
    // Copyright 2020-present Hunter Perrin
    function useActions(node, actions) {
        const actionReturns = [];
        if (actions) {
            for (let i = 0; i < actions.length; i++) {
                const actionEntry = actions[i];
                const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
                if (Array.isArray(actionEntry) && actionEntry.length > 1) {
                    actionReturns.push(action(node, actionEntry[1]));
                }
                else {
                    actionReturns.push(action(node));
                }
            }
        }
        return {
            update(actions) {
                if (((actions && actions.length) || 0) != actionReturns.length) {
                    throw new Error('You must not change the length of an actions array.');
                }
                if (actions) {
                    for (let i = 0; i < actions.length; i++) {
                        const returnEntry = actionReturns[i];
                        if (returnEntry && returnEntry.update) {
                            const actionEntry = actions[i];
                            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
                                returnEntry.update(actionEntry[1]);
                            }
                            else {
                                returnEntry.update();
                            }
                        }
                    }
                }
            },
            destroy() {
                for (let i = 0; i < actionReturns.length; i++) {
                    const returnEntry = actionReturns[i];
                    if (returnEntry && returnEntry.destroy) {
                        returnEntry.destroy();
                    }
                }
            }
        };
    }

    /* eslint-disable @typescript-eslint/no-empty-function */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const MODIFIER_DIVIDER = '!';
    const modifierRegex = new RegExp(`^[^${MODIFIER_DIVIDER}]+(?:${MODIFIER_DIVIDER}(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$`);
    /** Function for forwarding DOM events to the component's declaration */
    function createEventForwarder(component, except = []) {
        // This is our pseudo $on function. It is defined on component mount.
        let $on;
        // This is a list of events bound before mount.
        const events = [];
        // And we override the $on function to forward all bound events.
        component.$on = (fullEventType, callback) => {
            const eventType = fullEventType;
            let destructor = () => { };
            for (const exception of except) {
                if (typeof exception === 'string' && exception === eventType) {
                    // Bail out of the event forwarding and run the normal Svelte $on() code
                    const callbacks = component.$$.callbacks[eventType] || (component.$$.callbacks[eventType] = []);
                    callbacks.push(callback);
                    return () => {
                        const index = callbacks.indexOf(callback);
                        if (index !== -1)
                            callbacks.splice(index, 1);
                    };
                }
                if (typeof exception === 'object' && exception['name'] === eventType) {
                    const oldCallback = callback;
                    callback = (...props) => {
                        if (!(typeof exception === 'object' && exception['shouldExclude']())) {
                            oldCallback(...props);
                        }
                    };
                }
            }
            if ($on) {
                // The event was bound programmatically.
                destructor = $on(eventType, callback);
            }
            else {
                // The event was bound before mount by Svelte.
                events.push([eventType, callback]);
            }
            return () => {
                destructor();
            };
        };
        function forward(e) {
            // Internally bubble the event up from Svelte components.
            bubble(component, e);
        }
        return (node) => {
            const destructors = [];
            const forwardDestructors = {};
            // This function is responsible for listening and forwarding
            // all bound events.
            $on = (fullEventType, callback) => {
                let eventType = fullEventType;
                let handler = callback;
                // DOM addEventListener options argument.
                let options = false;
                const modifierMatch = eventType.match(modifierRegex);
                if (modifierMatch) {
                    // Parse the event modifiers.
                    // Supported modifiers:
                    // - preventDefault
                    // - stopPropagation
                    // - passive
                    // - nonpassive
                    // - capture
                    // - once
                    const parts = eventType.split(MODIFIER_DIVIDER);
                    eventType = parts[0];
                    const eventOptions = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
                    if (eventOptions.passive) {
                        options = options || {};
                        options.passive = true;
                    }
                    if (eventOptions.nonpassive) {
                        options = options || {};
                        options.passive = false;
                    }
                    if (eventOptions.capture) {
                        options = options || {};
                        options.capture = true;
                    }
                    if (eventOptions.once) {
                        options = options || {};
                        options.once = true;
                    }
                    if (eventOptions.preventDefault) {
                        handler = prevent_default(handler);
                    }
                    if (eventOptions.stopPropagation) {
                        handler = stop_propagation(handler);
                    }
                }
                // Listen for the event directly, with the given options.
                const off = listen(node, eventType, handler, options);
                const destructor = () => {
                    off();
                    const idx = destructors.indexOf(destructor);
                    if (idx > -1) {
                        destructors.splice(idx, 1);
                    }
                };
                destructors.push(destructor);
                // Forward the event from Svelte.
                if (!(eventType in forwardDestructors)) {
                    forwardDestructors[eventType] = listen(node, eventType, forward);
                }
                return destructor;
            };
            for (let i = 0; i < events.length; i++) {
                // Listen to all the events added before mount.
                $on(events[i][0], events[i][1]);
            }
            return {
                destroy: () => {
                    // Remove all event listeners.
                    for (let i = 0; i < destructors.length; i++) {
                        destructors[i]();
                    }
                    // Remove all event forwarders.
                    for (const entry of Object.entries(forwardDestructors)) {
                        entry[1]();
                    }
                }
            };
        };
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }
    function sineInOut(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    }

    function fade$1(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }

    /** --------------------- */
    const key = {};
    function useSvelteUIThemeContext() {
        return getContext(key);
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=} start
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0 && stop) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const colorScheme = writable('light');

    /* eslint-disable @typescript-eslint/ban-ts-comment */
    function useSvelteUITheme() {
        let observer;
        colorScheme?.subscribe((mode) => {
            observer = mode;
        });
        const DEFAULT_THEME = {
            // @ts-ignore
            ...theme,
            colorNames: colorNameMap,
            colorScheme: observer,
            dark: dark?.selector,
            fn: {
                cover: fns.cover,
                themeColor: fns.themeColor,
                size: fns.size,
                radius: fns.radius,
                rgba: fns.rgba,
                variant: fns.variant
            }
        };
        return DEFAULT_THEME;
    }

    /* node_modules/@svelteuidev/core/dist/styles/theme/SvelteUIProvider/SvelteUIProvider.svelte generated by Svelte v3.59.2 */
    const file$r = "node_modules/@svelteuidev/core/dist/styles/theme/SvelteUIProvider/SvelteUIProvider.svelte";

    function create_fragment$L(ctx) {
    	let div;
    	let div_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

    	let div_levels = [
    		{ id: "SVELTEUI_PROVIDER" },
    		{
    			class: div_class_value = /*cx*/ ctx[5](/*className*/ ctx[2], /*classes*/ ctx[4].root, /*currentTheme*/ ctx[3])
    		},
    		/*$$restProps*/ ctx[7]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$r, 49, 0, 1954);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[20](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[6].call(null, div))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				{ id: "SVELTEUI_PROVIDER" },
    				(!current || dirty & /*cx, className, classes, currentTheme*/ 60 && div_class_value !== (div_class_value = /*cx*/ ctx[5](/*className*/ ctx[2], /*classes*/ ctx[4].root, /*currentTheme*/ ctx[3]))) && { class: div_class_value },
    				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[20](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let overrides;
    	let mergedTheme;
    	let cx;
    	let classes;

    	const omit_props_names = [
    		"use","class","element","theme","styles","defaultProps","themeObserver","withNormalizeCSS","withGlobalStyles","override","inherit"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $colorScheme;
    	validate_store(colorScheme, 'colorScheme');
    	component_subscribe($$self, colorScheme, $$value => $$invalidate(21, $colorScheme = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SvelteUIProvider', slots, ['default']);
    	let { use = [], class: className = '', element = undefined, theme = useSvelteUITheme(), styles = {}, defaultProps = {}, themeObserver = 'light', withNormalizeCSS = false, withGlobalStyles = false, override = {}, inherit = false } = $$props;

    	beforeUpdate(() => {
    		const htmlClassList = document.documentElement.classList;
    		if ($colorScheme === 'dark') htmlClassList.add(dark.className);
    		if ($colorScheme === 'light') htmlClassList.remove(dark.className);
    	});

    	const ctx = useSvelteUIThemeContext();
    	const useStyles = createStyles(() => ({ root: {} }));
    	const forwardEvents = createEventForwarder(get_current_component());
    	const DEFAULT_THEME = useSvelteUITheme();
    	let currentTheme = null;

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('theme' in $$new_props) $$invalidate(8, theme = $$new_props.theme);
    		if ('styles' in $$new_props) $$invalidate(9, styles = $$new_props.styles);
    		if ('defaultProps' in $$new_props) $$invalidate(10, defaultProps = $$new_props.defaultProps);
    		if ('themeObserver' in $$new_props) $$invalidate(11, themeObserver = $$new_props.themeObserver);
    		if ('withNormalizeCSS' in $$new_props) $$invalidate(12, withNormalizeCSS = $$new_props.withNormalizeCSS);
    		if ('withGlobalStyles' in $$new_props) $$invalidate(13, withGlobalStyles = $$new_props.withGlobalStyles);
    		if ('override' in $$new_props) $$invalidate(14, override = $$new_props.override);
    		if ('inherit' in $$new_props) $$invalidate(15, inherit = $$new_props.inherit);
    		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		beforeUpdate,
    		get_current_component,
    		mergeTheme,
    		useSvelteUITheme,
    		colorScheme,
    		key,
    		useSvelteUIThemeContext,
    		createStyles,
    		dark,
    		NormalizeCSS,
    		SvelteUIGlobalCSS,
    		createEventForwarder,
    		useActions,
    		use,
    		className,
    		element,
    		theme,
    		styles,
    		defaultProps,
    		themeObserver,
    		withNormalizeCSS,
    		withGlobalStyles,
    		override,
    		inherit,
    		ctx,
    		useStyles,
    		forwardEvents,
    		DEFAULT_THEME,
    		currentTheme,
    		classes,
    		cx,
    		overrides,
    		mergedTheme,
    		$colorScheme
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('theme' in $$props) $$invalidate(8, theme = $$new_props.theme);
    		if ('styles' in $$props) $$invalidate(9, styles = $$new_props.styles);
    		if ('defaultProps' in $$props) $$invalidate(10, defaultProps = $$new_props.defaultProps);
    		if ('themeObserver' in $$props) $$invalidate(11, themeObserver = $$new_props.themeObserver);
    		if ('withNormalizeCSS' in $$props) $$invalidate(12, withNormalizeCSS = $$new_props.withNormalizeCSS);
    		if ('withGlobalStyles' in $$props) $$invalidate(13, withGlobalStyles = $$new_props.withGlobalStyles);
    		if ('override' in $$props) $$invalidate(14, override = $$new_props.override);
    		if ('inherit' in $$props) $$invalidate(15, inherit = $$new_props.inherit);
    		if ('currentTheme' in $$props) $$invalidate(3, currentTheme = $$new_props.currentTheme);
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(5, cx = $$new_props.cx);
    		if ('overrides' in $$props) $$invalidate(16, overrides = $$new_props.overrides);
    		if ('mergedTheme' in $$props) $$invalidate(17, mergedTheme = $$new_props.mergedTheme);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*inherit, theme, styles, defaultProps*/ 34560) {
    			$$invalidate(16, overrides = {
    				themeOverride: inherit ? { ...ctx.theme, ...theme } : theme,
    				styles: inherit ? { ...ctx.styles, ...styles } : styles,
    				defaultProps: inherit
    				? { ...ctx.styles, ...defaultProps }
    				: defaultProps
    			});
    		}

    		if ($$self.$$.dirty & /*overrides*/ 65536) {
    			$$invalidate(17, mergedTheme = mergeTheme(DEFAULT_THEME, overrides.themeOverride));
    		}

    		if ($$self.$$.dirty & /*themeObserver, mergedTheme*/ 133120) {
    			{
    				if (themeObserver !== null) {
    					$$invalidate(3, currentTheme = themeObserver === 'light' ? mergedTheme : dark);
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*withGlobalStyles*/ 8192) {
    			if (withGlobalStyles) SvelteUIGlobalCSS();
    		}

    		if ($$self.$$.dirty & /*withNormalizeCSS*/ 4096) {
    			if (withNormalizeCSS) NormalizeCSS();
    		}

    		if ($$self.$$.dirty & /*overrides*/ 65536) {
    			setContext(key, {
    				theme: overrides.themeOverride,
    				styles: {},
    				defaultProps: {}
    			});
    		}

    		if ($$self.$$.dirty & /*themeObserver*/ 2048) {
    			colorScheme.set(themeObserver);
    		}

    		if ($$self.$$.dirty & /*override*/ 16384) {
    			$$invalidate(5, { cx, classes } = useStyles(null, { override }), cx, ($$invalidate(4, classes), $$invalidate(14, override)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		currentTheme,
    		classes,
    		cx,
    		forwardEvents,
    		$$restProps,
    		theme,
    		styles,
    		defaultProps,
    		themeObserver,
    		withNormalizeCSS,
    		withGlobalStyles,
    		override,
    		inherit,
    		overrides,
    		mergedTheme,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class SvelteUIProvider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
    			use: 1,
    			class: 2,
    			element: 0,
    			theme: 8,
    			styles: 9,
    			defaultProps: 10,
    			themeObserver: 11,
    			withNormalizeCSS: 12,
    			withGlobalStyles: 13,
    			override: 14,
    			inherit: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SvelteUIProvider",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get use() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultProps() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultProps(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get themeObserver() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set themeObserver(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withNormalizeCSS() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withNormalizeCSS(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withGlobalStyles() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withGlobalStyles(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inherit() {
    		throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inherit(value) {
    		throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var SvelteUIProvider$1 = SvelteUIProvider;

    function themeColor(color, shade = 0) {
        const theme = useSvelteUIThemeContext()?.theme || useSvelteUITheme();
        let _shade = '50';
        if (!isSvelteUIColor(color))
            return color;
        if (shade !== Number(0))
            _shade = `${shade.toString()}00`;
        return theme.colors[`${color}${_shade}`]?.value;
    }
    function isSvelteUIColor(color) {
        let valid = false;
        switch (color) {
            case 'dark':
                valid = true;
                break;
            case 'gray':
                valid = true;
                break;
            case 'red':
                valid = true;
                break;
            case 'pink':
                valid = true;
                break;
            case 'grape':
                valid = true;
                break;
            case 'violet':
                valid = true;
                break;
            case 'indigo':
                valid = true;
                break;
            case 'blue':
                valid = true;
                break;
            case 'cyan':
                valid = true;
                break;
            case 'teal':
                valid = true;
                break;
            case 'green':
                valid = true;
                break;
            case 'lime':
                valid = true;
                break;
            case 'yellow':
                valid = true;
                break;
            case 'orange':
                valid = true;
                break;
            default:
                valid = false;
                break;
        }
        return valid;
    }

    function isHexColor(hex) {
        const replaced = hex.replace('#', '');
        return (typeof replaced === 'string' && replaced.length === 6 && !Number.isNaN(Number(`0x${replaced}`)));
    }
    function hexToRgba(color) {
        const replaced = color.replace('#', '');
        const parsed = parseInt(replaced, 16);
        const r = (parsed >> 16) & 255;
        const g = (parsed >> 8) & 255;
        const b = parsed & 255;
        return {
            r,
            g,
            b,
            a: 1
        };
    }
    function rgbStringToRgba(color) {
        const [r, g, b, a] = color
            .replace(/[^0-9,.]/g, '')
            .split(',')
            .map(Number);
        return { r, g, b, a: a || 1 };
    }
    function toRgba(color) {
        if (isHexColor(color)) {
            return hexToRgba(color);
        }
        if (color.startsWith('rgb')) {
            return rgbStringToRgba(color);
        }
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
    }

    const vFunc = (color, gradient) => {
        const { themeColor, rgba } = fns;
        const variants = {
            /** Filled variant */
            filled: {
                [`${dark.selector} &`]: {
                    backgroundColor: themeColor(color, 8)
                },
                border: 'transparent',
                backgroundColor: themeColor(color, 6),
                color: 'White',
                '&:hover': { backgroundColor: themeColor(color, 7) }
            },
            /** Light variant */
            light: {
                [`${dark.selector} &`]: {
                    backgroundColor: rgba(themeColor(color, 8), 0.35),
                    color: color === 'dark' ? themeColor('dark', 0) : themeColor(color, 2),
                    '&:hover': { backgroundColor: rgba(themeColor(color, 7), 0.45) }
                },
                border: 'transparent',
                backgroundColor: themeColor(color, 0),
                color: color === 'dark' ? themeColor('dark', 9) : themeColor(color, 6),
                '&:hover': { backgroundColor: themeColor(color, 1) }
            },
            /** Outline variant */
            outline: {
                [`${dark.selector} &`]: {
                    border: `1px solid ${themeColor(color, 4)}`,
                    color: `${themeColor(color, 4)}`,
                    '&:hover': { backgroundColor: rgba(themeColor(color, 4), 0.05) }
                },
                border: `1px solid ${themeColor(color, 7)}`,
                backgroundColor: 'transparent',
                color: themeColor(color, 7),
                '&:hover': {
                    backgroundColor: rgba(themeColor(color, 0), 0.35)
                }
            },
            /** Subtle variant */
            subtle: {
                [`${dark.selector} &`]: {
                    color: color === 'dark' ? themeColor('dark', 0) : themeColor(color, 2),
                    '&:hover': { backgroundColor: rgba(themeColor(color, 8), 0.35) }
                },
                border: 'transparent',
                backgroundColor: 'transparent',
                color: color === 'dark' ? themeColor('dark', 9) : themeColor(color, 6),
                '&:hover': {
                    backgroundColor: themeColor(color, 0)
                }
            },
            /** Default variant */
            default: {
                [`${dark.selector} &`]: {
                    border: `1px solid ${themeColor('dark', 5)}`,
                    backgroundColor: themeColor('dark', 5),
                    color: 'White',
                    '&:hover': { backgroundColor: themeColor('dark', 4) }
                },
                border: `1px solid ${themeColor('gray', 4)}`,
                backgroundColor: 'White',
                color: 'Black',
                '&:hover': { backgroundColor: themeColor('gray', 0) }
            },
            /** White variant */
            white: {
                border: 'transparent',
                backgroundColor: 'White',
                color: themeColor(color, 7),
                '&:hover': { backgroundColor: 'White' }
            },
            gradient: {}
        };
        if (gradient) {
            /** Gradient variant */
            variants.gradient = {
                border: 'transparent',
                background: `linear-gradient(${gradient.deg}deg, $${gradient.from}600 0%, $${gradient.to}600 100%)`,
                color: 'White'
            };
        }
        return variants;
    };

    function randomID(prefix = 'svelteui') {
        return `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
    }

    function createConverter(units) {
        return (px) => {
            if (typeof px === 'number') {
                return `${px / 16}${units}`;
            }
            if (typeof px === 'string') {
                const replaced = px.replace('px', '');
                if (!Number.isNaN(Number(replaced))) {
                    return `${Number(replaced) / 16}${units}`;
                }
            }
            return px;
        };
    }
    const rem = createConverter('rem');

    function mergeTheme(currentTheme, themeOverride) {
        if (!themeOverride) {
            return currentTheme;
        }
        return Object.keys(currentTheme).reduce((acc, key) => {
            acc[key] =
                typeof themeOverride[key] === 'object'
                    ? { ...currentTheme[key], ...themeOverride[key] }
                    : typeof themeOverride[key] === 'number'
                        ? themeOverride[key]
                        : themeOverride[key] || currentTheme[key];
            return acc;
        }, {});
    }

    function cover(offset = 0) {
        return {
            position: 'absolute',
            top: rem(offset),
            right: rem(offset),
            left: rem(offset),
            bottom: rem(offset)
        };
    }

    function size$2(props) {
        if (typeof props.size === 'number') {
            return props.size;
        }
        if (typeof props.sizes[props.size] === 'number') {
            return props.sizes[props.size];
        }
        return +props.sizes[props.size]?.value || +props.sizes.md?.value;
    }

    function radius(radii) {
        const theme = useSvelteUIThemeContext()?.theme || useSvelteUITheme();
        if (typeof radii === 'number') {
            return radii;
        }
        return theme.radii[radii].value;
    }

    function rgba(color, alpha = 1) {
        if (typeof color !== 'string' || alpha > 1 || alpha < 0) {
            return 'rgba(0, 0, 0, 1)';
        }
        const { r, g, b } = toRgba(color);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    const DEFAULT_GRADIENT = {
        from: 'indigo',
        to: 'cyan',
        deg: 45
    };
    /**
     * THe Variant function is a function that takes a variant, optional color/gradient and returns the desired styles for four specific properties.
     *
     * Some styles will return tuples of strings where the first value is the dark version of the specific style, and the second value is the light version.
     *
     * @param VariantInput - an object that has a variant, color, and optional gradient property
     * @returns an object with border, background, color, and hover property styles based on the variant
     */
    function variant({ variant, color, gradient }) {
        const theme = useSvelteUIThemeContext()?.theme || useSvelteUITheme();
        const primaryShade = 6;
        if (variant === 'light') {
            return {
                border: 'transparent',
                background: [rgba(themeColor(color, 8), 0.35), rgba(themeColor(color, 0), 1)],
                color: [
                    color === 'dark' ? themeColor('dark', 0) : themeColor(color, 2),
                    color === 'dark' ? themeColor('dark', 9) : themeColor(color, primaryShade)
                ],
                // themeColor(color, theme.colorScheme === 'dark' ? 2 : getPrimaryShade('light')),
                hover: [rgba(themeColor(color, 7), 0.45), rgba(themeColor(color, 1), 0.65)]
            };
        }
        if (variant === 'default') {
            return {
                border: [themeColor('dark', 5), themeColor('gray', 4)],
                background: [themeColor('dark', 5), theme.colors.white.value],
                color: [theme.colors.white.value, theme.colors.black.value],
                hover: [themeColor('dark', 4), themeColor('gray', 0)]
            };
        }
        if (variant === 'white') {
            return {
                border: 'transparent',
                background: theme.colors.white.value,
                color: themeColor(color, primaryShade),
                hover: null
            };
        }
        if (variant === 'outline') {
            return {
                border: [themeColor(color, 4), themeColor(color, primaryShade)],
                background: 'transparent',
                color: [themeColor(color, 4), themeColor(color, primaryShade)],
                hover: [rgba(themeColor(color, 4), 0.05), rgba(themeColor(color, 0), 0.35)]
            };
        }
        if (variant === 'gradient') {
            const merged = {
                from: gradient?.from || DEFAULT_GRADIENT.from,
                to: gradient?.to || DEFAULT_GRADIENT.to,
                deg: gradient?.deg || DEFAULT_GRADIENT.deg
            };
            return {
                background: `linear-gradient(${merged.deg}deg, ${themeColor(merged.from, primaryShade)} 0%, ${themeColor(merged.to, primaryShade)} 100%)`,
                color: theme.colors.white.value,
                border: 'transparent',
                hover: null
            };
        }
        if (variant === 'subtle') {
            return {
                border: 'transparent',
                background: 'transparent',
                color: [
                    color === 'dark' ? themeColor('dark', 0) : themeColor(color, 2),
                    color === 'dark' ? themeColor('dark', 9) : themeColor(color, primaryShade)
                ],
                hover: [rgba(themeColor(color, 8), 0.35), rgba(themeColor(color, 0), 1)]
            };
        }
        return {
            border: 'transparent',
            background: [themeColor(color, 8), themeColor(color, primaryShade)],
            color: theme.colors.white.value,
            hover: themeColor(color, 7)
        };
    }

    const fns = {
        cover,
        size: size$2,
        radius,
        themeColor,
        variant,
        rgba
    };

    const colors = {
        primary: '#228be6',
        white: '#ffffff',
        black: '#000000',
        dark50: '#C1C2C5',
        dark100: '#A6A7AB',
        dark200: '#909296',
        dark300: '#5c5f66',
        dark400: '#373A40',
        dark500: '#2C2E33',
        dark600: '#25262b',
        dark700: '#1A1B1E',
        dark800: '#141517',
        dark900: '#101113',
        gray50: '#f8f9fa',
        gray100: '#f1f3f5',
        gray200: '#e9ecef',
        gray300: '#dee2e6',
        gray400: '#ced4da',
        gray500: '#adb5bd',
        gray600: '#868e96',
        gray700: '#495057',
        gray800: '#343a40',
        gray900: '#212529',
        red50: '#fff5f5',
        red100: '#ffe3e3',
        red200: '#ffc9c9',
        red300: '#ffa8a8',
        red400: '#ff8787',
        red500: '#ff6b6b',
        red600: '#fa5252',
        red700: '#f03e3e',
        red800: '#e03131',
        red900: '#c92a2a',
        pink50: '#fff0f6',
        pink100: '#ffdeeb',
        pink200: '#fcc2d7',
        pink300: '#faa2c1',
        pink400: '#f783ac',
        pink500: '#f06595',
        pink600: '#e64980',
        pink700: '#d6336c',
        pink800: '#c2255c',
        pink900: '#a61e4d',
        grape50: '#f8f0fc',
        grape100: '#f3d9fa',
        grape200: '#eebefa',
        grape300: '#e599f7',
        grape400: '#da77f2',
        grape500: '#cc5de8',
        grape600: '#be4bdb',
        grape700: '#ae3ec9',
        grape800: '#9c36b5',
        grape900: '#862e9c',
        violet50: '#f3f0ff',
        violet100: '#e5dbff',
        violet200: '#d0bfff',
        violet300: '#b197fc',
        violet400: '#9775fa',
        violet500: '#845ef7',
        violet600: '#7950f2',
        violet700: '#7048e8',
        violet800: '#6741d9',
        violet900: '#5f3dc4',
        indigo50: '#edf2ff',
        indigo100: '#dbe4ff',
        indigo200: '#bac8ff',
        indigo300: '#91a7ff',
        indigo400: '#748ffc',
        indigo500: '#5c7cfa',
        indigo600: '#4c6ef5',
        indigo700: '#4263eb',
        indigo800: '#3b5bdb',
        indigo900: '#364fc7',
        blue50: '#e7f5ff',
        blue100: '#d0ebff',
        blue200: '#a5d8ff',
        blue300: '#74c0fc',
        blue400: '#4dabf7',
        blue500: '#339af0',
        blue600: '#228be6',
        blue700: '#1c7ed6',
        blue800: '#1971c2',
        blue900: '#1864ab',
        cyan50: '#e3fafc',
        cyan100: '#c5f6fa',
        cyan200: '#99e9f2',
        cyan300: '#66d9e8',
        cyan400: '#3bc9db',
        cyan500: '#22b8cf',
        cyan600: '#15aabf',
        cyan700: '#1098ad',
        cyan800: '#0c8599',
        cyan900: '#0b7285',
        teal50: '#e6fcf5',
        teal100: '#c3fae8',
        teal200: '#96f2d7',
        teal300: '#63e6be',
        teal400: '#38d9a9',
        teal500: '#20c997',
        teal600: '#12b886',
        teal700: '#0ca678',
        teal800: '#099268',
        teal900: '#087f5b',
        green50: '#ebfbee',
        green100: '#d3f9d8',
        green200: '#b2f2bb',
        green300: '#8ce99a',
        green400: '#69db7c',
        green500: '#51cf66',
        green600: '#40c057',
        green700: '#37b24d',
        green800: '#2f9e44',
        green900: '#2b8a3e',
        lime50: '#f4fce3',
        lime100: '#e9fac8',
        lime200: '#d8f5a2',
        lime300: '#c0eb75',
        lime400: '#a9e34b',
        lime500: '#94d82d',
        lime600: '#82c91e',
        lime700: '#74b816',
        lime800: '#66a80f',
        lime900: '#5c940d',
        yellow50: '#fff9db',
        yellow100: '#fff3bf',
        yellow200: '#ffec99',
        yellow300: '#ffe066',
        yellow400: '#ffd43b',
        yellow500: '#fcc419',
        yellow600: '#fab005',
        yellow700: '#f59f00',
        yellow800: '#f08c00',
        yellow900: '#e67700',
        orange50: '#fff4e6',
        orange100: '#ffe8cc',
        orange200: '#ffd8a8',
        orange300: '#ffc078',
        orange400: '#ffa94d',
        orange500: '#ff922b',
        orange600: '#fd7e14',
        orange700: '#f76707',
        orange800: '#e8590c',
        orange900: '#d9480f'
    };
    const colorNameMap = {
        blue: 'blue',
        cyan: 'cyan',
        dark: 'dark',
        grape: 'grape',
        gray: 'gray',
        green: 'green',
        indigo: 'indigo',
        lime: 'lime',
        orange: 'orange',
        pink: 'pink',
        red: 'red',
        teal: 'teal',
        violet: 'violet',
        yellow: 'yellow'
    };

    const hasOwn = {}.hasOwnProperty;
    function cx(...args) {
        const classes = [];
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (!arg)
                continue;
            const argType = typeof arg;
            if (argType === 'string' || argType === 'number') {
                classes.push(arg);
            }
            else if (Array.isArray(arg)) {
                if (arg.length) {
                    const inner = { ...arg };
                    if (inner) {
                        classes.push(inner);
                    }
                }
            }
            else if (argType === 'object') {
                if (arg.toString === Object.prototype.toString) {
                    for (const key in arg) {
                        if (hasOwn.call(arg, key) && arg[key]) {
                            classes.push(key);
                        }
                    }
                }
                else {
                    classes.push(arg.toString());
                }
            }
        }
        return classes.join(' ');
    }
    function cssFactory() {
        // This is a factory function to allow for scalability
        return { cx };
    }

    function fromEntries(entries) {
        const o = {};
        Object.keys(entries).forEach((key) => {
            const [k, v] = entries[key];
            o[k] = v;
        });
        return o;
    }

    /* eslint-disable @typescript-eslint/no-unused-vars */
    const CLASS_KEY = 'svelteui';
    function createRef(refName) {
        return `__svelteui-ref-${refName || ''}`;
    }
    /**
     * Sanitizes the provided CSS object, converting certain keywords to
     * respective CSS selectors, transforms keys into generated CSS classes
     * and returns the mapping between these generated classes and their initial
     * keys.
     *
     * @param object The CSS object that has not yet been sanitized.
     * @param theme The current theme object.
     * @param ref The ref object.
     * @returns The class map that maps the name of the key in the CSS object
     * and the generated hash class.
     */
    function sanitizeCss(object, theme) {
        // builds this to map the generated class name to the class key
        // given in the CSS object
        const refs = [];
        const classMap = {};
        const _sanitizeVariants = (obj) => {
            const variants = Object.keys(obj.variation);
            for (const variant of variants) {
                _sanitize(obj.variation[variant]);
            }
        };
        const _sanitize = (obj) => {
            Object.keys(obj).map((value) => {
                // transforms certain keywords into the correct CSS selectors
                if (value === 'variants') {
                    _sanitizeVariants(obj[value]);
                    return;
                }
                // saves the reference value so that later it can be added
                // to reference the CSS selector
                if (value === 'ref') {
                    refs.push(obj.ref);
                }
                if (value === 'darkMode') {
                    obj[`${theme.dark} &`] = obj.darkMode;
                }
                // returns the recursive call if the CSS is not an object
                if (obj[value] === null || typeof obj[value] !== 'object')
                    return;
                // calls the sanitize method recursively so that it can sanitize
                // all the style objects
                _sanitize(obj[value]);
                // removes the darkMode style since it has been switched
                // to the correct CSS selector
                if (value === 'darkMode') {
                    delete obj[value];
                }
                else if (value.startsWith('@media')) ;
                // only adds the correct selectors if it has none
                else if (!value.startsWith('&') && !value.startsWith(theme.dark)) {
                    const getStyles = css(obj[value]);
                    classMap[value] = getStyles().toString();
                    obj[`& .${getStyles().toString()}`] = obj[value];
                    delete obj[value];
                }
            });
        };
        _sanitize(object);
        // deletes the root key since it won't be sanitized here
        delete object['& .root'];
        return { classMap, refs: Array.from(new Set(refs)) };
    }
    function createStyles(input) {
        const getCssObject = typeof input === 'function' ? input : () => input;
        function useStyles(params = {}, options) {
            // uses the theme present in the current context or fallbacks to the default theme
            const theme = useSvelteUIThemeContext()?.theme || useSvelteUITheme();
            const { cx } = cssFactory();
            const { override, name } = options || {};
            const dirtyCssObject = getCssObject(theme, params, createRef);
            // builds the CSS object that contains transformed values
            const sanitizedCss = Object.assign({}, dirtyCssObject);
            const { classMap, refs } = sanitizeCss(sanitizedCss, theme);
            const root = dirtyCssObject['root'] ?? undefined;
            const cssObjectClean = root !== undefined ? { ...root, ...sanitizedCss } : dirtyCssObject;
            const getStyles = css(cssObjectClean);
            // transforms the keys into strings to be consumed by the classes
            const classes = fromEntries(Object.keys(dirtyCssObject).map((keys) => {
                const ref = refs.find((r) => r.includes(keys)) ?? '';
                const getRefName = ref?.split('-') ?? [];
                const keyIsRef = ref?.split('-')[getRefName?.length - 1] === keys;
                const value = keys.toString();
                let transformedClasses = classMap[value] ?? value;
                // add the value to the array if the ref provided is valid
                if (ref && keyIsRef) {
                    transformedClasses = `${transformedClasses} ${ref}`;
                }
                // generates the root styles, applying the override styles
                if (keys === 'root') {
                    transformedClasses = getStyles({ css: override }).toString();
                }
                // adds a custom class that can be used to override style
                let libClass = `${CLASS_KEY}-${keys.toString()}`;
                if (name) {
                    libClass = `${CLASS_KEY}-${name}-${keys.toString()}`;
                    transformedClasses = `${transformedClasses} ${libClass}`;
                }
                return [keys, transformedClasses];
            }));
            return {
                cx,
                theme,
                classes,
                getStyles: css(cssObjectClean)
            };
        }
        return useStyles;
    }

    var t="colors",n="sizes",r="space",i={gap:r,gridGap:r,columnGap:r,gridColumnGap:r,rowGap:r,gridRowGap:r,inset:r,insetBlock:r,insetBlockEnd:r,insetBlockStart:r,insetInline:r,insetInlineEnd:r,insetInlineStart:r,margin:r,marginTop:r,marginRight:r,marginBottom:r,marginLeft:r,marginBlock:r,marginBlockEnd:r,marginBlockStart:r,marginInline:r,marginInlineEnd:r,marginInlineStart:r,padding:r,paddingTop:r,paddingRight:r,paddingBottom:r,paddingLeft:r,paddingBlock:r,paddingBlockEnd:r,paddingBlockStart:r,paddingInline:r,paddingInlineEnd:r,paddingInlineStart:r,top:r,right:r,bottom:r,left:r,scrollMargin:r,scrollMarginTop:r,scrollMarginRight:r,scrollMarginBottom:r,scrollMarginLeft:r,scrollMarginX:r,scrollMarginY:r,scrollMarginBlock:r,scrollMarginBlockEnd:r,scrollMarginBlockStart:r,scrollMarginInline:r,scrollMarginInlineEnd:r,scrollMarginInlineStart:r,scrollPadding:r,scrollPaddingTop:r,scrollPaddingRight:r,scrollPaddingBottom:r,scrollPaddingLeft:r,scrollPaddingX:r,scrollPaddingY:r,scrollPaddingBlock:r,scrollPaddingBlockEnd:r,scrollPaddingBlockStart:r,scrollPaddingInline:r,scrollPaddingInlineEnd:r,scrollPaddingInlineStart:r,fontSize:"fontSizes",background:t,backgroundColor:t,backgroundImage:t,borderImage:t,border:t,borderBlock:t,borderBlockEnd:t,borderBlockStart:t,borderBottom:t,borderBottomColor:t,borderColor:t,borderInline:t,borderInlineEnd:t,borderInlineStart:t,borderLeft:t,borderLeftColor:t,borderRight:t,borderRightColor:t,borderTop:t,borderTopColor:t,caretColor:t,color:t,columnRuleColor:t,fill:t,outline:t,outlineColor:t,stroke:t,textDecorationColor:t,fontFamily:"fonts",fontWeight:"fontWeights",lineHeight:"lineHeights",letterSpacing:"letterSpacings",blockSize:n,minBlockSize:n,maxBlockSize:n,inlineSize:n,minInlineSize:n,maxInlineSize:n,width:n,minWidth:n,maxWidth:n,height:n,minHeight:n,maxHeight:n,flexBasis:n,gridTemplateColumns:n,gridTemplateRows:n,borderWidth:"borderWidths",borderTopWidth:"borderWidths",borderRightWidth:"borderWidths",borderBottomWidth:"borderWidths",borderLeftWidth:"borderWidths",borderStyle:"borderStyles",borderTopStyle:"borderStyles",borderRightStyle:"borderStyles",borderBottomStyle:"borderStyles",borderLeftStyle:"borderStyles",borderRadius:"radii",borderTopLeftRadius:"radii",borderTopRightRadius:"radii",borderBottomRightRadius:"radii",borderBottomLeftRadius:"radii",boxShadow:"shadows",textShadow:"shadows",transition:"transitions",zIndex:"zIndices"},o=(e,t)=>"function"==typeof t?{"()":Function.prototype.toString.call(t)}:t,l=()=>{const e=Object.create(null);return (t,n,...r)=>{const i=(e=>JSON.stringify(e,o))(t);return i in e?e[i]:e[i]=n(t,...r)}},s=Symbol.for("sxs.internal"),a=(e,t)=>Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)),c=e=>{for(const t in e)return !0;return !1},{hasOwnProperty:d}=Object.prototype,g=e=>e.includes("-")?e:e.replace(/[A-Z]/g,(e=>"-"+e.toLowerCase())),p=/\s+(?![^()]*\))/,u=e=>t=>e(..."string"==typeof t?String(t).split(p):[t]),h={appearance:e=>({WebkitAppearance:e,appearance:e}),backfaceVisibility:e=>({WebkitBackfaceVisibility:e,backfaceVisibility:e}),backdropFilter:e=>({WebkitBackdropFilter:e,backdropFilter:e}),backgroundClip:e=>({WebkitBackgroundClip:e,backgroundClip:e}),boxDecorationBreak:e=>({WebkitBoxDecorationBreak:e,boxDecorationBreak:e}),clipPath:e=>({WebkitClipPath:e,clipPath:e}),content:e=>({content:e.includes('"')||e.includes("'")||/^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e)?e:`"${e}"`}),hyphens:e=>({WebkitHyphens:e,hyphens:e}),maskImage:e=>({WebkitMaskImage:e,maskImage:e}),maskSize:e=>({WebkitMaskSize:e,maskSize:e}),tabSize:e=>({MozTabSize:e,tabSize:e}),textSizeAdjust:e=>({WebkitTextSizeAdjust:e,textSizeAdjust:e}),userSelect:e=>({WebkitUserSelect:e,userSelect:e}),marginBlock:u(((e,t)=>({marginBlockStart:e,marginBlockEnd:t||e}))),marginInline:u(((e,t)=>({marginInlineStart:e,marginInlineEnd:t||e}))),maxSize:u(((e,t)=>({maxBlockSize:e,maxInlineSize:t||e}))),minSize:u(((e,t)=>({minBlockSize:e,minInlineSize:t||e}))),paddingBlock:u(((e,t)=>({paddingBlockStart:e,paddingBlockEnd:t||e}))),paddingInline:u(((e,t)=>({paddingInlineStart:e,paddingInlineEnd:t||e})))},f=/([\d.]+)([^]*)/,m=(e,t)=>e.length?e.reduce(((e,n)=>(e.push(...t.map((e=>e.includes("&")?e.replace(/&/g,/[ +>|~]/.test(n)&&/&.*&/.test(e)?`:is(${n})`:n):n+" "+e))),e)),[]):t,b=(e,t)=>e in S&&"string"==typeof t?t.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,((t,n,r,i)=>n+("stretch"===r?`-moz-available${i};${g(e)}:${n}-webkit-fill-available`:`-moz-fit-content${i};${g(e)}:${n}fit-content`)+i)):String(t),S={blockSize:1,height:1,inlineSize:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,width:1},k=e=>e?e+"-":"",y=(e,t,n)=>e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,((e,r,i,o,l)=>"$"==o==!!i?e:(r||"--"==o?"calc(":"")+"var(--"+("$"===o?k(t)+(l.includes("$")?"":k(n))+l.replace(/\$/g,"-"):l)+")"+(r||"--"==o?"*"+(r||"")+(i||"1")+")":""))),B=/\s*,\s*(?![^()]*\))/,$=Object.prototype.toString,x=(e,t,n,r,i)=>{let o,l,s;const a=(e,t,n)=>{let c,d;const p=e=>{for(c in e){const x=64===c.charCodeAt(0),z=x&&Array.isArray(e[c])?e[c]:[e[c]];for(d of z){const e=/[A-Z]/.test(S=c)?S:S.replace(/-[^]/g,(e=>e[1].toUpperCase())),z="object"==typeof d&&d&&d.toString===$&&(!r.utils[e]||!t.length);if(e in r.utils&&!z){const t=r.utils[e];if(t!==l){l=t,p(t(d)),l=null;continue}}else if(e in h){const t=h[e];if(t!==s){s=t,p(t(d)),s=null;continue}}if(x&&(u=c.slice(1)in r.media?"@media "+r.media[c.slice(1)]:c,c=u.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,((e,t,n,r,i,o)=>{const l=f.test(t),s=.0625*(l?-1:1),[a,c]=l?[r,t]:[t,r];return "("+("="===n[0]?"":">"===n[0]===l?"max-":"min-")+a+":"+("="!==n[0]&&1===n.length?c.replace(f,((e,t,r)=>Number(t)+s*(">"===n?1:-1)+r)):c)+(i?") and ("+(">"===i[0]?"min-":"max-")+a+":"+(1===i.length?o.replace(f,((e,t,n)=>Number(t)+s*(">"===i?-1:1)+n)):o):"")+")"}))),z){const e=x?n.concat(c):[...n],r=x?[...t]:m(t,c.split(B));void 0!==o&&i(I(...o)),o=void 0,a(d,r,e);}else void 0===o&&(o=[[],t,n]),c=x||36!==c.charCodeAt(0)?c:`--${k(r.prefix)}${c.slice(1).replace(/\$/g,"-")}`,d=z?d:"number"==typeof d?d&&e in R?String(d)+"px":String(d):y(b(e,null==d?"":d),r.prefix,r.themeMap[e]),o[0].push(`${x?`${c} `:`${g(c)}:`}${d}`);}}var u,S;};p(e),void 0!==o&&i(I(...o)),o=void 0;};a(e,t,n);},I=(e,t,n)=>`${n.map((e=>`${e}{`)).join("")}${t.length?`${t.join(",")}{`:""}${e.join(";")}${t.length?"}":""}${Array(n.length?n.length+1:0).join("}")}`,R={animationDelay:1,animationDuration:1,backgroundSize:1,blockSize:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockEndWidth:1,borderBlockStart:1,borderBlockStartWidth:1,borderBlockWidth:1,borderBottom:1,borderBottomLeftRadius:1,borderBottomRightRadius:1,borderBottomWidth:1,borderEndEndRadius:1,borderEndStartRadius:1,borderInlineEnd:1,borderInlineEndWidth:1,borderInlineStart:1,borderInlineStartWidth:1,borderInlineWidth:1,borderLeft:1,borderLeftWidth:1,borderRadius:1,borderRight:1,borderRightWidth:1,borderSpacing:1,borderStartEndRadius:1,borderStartStartRadius:1,borderTop:1,borderTopLeftRadius:1,borderTopRightRadius:1,borderTopWidth:1,borderWidth:1,bottom:1,columnGap:1,columnRule:1,columnRuleWidth:1,columnWidth:1,containIntrinsicSize:1,flexBasis:1,fontSize:1,gap:1,gridAutoColumns:1,gridAutoRows:1,gridTemplateColumns:1,gridTemplateRows:1,height:1,inlineSize:1,inset:1,insetBlock:1,insetBlockEnd:1,insetBlockStart:1,insetInline:1,insetInlineEnd:1,insetInlineStart:1,left:1,letterSpacing:1,margin:1,marginBlock:1,marginBlockEnd:1,marginBlockStart:1,marginBottom:1,marginInline:1,marginInlineEnd:1,marginInlineStart:1,marginLeft:1,marginRight:1,marginTop:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,offsetDistance:1,offsetRotate:1,outline:1,outlineOffset:1,outlineWidth:1,overflowClipMargin:1,padding:1,paddingBlock:1,paddingBlockEnd:1,paddingBlockStart:1,paddingBottom:1,paddingInline:1,paddingInlineEnd:1,paddingInlineStart:1,paddingLeft:1,paddingRight:1,paddingTop:1,perspective:1,right:1,rowGap:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginBlockEnd:1,scrollMarginBlockStart:1,scrollMarginBottom:1,scrollMarginInline:1,scrollMarginInlineEnd:1,scrollMarginInlineStart:1,scrollMarginLeft:1,scrollMarginRight:1,scrollMarginTop:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingBlockEnd:1,scrollPaddingBlockStart:1,scrollPaddingBottom:1,scrollPaddingInline:1,scrollPaddingInlineEnd:1,scrollPaddingInlineStart:1,scrollPaddingLeft:1,scrollPaddingRight:1,scrollPaddingTop:1,shapeMargin:1,textDecoration:1,textDecorationThickness:1,textIndent:1,textUnderlineOffset:1,top:1,transitionDelay:1,transitionDuration:1,verticalAlign:1,width:1,wordSpacing:1},z=e=>String.fromCharCode(e+(e>25?39:97)),W=e=>(e=>{let t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=z(t%52)+n;return z(t%52)+n})(((e,t)=>{let n=t.length;for(;n;)e=33*e^t.charCodeAt(--n);return e})(5381,JSON.stringify(e))>>>0),j=["themed","global","styled","onevar","resonevar","allvar","inline"],E=e=>{if(e.href&&!e.href.startsWith(location.origin))return !1;try{return !!e.cssRules}catch(e){return !1}},T=e=>{let t;const n=()=>{const{cssRules:e}=t.sheet;return [].map.call(e,((n,r)=>{const{cssText:i}=n;let o="";if(i.startsWith("--sxs"))return "";if(e[r-1]&&(o=e[r-1].cssText).startsWith("--sxs")){if(!n.cssRules.length)return "";for(const e in t.rules)if(t.rules[e].group===n)return `--sxs{--sxs:${[...t.rules[e].cache].join(" ")}}${i}`;return n.cssRules.length?`${o}${i}`:""}return i})).join("")},r=()=>{if(t){const{rules:e,sheet:n}=t;if(!n.deleteRule){for(;3===Object(Object(n.cssRules)[0]).type;)n.cssRules.splice(0,1);n.cssRules=[];}for(const t in e)delete e[t];}const i=Object(e).styleSheets||[];for(const e of i)if(E(e)){for(let i=0,o=e.cssRules;o[i];++i){const l=Object(o[i]);if(1!==l.type)continue;const s=Object(o[i+1]);if(4!==s.type)continue;++i;const{cssText:a}=l;if(!a.startsWith("--sxs"))continue;const c=a.slice(14,-3).trim().split(/\s+/),d=j[c[0]];d&&(t||(t={sheet:e,reset:r,rules:{},toString:n}),t.rules[d]={group:s,index:i,cache:new Set(c)});}if(t)break}if(!t){const i=(e,t)=>({type:t,cssRules:[],insertRule(e,t){this.cssRules.splice(t,0,i(e,{import:3,undefined:1}[(e.toLowerCase().match(/^@([a-z]+)/)||[])[1]]||4));},get cssText(){return "@media{}"===e?`@media{${[].map.call(this.cssRules,(e=>e.cssText)).join("")}}`:e}});t={sheet:e?(e.head||e).appendChild(document.createElement("style")).sheet:i("","text/css"),rules:{},reset:r,toString:n};}const{sheet:o,rules:l}=t;for(let e=j.length-1;e>=0;--e){const t=j[e];if(!l[t]){const n=j[e+1],r=l[n]?l[n].index:o.cssRules.length;o.insertRule("@media{}",r),o.insertRule(`--sxs{--sxs:${e}}`,r),l[t]={group:o.cssRules[r+1],index:r,cache:new Set([e])};}v(l[t]);}};return r(),t},v=e=>{const t=e.group;let n=t.cssRules.length;e.apply=e=>{try{t.insertRule(e,n),++n;}catch(e){}};},M=Symbol(),w=l(),C=(e,t)=>w(e,(()=>(...n)=>{let r={type:null,composers:new Set};for(const t of n)if(null!=t)if(t[s]){null==r.type&&(r.type=t[s].type);for(const e of t[s].composers)r.composers.add(e);}else t.constructor!==Object||t.$$typeof?null==r.type&&(r.type=t):r.composers.add(P(t,e));return null==r.type&&(r.type="span"),r.composers.size||r.composers.add(["PJLV",{},[],[],{},[]]),L(e,r,t)})),P=({variants:e,compoundVariants:t,defaultVariants:n,...r},i)=>{const o=`${k(i.prefix)}c-${W(r)}`,l=[],s=[],a=Object.create(null),g=[];for(const e in n)a[e]=String(n[e]);if("object"==typeof e&&e)for(const t in e){p=a,u=t,d.call(p,u)||(a[t]="undefined");const n=e[t];for(const e in n){const r={[t]:String(e)};"undefined"===String(e)&&g.push(t);const i=n[e],o=[r,i,!c(i)];l.push(o);}}var p,u;if("object"==typeof t&&t)for(const e of t){let{css:t,...n}=e;t="object"==typeof t&&t||{};for(const e in n)n[e]=String(n[e]);const r=[n,t,!c(t)];s.push(r);}return [o,r,l,s,a,g]},L=(e,t,n)=>{const[r,i,o,l]=O(t.composers),c="function"==typeof t.type||t.type.$$typeof?(e=>{function t(){for(let n=0;n<t[M].length;n++){const[r,i]=t[M][n];e.rules[r].apply(i);}return t[M]=[],null}return t[M]=[],t.rules={},j.forEach((e=>t.rules[e]={apply:n=>t[M].push([e,n])})),t})(n):null,d=(c||n).rules,g=`.${r}${i.length>1?`:where(.${i.slice(1).join(".")})`:""}`,p=s=>{s="object"==typeof s&&s||D;const{css:a,...p}=s,u={};for(const e in o)if(delete p[e],e in s){let t=s[e];"object"==typeof t&&t?u[e]={"@initial":o[e],...t}:(t=String(t),u[e]="undefined"!==t||l.has(e)?t:o[e]);}else u[e]=o[e];const h=new Set([...i]);for(const[r,i,o,l]of t.composers){n.rules.styled.cache.has(r)||(n.rules.styled.cache.add(r),x(i,[`.${r}`],[],e,(e=>{d.styled.apply(e);})));const t=A(o,u,e.media),s=A(l,u,e.media,!0);for(const i of t)if(void 0!==i)for(const[t,o,l]of i){const i=`${r}-${W(o)}-${t}`;h.add(i);const s=(l?n.rules.resonevar:n.rules.onevar).cache,a=l?d.resonevar:d.onevar;s.has(i)||(s.add(i),x(o,[`.${i}`],[],e,(e=>{a.apply(e);})));}for(const t of s)if(void 0!==t)for(const[i,o]of t){const t=`${r}-${W(o)}-${i}`;h.add(t),n.rules.allvar.cache.has(t)||(n.rules.allvar.cache.add(t),x(o,[`.${t}`],[],e,(e=>{d.allvar.apply(e);})));}}if("object"==typeof a&&a){const t=`${r}-i${W(a)}-css`;h.add(t),n.rules.inline.cache.has(t)||(n.rules.inline.cache.add(t),x(a,[`.${t}`],[],e,(e=>{d.inline.apply(e);})));}for(const e of String(s.className||"").trim().split(/\s+/))e&&h.add(e);const f=p.className=[...h].join(" ");return {type:t.type,className:f,selector:g,props:p,toString:()=>f,deferredInjector:c}};return a(p,{className:r,selector:g,[s]:t,toString:()=>(n.rules.styled.cache.has(r)||p(),r)})},O=e=>{let t="";const n=[],r={},i=[];for(const[o,,,,l,s]of e){""===t&&(t=o),n.push(o),i.push(...s);for(const e in l){const t=l[e];(void 0===r[e]||"undefined"!==t||s.includes(t))&&(r[e]=t);}}return [t,n,r,new Set(i)]},A=(e,t,n,r)=>{const i=[];e:for(let[o,l,s]of e){if(s)continue;let e,a=0,c=!1;for(e in o){const r=o[e];let i=t[e];if(i!==r){if("object"!=typeof i||!i)continue e;{let e,t,o=0;for(const l in i){if(r===String(i[l])){if("@initial"!==l){const e=l.slice(1);(t=t||[]).push(e in n?n[e]:l.replace(/^@media ?/,"")),c=!0;}a+=o,e=!0;}++o;}if(t&&t.length&&(l={["@media "+t.join(", ")]:l}),!e)continue e}}}(i[a]=i[a]||[]).push([r?"cv":`${e}-${o[e]}`,l,c]);}return i},D={},H=l(),N=(e,t)=>H(e,(()=>(...n)=>{const r=()=>{for(let r of n){r="object"==typeof r&&r||{};let n=W(r);if(!t.rules.global.cache.has(n)){if(t.rules.global.cache.add(n),"@import"in r){let e=[].indexOf.call(t.sheet.cssRules,t.rules.themed.group)-1;for(let n of [].concat(r["@import"]))n=n.includes('"')||n.includes("'")?n:`"${n}"`,t.sheet.insertRule(`@import ${n};`,e++);delete r["@import"];}x(r,[],[],e,(e=>{t.rules.global.apply(e);}));}}return ""};return a(r,{toString:r})})),V=l(),G=(e,t)=>V(e,(()=>n=>{const r=`${k(e.prefix)}k-${W(n)}`,i=()=>{if(!t.rules.global.cache.has(r)){t.rules.global.cache.add(r);const i=[];x(n,[],[],e,(e=>i.push(e)));const o=`@keyframes ${r}{${i.join("")}}`;t.rules.global.apply(o);}return r};return a(i,{get name(){return i()},toString:i})})),F=class{constructor(e,t,n,r){this.token=null==e?"":String(e),this.value=null==t?"":String(t),this.scale=null==n?"":String(n),this.prefix=null==r?"":String(r);}get computedValue(){return "var("+this.variable+")"}get variable(){return "--"+k(this.prefix)+k(this.scale)+this.token}toString(){return this.computedValue}},J=l(),U=(e,t)=>J(e,(()=>(n,r)=>{r="object"==typeof n&&n||Object(r);const i=`.${n=(n="string"==typeof n?n:"")||`${k(e.prefix)}t-${W(r)}`}`,o={},l=[];for(const t in r){o[t]={};for(const n in r[t]){const i=`--${k(e.prefix)}${t}-${n}`,s=y(String(r[t][n]),e.prefix,t);o[t][n]=new F(n,s,t,e.prefix),l.push(`${i}:${s}`);}}const s=()=>{if(l.length&&!t.rules.themed.cache.has(n)){t.rules.themed.cache.add(n);const i=`${r===e.theme?":root,":""}.${n}{${l.join(";")}}`;t.rules.themed.apply(i);}return n};return {...o,get className(){return s()},selector:i,toString:s}})),Z=l(),X=e=>{let t=!1;const n=Z(e,(e=>{t=!0;const n="prefix"in(e="object"==typeof e&&e||{})?String(e.prefix):"",r="object"==typeof e.media&&e.media||{},o="object"==typeof e.root?e.root||null:globalThis.document||null,l="object"==typeof e.theme&&e.theme||{},s={prefix:n,media:r,theme:l,themeMap:"object"==typeof e.themeMap&&e.themeMap||{...i},utils:"object"==typeof e.utils&&e.utils||{}},a=T(o),c={css:C(s,a),globalCss:N(s,a),keyframes:G(s,a),createTheme:U(s,a),reset(){a.reset(),c.theme.toString();},theme:{},sheet:a,config:s,prefix:n,getCssText:a.toString,toString:a.toString};return String(c.theme=c.createTheme(l)),c}));return t||n.reset(),n};//# sourceMappingUrl=index.map

    const { css, globalCss, keyframes, getCssText, theme, createTheme, config, reset } = X({
        prefix: 'svelteui',
        theme: {
            colors,
            space: {
                0: '0rem',
                xs: 10,
                sm: 12,
                md: 16,
                lg: 20,
                xl: 24,
                xsPX: '10px',
                smPX: '12px',
                mdPX: '16px',
                lgPX: '20px',
                xlPX: '24px',
                1: '0.125rem',
                2: '0.25rem',
                3: '0.375rem',
                4: '0.5rem',
                5: '0.625rem',
                6: '0.75rem',
                7: '0.875rem',
                8: '1rem',
                9: '1.25rem',
                10: '1.5rem',
                11: '1.75rem',
                12: '2rem',
                13: '2.25rem',
                14: '2.5rem',
                15: '2.75rem',
                16: '3rem',
                17: '3.5rem',
                18: '4rem',
                20: '5rem',
                24: '6rem',
                28: '7rem',
                32: '8rem',
                36: '9rem',
                40: '10rem',
                44: '11rem',
                48: '12rem',
                52: '13rem',
                56: '14rem',
                60: '15rem',
                64: '16rem',
                72: '18rem',
                80: '20rem',
                96: '24rem'
            },
            fontSizes: {
                xs: '12px',
                sm: '14px',
                md: '16px',
                lg: '18px',
                xl: '20px'
            },
            fonts: {
                standard: '-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji',
                mono: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace',
                fallback: 'Segoe UI, system-ui, sans-serif'
            },
            fontWeights: {
                thin: 100,
                extralight: 200,
                light: 300,
                normal: 400,
                medium: 500,
                semibold: 600,
                bold: 700,
                extrabold: 800
            },
            lineHeights: {
                xs: 1,
                sm: 1.25,
                md: 1.5,
                lg: 1.625,
                xl: 1.75
            },
            letterSpacings: {
                tighter: '-0.05em',
                tight: '-0.025em',
                normal: '0',
                wide: '0.025em',
                wider: '0.05em',
                widest: '0.1em'
            },
            sizes: {},
            radii: {
                xs: '2px',
                sm: '4px',
                md: '8px',
                lg: '16px',
                xl: '32px',
                squared: '33%',
                rounded: '50%',
                pill: '9999px'
            },
            shadows: {
                xs: '0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)',
                sm: '0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 10px 15px -5px, rgba(0, 0, 0, 0.04) 0px 7px 7px -5px',
                md: '0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 20px 25px -5px, rgba(0, 0, 0, 0.04) 0px 10px 10px -5px',
                lg: '0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 28px 23px -7px, rgba(0, 0, 0, 0.04) 0px 12px 12px -7px',
                xl: '0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 36px 28px -7px, rgba(0, 0, 0, 0.04) 0px 17px 17px -7px'
            },
            zIndices: {
                1: '100',
                2: '200',
                3: '300',
                4: '400',
                5: '500',
                10: '1000',
                max: '9999'
            },
            borderWidths: {
                light: '1px',
                normal: '2px',
                bold: '3px',
                extrabold: '4px',
                black: '5px',
                xs: '1px',
                sm: '2px',
                md: '3px',
                lg: '4px',
                xl: '5px'
            },
            breakpoints: {
                xs: 576,
                sm: 768,
                md: 992,
                lg: 1200,
                xl: 1400
            },
            borderStyles: {},
            transitions: {}
        },
        media: {
            xs: '(min-width: 576px)',
            sm: '(min-width: 768px)',
            md: '(min-width: 992px)',
            lg: '(min-width: 1200px)',
            xl: '(min-width: 1400px)'
        },
        utils: {
            focusRing: (value) => ({
                WebkitTapHighlightColor: 'transparent',
                '&:focus': {
                    outlineOffset: 2,
                    outline: value === 'always' || value === 'auto' ? '2px solid $primary' : 'none'
                },
                '&:focus:not(:focus-visible)': {
                    outline: value === 'auto' || value === 'never' ? 'none' : undefined
                }
            }),
            /** padding top */
            p: (value) => ({
                padding: value
            }),
            pt: (value) => ({
                paddingTop: value
            }),
            pr: (value) => ({
                paddingRight: value
            }),
            pb: (value) => ({
                paddingBottom: value
            }),
            pl: (value) => ({
                paddingLeft: value
            }),
            px: (value) => ({
                paddingLeft: value,
                paddingRight: value
            }),
            py: (value) => ({
                paddingTop: value,
                paddingBottom: value
            }),
            /** margin */
            m: (value) => ({
                margin: value
            }),
            /** margin-top */
            mt: (value) => ({
                marginTop: value
            }),
            mr: (value) => ({
                marginRight: value
            }),
            mb: (value) => ({
                marginBottom: value
            }),
            ml: (value) => ({
                marginLeft: value
            }),
            mx: (value) => ({
                marginLeft: value,
                marginRight: value
            }),
            my: (value) => ({
                marginTop: value,
                marginBottom: value
            }),
            ta: (value) => ({
                textAlign: value
            }),
            tt: (value) => ({
                textTransform: value
            }),
            to: (value) => ({
                textOverflow: value
            }),
            d: (value) => ({ display: value }),
            dflex: (value) => ({
                display: 'flex',
                alignItems: value,
                justifyContent: value
            }),
            fd: (value) => ({
                flexDirection: value
            }),
            fw: (value) => ({ flexWrap: value }),
            ai: (value) => ({
                alignItems: value
            }),
            ac: (value) => ({
                alignContent: value
            }),
            jc: (value) => ({
                justifyContent: value
            }),
            as: (value) => ({
                alignSelf: value
            }),
            fg: (value) => ({ flexGrow: value }),
            fs: (value) => ({
                fontSize: value
            }),
            fb: (value) => ({
                flexBasis: value
            }),
            bc: (value) => ({
                backgroundColor: value
            }),
            bf: (value) => ({
                backdropFilter: value
            }),
            bg: (value) => ({
                background: value
            }),
            bgBlur: (value) => ({
                bf: 'saturate(180%) blur(10px)',
                bg: value
            }),
            bgColor: (value) => ({
                backgroundColor: value
            }),
            backgroundClip: (value) => ({
                WebkitBackgroundClip: value,
                backgroundClip: value
            }),
            bgClip: (value) => ({
                WebkitBackgroundClip: value,
                backgroundClip: value
            }),
            br: (value) => ({
                borderRadius: value
            }),
            bw: (value) => ({
                borderWidth: value
            }),
            btrr: (value) => ({
                borderTopRightRadius: value
            }),
            bbrr: (value) => ({
                borderBottomRightRadius: value
            }),
            bblr: (value) => ({
                borderBottomLeftRadius: value
            }),
            btlr: (value) => ({
                borderTopLeftRadius: value
            }),
            bs: (value) => ({
                boxShadow: value
            }),
            normalShadow: (value) => ({
                boxShadow: `0 4px 14px 0 $${value}`
            }),
            lh: (value) => ({
                lineHeight: value
            }),
            ov: (value) => ({ overflow: value }),
            ox: (value) => ({
                overflowX: value
            }),
            oy: (value) => ({
                overflowY: value
            }),
            pe: (value) => ({
                pointerEvents: value
            }),
            events: (value) => ({
                pointerEvents: value
            }),
            us: (value) => ({
                WebkitUserSelect: value,
                userSelect: value
            }),
            userSelect: (value) => ({
                WebkitUserSelect: value,
                userSelect: value
            }),
            w: (value) => ({ width: value }),
            h: (value) => ({
                height: value
            }),
            minW: (value) => ({
                minWidth: value
            }),
            minH: (value) => ({
                minWidth: value
            }),
            mw: (value) => ({
                maxWidth: value
            }),
            maxW: (value) => ({
                maxWidth: value
            }),
            mh: (value) => ({
                maxHeight: value
            }),
            maxH: (value) => ({
                maxHeight: value
            }),
            size: (value) => ({
                width: value,
                height: value
            }),
            minSize: (value) => ({
                minWidth: value,
                minHeight: value,
                width: value,
                height: value
            }),
            sizeMin: (value) => ({
                minWidth: value,
                minHeight: value,
                width: value,
                height: value
            }),
            maxSize: (value) => ({
                maxWidth: value,
                maxHeight: value
            }),
            sizeMax: (value) => ({
                maxWidth: value,
                maxHeight: value
            }),
            appearance: (value) => ({
                WebkitAppearance: value,
                appearance: value
            }),
            scale: (value) => ({
                transform: `scale(${value})`
            }),
            linearGradient: (value) => ({
                backgroundImage: `linear-gradient(${value})`
            }),
            tdl: (value) => ({
                textDecorationLine: value
            }),
            // Text gradient effect
            textGradient: (value) => ({
                backgroundImage: `linear-gradient(${value})`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent'
            })
        },
        themeMap: {
            ...i,
            width: 'space',
            height: 'space',
            minWidth: 'space',
            maxWidth: 'space',
            minHeight: 'space',
            maxHeight: 'space',
            flexBasis: 'space',
            gridTemplateColumns: 'space',
            gridTemplateRows: 'space',
            blockSize: 'space',
            minBlockSize: 'space',
            maxBlockSize: 'space',
            inlineSize: 'space',
            minInlineSize: 'space',
            maxInlineSize: 'space',
            borderWidth: 'borderWeights'
        }
    });
    /** Function for dark theme */
    const dark = createTheme('dark-theme', {
        colors,
        shadows: {
            xs: '-4px 0 15px rgb(0 0 0 / 50%)',
            sm: '0 5px 20px -5px rgba(20, 20, 20, 0.1)',
            md: '0 8px 30px rgba(20, 20, 20, 0.15)',
            lg: '0 30px 60px rgba(20, 20, 20, 0.15)',
            xl: '0 40px 80px rgba(20, 20, 20, 0.25)'
        }
    });
    /** Global styles for SvelteUI */
    const SvelteUIGlobalCSS = globalCss({
        a: {
            focusRing: 'auto'
        },
        body: {
            [`${dark.selector} &`]: {
                backgroundColor: '$dark700',
                color: '$dark50'
            },
            backgroundColor: '$white',
            color: '$black'
        }
    });
    /** Normalize css function */
    const NormalizeCSS = globalCss({
        html: {
            fontFamily: 'sans-serif',
            lineHeight: '1.15',
            textSizeAdjust: '100%',
            margin: 0
        },
        body: {
            margin: 0
        },
        'article, aside, footer, header, nav, section, figcaption, figure, main': {
            display: 'block'
        },
        h1: {
            fontSize: '2em',
            margin: 0
        },
        hr: {
            boxSizing: 'content-box',
            height: 0,
            overflow: 'visible'
        },
        pre: {
            fontFamily: 'monospace, monospace',
            fontSize: '1em'
        },
        a: {
            background: 'transparent',
            textDecorationSkip: 'objects'
        },
        'a:active, a:hover': {
            outlineWidth: 0
        },
        'abbr[title]': {
            borderBottom: 'none',
            textDecoration: 'underline'
        },
        'b, strong': {
            fontWeight: 'bolder'
        },
        'code, kbp, samp': {
            fontFamily: 'monospace, monospace',
            fontSize: '1em'
        },
        dfn: {
            fontStyle: 'italic'
        },
        mark: {
            backgroundColor: '#ff0',
            color: '#000'
        },
        small: {
            fontSize: '80%'
        },
        'sub, sup': {
            fontSize: '75%',
            lineHeight: 0,
            position: 'relative',
            verticalAlign: 'baseline'
        },
        sup: {
            top: '-0.5em'
        },
        sub: {
            bottom: '-0.25em'
        },
        'audio, video': {
            display: 'inline-block'
        },
        'audio:not([controls])': {
            display: 'none',
            height: 0
        },
        img: {
            borderStyle: 'none',
            verticalAlign: 'middle'
        },
        'svg:not(:root)': {
            overflow: 'hidden'
        },
        'button, input, optgroup, select, textarea': {
            fontFamily: 'sans-serif',
            fontSize: '100%',
            lineHeight: '1.15',
            margin: 0
        },
        'button, input': {
            overflow: 'visible'
        },
        'button, select': {
            textTransform: 'none'
        },
        'button, [type=reset], [type=submit]': {
            WebkitAppearance: 'button'
        },
        'button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner': {
            borderStyle: 'none',
            padding: 0
        },
        'button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring': {
            outline: '1px dotted ButtonText'
        },
        legend: {
            boxSizing: 'border-box',
            color: 'inherit',
            display: 'table',
            maxWidth: '100%',
            padding: 0,
            whiteSpace: 'normal'
        },
        progress: {
            display: 'inline-block',
            verticalAlign: 'baseline'
        },
        textarea: {
            overflow: 'auto'
        },
        '[type=checkbox], [type=radio]': {
            boxSizing: 'border-box',
            padding: 0
        },
        '[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button': {
            height: 'auto'
        },
        '[type=search]': {
            appearance: 'textfield',
            outlineOffset: '-2px'
        },
        '[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration': {
            appearance: 'none'
        },
        '::-webkit-file-upload-button': {
            appearance: 'button',
            font: 'inherit'
        },
        'details, menu': {
            display: 'block'
        },
        summary: {
            display: 'list-item'
        },
        canvas: {
            display: 'inline-block'
        },
        template: {
            display: 'none'
        },
        '[hidden]': {
            display: 'none'
        }
    });

    const SYSTEM_PROPS = {
        mt: 'marginTop',
        mb: 'marginBottom',
        ml: 'marginLeft',
        mr: 'marginRight',
        pt: 'paddingTop',
        pb: 'paddingBottom',
        pl: 'paddingLeft',
        pr: 'paddingRight'
    };
    const NEGATIVE_VALUES = ['-xs', '-sm', '-md', '-lg', '-xl'];
    function isValidSizeValue(margin) {
        return typeof margin === 'string' || typeof margin === 'number';
    }
    function getSizeValue(margin, theme) {
        if (NEGATIVE_VALUES.includes(margin)) {
            return theme.fn.size({ size: margin.replace('-', ''), sizes: theme.space }) * -1;
        }
        return theme.fn.size({ size: margin, sizes: theme.space });
    }
    function getSystemStyles(systemStyles, theme) {
        const styles = {};
        if (isValidSizeValue(systemStyles.p)) {
            const value = getSizeValue(systemStyles.p, theme);
            styles.padding = value;
        }
        if (isValidSizeValue(systemStyles.m)) {
            const value = getSizeValue(systemStyles.m, theme);
            styles.margin = value;
        }
        if (isValidSizeValue(systemStyles.py)) {
            const value = getSizeValue(systemStyles.py, theme);
            styles.paddingTop = value;
            styles.paddingBottom = value;
        }
        if (isValidSizeValue(systemStyles.px)) {
            const value = getSizeValue(systemStyles.px, theme);
            styles.paddingLeft = value;
            styles.paddingRight = value;
        }
        if (isValidSizeValue(systemStyles.my)) {
            const value = getSizeValue(systemStyles.my, theme);
            styles.marginTop = value;
            styles.marginBottom = value;
        }
        if (isValidSizeValue(systemStyles.mx)) {
            const value = getSizeValue(systemStyles.mx, theme);
            styles.marginLeft = value;
            styles.marginRight = value;
        }
        Object.keys(SYSTEM_PROPS).forEach((property) => {
            if (isValidSizeValue(systemStyles[property])) {
                styles[SYSTEM_PROPS[property]] = theme.fn.size({
                    size: getSizeValue(systemStyles[property], theme),
                    sizes: theme.space
                });
            }
        });
        return styles;
    }

    /* node_modules/@svelteuidev/core/dist/components/Box/Box.svelte generated by Svelte v3.59.2 */
    const file$q = "node_modules/@svelteuidev/core/dist/components/Box/Box.svelte";

    // (74:0) {:else}
    function create_else_block$a(ctx) {
    	let div;
    	let div_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);

    	let div_levels = [
    		{
    			class: div_class_value = "" + (/*className*/ ctx[2] + " " + /*BoxStyles*/ ctx[7]({
    				css: {
    					.../*getCSSStyles*/ ctx[11](/*theme*/ ctx[10]),
    					.../*systemStyles*/ ctx[6]
    				}
    			}))
    		},
    		/*$$restProps*/ ctx[12]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$q, 74, 1, 2269);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[31](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*forwardEvents*/ ctx[8].call(null, div)),
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[1]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[32],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[32], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*className, BoxStyles, systemStyles*/ 196 && div_class_value !== (div_class_value = "" + (/*className*/ ctx[2] + " " + /*BoxStyles*/ ctx[7]({
    					css: {
    						.../*getCSSStyles*/ ctx[11](/*theme*/ ctx[10]),
    						.../*systemStyles*/ ctx[6]
    					}
    				})))) && { class: div_class_value },
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[31](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(74:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:50) 
    function create_if_block_1$d(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[8], [useActions, /*use*/ ctx[1]]]
    		},
    		{
    			class: "" + (/*className*/ ctx[2] + " " + /*BoxStyles*/ ctx[7]({
    				css: {
    					.../*getCSSStyles*/ ctx[11](/*theme*/ ctx[10]),
    					.../*systemStyles*/ ctx[6]
    				}
    			}))
    		},
    		/*$$restProps*/ ctx[12]
    	];

    	var switch_value = /*root*/ ctx[3];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot$x] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    		/*switch_instance_binding*/ ctx[30](switch_instance);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*forwardEvents, use, className, BoxStyles, getCSSStyles, theme, systemStyles, $$restProps*/ 7622)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty[0] & /*forwardEvents, use*/ 258 && {
    						use: [/*forwardEvents*/ ctx[8], [useActions, /*use*/ ctx[1]]]
    					},
    					dirty[0] & /*className, BoxStyles, getCSSStyles, theme, systemStyles*/ 3268 && {
    						class: "" + (/*className*/ ctx[2] + " " + /*BoxStyles*/ ctx[7]({
    							css: {
    								.../*getCSSStyles*/ ctx[11](/*theme*/ ctx[10]),
    								.../*systemStyles*/ ctx[6]
    							}
    						}))
    					},
    					dirty[0] & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12])
    				])
    			: {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (dirty[0] & /*root*/ 8 && switch_value !== (switch_value = /*root*/ ctx[3])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					/*switch_instance_binding*/ ctx[30](switch_instance);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*switch_instance_binding*/ ctx[30](null);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(64:50) ",
    		ctx
    	});

    	return block;
    }

    // (52:0) {#if isHTMLElement}
    function create_if_block$k(ctx) {
    	let current;
    	validate_dynamic_element(/*castRoot*/ ctx[9]());
    	validate_void_dynamic_element(/*castRoot*/ ctx[9]());
    	let svelte_element = /*castRoot*/ ctx[9]() && create_dynamic_element$1(ctx);

    	const block = {
    		c: function create() {
    			if (svelte_element) svelte_element.c();
    		},
    		m: function mount(target, anchor) {
    			if (svelte_element) svelte_element.m(target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*castRoot*/ ctx[9]()) {
    				svelte_element.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svelte_element);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svelte_element);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (svelte_element) svelte_element.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(52:0) {#if isHTMLElement}",
    		ctx
    	});

    	return block;
    }

    // (65:1) <svelte:component   this={root}   bind:this={element}   use={[forwardEvents, [useActions, use]]}   class="{className} {BoxStyles({ css: { ...getCSSStyles(theme), ...systemStyles } })}"   {...$$restProps}  >
    function create_default_slot$x(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[32],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[32], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$x.name,
    		type: "slot",
    		source: "(65:1) <svelte:component   this={root}   bind:this={element}   use={[forwardEvents, [useActions, use]]}   class=\\\"{className} {BoxStyles({ css: { ...getCSSStyles(theme), ...systemStyles } })}\\\"   {...$$restProps}  >",
    		ctx
    	});

    	return block;
    }

    // (54:1) <svelte:element   bind:this={element}   this={castRoot()}   use:forwardEvents   use:useActions={use}   class="{className} {BoxStyles({ css: {...getCSSStyles(theme), ...systemStyles} })}"   {...$$restProps}  >
    function create_dynamic_element$1(ctx) {
    	let svelte_element;
    	let svelte_element_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);

    	let svelte_element_levels = [
    		{
    			class: svelte_element_class_value = "" + (/*className*/ ctx[2] + " " + /*BoxStyles*/ ctx[7]({
    				css: {
    					.../*getCSSStyles*/ ctx[11](/*theme*/ ctx[10]),
    					.../*systemStyles*/ ctx[6]
    				}
    			}))
    		},
    		/*$$restProps*/ ctx[12]
    	];

    	let svelte_element_data = {};

    	for (let i = 0; i < svelte_element_levels.length; i += 1) {
    		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svelte_element = element(/*castRoot*/ ctx[9]());
    			if (default_slot) default_slot.c();
    			set_dynamic_element_data(/*castRoot*/ ctx[9]())(svelte_element, svelte_element_data);
    			add_location(svelte_element, file$q, 53, 1, 1725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_element, anchor);

    			if (default_slot) {
    				default_slot.m(svelte_element, null);
    			}

    			/*svelte_element_binding*/ ctx[29](svelte_element);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*forwardEvents*/ ctx[8].call(null, svelte_element)),
    					action_destroyer(useActions_action = useActions.call(null, svelte_element, /*use*/ ctx[1]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[32],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[32], dirty, null),
    						null
    					);
    				}
    			}

    			set_dynamic_element_data(/*castRoot*/ ctx[9]())(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
    				(!current || dirty[0] & /*className, BoxStyles, systemStyles*/ 196 && svelte_element_class_value !== (svelte_element_class_value = "" + (/*className*/ ctx[2] + " " + /*BoxStyles*/ ctx[7]({
    					css: {
    						.../*getCSSStyles*/ ctx[11](/*theme*/ ctx[10]),
    						.../*systemStyles*/ ctx[6]
    					}
    				})))) && { class: svelte_element_class_value },
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_element);
    			if (default_slot) default_slot.d(detaching);
    			/*svelte_element_binding*/ ctx[29](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_dynamic_element$1.name,
    		type: "child_dynamic_element",
    		source: "(54:1) <svelte:element   bind:this={element}   this={castRoot()}   use:forwardEvents   use:useActions={use}   class=\\\"{className} {BoxStyles({ css: {...getCSSStyles(theme), ...systemStyles} })}\\\"   {...$$restProps}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_if_block_1$d, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isHTMLElement*/ ctx[4]) return 0;
    		if (/*isComponent*/ ctx[5] && typeof /*root*/ ctx[3] !== 'string') return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let BoxStyles;
    	let systemStyles;

    	const omit_props_names = [
    		"use","element","class","css","root","m","my","mx","mt","mb","ml","mr","p","py","px","pt","pb","pl","pr"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Box', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', css: css$1 = {}, root = undefined, m = undefined, my = undefined, mx = undefined, mt = undefined, mb = undefined, ml = undefined, mr = undefined, p = undefined, py = undefined, px = undefined, pt = undefined, pb = undefined, pl = undefined, pr = undefined } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	/** workaround for root type errors, this should be replaced by a better type system */
    	const castRoot = () => root;

    	const theme = useSvelteUIThemeContext()?.theme || useSvelteUITheme();
    	const getCSSStyles = typeof css$1 === 'function' ? css$1 : () => css$1;
    	let isHTMLElement;
    	let isComponent;

    	function svelte_element_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	function switch_instance_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('css' in $$new_props) $$invalidate(13, css$1 = $$new_props.css);
    		if ('root' in $$new_props) $$invalidate(3, root = $$new_props.root);
    		if ('m' in $$new_props) $$invalidate(14, m = $$new_props.m);
    		if ('my' in $$new_props) $$invalidate(15, my = $$new_props.my);
    		if ('mx' in $$new_props) $$invalidate(16, mx = $$new_props.mx);
    		if ('mt' in $$new_props) $$invalidate(17, mt = $$new_props.mt);
    		if ('mb' in $$new_props) $$invalidate(18, mb = $$new_props.mb);
    		if ('ml' in $$new_props) $$invalidate(19, ml = $$new_props.ml);
    		if ('mr' in $$new_props) $$invalidate(20, mr = $$new_props.mr);
    		if ('p' in $$new_props) $$invalidate(21, p = $$new_props.p);
    		if ('py' in $$new_props) $$invalidate(22, py = $$new_props.py);
    		if ('px' in $$new_props) $$invalidate(23, px = $$new_props.px);
    		if ('pt' in $$new_props) $$invalidate(24, pt = $$new_props.pt);
    		if ('pb' in $$new_props) $$invalidate(25, pb = $$new_props.pb);
    		if ('pl' in $$new_props) $$invalidate(26, pl = $$new_props.pl);
    		if ('pr' in $$new_props) $$invalidate(27, pr = $$new_props.pr);
    		if ('$$scope' in $$new_props) $$invalidate(32, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getSystemStyles,
    		_css: css,
    		useSvelteUITheme,
    		useSvelteUIThemeContext,
    		createEventForwarder,
    		useActions,
    		get_current_component,
    		use,
    		element,
    		className,
    		css: css$1,
    		root,
    		m,
    		my,
    		mx,
    		mt,
    		mb,
    		ml,
    		mr,
    		p,
    		py,
    		px,
    		pt,
    		pb,
    		pl,
    		pr,
    		forwardEvents,
    		castRoot,
    		theme,
    		getCSSStyles,
    		isHTMLElement,
    		isComponent,
    		systemStyles,
    		BoxStyles
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('css' in $$props) $$invalidate(13, css$1 = $$new_props.css);
    		if ('root' in $$props) $$invalidate(3, root = $$new_props.root);
    		if ('m' in $$props) $$invalidate(14, m = $$new_props.m);
    		if ('my' in $$props) $$invalidate(15, my = $$new_props.my);
    		if ('mx' in $$props) $$invalidate(16, mx = $$new_props.mx);
    		if ('mt' in $$props) $$invalidate(17, mt = $$new_props.mt);
    		if ('mb' in $$props) $$invalidate(18, mb = $$new_props.mb);
    		if ('ml' in $$props) $$invalidate(19, ml = $$new_props.ml);
    		if ('mr' in $$props) $$invalidate(20, mr = $$new_props.mr);
    		if ('p' in $$props) $$invalidate(21, p = $$new_props.p);
    		if ('py' in $$props) $$invalidate(22, py = $$new_props.py);
    		if ('px' in $$props) $$invalidate(23, px = $$new_props.px);
    		if ('pt' in $$props) $$invalidate(24, pt = $$new_props.pt);
    		if ('pb' in $$props) $$invalidate(25, pb = $$new_props.pb);
    		if ('pl' in $$props) $$invalidate(26, pl = $$new_props.pl);
    		if ('pr' in $$props) $$invalidate(27, pr = $$new_props.pr);
    		if ('isHTMLElement' in $$props) $$invalidate(4, isHTMLElement = $$new_props.isHTMLElement);
    		if ('isComponent' in $$props) $$invalidate(5, isComponent = $$new_props.isComponent);
    		if ('systemStyles' in $$props) $$invalidate(6, systemStyles = $$new_props.systemStyles);
    		if ('BoxStyles' in $$props) $$invalidate(7, BoxStyles = $$new_props.BoxStyles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*root*/ 8) {
    			{
    				$$invalidate(4, isHTMLElement = root && typeof root === 'string');
    				$$invalidate(5, isComponent = root && typeof root === 'function');
    			}
    		}

    		if ($$self.$$.dirty[0] & /*m, my, mx, mt, mb, ml, mr, p, py, px, pt, pb, pl, pr*/ 268419072) {
    			$$invalidate(6, systemStyles = getSystemStyles(
    				{
    					m,
    					my,
    					mx,
    					mt,
    					mb,
    					ml,
    					mr,
    					p,
    					py,
    					px,
    					pt,
    					pb,
    					pl,
    					pr
    				},
    				theme
    			));
    		}
    	};

    	$$invalidate(7, BoxStyles = css({}));

    	return [
    		element,
    		use,
    		className,
    		root,
    		isHTMLElement,
    		isComponent,
    		systemStyles,
    		BoxStyles,
    		forwardEvents,
    		castRoot,
    		theme,
    		getCSSStyles,
    		$$restProps,
    		css$1,
    		m,
    		my,
    		mx,
    		mt,
    		mb,
    		ml,
    		mr,
    		p,
    		py,
    		px,
    		pt,
    		pb,
    		pl,
    		pr,
    		slots,
    		svelte_element_binding,
    		switch_instance_binding,
    		div_binding,
    		$$scope
    	];
    }

    class Box extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$K,
    			create_fragment$K,
    			safe_not_equal,
    			{
    				use: 1,
    				element: 0,
    				class: 2,
    				css: 13,
    				root: 3,
    				m: 14,
    				my: 15,
    				mx: 16,
    				mt: 17,
    				mb: 18,
    				ml: 19,
    				mr: 20,
    				p: 21,
    				py: 22,
    				px: 23,
    				pt: 24,
    				pb: 25,
    				pl: 26,
    				pr: 27
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Box",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get use() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get css() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set css(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get root() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set root(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get m() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set m(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get my() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set my(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mx() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mx(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mt() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mt(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mb() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mb(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ml() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ml(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mr() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mr(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get p() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set p(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get py() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set py(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get px() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set px(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pt() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pt(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pb() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pb(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pl() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pl(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pr() {
    		throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pr(value) {
    		throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Box$1 = Box;

    const sizes$5 = {
        xs: {
            height: 30,
            padding: '0px 14px'
        },
        sm: {
            height: 36,
            padding: '0px 18px'
        },
        md: {
            height: 42,
            padding: '0px 22px'
        },
        lg: {
            height: 50,
            padding: '0px 26px'
        },
        xl: {
            height: 60,
            padding: '0px 32px'
        },
        'compact-xs': {
            height: 22,
            padding: '0 7px'
        },
        'compact-sm': {
            height: 26,
            padding: '0 8px'
        },
        'compact-md': {
            height: 30,
            padding: '0 10px'
        },
        'compact-lg': {
            height: 34,
            padding: '0 12px'
        },
        'compact-xl': {
            height: 40,
            padding: '0 14px'
        }
    };
    var useStyles$k = createStyles((theme, { color, compact, fullSize, gradient, radius, size, variant }) => {
        return {
            root: {
                focusRing: 'auto',
                cursor: 'pointer',
                position: 'relative',
                boxSizing: 'border-box',
                textDecoration: 'none',
                outline: 'none',
                userSelect: 'none',
                appearance: 'none',
                textAlign: 'center',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                background: null,
                borderRadius: typeof radius === 'number' ? radius : `$${radius}`,
                height: typeof size === 'number' ? `${size}px` : sizes$5[compact ? `compact-${size}` : size].height,
                padding: typeof size === 'number'
                    ? `0px ${size}px`
                    : sizes$5[compact ? `compact-${size}` : size].padding,
                fontFamily: '$standard',
                fontWeight: '$semibold',
                fontSize: `$${size}`,
                lineHeight: 1,
                flexGrow: 0,
                width: fullSize ? '100%' : 'fit-content',
                '&:hover': {
                    backgroundColor: variant === 'gradient' ? null : theme.fn.themeColor(color, 7),
                    backgroundSize: variant === 'gradient' ? '200%' : null
                },
                '&:active': {
                    transform: 'translateY(1px)'
                },
                '&:disabled': {
                    pointerEvents: 'none',
                    borderColor: 'transparent',
                    background: theme.fn.themeColor('gray', 2),
                    backgroundColor: theme.fn.themeColor('gray', 2),
                    color: theme.fn.themeColor('gray', 5),
                    cursor: 'not-allowed',
                    darkMode: {
                        borderColor: 'transparent',
                        backgroundColor: theme.fn.themeColor('dark', 4),
                        color: theme.fn.themeColor('dark', 6)
                    }
                }
            },
            disabled: {
                pointerEvents: 'none',
                borderColor: 'transparent',
                background: theme.fn.themeColor('gray', 2),
                backgroundColor: theme.fn.themeColor('gray', 2),
                color: theme.fn.themeColor('gray', 5),
                cursor: 'not-allowed',
                darkMode: {
                    backgroundColor: theme.fn.themeColor('dark', 4),
                    color: theme.fn.themeColor('dark', 6)
                }
            },
            loading: {
                pointerEvents: 'none',
                '&::before': {
                    content: '""',
                    position: 'absolute',
                    inset: -1,
                    backgroundColor: 'rgba(255, 255, 255, .5)',
                    borderRadius: `$${radius}`,
                    cursor: 'not-allowed'
                }
            },
            variants: {
                variation: vFunc(color, gradient),
                // Used to override the disable style when using anchor HTML element
                disabled: {
                    true: {
                        pointerEvents: 'none',
                        borderColor: 'transparent',
                        background: theme.fn.themeColor('gray', 2),
                        backgroundColor: theme.fn.themeColor('gray', 2),
                        color: theme.fn.themeColor('gray', 5),
                        cursor: 'not-allowed',
                        [`${dark.selector} &`]: {
                            borderColor: 'transparent',
                            backgroundColor: theme.fn.themeColor('dark', 4),
                            color: theme.fn.themeColor('dark', 6)
                        }
                    }
                }
            }
        };
    });

    /** Error codes for component
     *
     * `Object.freeze` is needed to keep modification outside of the object unavailable
     *
     * ## Code 1:
     * If using the disabled prop, a loading cannot be set at the same time
     *
     * ## Code 2:
     * If using the external prop, a href prop must be associated with it
     */
    const ButtonErrors = Object.freeze([
        {
            error: true,
            message: 'If using the disabled prop, a loading cannot be set at the same time',
            solution: `
                If your component looks like this:
                
                &lt;Button disabled loading ...&gt; Button Text &lt;/Button&gt;
                         ^^^^^^^^ ^^^^^^^ - Try removing one of these
                `
        },
        {
            error: true,
            message: 'If using the external prop, a href prop must be associated with it. If you have an href prop there must be content inside.',
            solution: `
                If your component looks like this:
                
                &lt;Button external ...&gt; Button Text &lt;/Button&gt;
                         ^^^^^^^^ - Try adding the href prop too
                `
        }
    ]);

    /* node_modules/@svelteuidev/core/dist/components/Loader/loaders/Circle.svelte generated by Svelte v3.59.2 */
    const file$p = "node_modules/@svelteuidev/core/dist/components/Loader/loaders/Circle.svelte";

    function create_fragment$J(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let circle;
    	let path;
    	let animateTransform;
    	let svg_width_value;
    	let svg_height_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			circle = svg_element("circle");
    			path = svg_element("path");
    			animateTransform = svg_element("animateTransform");
    			attr_dev(circle, "stroke-opacity", ".5");
    			attr_dev(circle, "cx", "16");
    			attr_dev(circle, "cy", "16");
    			attr_dev(circle, "r", "16");
    			add_location(circle, file$p, 19, 3, 453);
    			attr_dev(animateTransform, "attributeName", "transform");
    			attr_dev(animateTransform, "type", "rotate");
    			attr_dev(animateTransform, "from", "0 16 16");
    			attr_dev(animateTransform, "to", "360 16 16");
    			attr_dev(animateTransform, "dur", "1s");
    			attr_dev(animateTransform, "repeatCount", "indefinite");
    			add_location(animateTransform, file$p, 21, 4, 553);
    			attr_dev(path, "d", "M32 16c0-9.94-8.06-16-16-16");
    			add_location(path, file$p, 20, 3, 510);
    			attr_dev(g0, "transform", "translate(2.5 2.5)");
    			attr_dev(g0, "stroke-width", "5");
    			add_location(g0, file$p, 18, 2, 398);
    			attr_dev(g1, "fill", "none");
    			attr_dev(g1, "fill-rule", "evenodd");
    			add_location(g1, file$p, 17, 1, 360);
    			attr_dev(svg, "width", svg_width_value = `${/*size*/ ctx[1]}px`);
    			attr_dev(svg, "height", svg_height_value = `${/*size*/ ctx[1]}px`);
    			attr_dev(svg, "viewBox", "0 0 38 38");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "stroke", /*color*/ ctx[2]);
    			attr_dev(svg, "class", /*className*/ ctx[3]);
    			add_location(svg, file$p, 8, 0, 195);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, circle);
    			append_dev(g0, path);
    			append_dev(path, animateTransform);

    			if (!mounted) {
    				dispose = action_destroyer(useActions_action = useActions.call(null, svg, /*use*/ ctx[0]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*size*/ 2 && svg_width_value !== (svg_width_value = `${/*size*/ ctx[1]}px`)) {
    				attr_dev(svg, "width", svg_width_value);
    			}

    			if (dirty & /*size*/ 2 && svg_height_value !== (svg_height_value = `${/*size*/ ctx[1]}px`)) {
    				attr_dev(svg, "height", svg_height_value);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(svg, "stroke", /*color*/ ctx[2]);
    			}

    			if (dirty & /*className*/ 8) {
    				attr_dev(svg, "class", /*className*/ ctx[3]);
    			}

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Circle', slots, []);
    	let { use = [] } = $$props;
    	let { size = 25 } = $$props;
    	let { color = 'blue' } = $$props;
    	let { class: className = '' } = $$props;
    	const writable_props = ['use', 'size', 'color', 'class'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Circle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('use' in $$props) $$invalidate(0, use = $$props.use);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('class' in $$props) $$invalidate(3, className = $$props.class);
    	};

    	$$self.$capture_state = () => ({ useActions, use, size, color, className });

    	$$self.$inject_state = $$props => {
    		if ('use' in $$props) $$invalidate(0, use = $$props.use);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [use, size, color, className];
    }

    class Circle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, { use: 0, size: 1, color: 2, class: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Circle",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get use() {
    		throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Circle$1 = Circle;

    /* node_modules/@svelteuidev/core/dist/components/Loader/loaders/Bars.svelte generated by Svelte v3.59.2 */
    const file$o = "node_modules/@svelteuidev/core/dist/components/Loader/loaders/Bars.svelte";

    function create_fragment$I(ctx) {
    	let svg;
    	let rect0;
    	let animate0;
    	let animate1;
    	let rect1;
    	let animate2;
    	let animate3;
    	let rect2;
    	let animate4;
    	let animate5;
    	let rect3;
    	let animate6;
    	let animate7;
    	let rect4;
    	let animate8;
    	let animate9;
    	let svg_width_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect0 = svg_element("rect");
    			animate0 = svg_element("animate");
    			animate1 = svg_element("animate");
    			rect1 = svg_element("rect");
    			animate2 = svg_element("animate");
    			animate3 = svg_element("animate");
    			rect2 = svg_element("rect");
    			animate4 = svg_element("animate");
    			animate5 = svg_element("animate");
    			rect3 = svg_element("rect");
    			animate6 = svg_element("animate");
    			animate7 = svg_element("animate");
    			rect4 = svg_element("rect");
    			animate8 = svg_element("animate");
    			animate9 = svg_element("animate");
    			attr_dev(animate0, "attributeName", "height");
    			attr_dev(animate0, "begin", "0.5s");
    			attr_dev(animate0, "dur", "1s");
    			attr_dev(animate0, "values", "120;110;100;90;80;70;60;50;40;140;120");
    			attr_dev(animate0, "calcMode", "linear");
    			attr_dev(animate0, "repeatCount", "indefinite");
    			add_location(animate0, file$o, 17, 2, 385);
    			attr_dev(animate1, "attributeName", "y");
    			attr_dev(animate1, "begin", "0.5s");
    			attr_dev(animate1, "dur", "1s");
    			attr_dev(animate1, "values", "10;15;20;25;30;35;40;45;50;0;10");
    			attr_dev(animate1, "calcMode", "linear");
    			attr_dev(animate1, "repeatCount", "indefinite");
    			add_location(animate1, file$o, 25, 2, 554);
    			attr_dev(rect0, "y", "10");
    			attr_dev(rect0, "width", "15");
    			attr_dev(rect0, "height", "120");
    			attr_dev(rect0, "rx", "6");
    			add_location(rect0, file$o, 16, 1, 338);
    			attr_dev(animate2, "attributeName", "height");
    			attr_dev(animate2, "begin", "0.25s");
    			attr_dev(animate2, "dur", "1s");
    			attr_dev(animate2, "values", "120;110;100;90;80;70;60;50;40;140;120");
    			attr_dev(animate2, "calcMode", "linear");
    			attr_dev(animate2, "repeatCount", "indefinite");
    			add_location(animate2, file$o, 35, 2, 774);
    			attr_dev(animate3, "attributeName", "y");
    			attr_dev(animate3, "begin", "0.25s");
    			attr_dev(animate3, "dur", "1s");
    			attr_dev(animate3, "values", "10;15;20;25;30;35;40;45;50;0;10");
    			attr_dev(animate3, "calcMode", "linear");
    			attr_dev(animate3, "repeatCount", "indefinite");
    			add_location(animate3, file$o, 43, 2, 944);
    			attr_dev(rect1, "x", "30");
    			attr_dev(rect1, "y", "10");
    			attr_dev(rect1, "width", "15");
    			attr_dev(rect1, "height", "120");
    			attr_dev(rect1, "rx", "6");
    			add_location(rect1, file$o, 34, 1, 720);
    			attr_dev(animate4, "attributeName", "height");
    			attr_dev(animate4, "begin", "0s");
    			attr_dev(animate4, "dur", "1s");
    			attr_dev(animate4, "values", "120;110;100;90;80;70;60;50;40;140;120");
    			attr_dev(animate4, "calcMode", "linear");
    			attr_dev(animate4, "repeatCount", "indefinite");
    			add_location(animate4, file$o, 53, 2, 1158);
    			attr_dev(animate5, "attributeName", "y");
    			attr_dev(animate5, "begin", "0s");
    			attr_dev(animate5, "dur", "1s");
    			attr_dev(animate5, "values", "10;15;20;25;30;35;40;45;50;0;10");
    			attr_dev(animate5, "calcMode", "linear");
    			attr_dev(animate5, "repeatCount", "indefinite");
    			add_location(animate5, file$o, 61, 2, 1325);
    			attr_dev(rect2, "x", "60");
    			attr_dev(rect2, "width", "15");
    			attr_dev(rect2, "height", "140");
    			attr_dev(rect2, "rx", "6");
    			add_location(rect2, file$o, 52, 1, 1111);
    			attr_dev(animate6, "attributeName", "height");
    			attr_dev(animate6, "begin", "0.25s");
    			attr_dev(animate6, "dur", "1s");
    			attr_dev(animate6, "values", "120;110;100;90;80;70;60;50;40;140;120");
    			attr_dev(animate6, "calcMode", "linear");
    			attr_dev(animate6, "repeatCount", "indefinite");
    			add_location(animate6, file$o, 71, 2, 1543);
    			attr_dev(animate7, "attributeName", "y");
    			attr_dev(animate7, "begin", "0.25s");
    			attr_dev(animate7, "dur", "1s");
    			attr_dev(animate7, "values", "10;15;20;25;30;35;40;45;50;0;10");
    			attr_dev(animate7, "calcMode", "linear");
    			attr_dev(animate7, "repeatCount", "indefinite");
    			add_location(animate7, file$o, 79, 2, 1713);
    			attr_dev(rect3, "x", "90");
    			attr_dev(rect3, "y", "10");
    			attr_dev(rect3, "width", "15");
    			attr_dev(rect3, "height", "120");
    			attr_dev(rect3, "rx", "6");
    			add_location(rect3, file$o, 70, 1, 1489);
    			attr_dev(animate8, "attributeName", "height");
    			attr_dev(animate8, "begin", "0.5s");
    			attr_dev(animate8, "dur", "1s");
    			attr_dev(animate8, "values", "120;110;100;90;80;70;60;50;40;140;120");
    			attr_dev(animate8, "calcMode", "linear");
    			attr_dev(animate8, "repeatCount", "indefinite");
    			add_location(animate8, file$o, 89, 2, 1935);
    			attr_dev(animate9, "attributeName", "y");
    			attr_dev(animate9, "begin", "0.5s");
    			attr_dev(animate9, "dur", "1s");
    			attr_dev(animate9, "values", "10;15;20;25;30;35;40;45;50;0;10");
    			attr_dev(animate9, "calcMode", "linear");
    			attr_dev(animate9, "repeatCount", "indefinite");
    			add_location(animate9, file$o, 97, 2, 2104);
    			attr_dev(rect4, "x", "120");
    			attr_dev(rect4, "y", "10");
    			attr_dev(rect4, "width", "15");
    			attr_dev(rect4, "height", "120");
    			attr_dev(rect4, "rx", "6");
    			add_location(rect4, file$o, 88, 1, 1880);
    			attr_dev(svg, "viewBox", "0 0 135 140");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "fill", /*color*/ ctx[2]);
    			attr_dev(svg, "width", svg_width_value = `${/*size*/ ctx[1]}px`);
    			attr_dev(svg, "class", /*className*/ ctx[3]);
    			add_location(svg, file$o, 8, 0, 195);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect0);
    			append_dev(rect0, animate0);
    			append_dev(rect0, animate1);
    			append_dev(svg, rect1);
    			append_dev(rect1, animate2);
    			append_dev(rect1, animate3);
    			append_dev(svg, rect2);
    			append_dev(rect2, animate4);
    			append_dev(rect2, animate5);
    			append_dev(svg, rect3);
    			append_dev(rect3, animate6);
    			append_dev(rect3, animate7);
    			append_dev(svg, rect4);
    			append_dev(rect4, animate8);
    			append_dev(rect4, animate9);

    			if (!mounted) {
    				dispose = action_destroyer(useActions_action = useActions.call(null, svg, /*use*/ ctx[0]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(svg, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*size*/ 2 && svg_width_value !== (svg_width_value = `${/*size*/ ctx[1]}px`)) {
    				attr_dev(svg, "width", svg_width_value);
    			}

    			if (dirty & /*className*/ 8) {
    				attr_dev(svg, "class", /*className*/ ctx[3]);
    			}

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bars', slots, []);
    	let { use = [] } = $$props;
    	let { size = 25 } = $$props;
    	let { color = 'blue' } = $$props;
    	let { class: className = '' } = $$props;
    	const writable_props = ['use', 'size', 'color', 'class'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bars> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('use' in $$props) $$invalidate(0, use = $$props.use);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('class' in $$props) $$invalidate(3, className = $$props.class);
    	};

    	$$self.$capture_state = () => ({ useActions, use, size, color, className });

    	$$self.$inject_state = $$props => {
    		if ('use' in $$props) $$invalidate(0, use = $$props.use);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [use, size, color, className];
    }

    class Bars extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, { use: 0, size: 1, color: 2, class: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bars",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get use() {
    		throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Bars$1 = Bars;

    /* node_modules/@svelteuidev/core/dist/components/Loader/loaders/Dots.svelte generated by Svelte v3.59.2 */
    const file$n = "node_modules/@svelteuidev/core/dist/components/Loader/loaders/Dots.svelte";

    function create_fragment$H(ctx) {
    	let svg;
    	let circle0;
    	let animate0;
    	let animate1;
    	let circle1;
    	let animate2;
    	let animate3;
    	let circle2;
    	let animate4;
    	let animate5;
    	let svg_width_value;
    	let svg_height_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle0 = svg_element("circle");
    			animate0 = svg_element("animate");
    			animate1 = svg_element("animate");
    			circle1 = svg_element("circle");
    			animate2 = svg_element("animate");
    			animate3 = svg_element("animate");
    			circle2 = svg_element("circle");
    			animate4 = svg_element("animate");
    			animate5 = svg_element("animate");
    			attr_dev(animate0, "attributeName", "r");
    			attr_dev(animate0, "from", "15");
    			attr_dev(animate0, "to", "15");
    			attr_dev(animate0, "begin", "0s");
    			attr_dev(animate0, "dur", "0.8s");
    			attr_dev(animate0, "values", "15;9;15");
    			attr_dev(animate0, "calcMode", "linear");
    			attr_dev(animate0, "repeatCount", "indefinite");
    			add_location(animate0, file$n, 18, 2, 405);
    			attr_dev(animate1, "attributeName", "fill-opacity");
    			attr_dev(animate1, "from", "1");
    			attr_dev(animate1, "to", "1");
    			attr_dev(animate1, "begin", "0s");
    			attr_dev(animate1, "dur", "0.8s");
    			attr_dev(animate1, "values", "1;.5;1");
    			attr_dev(animate1, "calcMode", "linear");
    			attr_dev(animate1, "repeatCount", "indefinite");
    			add_location(animate1, file$n, 28, 2, 563);
    			attr_dev(circle0, "cx", "15");
    			attr_dev(circle0, "cy", "15");
    			attr_dev(circle0, "r", "15");
    			add_location(circle0, file$n, 17, 1, 371);
    			attr_dev(animate2, "attributeName", "r");
    			attr_dev(animate2, "from", "9");
    			attr_dev(animate2, "to", "9");
    			attr_dev(animate2, "begin", "0s");
    			attr_dev(animate2, "dur", "0.8s");
    			attr_dev(animate2, "values", "9;15;9");
    			attr_dev(animate2, "calcMode", "linear");
    			attr_dev(animate2, "repeatCount", "indefinite");
    			add_location(animate2, file$n, 40, 2, 791);
    			attr_dev(animate3, "attributeName", "fill-opacity");
    			attr_dev(animate3, "from", "0.5");
    			attr_dev(animate3, "to", "0.5");
    			attr_dev(animate3, "begin", "0s");
    			attr_dev(animate3, "dur", "0.8s");
    			attr_dev(animate3, "values", ".5;1;.5");
    			attr_dev(animate3, "calcMode", "linear");
    			attr_dev(animate3, "repeatCount", "indefinite");
    			add_location(animate3, file$n, 50, 2, 946);
    			attr_dev(circle1, "cx", "60");
    			attr_dev(circle1, "cy", "15");
    			attr_dev(circle1, "r", "9");
    			attr_dev(circle1, "fill-opacity", "0.3");
    			add_location(circle1, file$n, 39, 1, 739);
    			attr_dev(animate4, "attributeName", "r");
    			attr_dev(animate4, "from", "15");
    			attr_dev(animate4, "to", "15");
    			attr_dev(animate4, "begin", "0s");
    			attr_dev(animate4, "dur", "0.8s");
    			attr_dev(animate4, "values", "15;9;15");
    			attr_dev(animate4, "calcMode", "linear");
    			attr_dev(animate4, "repeatCount", "indefinite");
    			add_location(animate4, file$n, 62, 2, 1162);
    			attr_dev(animate5, "attributeName", "fill-opacity");
    			attr_dev(animate5, "from", "1");
    			attr_dev(animate5, "to", "1");
    			attr_dev(animate5, "begin", "0s");
    			attr_dev(animate5, "dur", "0.8s");
    			attr_dev(animate5, "values", "1;.5;1");
    			attr_dev(animate5, "calcMode", "linear");
    			attr_dev(animate5, "repeatCount", "indefinite");
    			add_location(animate5, file$n, 72, 2, 1320);
    			attr_dev(circle2, "cx", "105");
    			attr_dev(circle2, "cy", "15");
    			attr_dev(circle2, "r", "15");
    			add_location(circle2, file$n, 61, 1, 1127);
    			attr_dev(svg, "width", svg_width_value = `${/*size*/ ctx[1]}px`);
    			attr_dev(svg, "height", svg_height_value = `${Number(/*size*/ ctx[1]) / 4}px`);
    			attr_dev(svg, "viewBox", "0 0 120 30");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "fill", /*color*/ ctx[2]);
    			attr_dev(svg, "class", /*className*/ ctx[3]);
    			add_location(svg, file$n, 8, 0, 195);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle0);
    			append_dev(circle0, animate0);
    			append_dev(circle0, animate1);
    			append_dev(svg, circle1);
    			append_dev(circle1, animate2);
    			append_dev(circle1, animate3);
    			append_dev(svg, circle2);
    			append_dev(circle2, animate4);
    			append_dev(circle2, animate5);

    			if (!mounted) {
    				dispose = action_destroyer(useActions_action = useActions.call(null, svg, /*use*/ ctx[0]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*size*/ 2 && svg_width_value !== (svg_width_value = `${/*size*/ ctx[1]}px`)) {
    				attr_dev(svg, "width", svg_width_value);
    			}

    			if (dirty & /*size*/ 2 && svg_height_value !== (svg_height_value = `${Number(/*size*/ ctx[1]) / 4}px`)) {
    				attr_dev(svg, "height", svg_height_value);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(svg, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*className*/ 8) {
    				attr_dev(svg, "class", /*className*/ ctx[3]);
    			}

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dots', slots, []);
    	let { use = [] } = $$props;
    	let { size = 25 } = $$props;
    	let { color = 'blue' } = $$props;
    	let { class: className = '' } = $$props;
    	const writable_props = ['use', 'size', 'color', 'class'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dots> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('use' in $$props) $$invalidate(0, use = $$props.use);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('class' in $$props) $$invalidate(3, className = $$props.class);
    	};

    	$$self.$capture_state = () => ({ useActions, use, size, color, className });

    	$$self.$inject_state = $$props => {
    		if ('use' in $$props) $$invalidate(0, use = $$props.use);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [use, size, color, className];
    }

    class Dots extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, { use: 0, size: 1, color: 2, class: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dots",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get use() {
    		throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Dots$1 = Dots;

    const LOADER_SIZES = {
        xs: 18,
        sm: 22,
        md: 36,
        lg: 44,
        xl: 58
    };
    const getCorrectShade = (color, dark = false) => {
        return theme.colors[dark ? `${color}400` : `${color}600`].value;
    };

    /* node_modules/@svelteuidev/core/dist/components/Loader/Loader.svelte generated by Svelte v3.59.2 */

    function create_fragment$G(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[5], [useActions, /*use*/ ctx[1]]]
    		},
    		{
    			color: /*color*/ ctx[4] === 'white'
    			? 'white'
    			: getCorrectShade(/*color*/ ctx[4])
    		},
    		{ size: LOADER_SIZES[/*size*/ ctx[3]] },
    		{ class: /*className*/ ctx[2] },
    		/*$$restProps*/ ctx[8]
    	];

    	var switch_value = /*LOADERS*/ ctx[6][/*defaultLoader*/ ctx[7]];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    		/*switch_instance_binding*/ ctx[10](switch_instance);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*forwardEvents, useActions, use, color, getCorrectShade, LOADER_SIZES, size, className, $$restProps*/ 318)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*forwardEvents, useActions, use*/ 34 && {
    						use: [/*forwardEvents*/ ctx[5], [useActions, /*use*/ ctx[1]]]
    					},
    					dirty & /*color, getCorrectShade*/ 16 && {
    						color: /*color*/ ctx[4] === 'white'
    						? 'white'
    						: getCorrectShade(/*color*/ ctx[4])
    					},
    					dirty & /*LOADER_SIZES, size*/ 8 && { size: LOADER_SIZES[/*size*/ ctx[3]] },
    					dirty & /*className*/ 4 && { class: /*className*/ ctx[2] },
    					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*LOADERS*/ ctx[6][/*defaultLoader*/ ctx[7]])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					/*switch_instance_binding*/ ctx[10](switch_instance);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*switch_instance_binding*/ ctx[10](null);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	const omit_props_names = ["use","element","class","size","color","variant"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Loader', slots, []);
    	let { use = [], element = undefined, class: className = '', size = 'md', color = 'blue', variant = 'circle' } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	/** Loader logic */
    	const LOADERS = { bars: Bars$1, circle: Circle$1, dots: Dots$1 };

    	const defaultLoader = variant in LOADERS ? variant : 'circle';

    	function switch_instance_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('size' in $$new_props) $$invalidate(3, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ('variant' in $$new_props) $$invalidate(9, variant = $$new_props.variant);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		Circle: Circle$1,
    		Bars: Bars$1,
    		Dots: Dots$1,
    		LOADER_SIZES,
    		getCorrectShade,
    		use,
    		element,
    		className,
    		size,
    		color,
    		variant,
    		forwardEvents,
    		LOADERS,
    		defaultLoader
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('size' in $$props) $$invalidate(3, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
    		if ('variant' in $$props) $$invalidate(9, variant = $$new_props.variant);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		element,
    		use,
    		className,
    		size,
    		color,
    		forwardEvents,
    		LOADERS,
    		defaultLoader,
    		$$restProps,
    		variant,
    		switch_instance_binding
    	];
    }

    class Loader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			size: 3,
    			color: 4,
    			variant: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loader",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get use() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Loader$1 = Loader;

    /* node_modules/@svelteuidev/core/dist/components/Button/Ripple.svelte generated by Svelte v3.59.2 */

    const { console: console_1$4 } = globals;
    const file$m = "node_modules/@svelteuidev/core/dist/components/Button/Ripple.svelte";

    function add_css$1(target) {
    	append_styles(target, "svelte-3pkhve", ".ripple.svelte-3pkhve{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-3pkhve .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-3pkhve .animation-enter{transition:none}.ripple.svelte-3pkhve .animation-in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-3pkhve .animation-out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmlwcGxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5SkMscUJBQVEsQ0FDUCxPQUFPLENBQUUsS0FBSyxDQUNkLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLENBQ1QsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsYUFBYSxDQUFFLE9BQU8sQ0FDdEIsS0FBSyxDQUFFLE9BQU8sQ0FDZCxjQUFjLENBQUUsSUFBSSxDQUNwQixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxNQUNWLENBQ0EscUJBQU8sQ0FBUyxVQUFZLENBQzNCLEtBQUssQ0FBRSxPQUFPLENBQ2QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsY0FBYyxDQUFFLElBQUksQ0FDcEIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsV0FBVyxDQUFFLFNBQVMsQ0FBQyxDQUFDLE9BQ3pCLENBQ0EscUJBQU8sQ0FBUyxnQkFBa0IsQ0FDakMsVUFBVSxDQUFFLElBQ2IsQ0FDQSxxQkFBTyxDQUFTLGFBQWUsQ0FDOUIsVUFBVSxDQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDckQsVUFBVSxDQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUMxRCxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQzFDLENBQ0EscUJBQU8sQ0FBUyxjQUFnQixDQUMvQixVQUFVLENBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDckQiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUmlwcGxlLnN2ZWx0ZSJdfQ== */");
    }

    function create_fragment$F(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "ripple svelte-3pkhve");
    			add_location(div, file$m, 150, 0, 4661);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[4](div);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[4](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isTouchEvent(e) {
    	return e.constructor.name === 'TouchEvent';
    }

    function transform(el, value) {
    	el.style['transform'] = value;
    	el.style['webkitTransform'] = value;
    }

    function opacity(el, value) {
    	el.style['opacity'] = value.toString();
    }

    const calculate = (e, el) => {
    	const offset = el.getBoundingClientRect();
    	const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
    	const localX = target.clientX - offset.left;
    	const localY = target.clientY - offset.top;
    	let radius = 0;
    	let scale = 0.3;

    	// Get ripple position
    	const center = el.dataset.center;

    	const circle = el.dataset.circle;

    	if (circle) {
    		scale = 0.15;
    		radius = el.clientWidth / 2;

    		radius = center
    		? radius
    		: radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
    	} else {
    		radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
    	}

    	const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
    	const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
    	const x = center ? centerX : `${localX - radius}px`;
    	const y = center ? centerY : `${localY - radius}px`;
    	return { radius, scale, x, y, centerX, centerY };
    };

    const startRipple = function (eventType, event) {
    	const hideEvents = ['touchcancel', 'mouseleave', 'dragstart'];
    	let container = event.currentTarget || event.target;

    	if (container && !container.classList.contains('ripple')) {
    		container = container.querySelector('.ripple');
    	}

    	if (!container) {
    		return;
    	}

    	const prev = container.dataset.event;

    	if (prev && prev !== eventType) {
    		return;
    	}

    	container.dataset.event = eventType;

    	// Create the ripple
    	const wave = document.createElement('span');

    	const { radius, scale, x, y, centerX, centerY } = calculate(event, container);
    	const color = container.dataset.color;
    	const size = `${radius * 2}px`;
    	wave.className = 'animation';
    	wave.style.width = size;
    	wave.style.height = size;
    	wave.style.background = color;
    	wave.classList.add('animation-enter');
    	wave.classList.add('animation--visible');
    	transform(wave, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
    	opacity(wave, 0);
    	wave.dataset.activated = String(performance.now());
    	container.appendChild(wave);

    	setTimeout(
    		() => {
    			wave.classList.remove('animation-enter');
    			wave.classList.add('animation-in');
    			transform(wave, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
    			opacity(wave, 0.25);
    		},
    		0
    	);

    	const releaseEvent = eventType === 'mousedown' ? 'mouseup' : 'touchend';

    	const onRelease = function () {
    		document.removeEventListener(releaseEvent, onRelease);

    		hideEvents.forEach(name => {
    			document.removeEventListener(name, onRelease);
    		});

    		const diff = performance.now() - Number(wave.dataset.activated);
    		const delay = Math.max(250 - diff, 0);

    		setTimeout(
    			() => {
    				wave.classList.remove('animation-in');
    				wave.classList.add('animation-out');
    				opacity(wave, 0);

    				setTimeout(
    					() => {
    						wave && container.removeChild(wave);

    						if (container.children.length === 0) {
    							delete container.dataset.event;
    						}
    					},
    					300
    				);
    			},
    			delay
    		);
    	};

    	document.addEventListener(releaseEvent, onRelease);

    	hideEvents.forEach(name => {
    		document.addEventListener(name, onRelease, { passive: true });
    	});
    };

    const onMouseDown = function (e) {
    	// Trigger on left click only
    	if (e.button === 0) {
    		startRipple(e.type, e);
    	}
    };

    const onTouchStart = function (e) {
    	if (e.changedTouches) {
    		for (let i = 0; i < e.changedTouches.length; ++i) {
    			startRipple(e.type, e.changedTouches[i]);
    		}
    	}
    };

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ripple', slots, []);
    	let { center = false } = $$props;
    	let { circle = false } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let el;
    	let trigEl;

    	onMount(async () => {
    		await tick();

    		try {
    			if (center) {
    				$$invalidate(0, el.dataset.center = 'true', el);
    			}

    			if (circle) {
    				$$invalidate(0, el.dataset.circle = 'true', el);
    			}

    			$$invalidate(0, el.dataset.color = color, el);
    			trigEl = el.parentElement;
    		} catch(err) {
    			
    		} // eslint-disable-line

    		if (!trigEl) {
    			console.error('Ripple: Trigger element not found.');
    			return;
    		}

    		let style = window.getComputedStyle(trigEl);

    		if (style.position.length === 0 || style.position === 'static') {
    			trigEl.style.position = 'relative';
    		}

    		trigEl.addEventListener('touchstart', onTouchStart, { passive: true });
    		trigEl.addEventListener('mousedown', onMouseDown, { passive: true });
    	});

    	onDestroy(() => {
    		if (!trigEl) {
    			return;
    		}

    		trigEl.removeEventListener('mousedown', onMouseDown);
    		trigEl.removeEventListener('touchstart', onTouchStart);
    	});

    	const writable_props = ['center', 'circle', 'color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<Ripple> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('center' in $$props) $$invalidate(1, center = $$props.center);
    		if ('circle' in $$props) $$invalidate(2, circle = $$props.circle);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({
    		isTouchEvent,
    		transform,
    		opacity,
    		calculate,
    		startRipple,
    		onMouseDown,
    		onTouchStart,
    		center,
    		circle,
    		color,
    		tick,
    		onMount,
    		onDestroy,
    		el,
    		trigEl
    	});

    	$$self.$inject_state = $$props => {
    		if ('center' in $$props) $$invalidate(1, center = $$props.center);
    		if ('circle' in $$props) $$invalidate(2, circle = $$props.circle);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    		if ('el' in $$props) $$invalidate(0, el = $$props.el);
    		if ('trigEl' in $$props) trigEl = $$props.trigEl;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [el, center, circle, color, div_binding];
    }

    class Ripple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, { center: 1, circle: 2, color: 3 }, add_css$1);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ripple",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get center() {
    		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get circle() {
    		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set circle(value) {
    		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Ripple$1 = Ripple;

    /* node_modules/@svelteuidev/core/dist/components/Button/Button.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1$4 } = globals;
    const file$l = "node_modules/@svelteuidev/core/dist/components/Button/Button.svelte";

    function add_css(target) {
    	append_styles(target, "svelte-5xpm5q", ".uppercase.svelte-5xpm5q{text-transform:uppercase}.left-section.svelte-5xpm5q{margin-right:10px;display:flex;align-items:center;justify-content:center}.right-section.svelte-5xpm5q{margin-left:10px;display:flex;align-items:center;justify-content:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF3SUMsd0JBQVcsQ0FDVixjQUFjLENBQUUsU0FDakIsQ0FDQSwyQkFBYyxDQUNiLFlBQVksQ0FBRSxJQUFJLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQ2xCLENBQ0EsNEJBQWUsQ0FDZCxXQUFXLENBQUUsSUFBSSxDQUNqQixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxNQUNsQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCdXR0b24uc3ZlbHRlIl19 */");
    }

    const get_rightIcon_slot_changes_1 = dirty => ({});
    const get_rightIcon_slot_context_1 = ctx => ({});
    const get_leftIcon_slot_changes_1 = dirty => ({});
    const get_leftIcon_slot_context_1 = ctx => ({});
    const get_rightIcon_slot_changes = dirty => ({});
    const get_rightIcon_slot_context = ctx => ({});
    const get_leftIcon_slot_changes = dirty => ({});
    const get_leftIcon_slot_context = ctx => ({});

    // (96:0) {:else}
    function create_else_block$9(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let t1;
    	let t2;
    	let current_block_type_index_1;
    	let if_block2;
    	let button_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_9$1, create_if_block_10$1];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*loading*/ ctx[11] && /*loaderPosition*/ ctx[5] === 'left') return 0;
    		if (/*$$slots*/ ctx[21].leftIcon) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_3(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], null);
    	const default_slot_or_fallback = default_slot || fallback_block_4(ctx);
    	let if_block1 = /*ripple*/ ctx[13] && create_if_block_8$1(ctx);
    	const if_block_creators_1 = [create_if_block_6$1, create_if_block_7$1];
    	const if_blocks_1 = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*loading*/ ctx[11] && /*loaderPosition*/ ctx[5] === 'right') return 0;
    		if (/*$$slots*/ ctx[21].rightIcon) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index_1 = select_block_type_4(ctx))) {
    		if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	}

    	let button_levels = [
    		{
    			class: button_class_value = /*cx*/ ctx[18](
    				/*className*/ ctx[3],
    				/*classes*/ ctx[17].root,
    				/*getStyles*/ ctx[16]({
    					css: /*override*/ ctx[1],
    					variation: /*variant*/ ctx[4]
    				}),
    				{
    					[/*classes*/ ctx[17].disabled]: /*disabled*/ ctx[9],
    					[/*classes*/ ctx[17].loading]: /*loading*/ ctx[11]
    				}
    			)
    		},
    		{ disabled: /*disabled*/ ctx[9] },
    		/*$$restProps*/ ctx[20],
    		{ tabindex: "0" }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			set_attributes(button, button_data);
    			toggle_class(button, "compact", /*compact*/ ctx[10]);
    			toggle_class(button, "uppercase", /*uppercase*/ ctx[12]);
    			toggle_class(button, "svelte-5xpm5q", true);
    			add_location(button, file$l, 96, 1, 3085);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(button, null);
    			}

    			append_dev(button, t0);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			append_dev(button, t1);
    			if (if_block1) if_block1.m(button, null);
    			append_dev(button, t2);

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[30](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, button, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[19].call(null, button))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(button, t0);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 134217728)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[27],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[27], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*ripple*/ ctx[13]) {
    				if (if_block1) {
    					if (dirty & /*ripple*/ 8192) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_8$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(button, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_4(ctx);

    			if (current_block_type_index_1 === previous_block_index_1) {
    				if (~current_block_type_index_1) {
    					if_blocks_1[current_block_type_index_1].p(ctx, dirty);
    				}
    			} else {
    				if (if_block2) {
    					group_outros();

    					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    						if_blocks_1[previous_block_index_1] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index_1) {
    					if_block2 = if_blocks_1[current_block_type_index_1];

    					if (!if_block2) {
    						if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    						if_block2.c();
    					} else {
    						if_block2.p(ctx, dirty);
    					}

    					transition_in(if_block2, 1);
    					if_block2.m(button, null);
    				} else {
    					if_block2 = null;
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty & /*cx, className, classes, getStyles, override, variant, disabled, loading*/ 461338 && button_class_value !== (button_class_value = /*cx*/ ctx[18](
    					/*className*/ ctx[3],
    					/*classes*/ ctx[17].root,
    					/*getStyles*/ ctx[16]({
    						css: /*override*/ ctx[1],
    						variation: /*variant*/ ctx[4]
    					}),
    					{
    						[/*classes*/ ctx[17].disabled]: /*disabled*/ ctx[9],
    						[/*classes*/ ctx[17].loading]: /*loading*/ ctx[11]
    					}
    				))) && { class: button_class_value },
    				(!current || dirty & /*disabled*/ 512) && { disabled: /*disabled*/ ctx[9] },
    				dirty & /*$$restProps*/ 1048576 && /*$$restProps*/ ctx[20],
    				{ tabindex: "0" }
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    			toggle_class(button, "compact", /*compact*/ ctx[10]);
    			toggle_class(button, "uppercase", /*uppercase*/ ctx[12]);
    			toggle_class(button, "svelte-5xpm5q", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot_or_fallback, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot_or_fallback, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			if (if_block1) if_block1.d();

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].d();
    			}

    			/*button_binding*/ ctx[30](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(96:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (55:0) {#if href}
    function create_if_block$j(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let t1;
    	let t2;
    	let current_block_type_index_1;
    	let if_block2;
    	let a_class_value;
    	let a_target_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_4$2, create_if_block_5$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*loading*/ ctx[11] && /*loaderPosition*/ ctx[5] === 'left') return 0;
    		if (/*$$slots*/ ctx[21].leftIcon) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], null);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);
    	let if_block1 = /*ripple*/ ctx[13] && create_if_block_3$2(ctx);
    	const if_block_creators_1 = [create_if_block_1$c, create_if_block_2$7];
    	const if_blocks_1 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*loading*/ ctx[11] && /*loaderPosition*/ ctx[5] === 'right') return 0;
    		if (/*$$slots*/ ctx[21].rightIcon) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index_1 = select_block_type_2(ctx))) {
    		if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	}

    	let a_levels = [
    		{ href: /*href*/ ctx[7] },
    		{
    			class: a_class_value = /*cx*/ ctx[18](
    				/*className*/ ctx[3],
    				/*classes*/ ctx[17].root,
    				/*getStyles*/ ctx[16]({
    					css: /*override*/ ctx[1],
    					variation: /*variant*/ ctx[4],
    					disabled: /*disabled*/ ctx[9]
    				}),
    				{
    					[/*classes*/ ctx[17].disabled]: /*disabled*/ ctx[9],
    					[/*classes*/ ctx[17].loading]: /*loading*/ ctx[11]
    				}
    			)
    		},
    		{ role: "button" },
    		{ rel: "noreferrer noopener" },
    		{
    			target: a_target_value = /*external*/ ctx[8] ? '_blank' : '_self'
    		},
    		/*$$restProps*/ ctx[20],
    		{ tabindex: "0" }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			set_attributes(a, a_data);
    			toggle_class(a, "compact", /*compact*/ ctx[10]);
    			toggle_class(a, "uppercase", /*uppercase*/ ctx[12]);
    			toggle_class(a, "svelte-5xpm5q", true);
    			add_location(a, file$l, 55, 1, 1981);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(a, null);
    			}

    			append_dev(a, t0);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(a, null);
    			}

    			append_dev(a, t1);
    			if (if_block1) if_block1.m(a, null);
    			append_dev(a, t2);

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].m(a, null);
    			}

    			/*a_binding*/ ctx[29](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[19].call(null, a))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(a, t0);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 134217728)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[27],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[27], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*ripple*/ ctx[13]) {
    				if (if_block1) {
    					if (dirty & /*ripple*/ 8192) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(a, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_2(ctx);

    			if (current_block_type_index_1 === previous_block_index_1) {
    				if (~current_block_type_index_1) {
    					if_blocks_1[current_block_type_index_1].p(ctx, dirty);
    				}
    			} else {
    				if (if_block2) {
    					group_outros();

    					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    						if_blocks_1[previous_block_index_1] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index_1) {
    					if_block2 = if_blocks_1[current_block_type_index_1];

    					if (!if_block2) {
    						if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    						if_block2.c();
    					} else {
    						if_block2.p(ctx, dirty);
    					}

    					transition_in(if_block2, 1);
    					if_block2.m(a, null);
    				} else {
    					if_block2 = null;
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 128) && { href: /*href*/ ctx[7] },
    				(!current || dirty & /*cx, className, classes, getStyles, override, variant, disabled, loading*/ 461338 && a_class_value !== (a_class_value = /*cx*/ ctx[18](
    					/*className*/ ctx[3],
    					/*classes*/ ctx[17].root,
    					/*getStyles*/ ctx[16]({
    						css: /*override*/ ctx[1],
    						variation: /*variant*/ ctx[4],
    						disabled: /*disabled*/ ctx[9]
    					}),
    					{
    						[/*classes*/ ctx[17].disabled]: /*disabled*/ ctx[9],
    						[/*classes*/ ctx[17].loading]: /*loading*/ ctx[11]
    					}
    				))) && { class: a_class_value },
    				{ role: "button" },
    				{ rel: "noreferrer noopener" },
    				(!current || dirty & /*external*/ 256 && a_target_value !== (a_target_value = /*external*/ ctx[8] ? '_blank' : '_self')) && { target: a_target_value },
    				dirty & /*$$restProps*/ 1048576 && /*$$restProps*/ ctx[20],
    				{ tabindex: "0" }
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    			toggle_class(a, "compact", /*compact*/ ctx[10]);
    			toggle_class(a, "uppercase", /*uppercase*/ ctx[12]);
    			toggle_class(a, "svelte-5xpm5q", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot_or_fallback, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot_or_fallback, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			if (if_block1) if_block1.d();

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].d();
    			}

    			/*a_binding*/ ctx[29](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(55:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    // (115:29) 
    function create_if_block_10$1(ctx) {
    	let span;
    	let current;
    	const leftIcon_slot_template = /*#slots*/ ctx[28].leftIcon;
    	const leftIcon_slot = create_slot(leftIcon_slot_template, ctx, /*$$scope*/ ctx[27], get_leftIcon_slot_context_1);
    	const leftIcon_slot_or_fallback = leftIcon_slot || fallback_block_5(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (leftIcon_slot_or_fallback) leftIcon_slot_or_fallback.c();
    			attr_dev(span, "class", "left-section svelte-5xpm5q");
    			add_location(span, file$l, 115, 3, 3615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (leftIcon_slot_or_fallback) {
    				leftIcon_slot_or_fallback.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (leftIcon_slot) {
    				if (leftIcon_slot.p && (!current || dirty & /*$$scope*/ 134217728)) {
    					update_slot_base(
    						leftIcon_slot,
    						leftIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[27],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
    						: get_slot_changes(leftIcon_slot_template, /*$$scope*/ ctx[27], dirty, get_leftIcon_slot_changes_1),
    						get_leftIcon_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(leftIcon_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(leftIcon_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (leftIcon_slot_or_fallback) leftIcon_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(115:29) ",
    		ctx
    	});

    	return block;
    }

    // (111:2) {#if loading && loaderPosition === 'left'}
    function create_if_block_9$1(ctx) {
    	let span;
    	let loader;
    	let current;

    	loader = new Loader$1({
    			props: {
    				variant: /*loaderProps*/ ctx[6].variant,
    				size: /*loaderProps*/ ctx[6].size,
    				color: /*loaderProps*/ ctx[6].color
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(loader.$$.fragment);
    			attr_dev(span, "class", "left-section svelte-5xpm5q");
    			add_location(span, file$l, 111, 3, 3448);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(loader, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loader_changes = {};
    			if (dirty & /*loaderProps*/ 64) loader_changes.variant = /*loaderProps*/ ctx[6].variant;
    			if (dirty & /*loaderProps*/ 64) loader_changes.size = /*loaderProps*/ ctx[6].size;
    			if (dirty & /*loaderProps*/ 64) loader_changes.color = /*loaderProps*/ ctx[6].color;
    			loader.$set(loader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(loader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(111:2) {#if loading && loaderPosition === 'left'}",
    		ctx
    	});

    	return block;
    }

    // (117:26) X
    function fallback_block_5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("X");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_5.name,
    		type: "fallback",
    		source: "(117:26) X",
    		ctx
    	});

    	return block;
    }

    // (120:8) Button
    function fallback_block_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_4.name,
    		type: "fallback",
    		source: "(120:8) Button",
    		ctx
    	});

    	return block;
    }

    // (121:2) {#if ripple}
    function create_if_block_8$1(ctx) {
    	let ripple_1;
    	let current;

    	ripple_1 = new Ripple$1({
    			props: { center: false, circle: false },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ripple_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ripple_1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ripple_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(121:2) {#if ripple}",
    		ctx
    	});

    	return block;
    }

    // (128:30) 
    function create_if_block_7$1(ctx) {
    	let span;
    	let current;
    	const rightIcon_slot_template = /*#slots*/ ctx[28].rightIcon;
    	const rightIcon_slot = create_slot(rightIcon_slot_template, ctx, /*$$scope*/ ctx[27], get_rightIcon_slot_context_1);
    	const rightIcon_slot_or_fallback = rightIcon_slot || fallback_block_3(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (rightIcon_slot_or_fallback) rightIcon_slot_or_fallback.c();
    			attr_dev(span, "class", "right-section svelte-5xpm5q");
    			add_location(span, file$l, 128, 3, 4004);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (rightIcon_slot_or_fallback) {
    				rightIcon_slot_or_fallback.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (rightIcon_slot) {
    				if (rightIcon_slot.p && (!current || dirty & /*$$scope*/ 134217728)) {
    					update_slot_base(
    						rightIcon_slot,
    						rightIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[27],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
    						: get_slot_changes(rightIcon_slot_template, /*$$scope*/ ctx[27], dirty, get_rightIcon_slot_changes_1),
    						get_rightIcon_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rightIcon_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rightIcon_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (rightIcon_slot_or_fallback) rightIcon_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(128:30) ",
    		ctx
    	});

    	return block;
    }

    // (124:2) {#if loading && loaderPosition === 'right'}
    function create_if_block_6$1(ctx) {
    	let span;
    	let loader;
    	let current;

    	loader = new Loader$1({
    			props: {
    				variant: /*loaderProps*/ ctx[6].variant,
    				size: /*loaderProps*/ ctx[6].size,
    				color: /*loaderProps*/ ctx[6].color
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(loader.$$.fragment);
    			attr_dev(span, "class", "right-section svelte-5xpm5q");
    			add_location(span, file$l, 124, 3, 3835);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(loader, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loader_changes = {};
    			if (dirty & /*loaderProps*/ 64) loader_changes.variant = /*loaderProps*/ ctx[6].variant;
    			if (dirty & /*loaderProps*/ 64) loader_changes.size = /*loaderProps*/ ctx[6].size;
    			if (dirty & /*loaderProps*/ 64) loader_changes.color = /*loaderProps*/ ctx[6].color;
    			loader.$set(loader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(loader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(124:2) {#if loading && loaderPosition === 'right'}",
    		ctx
    	});

    	return block;
    }

    // (130:27) X
    function fallback_block_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("X");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_3.name,
    		type: "fallback",
    		source: "(130:27) X",
    		ctx
    	});

    	return block;
    }

    // (77:29) 
    function create_if_block_5$1(ctx) {
    	let span;
    	let current;
    	const leftIcon_slot_template = /*#slots*/ ctx[28].leftIcon;
    	const leftIcon_slot = create_slot(leftIcon_slot_template, ctx, /*$$scope*/ ctx[27], get_leftIcon_slot_context);
    	const leftIcon_slot_or_fallback = leftIcon_slot || fallback_block_2(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (leftIcon_slot_or_fallback) leftIcon_slot_or_fallback.c();
    			attr_dev(span, "class", "left-section svelte-5xpm5q");
    			add_location(span, file$l, 77, 3, 2597);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (leftIcon_slot_or_fallback) {
    				leftIcon_slot_or_fallback.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (leftIcon_slot) {
    				if (leftIcon_slot.p && (!current || dirty & /*$$scope*/ 134217728)) {
    					update_slot_base(
    						leftIcon_slot,
    						leftIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[27],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
    						: get_slot_changes(leftIcon_slot_template, /*$$scope*/ ctx[27], dirty, get_leftIcon_slot_changes),
    						get_leftIcon_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(leftIcon_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(leftIcon_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (leftIcon_slot_or_fallback) leftIcon_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(77:29) ",
    		ctx
    	});

    	return block;
    }

    // (73:2) {#if loading && loaderPosition === 'left'}
    function create_if_block_4$2(ctx) {
    	let span;
    	let loader;
    	let current;

    	loader = new Loader$1({
    			props: {
    				variant: /*loaderProps*/ ctx[6].variant,
    				size: /*loaderProps*/ ctx[6].size,
    				color: /*loaderProps*/ ctx[6].color
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(loader.$$.fragment);
    			attr_dev(span, "class", "left-section svelte-5xpm5q");
    			add_location(span, file$l, 73, 3, 2430);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(loader, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loader_changes = {};
    			if (dirty & /*loaderProps*/ 64) loader_changes.variant = /*loaderProps*/ ctx[6].variant;
    			if (dirty & /*loaderProps*/ 64) loader_changes.size = /*loaderProps*/ ctx[6].size;
    			if (dirty & /*loaderProps*/ 64) loader_changes.color = /*loaderProps*/ ctx[6].color;
    			loader.$set(loader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(loader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(73:2) {#if loading && loaderPosition === 'left'}",
    		ctx
    	});

    	return block;
    }

    // (79:26) X
    function fallback_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("X");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(79:26) X",
    		ctx
    	});

    	return block;
    }

    // (82:8) Button
    function fallback_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(82:8) Button",
    		ctx
    	});

    	return block;
    }

    // (83:2) {#if ripple}
    function create_if_block_3$2(ctx) {
    	let ripple_1;
    	let current;

    	ripple_1 = new Ripple$1({
    			props: { center: false, circle: false },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ripple_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ripple_1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ripple_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(83:2) {#if ripple}",
    		ctx
    	});

    	return block;
    }

    // (90:30) 
    function create_if_block_2$7(ctx) {
    	let span;
    	let current;
    	const rightIcon_slot_template = /*#slots*/ ctx[28].rightIcon;
    	const rightIcon_slot = create_slot(rightIcon_slot_template, ctx, /*$$scope*/ ctx[27], get_rightIcon_slot_context);
    	const rightIcon_slot_or_fallback = rightIcon_slot || fallback_block$5(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (rightIcon_slot_or_fallback) rightIcon_slot_or_fallback.c();
    			attr_dev(span, "class", "right-section svelte-5xpm5q");
    			add_location(span, file$l, 90, 3, 2986);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (rightIcon_slot_or_fallback) {
    				rightIcon_slot_or_fallback.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (rightIcon_slot) {
    				if (rightIcon_slot.p && (!current || dirty & /*$$scope*/ 134217728)) {
    					update_slot_base(
    						rightIcon_slot,
    						rightIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[27],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
    						: get_slot_changes(rightIcon_slot_template, /*$$scope*/ ctx[27], dirty, get_rightIcon_slot_changes),
    						get_rightIcon_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rightIcon_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rightIcon_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (rightIcon_slot_or_fallback) rightIcon_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(90:30) ",
    		ctx
    	});

    	return block;
    }

    // (86:2) {#if loading && loaderPosition === 'right'}
    function create_if_block_1$c(ctx) {
    	let span;
    	let loader;
    	let current;

    	loader = new Loader$1({
    			props: {
    				variant: /*loaderProps*/ ctx[6].variant,
    				size: /*loaderProps*/ ctx[6].size,
    				color: /*loaderProps*/ ctx[6].color
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(loader.$$.fragment);
    			attr_dev(span, "class", "right-section svelte-5xpm5q");
    			add_location(span, file$l, 86, 3, 2817);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(loader, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loader_changes = {};
    			if (dirty & /*loaderProps*/ 64) loader_changes.variant = /*loaderProps*/ ctx[6].variant;
    			if (dirty & /*loaderProps*/ 64) loader_changes.size = /*loaderProps*/ ctx[6].size;
    			if (dirty & /*loaderProps*/ 64) loader_changes.color = /*loaderProps*/ ctx[6].color;
    			loader.$set(loader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(loader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(86:2) {#if loading && loaderPosition === 'right'}",
    		ctx
    	});

    	return block;
    }

    // (92:27) X
    function fallback_block$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("X");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$5.name,
    		type: "fallback",
    		source: "(92:27) X",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let error;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	error = new Error$2({
    			props: {
    				observable: /*observable*/ ctx[14],
    				component: "Button",
    				code: /*err*/ ctx[15]
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$j, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(error.$$.fragment);
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1$4("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const error_changes = {};
    			if (dirty & /*observable*/ 16384) error_changes.observable = /*observable*/ ctx[14];
    			if (dirty & /*err*/ 32768) error_changes.code = /*err*/ ctx[15];
    			error.$set(error_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","variant","color","size","radius","gradient","loaderPosition","loaderProps","href","external","disabled","compact","loading","uppercase","fullSize","ripple"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['leftIcon','default','rightIcon']);
    	const $$slots = compute_slots(slots);

    	let { use = [], element = undefined, class: className = '', override = {}, variant = 'filled', color = 'blue', size = 'sm', radius = 'sm', gradient = { from: 'indigo', to: 'cyan', deg: 45 }, loaderPosition = 'left', loaderProps = {
    		size: 'xs',
    		color: 'white',
    		variant: 'circle'
    	}, href = null, external = false, disabled = false, compact = false, loading = false, uppercase = false, fullSize = false, ripple = false } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	// --------------Error Handling-------------------
    	let observable = false;

    	let err;

    	if (disabled && loading) {
    		observable = true;
    		err = ButtonErrors[0];
    	}

    	if (external && typeof href !== 'string' || href?.length < 1) {
    		observable = true;
    		err = ButtonErrors[1];
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(1, override = $$new_props.override);
    		if ('variant' in $$new_props) $$invalidate(4, variant = $$new_props.variant);
    		if ('color' in $$new_props) $$invalidate(22, color = $$new_props.color);
    		if ('size' in $$new_props) $$invalidate(23, size = $$new_props.size);
    		if ('radius' in $$new_props) $$invalidate(24, radius = $$new_props.radius);
    		if ('gradient' in $$new_props) $$invalidate(25, gradient = $$new_props.gradient);
    		if ('loaderPosition' in $$new_props) $$invalidate(5, loaderPosition = $$new_props.loaderPosition);
    		if ('loaderProps' in $$new_props) $$invalidate(6, loaderProps = $$new_props.loaderProps);
    		if ('href' in $$new_props) $$invalidate(7, href = $$new_props.href);
    		if ('external' in $$new_props) $$invalidate(8, external = $$new_props.external);
    		if ('disabled' in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('compact' in $$new_props) $$invalidate(10, compact = $$new_props.compact);
    		if ('loading' in $$new_props) $$invalidate(11, loading = $$new_props.loading);
    		if ('uppercase' in $$new_props) $$invalidate(12, uppercase = $$new_props.uppercase);
    		if ('fullSize' in $$new_props) $$invalidate(26, fullSize = $$new_props.fullSize);
    		if ('ripple' in $$new_props) $$invalidate(13, ripple = $$new_props.ripple);
    		if ('$$scope' in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$k,
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		ButtonErrors,
    		Error: Error$2,
    		Loader: Loader$1,
    		Ripple: Ripple$1,
    		use,
    		element,
    		className,
    		override,
    		variant,
    		color,
    		size,
    		radius,
    		gradient,
    		loaderPosition,
    		loaderProps,
    		href,
    		external,
    		disabled,
    		compact,
    		loading,
    		uppercase,
    		fullSize,
    		ripple,
    		forwardEvents,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(1, override = $$new_props.override);
    		if ('variant' in $$props) $$invalidate(4, variant = $$new_props.variant);
    		if ('color' in $$props) $$invalidate(22, color = $$new_props.color);
    		if ('size' in $$props) $$invalidate(23, size = $$new_props.size);
    		if ('radius' in $$props) $$invalidate(24, radius = $$new_props.radius);
    		if ('gradient' in $$props) $$invalidate(25, gradient = $$new_props.gradient);
    		if ('loaderPosition' in $$props) $$invalidate(5, loaderPosition = $$new_props.loaderPosition);
    		if ('loaderProps' in $$props) $$invalidate(6, loaderProps = $$new_props.loaderProps);
    		if ('href' in $$props) $$invalidate(7, href = $$new_props.href);
    		if ('external' in $$props) $$invalidate(8, external = $$new_props.external);
    		if ('disabled' in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('compact' in $$props) $$invalidate(10, compact = $$new_props.compact);
    		if ('loading' in $$props) $$invalidate(11, loading = $$new_props.loading);
    		if ('uppercase' in $$props) $$invalidate(12, uppercase = $$new_props.uppercase);
    		if ('fullSize' in $$props) $$invalidate(26, fullSize = $$new_props.fullSize);
    		if ('ripple' in $$props) $$invalidate(13, ripple = $$new_props.ripple);
    		if ('observable' in $$props) $$invalidate(14, observable = $$new_props.observable);
    		if ('err' in $$props) $$invalidate(15, err = $$new_props.err);
    		if ('getStyles' in $$props) $$invalidate(16, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(17, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(18, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*observable*/ 16384) {
    			if (observable) $$invalidate(1, override = { display: 'none' });
    		}

    		if ($$self.$$.dirty & /*color, compact, fullSize, gradient, radius, size, variant*/ 130024464) {
    			// --------------Error Handling-------------------
    			$$invalidate(
    				18,
    				{ cx, classes, getStyles } = useStyles$k(
    					{
    						color,
    						compact,
    						fullSize,
    						gradient,
    						radius,
    						size,
    						variant
    					},
    					{ name: 'Button' }
    				),
    				cx,
    				((((((($$invalidate(17, classes), $$invalidate(22, color)), $$invalidate(10, compact)), $$invalidate(26, fullSize)), $$invalidate(25, gradient)), $$invalidate(24, radius)), $$invalidate(23, size)), $$invalidate(4, variant)),
    				((((((($$invalidate(16, getStyles), $$invalidate(22, color)), $$invalidate(10, compact)), $$invalidate(26, fullSize)), $$invalidate(25, gradient)), $$invalidate(24, radius)), $$invalidate(23, size)), $$invalidate(4, variant))
    			);
    		}
    	};

    	return [
    		element,
    		override,
    		use,
    		className,
    		variant,
    		loaderPosition,
    		loaderProps,
    		href,
    		external,
    		disabled,
    		compact,
    		loading,
    		uppercase,
    		ripple,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx,
    		forwardEvents,
    		$$restProps,
    		$$slots,
    		color,
    		size,
    		radius,
    		gradient,
    		fullSize,
    		$$scope,
    		slots,
    		a_binding,
    		button_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$E,
    			create_fragment$E,
    			safe_not_equal,
    			{
    				use: 2,
    				element: 0,
    				class: 3,
    				override: 1,
    				variant: 4,
    				color: 22,
    				size: 23,
    				radius: 24,
    				gradient: 25,
    				loaderPosition: 5,
    				loaderProps: 6,
    				href: 7,
    				external: 8,
    				disabled: 9,
    				compact: 10,
    				loading: 11,
    				uppercase: 12,
    				fullSize: 26,
    				ripple: 13
    			},
    			add_css
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get use() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gradient() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gradient(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loaderPosition() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaderPosition(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loaderProps() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaderProps(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get external() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set external(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get compact() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set compact(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get uppercase() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set uppercase(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullSize() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullSize(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error_1$4("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error_1$4("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Button$1 = Button;

    const sizes$4 = {
        xs: 18,
        sm: 22,
        md: 28,
        lg: 34,
        xl: 44
    };
    function getVariantStyles(color) {
        const { themeColor } = fns;
        const variants = vFunc(color);
        return {
            ...variants,
            hover: {
                [`${dark.selector} &`]: {
                    color: themeColor(color, 8),
                    '&:hover': { backgroundColor: themeColor('dark', 8) }
                },
                border: '1px solid transparent',
                backgroundColor: 'transparent',
                color: themeColor(color, 7),
                '&:hover': { backgroundColor: themeColor(color) }
            },
            transparent: {
                [`${dark.selector} &`]: {
                    color: themeColor(color, 8),
                    '&:hover': { backgroundColor: null }
                },
                border: '1px solid transparent',
                backgroundColor: 'transparent',
                color: themeColor(color, 7),
                '&:hover': { backgroundColor: null }
            }
        };
    }
    var useStyles$j = createStyles((theme, { color, radius, size }) => {
        return {
            root: {
                focusRing: 'auto',
                position: 'relative',
                appearance: 'none',
                WebkitAppearance: 'none',
                WebkitTapHighlightColor: 'transparent',
                boxSizing: 'border-box',
                height: typeof size === 'string' ? sizes$4[size] : `${size}px`,
                minHeight: typeof size === 'string' ? sizes$4[size] : `${size}px`,
                width: typeof size === 'string' ? sizes$4[size] : `${size}px`,
                minWidth: typeof size === 'string' ? sizes$4[size] : `${size}px`,
                borderRadius: `$${radius}`,
                padding: 0,
                lineHeight: 1,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                cursor: 'pointer',
                textDecoration: 'none',
                '&:not(:disabled):active': {
                    transform: 'translateY(1px)'
                },
                '&:disabled': {
                    pointerEvents: 'none',
                    borderColor: 'transparent',
                    background: theme.fn.themeColor('gray', 2),
                    backgroundColor: theme.fn.themeColor('gray', 2),
                    color: theme.fn.themeColor('gray', 5),
                    cursor: 'not-allowed',
                    darkMode: {
                        borderColor: 'transparent',
                        backgroundColor: theme.fn.themeColor('dark', 4),
                        color: theme.fn.themeColor('dark', 6)
                    }
                }
            },
            loading: {
                pointerEvents: 'none',
                '&::before': {
                    content: '""',
                    position: 'absolute',
                    top: -1,
                    left: -1,
                    right: -1,
                    bottom: -1,
                    backgroundColor: 'rgba(255, 255, 255, .5)',
                    borderRadius: `$${radius}`,
                    cursor: 'not-allowed'
                }
            },
            variants: {
                variation: getVariantStyles(color)
            }
        };
    });

    /** Error codes for component Text
     *
     * `Object.freeze` is needed to keep modification outside of the object unavailable
     *
     * ## Code 1:
     * If using the 'href' prop, set 'root' prop to an anchor ('a') tag
     *
     */
    const ActionIconErrors = Object.freeze([
        {
            error: true,
            message: "If using the 'href' prop, set 'root' prop to an anchor ('a') tag",
            solution: `
                If your component looks like this:

                &lt;ActionIcon href='https://example.com'&gt;
                          ^^^ - Try adding prop root='a'
                       &lt;Icon /&gt;
                &lt;/ActionIcon&gt;
                `
        }
    ]);

    /* node_modules/@svelteuidev/core/dist/components/ActionIcon/ActionIcon.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1$3 } = globals;

    // (63:1) {:else}
    function create_else_block$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);
    	const default_slot_or_fallback = default_slot || fallback_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(63:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (61:1) {#if loading}
    function create_if_block$i(ctx) {
    	let loader;
    	let current;

    	loader = new Loader$1({
    			props: {
    				size: /*loaderProps*/ ctx[6].size,
    				color: /*loaderProps*/ ctx[6].color,
    				variant: /*loaderProps*/ ctx[6].variant
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loader_changes = {};
    			if (dirty & /*loaderProps*/ 64) loader_changes.size = /*loaderProps*/ ctx[6].size;
    			if (dirty & /*loaderProps*/ 64) loader_changes.color = /*loaderProps*/ ctx[6].color;
    			if (dirty & /*loaderProps*/ 64) loader_changes.variant = /*loaderProps*/ ctx[6].variant;
    			loader.$set(loader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(61:1) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (64:8) +
    function fallback_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("+");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$4.name,
    		type: "fallback",
    		source: "(64:8) +",
    		ctx
    	});

    	return block;
    }

    // (44:0) <Box  bind:element  use={[forwardEvents, [useActions, use]]}  tabindex={0}  disabled={disabled || loading}  class={cx(   className,   classes.root,   { [classes.loading]: loading },   getStyles({ css: override, variation: variant })  )}  target={external ? '_blank' : null}  rel={external ? 'noreferrer noopener' : null}  {root}  {href}  {...$$restProps} >
    function create_default_slot$w(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$i, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loading*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(44:0) <Box  bind:element  use={[forwardEvents, [useActions, use]]}  tabindex={0}  disabled={disabled || loading}  class={cx(   className,   classes.root,   { [classes.loading]: loading },   getStyles({ css: override, variation: variant })  )}  target={external ? '_blank' : null}  rel={external ? 'noreferrer noopener' : null}  {root}  {href}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let error;
    	let t;
    	let box;
    	let updating_element;
    	let current;

    	error = new Error$2({
    			props: {
    				observable: /*observable*/ ctx[11],
    				component: "ActionIcon",
    				code: /*err*/ ctx[12]
    			},
    			$$inline: true
    		});

    	const box_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[16], [useActions, /*use*/ ctx[2]]]
    		},
    		{ tabindex: 0 },
    		{
    			disabled: /*disabled*/ ctx[8] || /*loading*/ ctx[7]
    		},
    		{
    			class: /*cx*/ ctx[15](
    				/*className*/ ctx[3],
    				/*classes*/ ctx[14].root,
    				{
    					[/*classes*/ ctx[14].loading]: /*loading*/ ctx[7]
    				},
    				/*getStyles*/ ctx[13]({
    					css: /*override*/ ctx[1],
    					variation: /*variant*/ ctx[5]
    				})
    			)
    		},
    		{
    			target: /*external*/ ctx[10] ? '_blank' : null
    		},
    		{
    			rel: /*external*/ ctx[10] ? 'noreferrer noopener' : null
    		},
    		{ root: /*root*/ ctx[4] },
    		{ href: /*href*/ ctx[9] },
    		/*$$restProps*/ ctx[17]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[22](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$w] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(error.$$.fragment);
    			t = space();
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$3("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const error_changes = {};
    			if (dirty & /*observable*/ 2048) error_changes.observable = /*observable*/ ctx[11];
    			if (dirty & /*err*/ 4096) error_changes.code = /*err*/ ctx[12];
    			error.$set(error_changes);

    			const box_changes = (dirty & /*forwardEvents, useActions, use, disabled, loading, cx, className, classes, getStyles, override, variant, external, root, href, $$restProps*/ 255934)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*forwardEvents, useActions, use*/ 65540 && {
    						use: [/*forwardEvents*/ ctx[16], [useActions, /*use*/ ctx[2]]]
    					},
    					box_spread_levels[1],
    					dirty & /*disabled, loading*/ 384 && {
    						disabled: /*disabled*/ ctx[8] || /*loading*/ ctx[7]
    					},
    					dirty & /*cx, className, classes, loading, getStyles, override, variant*/ 57514 && {
    						class: /*cx*/ ctx[15](
    							/*className*/ ctx[3],
    							/*classes*/ ctx[14].root,
    							{
    								[/*classes*/ ctx[14].loading]: /*loading*/ ctx[7]
    							},
    							/*getStyles*/ ctx[13]({
    								css: /*override*/ ctx[1],
    								variation: /*variant*/ ctx[5]
    							})
    						)
    					},
    					dirty & /*external*/ 1024 && {
    						target: /*external*/ ctx[10] ? '_blank' : null
    					},
    					dirty & /*external*/ 1024 && {
    						rel: /*external*/ ctx[10] ? 'noreferrer noopener' : null
    					},
    					dirty & /*root*/ 16 && { root: /*root*/ ctx[4] },
    					dirty & /*href*/ 512 && { href: /*href*/ ctx[9] },
    					dirty & /*$$restProps*/ 131072 && get_spread_object(/*$$restProps*/ ctx[17])
    				])
    			: {};

    			if (dirty & /*$$scope, loaderProps, loading*/ 8388800) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","root","color","variant","size","radius","loaderProps","loading","disabled","href","external"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ActionIcon', slots, ['default']);

    	let { use = [], element = undefined, class: className = '', override = {}, root = 'button', color = 'gray', variant = 'hover', size = 'md', radius = 'sm', loaderProps = {
    		size: 'xs',
    		color: 'gray',
    		variant: 'circle'
    	}, loading = false, disabled = false, href = '', external = false } = $$props;

    	const forwardEvents = createEventForwarder(get_current_component());

    	// --------------Error Handling-------------------
    	let observable = false;

    	let err;

    	if (root !== 'a' && $$props.href) {
    		observable = true;
    		err = ActionIconErrors[0];
    	}

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(1, override = $$new_props.override);
    		if ('root' in $$new_props) $$invalidate(4, root = $$new_props.root);
    		if ('color' in $$new_props) $$invalidate(18, color = $$new_props.color);
    		if ('variant' in $$new_props) $$invalidate(5, variant = $$new_props.variant);
    		if ('size' in $$new_props) $$invalidate(19, size = $$new_props.size);
    		if ('radius' in $$new_props) $$invalidate(20, radius = $$new_props.radius);
    		if ('loaderProps' in $$new_props) $$invalidate(6, loaderProps = $$new_props.loaderProps);
    		if ('loading' in $$new_props) $$invalidate(7, loading = $$new_props.loading);
    		if ('disabled' in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ('href' in $$new_props) $$invalidate(9, href = $$new_props.href);
    		if ('external' in $$new_props) $$invalidate(10, external = $$new_props.external);
    		if ('$$scope' in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$j,
    		ActionIconErrors,
    		createEventForwarder,
    		useActions,
    		get_current_component,
    		Box: Box$1,
    		Loader: Loader$1,
    		Error: Error$2,
    		use,
    		element,
    		className,
    		override,
    		root,
    		color,
    		variant,
    		size,
    		radius,
    		loaderProps,
    		loading,
    		disabled,
    		href,
    		external,
    		forwardEvents,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(1, override = $$new_props.override);
    		if ('root' in $$props) $$invalidate(4, root = $$new_props.root);
    		if ('color' in $$props) $$invalidate(18, color = $$new_props.color);
    		if ('variant' in $$props) $$invalidate(5, variant = $$new_props.variant);
    		if ('size' in $$props) $$invalidate(19, size = $$new_props.size);
    		if ('radius' in $$props) $$invalidate(20, radius = $$new_props.radius);
    		if ('loaderProps' in $$props) $$invalidate(6, loaderProps = $$new_props.loaderProps);
    		if ('loading' in $$props) $$invalidate(7, loading = $$new_props.loading);
    		if ('disabled' in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ('href' in $$props) $$invalidate(9, href = $$new_props.href);
    		if ('external' in $$props) $$invalidate(10, external = $$new_props.external);
    		if ('observable' in $$props) $$invalidate(11, observable = $$new_props.observable);
    		if ('err' in $$props) $$invalidate(12, err = $$new_props.err);
    		if ('getStyles' in $$props) $$invalidate(13, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(14, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(15, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*observable*/ 2048) {
    			if (observable) $$invalidate(1, override = { display: 'none' });
    		}

    		if ($$self.$$.dirty & /*color, radius, size*/ 1835008) {
    			// --------------End Error Handling-------------------
    			$$invalidate(15, { cx, classes, getStyles } = useStyles$j({ color, radius, size }, { name: 'ActionIcon' }), cx, ((($$invalidate(14, classes), $$invalidate(18, color)), $$invalidate(20, radius)), $$invalidate(19, size)), ((($$invalidate(13, getStyles), $$invalidate(18, color)), $$invalidate(20, radius)), $$invalidate(19, size)));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		element,
    		override,
    		use,
    		className,
    		root,
    		variant,
    		loaderProps,
    		loading,
    		disabled,
    		href,
    		external,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx,
    		forwardEvents,
    		$$restProps,
    		color,
    		size,
    		radius,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class ActionIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			use: 2,
    			element: 0,
    			class: 3,
    			override: 1,
    			root: 4,
    			color: 18,
    			variant: 5,
    			size: 19,
    			radius: 20,
    			loaderProps: 6,
    			loading: 7,
    			disabled: 8,
    			href: 9,
    			external: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ActionIcon",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get use() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get root() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set root(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loaderProps() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaderProps(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get external() {
    		throw new Error_1$3("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set external(value) {
    		throw new Error_1$3("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var ActionIcon$1 = ActionIcon;

    /* node_modules/@svelteuidev/core/dist/components/ActionIcon/CloseButton/CloseIcon.svelte generated by Svelte v3.59.2 */

    const file$k = "node_modules/@svelteuidev/core/dist/components/ActionIcon/CloseButton/CloseIcon.svelte";

    function create_fragment$C(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ width: /*width*/ ctx[0] },
    		{ height: /*height*/ ctx[1] },
    		{ viewBox: "0 0 15 15" },
    		{ fill: "none" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		/*$$restProps*/ ctx[2]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			add_location(path, file$k, 12, 1, 181);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$k, 4, 0, 66);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				dirty & /*width*/ 1 && { width: /*width*/ ctx[0] },
    				dirty & /*height*/ 2 && { height: /*height*/ ctx[1] },
    				{ viewBox: "0 0 15 15" },
    				{ fill: "none" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	const omit_props_names = ["width","height"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CloseIcon', slots, []);
    	let { width = 16 } = $$props;
    	let { height = 16 } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('width' in $$new_props) $$invalidate(0, width = $$new_props.width);
    		if ('height' in $$new_props) $$invalidate(1, height = $$new_props.height);
    	};

    	$$self.$capture_state = () => ({ width, height });

    	$$self.$inject_state = $$new_props => {
    		if ('width' in $$props) $$invalidate(0, width = $$new_props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$new_props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, $$restProps];
    }

    class CloseIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { width: 0, height: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CloseIcon",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get width() {
    		throw new Error("<CloseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<CloseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<CloseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<CloseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var CloseIcon$1 = CloseIcon;

    /* node_modules/@svelteuidev/core/dist/components/ActionIcon/CloseButton/CloseButton.svelte generated by Svelte v3.59.2 */

    // (34:0) <ActionIcon  bind:element  class={className}  use={[forwardEvents, [useActions, use]]}  {override}  {root}  {color}  {variant}  {size}  {radius}  {loaderProps}  {loading}  {disabled}  {href}  {external}  {...$$restProps} >
    function create_default_slot$v(ctx) {
    	let closeicon;
    	let current;

    	closeicon = new CloseIcon$1({
    			props: {
    				width: /*iconSizes*/ ctx[16][/*iconSize*/ ctx[4]],
    				height: /*iconSizes*/ ctx[16][/*iconSize*/ ctx[4]]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(closeicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(closeicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const closeicon_changes = {};
    			if (dirty & /*iconSize*/ 16) closeicon_changes.width = /*iconSizes*/ ctx[16][/*iconSize*/ ctx[4]];
    			if (dirty & /*iconSize*/ 16) closeicon_changes.height = /*iconSizes*/ ctx[16][/*iconSize*/ ctx[4]];
    			closeicon.$set(closeicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(closeicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(closeicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(closeicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(34:0) <ActionIcon  bind:element  class={className}  use={[forwardEvents, [useActions, use]]}  {override}  {root}  {color}  {variant}  {size}  {radius}  {loaderProps}  {loading}  {disabled}  {href}  {external}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let actionicon;
    	let updating_element;
    	let current;

    	const actionicon_spread_levels = [
    		{ class: /*className*/ ctx[2] },
    		{
    			use: [/*forwardEvents*/ ctx[15], [useActions, /*use*/ ctx[1]]]
    		},
    		{ override: /*override*/ ctx[3] },
    		{ root: /*root*/ ctx[5] },
    		{ color: /*color*/ ctx[6] },
    		{ variant: /*variant*/ ctx[7] },
    		{ size: /*size*/ ctx[8] },
    		{ radius: /*radius*/ ctx[9] },
    		{ loaderProps: /*loaderProps*/ ctx[10] },
    		{ loading: /*loading*/ ctx[11] },
    		{ disabled: /*disabled*/ ctx[12] },
    		{ href: /*href*/ ctx[13] },
    		{ external: /*external*/ ctx[14] },
    		/*$$restProps*/ ctx[17]
    	];

    	function actionicon_element_binding(value) {
    		/*actionicon_element_binding*/ ctx[18](value);
    	}

    	let actionicon_props = {
    		$$slots: { default: [create_default_slot$v] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < actionicon_spread_levels.length; i += 1) {
    		actionicon_props = assign(actionicon_props, actionicon_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		actionicon_props.element = /*element*/ ctx[0];
    	}

    	actionicon = new ActionIcon$1({ props: actionicon_props, $$inline: true });
    	binding_callbacks.push(() => bind(actionicon, 'element', actionicon_element_binding));

    	const block = {
    		c: function create() {
    			create_component(actionicon.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(actionicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const actionicon_changes = (dirty & /*className, forwardEvents, useActions, use, override, root, color, variant, size, radius, loaderProps, loading, disabled, href, external, $$restProps*/ 196590)
    			? get_spread_update(actionicon_spread_levels, [
    					dirty & /*className*/ 4 && { class: /*className*/ ctx[2] },
    					dirty & /*forwardEvents, useActions, use*/ 32770 && {
    						use: [/*forwardEvents*/ ctx[15], [useActions, /*use*/ ctx[1]]]
    					},
    					dirty & /*override*/ 8 && { override: /*override*/ ctx[3] },
    					dirty & /*root*/ 32 && { root: /*root*/ ctx[5] },
    					dirty & /*color*/ 64 && { color: /*color*/ ctx[6] },
    					dirty & /*variant*/ 128 && { variant: /*variant*/ ctx[7] },
    					dirty & /*size*/ 256 && { size: /*size*/ ctx[8] },
    					dirty & /*radius*/ 512 && { radius: /*radius*/ ctx[9] },
    					dirty & /*loaderProps*/ 1024 && { loaderProps: /*loaderProps*/ ctx[10] },
    					dirty & /*loading*/ 2048 && { loading: /*loading*/ ctx[11] },
    					dirty & /*disabled*/ 4096 && { disabled: /*disabled*/ ctx[12] },
    					dirty & /*href*/ 8192 && { href: /*href*/ ctx[13] },
    					dirty & /*external*/ 16384 && { external: /*external*/ ctx[14] },
    					dirty & /*$$restProps*/ 131072 && get_spread_object(/*$$restProps*/ ctx[17])
    				])
    			: {};

    			if (dirty & /*$$scope, iconSize*/ 524304) {
    				actionicon_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				actionicon_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			actionicon.$set(actionicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actionicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actionicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actionicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"use","element","class","override","iconSize","root","color","variant","size","radius","loaderProps","loading","disabled","href","external"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CloseButton', slots, []);

    	let { use = [], element = undefined, class: className = '', override = {}, iconSize = 'md', root = 'button', color = 'gray', variant = 'hover', size = 'md', radius = 'sm', loaderProps = {
    		size: 'xs',
    		color: 'gray',
    		variant: 'circle'
    	}, loading = false, disabled = false, href = '', external = false } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	const iconSizes = { xs: 12, sm: 14, md: 16, lg: 20, xl: 24 };

    	function actionicon_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('iconSize' in $$new_props) $$invalidate(4, iconSize = $$new_props.iconSize);
    		if ('root' in $$new_props) $$invalidate(5, root = $$new_props.root);
    		if ('color' in $$new_props) $$invalidate(6, color = $$new_props.color);
    		if ('variant' in $$new_props) $$invalidate(7, variant = $$new_props.variant);
    		if ('size' in $$new_props) $$invalidate(8, size = $$new_props.size);
    		if ('radius' in $$new_props) $$invalidate(9, radius = $$new_props.radius);
    		if ('loaderProps' in $$new_props) $$invalidate(10, loaderProps = $$new_props.loaderProps);
    		if ('loading' in $$new_props) $$invalidate(11, loading = $$new_props.loading);
    		if ('disabled' in $$new_props) $$invalidate(12, disabled = $$new_props.disabled);
    		if ('href' in $$new_props) $$invalidate(13, href = $$new_props.href);
    		if ('external' in $$new_props) $$invalidate(14, external = $$new_props.external);
    	};

    	$$self.$capture_state = () => ({
    		ActionIcon: ActionIcon$1,
    		CloseIcon: CloseIcon$1,
    		createEventForwarder,
    		useActions,
    		get_current_component,
    		use,
    		element,
    		className,
    		override,
    		iconSize,
    		root,
    		color,
    		variant,
    		size,
    		radius,
    		loaderProps,
    		loading,
    		disabled,
    		href,
    		external,
    		forwardEvents,
    		iconSizes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('iconSize' in $$props) $$invalidate(4, iconSize = $$new_props.iconSize);
    		if ('root' in $$props) $$invalidate(5, root = $$new_props.root);
    		if ('color' in $$props) $$invalidate(6, color = $$new_props.color);
    		if ('variant' in $$props) $$invalidate(7, variant = $$new_props.variant);
    		if ('size' in $$props) $$invalidate(8, size = $$new_props.size);
    		if ('radius' in $$props) $$invalidate(9, radius = $$new_props.radius);
    		if ('loaderProps' in $$props) $$invalidate(10, loaderProps = $$new_props.loaderProps);
    		if ('loading' in $$props) $$invalidate(11, loading = $$new_props.loading);
    		if ('disabled' in $$props) $$invalidate(12, disabled = $$new_props.disabled);
    		if ('href' in $$props) $$invalidate(13, href = $$new_props.href);
    		if ('external' in $$props) $$invalidate(14, external = $$new_props.external);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		element,
    		use,
    		className,
    		override,
    		iconSize,
    		root,
    		color,
    		variant,
    		size,
    		radius,
    		loaderProps,
    		loading,
    		disabled,
    		href,
    		external,
    		forwardEvents,
    		iconSizes,
    		$$restProps,
    		actionicon_element_binding
    	];
    }

    class CloseButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			iconSize: 4,
    			root: 5,
    			color: 6,
    			variant: 7,
    			size: 8,
    			radius: 9,
    			loaderProps: 10,
    			loading: 11,
    			disabled: 12,
    			href: 13,
    			external: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CloseButton",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get use() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconSize() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconSize(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get root() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set root(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loaderProps() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaderProps(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get external() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set external(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var CloseButton$1 = CloseButton;

    const TABBABLE_NODES = /input|select|textarea|button|object/;
    const FOCUS_SELECTOR = 'a, input, select, textarea, button, object, [tabindex]';
    function hidden(element) {
        if (process.env.NODE_ENV === 'test') {
            return false;
        }
        return element.style.display === 'none';
    }
    function visible(element) {
        const isHidden = element.getAttribute('aria-hidden') ||
            element.getAttribute('hidden') ||
            element.getAttribute('type') === 'hidden';
        if (isHidden) {
            return false;
        }
        let parentElement = element;
        while (parentElement) {
            if (parentElement === document.body || parentElement.nodeType === 11) {
                break;
            }
            if (hidden(parentElement)) {
                return false;
            }
            parentElement = parentElement.parentNode;
        }
        return true;
    }
    function getElementTabIndex(element) {
        const tabIndex = element.getAttribute('tabindex');
        return tabIndex ? parseInt(tabIndex, 10) : null;
    }
    function focusable(element) {
        const nodeName = element.nodeName.toLowerCase();
        const isTabIndexNotNull = getElementTabIndex(element) !== null;
        const res = 
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        (TABBABLE_NODES.test(nodeName) && !element.disabled) ||
            (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNull : isTabIndexNotNull);
        return res && visible(element);
    }
    function tabbable(element) {
        const tabIndex = getElementTabIndex(element);
        const isTabIndexNull = tabIndex === null;
        return (isTabIndexNull || tabIndex >= 0) && focusable(element);
    }
    function findTabbableDescendants(element) {
        return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
    }

    function scopeTab(node, event) {
        const tabbable = findTabbableDescendants(node);
        if (!tabbable.length) {
            event.preventDefault();
            return;
        }
        const finalTabbable = tabbable[event.shiftKey ? 0 : tabbable.length - 1];
        const root = node.getRootNode();
        const leavingFinalTabbable = finalTabbable === root.activeElement || node === root.activeElement;
        if (!leavingFinalTabbable) {
            return;
        }
        event.preventDefault();
        const target = tabbable[event.shiftKey ? tabbable.length - 1 : 0];
        if (target) {
            target.focus();
        }
    }

    function createAriaHider(containerNode) {
        const hiddenDomNodes = [];
        gatherOutsideDomNodes(containerNode);
        hiddenDomNodes.map(({ node }) => {
            node.setAttribute('aria-hidden', 'true');
        });
        function gatherOutsideDomNodes(currentElement) {
            // 1. Start at the current element (begins with the container element).
            // 2. Hide all sibling elements that are not already aria-hidden.
            // 3. Go up one level to the parent element.
            // 4. Repeat steps 2-3 until you reach the `html` element.
            if (!currentElement) {
                return undefined;
            }
            if (currentElement !== document.querySelector('body')) {
                const parentElement = currentElement.parentElement;
                const siblingElements = [...Array.from(parentElement.children)];
                siblingElements.forEach((node) => {
                    const ariaHidden = node.getAttribute('aria-hidden');
                    if (node !== currentElement &&
                        node.nodeName !== 'SCRIPT' &&
                        (ariaHidden === null || ariaHidden === 'false')) {
                        hiddenDomNodes.push({ node, ariaHidden });
                    }
                });
                gatherOutsideDomNodes(parentElement);
            }
        }
        return () => {
            hiddenDomNodes.forEach((item) => {
                if (!item) {
                    return;
                }
                if (item.ariaHidden === null) {
                    item.node.removeAttribute('aria-hidden');
                }
                else {
                    item.node.setAttribute('aria-hidden', item.ariaHidden);
                }
            });
        };
    }

    /**
     * With the `use-focus-trap` action, the first focusable child gets the focus in the provided affected dom node
     *
     * ```tsx
     *  <div use:focustrap>
     *    <input placeholder="Focused" />
     *  </div>
     * ```
     * @see https://svelteui.org/actions/use-focus-trap
     */
    function focustrap(node, active = true) {
        let restoreAria = null;
        const handleKeyDown = (event) => {
            if (!active) {
                return;
            }
            if (event.key === 'Tab' && node) {
                scopeTab(node, event);
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        activate();
        // since action called only once and don't rerun on params update we have to make a function
        // which we can call on initialization and update
        function activate() {
            if (!active) {
                if (restoreAria) {
                    restoreAria();
                }
                return;
            }
            restoreAria = createAriaHider(node);
            const processNode = () => {
                let focusElement = node.querySelector('[autofocus]');
                if (!focusElement) {
                    const children = Array.from(node.querySelectorAll(FOCUS_SELECTOR));
                    focusElement = children.find(tabbable) || children.find(focusable) || null;
                    if (!focusElement && focusable(node))
                        focusElement = node;
                }
                if (focusElement) {
                    focusElement.focus({ preventScroll: true });
                }
                else if (process.env.NODE_ENV === 'development') {
                    // eslint-disable-next-line no-console
                    console.warn('[@svelteuidev/composables/use-focus-trap] Failed to find focusable element within provided node', node);
                }
            };
            // Delay processing the HTML node by a frame. This ensures focus is assigned correctly.
            setTimeout(() => {
                if (node.getRootNode()) {
                    processNode();
                }
                else if (process.env.NODE_ENV === 'development') {
                    // eslint-disable-next-line no-console
                    console.warn('[@svelteuidev/composables/use-focus-trap] node is not part of the dom', node);
                }
            });
        }
        return {
            update(newActive) {
                active = newActive;
                activate();
            },
            destroy() {
                document.removeEventListener('keydown', handleKeyDown);
                if (restoreAria) {
                    restoreAria();
                }
            }
        };
    }

    function createStyleTag() {
        const tag = document.createElement('style');
        tag.type = 'text/css';
        tag.setAttribute('svelteui-scroll-lock', '');
        return tag;
    }

    function getScrollWidth() {
        if (typeof window === 'undefined' || typeof document === 'undefined')
            return 0;
        const paddingRight = parseInt(window.getComputedStyle(document.body).paddingRight, 10);
        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        return paddingRight + scrollbarWidth;
    }

    const getLockStyles = ({ disableBodyPadding }) => {
        const scrollWidth = disableBodyPadding ? null : getScrollWidth();
        const styles = `body {
        --removed-scroll-width: ${scrollWidth}px;
        touch-action: none;
        overflow: hidden !important;
        position: relative !important;
        ${scrollWidth ? 'padding-right: var(--removed-scroll-width) !important;' : ''}
        `;
        return styles;
    };

    function injectStyles(tag, css) {
        if (tag.styleSheet) {
            tag.styleSheet.cssText = css;
        }
        else {
            tag.appendChild(document.createTextNode(css));
        }
    }

    function insertStyleTag(tag) {
        const head = document.head || document.getElementsByTagName('head')[0];
        head.appendChild(tag);
    }

    const isBrowser = () => typeof window !== 'undefined';
    const ENVIRONMENT = {
        browser: isBrowser(),
        server: !isBrowser()
    };
    const defaultWindow = ENVIRONMENT.browser ? window : undefined;

    /**
     *

     * @returns
     */
    /**
     * use-lock-scroll locks scroll at current position by setting document.body overflow to hidden.
     *
     * ```tsx
     * <div use:lockscroll={visible}>Can't scroll anymore</div>
     * ```
     *
     * @param lock - A boolean to specify whether or not to lock the screen
     * @param options - An object to specify offset width
     * @see https://svelteui.org/actions/use-lock-scroll
     */
    function lockscroll(node, lock, options = { disableBodyPadding: false }) {
        const { browser } = ENVIRONMENT;
        let window;
        if (browser) {
            window = defaultWindow;
        }
        let scrollLocked = lock ?? false;
        const { disableBodyPadding } = options;
        let stylesheet;
        const lockScroll = () => {
            const styles = getLockStyles({ disableBodyPadding });
            const sheet = createStyleTag();
            injectStyles(sheet, styles);
            insertStyleTag(sheet);
            stylesheet = sheet;
        };
        const unlockScroll = () => {
            if (!stylesheet)
                return;
            stylesheet?.parentNode?.removeChild(stylesheet);
            stylesheet = null;
        };
        if (scrollLocked) {
            lockScroll();
        }
        else {
            unlockScroll();
        }
        if (lock !== undefined) {
            scrollLocked = lock;
        }
        if (lock === undefined && typeof window !== 'undefined') {
            window.document.body.style.overflow === 'hidden' && (scrollLocked = lock);
        }
        return {
            update: (locked) => {
                if (locked) {
                    lockScroll();
                }
                else {
                    window.document.body.style.overflow === 'visible' && (scrollLocked = lock);
                    unlockScroll();
                }
            },
            destroy: () => {
                unlockScroll();
                return;
            }
        };
    }

    // adapted from romkor/svelte-portal
    /**
     * Usage: <div use:portal={'css selector'}> or <div use:portal={document.body}>
     *
     * @param target- DOM element or CSS selector to be appended to
     * @see https://svelteui.org/actions/use-portal
     */
    function portal(node, target = 'body') {
        let targetNode;
        async function update(newTarget) {
            target = newTarget;
            if (typeof target === 'string') {
                targetNode = document.querySelector(target);
                if (targetNode === null) {
                    await tick();
                    targetNode = document.querySelector(target);
                }
                if (targetNode === null) {
                    throw new Error(`No element found matching css selector: "${target}"`);
                }
            }
            else if (target instanceof HTMLElement) {
                targetNode = target;
            }
            else {
                throw new TypeError(`Unknown portal target type: ${target === null ? 'null' : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
            }
            targetNode.appendChild(node);
            node.hidden = false;
        }
        function destroy() {
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
        }
        update(target);
        return {
            update,
            destroy
        };
    }

    /** Return utilities for focus last active element, useful for Modal and Drawer */
    function useFocusReturn() {
        let lastActiveElement;
        const returnFocus = () => {
            if (lastActiveElement &&
                'focus' in lastActiveElement &&
                typeof lastActiveElement.focus === 'function') {
                lastActiveElement.focus({ preventScroll: true });
            }
        };
        return {
            handleFocusReturn(opened, shouldReturnFocus = true) {
                if (opened) {
                    lastActiveElement = document.activeElement;
                }
                else if (shouldReturnFocus) {
                    returnFocus();
                }
            },
            returnFocus
        };
    }

    /* node_modules/@svelteuidev/core/dist/components/Portal/Portal.svelte generated by Svelte v3.59.2 */
    const file$j = "node_modules/@svelteuidev/core/dist/components/Portal/Portal.svelte";

    function create_fragment$A(ctx) {
    	let div;
    	let useActions_action;
    	let portal_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*className*/ ctx[2]);
    			div.hidden = true;
    			set_style(div, "position", /*position*/ ctx[4]);
    			set_style(div, "zIndex", /*zIndex*/ ctx[5]);
    			add_location(div, file$j, 9, 0, 479);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[9](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[6].call(null, div)),
    					action_destroyer(portal_action = portal.call(null, div, /*target*/ ctx[3]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*className*/ 4) {
    				attr_dev(div, "class", /*className*/ ctx[2]);
    			}

    			if (!current || dirty & /*position*/ 16) {
    				set_style(div, "position", /*position*/ ctx[4]);
    			}

    			if (!current || dirty & /*zIndex*/ 32) {
    				set_style(div, "zIndex", /*zIndex*/ ctx[5]);
    			}

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);
    			if (portal_action && is_function(portal_action.update) && dirty & /*target*/ 8) portal_action.update.call(null, /*target*/ ctx[3]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[9](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Portal', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', target = 'body', position = 'relative', zIndex = 1 } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	const writable_props = ['use', 'element', 'class', 'target', 'position', 'zIndex'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Portal> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('use' in $$props) $$invalidate(1, use = $$props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$props.element);
    		if ('class' in $$props) $$invalidate(2, className = $$props.class);
    		if ('target' in $$props) $$invalidate(3, target = $$props.target);
    		if ('position' in $$props) $$invalidate(4, position = $$props.position);
    		if ('zIndex' in $$props) $$invalidate(5, zIndex = $$props.zIndex);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventForwarder,
    		useActions,
    		get_current_component,
    		portal,
    		use,
    		element,
    		className,
    		target,
    		position,
    		zIndex,
    		forwardEvents
    	});

    	$$self.$inject_state = $$props => {
    		if ('use' in $$props) $$invalidate(1, use = $$props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('target' in $$props) $$invalidate(3, target = $$props.target);
    		if ('position' in $$props) $$invalidate(4, position = $$props.position);
    		if ('zIndex' in $$props) $$invalidate(5, zIndex = $$props.zIndex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		element,
    		use,
    		className,
    		target,
    		position,
    		zIndex,
    		forwardEvents,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Portal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			target: 3,
    			position: 4,
    			zIndex: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Portal",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get use() {
    		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zIndex() {
    		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zIndex(value) {
    		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Portal$1 = Portal;

    /* node_modules/@svelteuidev/core/dist/components/Portal/OptionalPortal.svelte generated by Svelte v3.59.2 */

    // (10:0) {:else}
    function create_else_block$7(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(10:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (6:0) {#if withinPortal}
    function create_if_block$h(ctx) {
    	let portal;
    	let updating_element;
    	let current;

    	function portal_element_binding(value) {
    		/*portal_element_binding*/ ctx[6](value);
    	}

    	let portal_props = {
    		class: /*className*/ ctx[3],
    		use: /*use*/ ctx[2],
    		target: /*target*/ ctx[4],
    		$$slots: { default: [create_default_slot$u] },
    		$$scope: { ctx }
    	};

    	if (/*element*/ ctx[0] !== void 0) {
    		portal_props.element = /*element*/ ctx[0];
    	}

    	portal = new Portal$1({ props: portal_props, $$inline: true });
    	binding_callbacks.push(() => bind(portal, 'element', portal_element_binding));

    	const block = {
    		c: function create() {
    			create_component(portal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(portal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const portal_changes = {};
    			if (dirty & /*className*/ 8) portal_changes.class = /*className*/ ctx[3];
    			if (dirty & /*use*/ 4) portal_changes.use = /*use*/ ctx[2];
    			if (dirty & /*target*/ 16) portal_changes.target = /*target*/ ctx[4];

    			if (dirty & /*$$scope*/ 128) {
    				portal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				portal_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			portal.$set(portal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(portal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(portal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(portal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(6:0) {#if withinPortal}",
    		ctx
    	});

    	return block;
    }

    // (7:1) <Portal bind:element class={className} {use} {target}>
    function create_default_slot$u(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(7:1) <Portal bind:element class={className} {use} {target}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$h, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*withinPortal*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OptionalPortal', slots, ['default']);
    	let { withinPortal = true, use = [], element = undefined, class: className = '', target = 'body' } = $$props;
    	const writable_props = ['withinPortal', 'use', 'element', 'class', 'target'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OptionalPortal> was created with unknown prop '${key}'`);
    	});

    	function portal_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$props => {
    		if ('withinPortal' in $$props) $$invalidate(1, withinPortal = $$props.withinPortal);
    		if ('use' in $$props) $$invalidate(2, use = $$props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$props.element);
    		if ('class' in $$props) $$invalidate(3, className = $$props.class);
    		if ('target' in $$props) $$invalidate(4, target = $$props.target);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Portal: Portal$1,
    		withinPortal,
    		use,
    		element,
    		className,
    		target
    	});

    	$$self.$inject_state = $$props => {
    		if ('withinPortal' in $$props) $$invalidate(1, withinPortal = $$props.withinPortal);
    		if ('use' in $$props) $$invalidate(2, use = $$props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$props.element);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('target' in $$props) $$invalidate(4, target = $$props.target);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		element,
    		withinPortal,
    		use,
    		className,
    		target,
    		slots,
    		portal_element_binding,
    		$$scope
    	];
    }

    class OptionalPortal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
    			withinPortal: 1,
    			use: 2,
    			element: 0,
    			class: 3,
    			target: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OptionalPortal",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get withinPortal() {
    		throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withinPortal(value) {
    		throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get use() {
    		throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var OptionalPortal$1 = OptionalPortal;

    /* node_modules/@svelteuidev/core/dist/components/Affix/Affix.svelte generated by Svelte v3.59.2 */

    // (8:1) <Box   bind:element   class={className}   css={{ position: 'fixed', ...position, ...override }}   {use}   {...$$restProps}  >
    function create_default_slot_1$c(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(8:1) <Box   bind:element   class={className}   css={{ position: 'fixed', ...position, ...override }}   {use}   {...$$restProps}  >",
    		ctx
    	});

    	return block;
    }

    // (7:0) <Portal {zIndex} {target}>
    function create_default_slot$t(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ class: /*className*/ ctx[2] },
    		{
    			css: {
    				position: 'fixed',
    				.../*position*/ ctx[5],
    				.../*override*/ ctx[3]
    			}
    		},
    		{ use: /*use*/ ctx[1] },
    		/*$$restProps*/ ctx[7]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[9](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot_1$c] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const box_changes = (dirty & /*className, position, override, use, $$restProps*/ 174)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*className*/ 4 && { class: /*className*/ ctx[2] },
    					dirty & /*position, override*/ 40 && {
    						css: {
    							position: 'fixed',
    							.../*position*/ ctx[5],
    							.../*override*/ ctx[3]
    						}
    					},
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 1024) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(7:0) <Portal {zIndex} {target}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let portal;
    	let current;

    	portal = new Portal$1({
    			props: {
    				zIndex: /*zIndex*/ ctx[6],
    				target: /*target*/ ctx[4],
    				$$slots: { default: [create_default_slot$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(portal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(portal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const portal_changes = {};
    			if (dirty & /*zIndex*/ 64) portal_changes.zIndex = /*zIndex*/ ctx[6];
    			if (dirty & /*target*/ 16) portal_changes.target = /*target*/ ctx[4];

    			if (dirty & /*$$scope, className, position, override, use, $$restProps, element*/ 1199) {
    				portal_changes.$$scope = { dirty, ctx };
    			}

    			portal.$set(portal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(portal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(portal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(portal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	const omit_props_names = ["use","element","class","override","target","position","zIndex"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Affix', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, target = 'body', position = { bottom: 0, right: 0 }, zIndex = 200 } = $$props;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('target' in $$new_props) $$invalidate(4, target = $$new_props.target);
    		if ('position' in $$new_props) $$invalidate(5, position = $$new_props.position);
    		if ('zIndex' in $$new_props) $$invalidate(6, zIndex = $$new_props.zIndex);
    		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Box: Box$1,
    		Portal: Portal$1,
    		use,
    		element,
    		className,
    		override,
    		target,
    		position,
    		zIndex
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('target' in $$props) $$invalidate(4, target = $$new_props.target);
    		if ('position' in $$props) $$invalidate(5, position = $$new_props.position);
    		if ('zIndex' in $$props) $$invalidate(6, zIndex = $$new_props.zIndex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		element,
    		use,
    		className,
    		override,
    		target,
    		position,
    		zIndex,
    		$$restProps,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Affix extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			target: 4,
    			position: 5,
    			zIndex: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Affix",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get use() {
    		throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zIndex() {
    		throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zIndex(value) {
    		throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Affix$1 = Affix;

    var useStyles$i = createStyles((theme, { color, radius, variant }, getRef) => {
        return {
            root: {
                position: 'relative',
                overflow: 'hidden',
                padding: `${theme.space.sm.value}px ${theme.space.md.value}px`,
                borderRadius: theme.fn.radius(radius),
                border: '1px solid transparent',
                '&.light': {
                    darkMode: {
                        backgroundColor: theme.fn.variant({ variant: 'light', color }).background[0],
                        color: theme.fn.variant({ variant: 'light', color }).color[0]
                    },
                    backgroundColor: theme.fn.variant({ variant: 'light', color }).background[1],
                    color: theme.fn.variant({ variant: 'light', color }).color[1]
                },
                '&.filled': {
                    darkMode: {
                        backgroundColor: theme.fn.variant({ variant: 'filled', color }).background[0]
                    },
                    backgroundColor: theme.fn.variant({ variant: 'filled', color }).background[1],
                    color: theme.colors.white.value,
                    [`& .${getRef('closeButton')}`]: {
                        color: theme.colors.white.value
                    }
                },
                '&.outline': {
                    darkMode: {
                        color: theme.fn.variant({ variant: 'outline', color }).color[0],
                        borderColor: theme.fn.variant({ variant: 'outline', color }).border[0]
                    },
                    color: theme.fn.variant({ variant: 'outline', color }).color[1],
                    borderColor: theme.fn.variant({ variant: 'outline', color }).border[1]
                }
            },
            wrapper: {
                display: 'flex'
            },
            content: {
                flex: 1
            },
            title: {
                boxSizing: 'border-box',
                margin: 0,
                marginBottom: 7,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                lineHeight: theme.lineHeights.sm.value,
                fontSize: theme.fontSizes.sm.value,
                fontWeight: '$bold'
            },
            label: {
                display: 'block',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
            },
            icon: {
                lineHeight: 1,
                width: 20,
                height: 20,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'flex-start',
                marginRight: theme.space.mdPX.value,
                marginTop: 1
            },
            message: {
                darkMode: {
                    color: variant === 'filled'
                        ? theme.colors.white.value
                        : variant === 'light'
                            ? theme.colors.white.value
                            : theme.fn.themeColor('dark', 0)
                },
                lineHeight: theme.lineHeights.sm.value,
                textOverflow: 'ellipsis',
                overflow: 'hidden',
                fontSize: theme.fontSizes.sm.value,
                color: variant === 'filled' ? theme.colors.white.value : theme.colors.black.value
            },
            closeButton: {
                ref: getRef('closeButton'),
                marginTop: 2
            }
        };
    });

    var useStyles$h = createStyles((theme, { iconSize }) => {
        return {
            root: {
                focusRing: 'auto',
                position: 'relative',
                appearance: 'none',
                WebkitAppearance: 'none',
                WebkitTapHighlightColor: 'transparent',
                boxSizing: 'border-box',
                height: `${theme.fn.size({ size: iconSize, sizes: theme.space })}px`,
                minHeight: `${theme.fn.size({ size: iconSize, sizes: theme.space })}px`,
                width: `${theme.fn.size({ size: iconSize, sizes: theme.space })}px`,
                minWidth: `${theme.fn.size({ size: iconSize, sizes: theme.space })}px`,
                padding: 0,
                lineHeight: 1,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                cursor: 'pointer',
                textDecoration: 'none'
            },
            icon: {
                height: `${theme.fn.size({ size: iconSize, sizes: theme.space })}px`,
                minHeight: `${theme.fn.size({ size: iconSize, sizes: theme.space })}px`,
                position: 'static',
                margin: 0,
                ml: 0,
                mr: 0,
                mt: 0,
                mb: 0
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/IconRenderer/IconRenderer.svelte generated by Svelte v3.59.2 */
    const file$i = "node_modules/@svelteuidev/core/dist/components/IconRenderer/IconRenderer.svelte";

    // (17:24) 
    function create_if_block_1$b(ctx) {
    	let if_block_anchor;
    	let if_block = (/*icon*/ ctx[2] instanceof HTMLElement || /*icon*/ ctx[2] instanceof SVGElement) && create_if_block_2$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[2] instanceof HTMLElement || /*icon*/ ctx[2] instanceof SVGElement) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(17:24) ",
    		ctx
    	});

    	return block;
    }

    // (11:0) {#if typeof icon === 'function'}
    function create_if_block$g(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			class: /*cx*/ ctx[6](/*className*/ ctx[0], /*classes*/ ctx[4].root, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[1] }))
    		},
    		/*iconProps*/ ctx[3]
    	];

    	var switch_value = /*icon*/ ctx[2];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*cx, className, classes, getStyles, override, iconProps*/ 123)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*cx, className, classes, getStyles, override*/ 115 && {
    						class: /*cx*/ ctx[6](/*className*/ ctx[0], /*classes*/ ctx[4].root, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[1] }))
    					},
    					dirty & /*iconProps*/ 8 && get_spread_object(/*iconProps*/ ctx[3])
    				])
    			: {};

    			if (dirty & /*icon*/ 4 && switch_value !== (switch_value = /*icon*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(11:0) {#if typeof icon === 'function'}",
    		ctx
    	});

    	return block;
    }

    // (18:1) {#if icon instanceof HTMLElement || icon instanceof SVGElement}
    function create_if_block_2$6(ctx) {
    	let span;
    	let raw_value = /*icon*/ ctx[2].outerHTML + "";
    	let span_class_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", span_class_value = /*cx*/ ctx[6](/*className*/ ctx[0], /*classes*/ ctx[4].root, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[1] })));
    			add_location(span, file$i, 18, 2, 796);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icon*/ 4 && raw_value !== (raw_value = /*icon*/ ctx[2].outerHTML + "")) span.innerHTML = raw_value;
    			if (dirty & /*cx, className, classes, getStyles, override*/ 115 && span_class_value !== (span_class_value = /*cx*/ ctx[6](/*className*/ ctx[0], /*classes*/ ctx[4].root, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[1] })))) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(18:1) {#if icon instanceof HTMLElement || icon instanceof SVGElement}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$g, create_if_block_1$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (typeof /*icon*/ ctx[2] === 'function') return 0;
    		if (!/*requiresShim*/ ctx[7]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let cx;
    	let getStyles;
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconRenderer', slots, []);
    	let { className = '', override = {}, icon = undefined, iconSize = 16, iconProps = {} } = $$props;

    	// Verifies if CSR only elements are defined, or else it won't use them
    	const requiresShim = typeof HTMLElement === 'undefined' && typeof SVGElement === 'undefined';

    	const writable_props = ['className', 'override', 'icon', 'iconSize', 'iconProps'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconRenderer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('override' in $$props) $$invalidate(1, override = $$props.override);
    		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
    		if ('iconSize' in $$props) $$invalidate(8, iconSize = $$props.iconSize);
    		if ('iconProps' in $$props) $$invalidate(3, iconProps = $$props.iconProps);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$h,
    		className,
    		override,
    		icon,
    		iconSize,
    		iconProps,
    		requiresShim,
    		classes,
    		getStyles,
    		cx
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('override' in $$props) $$invalidate(1, override = $$props.override);
    		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
    		if ('iconSize' in $$props) $$invalidate(8, iconSize = $$props.iconSize);
    		if ('iconProps' in $$props) $$invalidate(3, iconProps = $$props.iconProps);
    		if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
    		if ('getStyles' in $$props) $$invalidate(5, getStyles = $$props.getStyles);
    		if ('cx' in $$props) $$invalidate(6, cx = $$props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*iconSize*/ 256) {
    			$$invalidate(6, { cx, getStyles, classes } = useStyles$h({ iconSize }, { name: 'IconRenderer' }), cx, ($$invalidate(5, getStyles), $$invalidate(8, iconSize)), ($$invalidate(4, classes), $$invalidate(8, iconSize)));
    		}

    		if ($$self.$$.dirty & /*icon, classes*/ 20) {
    			if (!requiresShim && (icon instanceof HTMLElement || icon instanceof SVGElement)) {
    				icon.classList.add(...classes.icon.split(' '));
    			}
    		}
    	};

    	return [
    		className,
    		override,
    		icon,
    		iconProps,
    		classes,
    		getStyles,
    		cx,
    		requiresShim,
    		iconSize
    	];
    }

    class IconRenderer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
    			className: 0,
    			override: 1,
    			icon: 2,
    			iconSize: 8,
    			iconProps: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconRenderer",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get className() {
    		throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconSize() {
    		throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconSize(value) {
    		throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconProps() {
    		throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconProps(value) {
    		throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var IconRenderer$1 = IconRenderer;

    /* node_modules/@svelteuidev/core/dist/components/Alert/Alert.svelte generated by Svelte v3.59.2 */
    const file$h = "node_modules/@svelteuidev/core/dist/components/Alert/Alert.svelte";

    // (17:2) {#if icon}
    function create_if_block_2$5(ctx) {
    	let iconrenderer;
    	let current;

    	iconrenderer = new IconRenderer$1({
    			props: {
    				icon: /*icon*/ ctx[5],
    				className: /*classes*/ ctx[10].icon,
    				iconSize: /*iconSize*/ ctx[6],
    				iconProps: /*iconProps*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(iconrenderer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconrenderer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const iconrenderer_changes = {};
    			if (dirty & /*icon*/ 32) iconrenderer_changes.icon = /*icon*/ ctx[5];
    			if (dirty & /*classes*/ 1024) iconrenderer_changes.className = /*classes*/ ctx[10].icon;
    			if (dirty & /*iconSize*/ 64) iconrenderer_changes.iconSize = /*iconSize*/ ctx[6];
    			if (dirty & /*iconProps*/ 128) iconrenderer_changes.iconProps = /*iconProps*/ ctx[7];
    			iconrenderer.$set(iconrenderer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconrenderer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconrenderer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconrenderer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(17:2) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (22:3) {#if title}
    function create_if_block$f(ctx) {
    	let div;
    	let span;
    	let t0;
    	let span_class_value;
    	let t1;
    	let div_class_value;
    	let current;
    	let if_block = /*withCloseButton*/ ctx[8] && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = text(/*title*/ ctx[3]);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(span, "class", span_class_value = /*classes*/ ctx[10].label);
    			add_location(span, file$h, 23, 5, 1017);
    			attr_dev(div, "class", div_class_value = /*classes*/ ctx[10].title);
    			add_location(div, file$h, 22, 4, 984);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*title*/ 8) set_data_dev(t0, /*title*/ ctx[3]);

    			if (!current || dirty & /*classes*/ 1024 && span_class_value !== (span_class_value = /*classes*/ ctx[10].label)) {
    				attr_dev(span, "class", span_class_value);
    			}

    			if (/*withCloseButton*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*withCloseButton*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*classes*/ 1024 && div_class_value !== (div_class_value = /*classes*/ ctx[10].title)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(22:3) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (27:5) {#if withCloseButton}
    function create_if_block_1$a(ctx) {
    	let closebutton;
    	let current;

    	closebutton = new CloseButton$1({
    			props: {
    				class: /*classes*/ ctx[10].closeButton,
    				"aria-label": /*closeButtonLabel*/ ctx[9],
    				variant: "transparent",
    				size: /*iconSize*/ ctx[6],
    				iconSize: /*iconSize*/ ctx[6]
    			},
    			$$inline: true
    		});

    	closebutton.$on("click", /*onClose*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(closebutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(closebutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const closebutton_changes = {};
    			if (dirty & /*classes*/ 1024) closebutton_changes.class = /*classes*/ ctx[10].closeButton;
    			if (dirty & /*closeButtonLabel*/ 512) closebutton_changes["aria-label"] = /*closeButtonLabel*/ ctx[9];
    			if (dirty & /*iconSize*/ 64) closebutton_changes.size = /*iconSize*/ ctx[6];
    			if (dirty & /*iconSize*/ 64) closebutton_changes.iconSize = /*iconSize*/ ctx[6];
    			closebutton.$set(closebutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(closebutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(closebutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(closebutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(27:5) {#if withCloseButton}",
    		ctx
    	});

    	return block;
    }

    // (15:0) <Box {use} bind:element role="alert" class={cx(className, variant, classes.root)} {...$$restProps}>
    function create_default_slot$s(ctx) {
    	let div2;
    	let t0;
    	let div1;
    	let t1;
    	let div0;
    	let div0_class_value;
    	let div1_class_value;
    	let div2_class_value;
    	let current;
    	let if_block0 = /*icon*/ ctx[5] && create_if_block_2$5(ctx);
    	let if_block1 = /*title*/ ctx[3] && create_if_block$f(ctx);
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", div0_class_value = /*classes*/ ctx[10].message);
    			add_location(div0, file$h, 38, 3, 1330);
    			attr_dev(div1, "class", div1_class_value = /*classes*/ ctx[10].content);
    			add_location(div1, file$h, 20, 2, 935);
    			attr_dev(div2, "class", div2_class_value = /*classes*/ ctx[10].wrapper);
    			add_location(div2, file$h, 15, 1, 806);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*icon*/ 32) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div2, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*title*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*title*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$f(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 1024 && div0_class_value !== (div0_class_value = /*classes*/ ctx[10].message)) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty & /*classes*/ 1024 && div1_class_value !== (div1_class_value = /*classes*/ ctx[10].content)) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty & /*classes*/ 1024 && div2_class_value !== (div2_class_value = /*classes*/ ctx[10].wrapper)) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(15:0) <Box {use} bind:element role=\\\"alert\\\" class={cx(className, variant, classes.root)} {...$$restProps}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{ role: "alert" },
    		{
    			class: /*cx*/ ctx[11](/*className*/ ctx[2], /*variant*/ ctx[4], /*classes*/ ctx[10].root)
    		},
    		/*$$restProps*/ ctx[13]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[18](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$s] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, variant, classes, $$restProps*/ 11286)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					box_spread_levels[1],
    					dirty & /*cx, className, variant, classes*/ 3092 && {
    						class: /*cx*/ ctx[11](/*className*/ ctx[2], /*variant*/ ctx[4], /*classes*/ ctx[10].root)
    					},
    					dirty & /*$$restProps*/ 8192 && get_spread_object(/*$$restProps*/ ctx[13])
    				])
    			: {};

    			if (dirty & /*$$scope, classes, closeButtonLabel, iconSize, withCloseButton, title, icon, iconProps*/ 526312) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;

    	const omit_props_names = [
    		"use","element","class","override","title","color","radius","variant","icon","iconSize","iconProps","withCloseButton","closeButtonLabel"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Alert', slots, ['default']);
    	let { use = [], element = undefined, class: className = 'blue', override = {}, title = undefined, color = 'red', radius = 'sm', variant = 'light', icon = undefined, iconSize = 16, iconProps = {}, withCloseButton = false, closeButtonLabel = undefined } = $$props;
    	const dispatch = createEventDispatcher();

    	function onClose() {
    		dispatch('close');
    	}

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(14, override = $$new_props.override);
    		if ('title' in $$new_props) $$invalidate(3, title = $$new_props.title);
    		if ('color' in $$new_props) $$invalidate(15, color = $$new_props.color);
    		if ('radius' in $$new_props) $$invalidate(16, radius = $$new_props.radius);
    		if ('variant' in $$new_props) $$invalidate(4, variant = $$new_props.variant);
    		if ('icon' in $$new_props) $$invalidate(5, icon = $$new_props.icon);
    		if ('iconSize' in $$new_props) $$invalidate(6, iconSize = $$new_props.iconSize);
    		if ('iconProps' in $$new_props) $$invalidate(7, iconProps = $$new_props.iconProps);
    		if ('withCloseButton' in $$new_props) $$invalidate(8, withCloseButton = $$new_props.withCloseButton);
    		if ('closeButtonLabel' in $$new_props) $$invalidate(9, closeButtonLabel = $$new_props.closeButtonLabel);
    		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		useStyles: useStyles$i,
    		Box: Box$1,
    		IconRenderer: IconRenderer$1,
    		CloseButton: CloseButton$1,
    		use,
    		element,
    		className,
    		override,
    		title,
    		color,
    		radius,
    		variant,
    		icon,
    		iconSize,
    		iconProps,
    		withCloseButton,
    		closeButtonLabel,
    		dispatch,
    		onClose,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(14, override = $$new_props.override);
    		if ('title' in $$props) $$invalidate(3, title = $$new_props.title);
    		if ('color' in $$props) $$invalidate(15, color = $$new_props.color);
    		if ('radius' in $$props) $$invalidate(16, radius = $$new_props.radius);
    		if ('variant' in $$props) $$invalidate(4, variant = $$new_props.variant);
    		if ('icon' in $$props) $$invalidate(5, icon = $$new_props.icon);
    		if ('iconSize' in $$props) $$invalidate(6, iconSize = $$new_props.iconSize);
    		if ('iconProps' in $$props) $$invalidate(7, iconProps = $$new_props.iconProps);
    		if ('withCloseButton' in $$props) $$invalidate(8, withCloseButton = $$new_props.withCloseButton);
    		if ('closeButtonLabel' in $$props) $$invalidate(9, closeButtonLabel = $$new_props.closeButtonLabel);
    		if ('classes' in $$props) $$invalidate(10, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(11, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*color, radius, variant, override*/ 114704) {
    			$$invalidate(11, { cx, classes } = useStyles$i({ color, radius, variant }, { name: 'Alert', override }), cx, (((($$invalidate(10, classes), $$invalidate(15, color)), $$invalidate(16, radius)), $$invalidate(4, variant)), $$invalidate(14, override)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		title,
    		variant,
    		icon,
    		iconSize,
    		iconProps,
    		withCloseButton,
    		closeButtonLabel,
    		classes,
    		cx,
    		onClose,
    		$$restProps,
    		override,
    		color,
    		radius,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Alert extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 14,
    			title: 3,
    			color: 15,
    			radius: 16,
    			variant: 4,
    			icon: 5,
    			iconSize: 6,
    			iconProps: 7,
    			withCloseButton: 8,
    			closeButtonLabel: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Alert",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get use() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconSize() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconSize(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconProps() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconProps(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withCloseButton() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withCloseButton(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeButtonLabel() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeButtonLabel(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Alert$1 = Alert;

    function getTextColor(theme, color, variant, gradient, dark = false) {
        if (color === 'dimmed')
            return dark ? theme.fn.themeColor('dark', 2) : theme.fn.themeColor('gray', 6);
        if (variant === 'gradient' || gradient)
            return theme.fn.themeColor(color, 6);
        if (variant === 'link')
            return dark ? theme.fn.themeColor('blue', 4) : theme.fn.themeColor('blue', 7);
        if (variant === 'text')
            return dark ? theme.fn.themeColor(color, 5) : theme.fn.themeColor(color, 7);
    }
    var useStyles$g = createStyles((theme, { align, color, inherit, inline, lineClamp, size, tracking, transform, underline, weight, gradient, variant }) => {
        return {
            root: {
                focusRing: 'auto',
                [`${theme.dark} &`]: {
                    color: color === 'dark' ? '$dark50' : getTextColor(theme, color, variant, gradient, true)
                },
                fontFamily: inherit ? 'inherit' : '$standard',
                fontSize: inherit ? 'inherit' : typeof size === 'string' ? `$${size}` : `${size}px`,
                fontWeight: inherit ? 'inherit' : `$${weight}`,
                letterSpacing: theme.letterSpacings[tracking]?.value,
                lineHeight: inherit
                    ? 'inherit'
                    : inline
                        ? 1
                        : typeof size === 'string'
                            ? `$${size}`
                            : `${size}px`,
                textTransform: transform,
                textDecoration: underline ? 'underline' : 'none',
                textAlign: align,
                cursor: variant === 'link' ? 'pointer' : 'inherit',
                color: color === 'green' ? 'Black' : getTextColor(theme, color, variant, gradient),
                backgroundImage: variant === 'gradient'
                    ? `linear-gradient(${gradient?.deg}deg, $${gradient?.from}600 0%, $${gradient?.to}600 100%)`
                    : null,
                WebkitBackgroundClip: variant === 'gradient' ? 'text' : null,
                WebkitTextFillColor: variant === 'gradient' ? 'transparent' : null,
                ...(lineClamp !== undefined
                    ? {
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        display: '-webkit-box',
                        WebkitLineClamp: lineClamp,
                        WebkitBoxOrient: 'vertical'
                    }
                    : {}),
                '&:hover': variant === 'link' && underline === true
                    ? {
                        textDecoration: 'underline'
                    }
                    : undefined
            }
        };
    });

    /** Error codes for component Text
     *
     * `Object.freeze` is needed to keep modification outside of the object unavailable
     *
     * ## Code 1:
     * If using the 'gradient' prop, set 'variant' prop to 'gradient' to apply the gradient
     *
     * ## Code 2:
     * If using the 'link' variant, an href needs to be set and the root must be an anchor
     */
    const TextErrors = Object.freeze([
        {
            error: true,
            message: "If using the 'gradient' prop, set 'variant' prop to 'gradient' to apply the gradient",
            solution: `
                If your component looks like this:

                &lt;Text gradient={{from: 'blue', to: 'red', deg: 45}}&gt;Text string &lt;/Text&gt;
                                                                    ^^^ - Try adding prop variant='gradient'
                `
        },
        {
            error: true,
            message: "If using the 'link' variant, an href needs to be set and the root must be an anchor",
            solution: `
                If your component looks like this:

                &lt;Text variant='link'&gt;Text string &lt;/Text&gt;
                                    ^^^ - Try adding props href && root={'a'}'
                `
        }
    ]);

    /* node_modules/@svelteuidev/core/dist/components/Text/Text.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1$2 } = globals;

    // (55:0) <Box  {root}  bind:element  use={[forwardEvents, [useActions, use]]}  class={cx(className, classes.root, getStyles({ css: override }))}  href={href ?? undefined}  {...$$restProps} >
    function create_default_slot$r(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[25].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 134217728)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[27],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[27], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(55:0) <Box  {root}  bind:element  use={[forwardEvents, [useActions, use]]}  class={cx(className, classes.root, getStyles({ css: override }))}  href={href ?? undefined}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let error;
    	let t;
    	let box;
    	let updating_element;
    	let current;

    	error = new Error$2({
    			props: {
    				observable: /*observable*/ ctx[6],
    				component: "Text",
    				code: /*err*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const box_spread_levels = [
    		{ root: /*root*/ ctx[4] },
    		{
    			use: [/*forwardEvents*/ ctx[11], [useActions, /*use*/ ctx[1]]]
    		},
    		{
    			class: /*cx*/ ctx[10](/*className*/ ctx[2], /*classes*/ ctx[9].root, /*getStyles*/ ctx[8]({ css: /*override*/ ctx[3] }))
    		},
    		{ href: /*href*/ ctx[5] ?? undefined },
    		/*$$restProps*/ ctx[12]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[26](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$r] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(error.$$.fragment);
    			t = space();
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const error_changes = {};
    			if (dirty & /*observable*/ 64) error_changes.observable = /*observable*/ ctx[6];
    			if (dirty & /*err*/ 128) error_changes.code = /*err*/ ctx[7];
    			error.$set(error_changes);

    			const box_changes = (dirty & /*root, forwardEvents, useActions, use, cx, className, classes, getStyles, override, href, undefined, $$restProps*/ 7998)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*root*/ 16 && { root: /*root*/ ctx[4] },
    					dirty & /*forwardEvents, useActions, use*/ 2050 && {
    						use: [/*forwardEvents*/ ctx[11], [useActions, /*use*/ ctx[1]]]
    					},
    					dirty & /*cx, className, classes, getStyles, override*/ 1804 && {
    						class: /*cx*/ ctx[10](/*className*/ ctx[2], /*classes*/ ctx[9].root, /*getStyles*/ ctx[8]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*href, undefined*/ 32 && { href: /*href*/ ctx[5] ?? undefined },
    					dirty & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 134217728) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","align","color","root","transform","variant","size","weight","gradient","inline","lineClamp","underline","inherit","href","tracking"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, align = 'left', color = 'dark', root = undefined, transform = 'none', variant = 'text', size = 'md', weight = 'normal', gradient = { from: 'indigo', to: 'cyan', deg: 45 }, inline = true, lineClamp = undefined, underline = false, inherit = false, href = '', tracking = 'normal' } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	// --------------Error Handling-------------------
    	let observable = false;

    	let err;

    	if (gradient.from === 'indigo' && gradient.to === 'cyan0' && gradient.deg === 45 && variant !== 'gradient') {
    		observable = true;
    		err = TextErrors[0];
    	}

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('align' in $$new_props) $$invalidate(13, align = $$new_props.align);
    		if ('color' in $$new_props) $$invalidate(14, color = $$new_props.color);
    		if ('root' in $$new_props) $$invalidate(4, root = $$new_props.root);
    		if ('transform' in $$new_props) $$invalidate(15, transform = $$new_props.transform);
    		if ('variant' in $$new_props) $$invalidate(16, variant = $$new_props.variant);
    		if ('size' in $$new_props) $$invalidate(17, size = $$new_props.size);
    		if ('weight' in $$new_props) $$invalidate(18, weight = $$new_props.weight);
    		if ('gradient' in $$new_props) $$invalidate(19, gradient = $$new_props.gradient);
    		if ('inline' in $$new_props) $$invalidate(20, inline = $$new_props.inline);
    		if ('lineClamp' in $$new_props) $$invalidate(21, lineClamp = $$new_props.lineClamp);
    		if ('underline' in $$new_props) $$invalidate(22, underline = $$new_props.underline);
    		if ('inherit' in $$new_props) $$invalidate(23, inherit = $$new_props.inherit);
    		if ('href' in $$new_props) $$invalidate(5, href = $$new_props.href);
    		if ('tracking' in $$new_props) $$invalidate(24, tracking = $$new_props.tracking);
    		if ('$$scope' in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		Error: Error$2,
    		Box: Box$1,
    		useStyles: useStyles$g,
    		TextErrors,
    		use,
    		element,
    		className,
    		override,
    		align,
    		color,
    		root,
    		transform,
    		variant,
    		size,
    		weight,
    		gradient,
    		inline,
    		lineClamp,
    		underline,
    		inherit,
    		href,
    		tracking,
    		forwardEvents,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('align' in $$props) $$invalidate(13, align = $$new_props.align);
    		if ('color' in $$props) $$invalidate(14, color = $$new_props.color);
    		if ('root' in $$props) $$invalidate(4, root = $$new_props.root);
    		if ('transform' in $$props) $$invalidate(15, transform = $$new_props.transform);
    		if ('variant' in $$props) $$invalidate(16, variant = $$new_props.variant);
    		if ('size' in $$props) $$invalidate(17, size = $$new_props.size);
    		if ('weight' in $$props) $$invalidate(18, weight = $$new_props.weight);
    		if ('gradient' in $$props) $$invalidate(19, gradient = $$new_props.gradient);
    		if ('inline' in $$props) $$invalidate(20, inline = $$new_props.inline);
    		if ('lineClamp' in $$props) $$invalidate(21, lineClamp = $$new_props.lineClamp);
    		if ('underline' in $$props) $$invalidate(22, underline = $$new_props.underline);
    		if ('inherit' in $$props) $$invalidate(23, inherit = $$new_props.inherit);
    		if ('href' in $$props) $$invalidate(5, href = $$new_props.href);
    		if ('tracking' in $$props) $$invalidate(24, tracking = $$new_props.tracking);
    		if ('observable' in $$props) $$invalidate(6, observable = $$new_props.observable);
    		if ('err' in $$props) $$invalidate(7, err = $$new_props.err);
    		if ('getStyles' in $$props) $$invalidate(8, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(10, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*lineClamp, underline, inline, inherit, gradient, variant, align, color, transform, size, weight, tracking*/ 33546240) {
    			// --------------End Error Handling-------------------
    			$$invalidate(
    				10,
    				{ cx, classes, getStyles } = useStyles$g(
    					{
    						lineClamp,
    						underline,
    						inline,
    						inherit,
    						gradient,
    						variant,
    						align,
    						color,
    						transform,
    						size,
    						weight,
    						tracking
    					},
    					{ name: 'Text' }
    				),
    				cx,
    				(((((((((((($$invalidate(9, classes), $$invalidate(21, lineClamp)), $$invalidate(22, underline)), $$invalidate(20, inline)), $$invalidate(23, inherit)), $$invalidate(19, gradient)), $$invalidate(16, variant)), $$invalidate(13, align)), $$invalidate(14, color)), $$invalidate(15, transform)), $$invalidate(17, size)), $$invalidate(18, weight)), $$invalidate(24, tracking)),
    				(((((((((((($$invalidate(8, getStyles), $$invalidate(21, lineClamp)), $$invalidate(22, underline)), $$invalidate(20, inline)), $$invalidate(23, inherit)), $$invalidate(19, gradient)), $$invalidate(16, variant)), $$invalidate(13, align)), $$invalidate(14, color)), $$invalidate(15, transform)), $$invalidate(17, size)), $$invalidate(18, weight)), $$invalidate(24, tracking))
    			);
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		root,
    		href,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx,
    		forwardEvents,
    		$$restProps,
    		align,
    		color,
    		transform,
    		variant,
    		size,
    		weight,
    		gradient,
    		inline,
    		lineClamp,
    		underline,
    		inherit,
    		tracking,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			align: 13,
    			color: 14,
    			root: 4,
    			transform: 15,
    			variant: 16,
    			size: 17,
    			weight: 18,
    			gradient: 19,
    			inline: 20,
    			lineClamp: 21,
    			underline: 22,
    			inherit: 23,
    			href: 5,
    			tracking: 24
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get use() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get root() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set root(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transform() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transform(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get weight() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set weight(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gradient() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gradient(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inline() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inline(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineClamp() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineClamp(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get underline() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set underline(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inherit() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inherit(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tracking() {
    		throw new Error_1$2("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tracking(value) {
    		throw new Error_1$2("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Text$1 = Text;

    const sizes$3 = {
        xs: {
            fontSize: 9,
            height: 16
        },
        sm: {
            fontSize: 10,
            height: 18
        },
        md: {
            fontSize: 11,
            height: 20
        },
        lg: {
            fontSize: 13,
            height: 26
        },
        xl: {
            fontSize: 16,
            height: 32
        }
    };
    const dotSizes = {
        xs: 4,
        sm: 4,
        md: 6,
        lg: 8,
        xl: 10
    };
    var useStyles$f = createStyles((theme, { fullWidth, radius, size, color, gradientDeg, gradientFrom, gradientTo }) => {
        const dotSize = theme.fn.size({ size, sizes: dotSizes });
        const lightColors = theme.fn.variant({ color, variant: 'light' });
        const filledColors = theme.fn.variant({ color, variant: 'filled' });
        const outlineColors = theme.fn.variant({ color, variant: 'outline' });
        const gradientColors = theme.fn.variant({
            variant: 'gradient',
            gradient: { from: gradientFrom, to: gradientTo, deg: gradientDeg }
        });
        const { fontSize, height } = size in sizes$3 ? sizes$3[size] : sizes$3.md;
        return {
            root: {
                focusRing: 'auto',
                fontSize,
                height,
                WebkitTapHighlightColor: 'transparent',
                lineHeight: `${height - 2}px`,
                textDecoration: 'none',
                padding: `0 ${theme.fn.size({ size, sizes: theme.space }) / 1.5}px`,
                boxSizing: 'border-box',
                display: fullWidth ? 'flex' : 'inline-flex',
                alignItems: 'center',
                justifyContent: 'center',
                width: fullWidth ? '100%' : 'auto',
                textTransform: 'uppercase',
                borderRadius: theme.fn.radius(radius),
                fontWeight: 700,
                letterSpacing: 0.25,
                cursor: 'default',
                textOverflow: 'ellipsis',
                overflow: 'hidden',
                // As of now the createStyles function has a limitation that doesn't allow you to have multiple properties per component.
                // For an example, I can not make a `root` key, and then a `wrapper` key, and expect it to work. So for now they will be done manually.
                '&.light': {
                    [`${theme.dark} &`]: {
                        backgroundColor: lightColors.background[0],
                        color: lightColors.color[0]
                    },
                    backgroundColor: lightColors.background[1],
                    color: lightColors.color[1],
                    border: '1px solid transparent'
                },
                '&.filled': {
                    [`${theme.dark} &`]: {
                        backgroundColor: filledColors.background[0]
                    },
                    backgroundColor: filledColors.background[1],
                    color: filledColors.color,
                    border: '1px solid transparent'
                },
                '&.outline': {
                    [`${theme.dark} &`]: {
                        color: outlineColors.color[0],
                        border: `1px solid ${outlineColors.border[0]}`
                    },
                    backgroundColor: outlineColors.background,
                    color: outlineColors.color[1],
                    border: `1px solid ${outlineColors.border[1]}`
                },
                '&.gradient': {
                    backgroundImage: gradientColors.background,
                    color: gradientColors.color,
                    border: 0
                },
                '&.dot': {
                    darkMode: {
                        color: theme.fn.themeColor('dark', 0),
                        border: `1px solid ${theme.fn.themeColor('dark', 3)}`,
                        '&::before': {
                            backgroundColor: theme.fn.themeColor(color, 4)
                        }
                    },
                    backgroundColor: 'transparent',
                    color: theme.fn.themeColor('gray', 7),
                    border: `1px solid ${theme.fn.themeColor('gray', 3)}`,
                    paddingLeft: theme.fn.size({ size, sizes: theme.space }) / 1.5 - dotSize / 2,
                    '&::before': {
                        content: '""',
                        display: 'block',
                        width: dotSize,
                        height: dotSize,
                        borderRadius: dotSize,
                        backgroundColor: theme.fn.themeColor(color, 6),
                        marginRight: dotSize
                    }
                }
            },
            leftSection: {
                marginRight: parseInt(theme.space.xs.value) / 2
            },
            rightSection: {
                marginLeft: parseInt(theme.space.xs.value) / 2
            },
            inner: {
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Badge/Badge.svelte generated by Svelte v3.59.2 */
    const file$g = "node_modules/@svelteuidev/core/dist/components/Badge/Badge.svelte";
    const get_rightSection_slot_changes$3 = dirty => ({});
    const get_rightSection_slot_context$3 = ctx => ({});
    const get_leftSection_slot_changes = dirty => ({});
    const get_leftSection_slot_context = ctx => ({});

    // (42:1) {#if $$slots.leftSection}
    function create_if_block_1$9(ctx) {
    	let span;
    	let span_class_value;
    	let current;
    	const leftSection_slot_template = /*#slots*/ ctx[15].leftSection;
    	const leftSection_slot = create_slot(leftSection_slot_template, ctx, /*$$scope*/ ctx[17], get_leftSection_slot_context);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (leftSection_slot) leftSection_slot.c();
    			attr_dev(span, "class", span_class_value = /*classes*/ ctx[4].leftSection);
    			add_location(span, file$g, 42, 2, 1336);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (leftSection_slot) {
    				leftSection_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (leftSection_slot) {
    				if (leftSection_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						leftSection_slot,
    						leftSection_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(leftSection_slot_template, /*$$scope*/ ctx[17], dirty, get_leftSection_slot_changes),
    						get_leftSection_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 16 && span_class_value !== (span_class_value = /*classes*/ ctx[4].leftSection)) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(leftSection_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(leftSection_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (leftSection_slot) leftSection_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(42:1) {#if $$slots.leftSection}",
    		ctx
    	});

    	return block;
    }

    // (48:1) {#if $$slots.rightSection}
    function create_if_block$e(ctx) {
    	let span;
    	let span_class_value;
    	let current;
    	const rightSection_slot_template = /*#slots*/ ctx[15].rightSection;
    	const rightSection_slot = create_slot(rightSection_slot_template, ctx, /*$$scope*/ ctx[17], get_rightSection_slot_context$3);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (rightSection_slot) rightSection_slot.c();
    			attr_dev(span, "class", span_class_value = /*classes*/ ctx[4].rightSection);
    			add_location(span, file$g, 48, 2, 1494);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (rightSection_slot) {
    				rightSection_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (rightSection_slot) {
    				if (rightSection_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						rightSection_slot,
    						rightSection_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(rightSection_slot_template, /*$$scope*/ ctx[17], dirty, get_rightSection_slot_changes$3),
    						get_rightSection_slot_context$3
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 16 && span_class_value !== (span_class_value = /*classes*/ ctx[4].rightSection)) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rightSection_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rightSection_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (rightSection_slot) rightSection_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(48:1) {#if $$slots.rightSection}",
    		ctx
    	});

    	return block;
    }

    // (36:0) <Box  use={[forwardEvents, [useActions, use]]}  bind:element  class={cx(className, variant, classes.root)}  {...$$restProps} >
    function create_default_slot$q(ctx) {
    	let t0;
    	let span;
    	let span_class_value;
    	let t1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$$slots*/ ctx[8].leftSection && create_if_block_1$9(ctx);
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
    	let if_block1 = /*$$slots*/ ctx[8].rightSection && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			span = element("span");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(span, "class", span_class_value = /*classes*/ ctx[4].inner);
    			add_location(span, file$g, 46, 1, 1420);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[8].leftSection) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$9(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 16 && span_class_value !== (span_class_value = /*classes*/ ctx[4].inner)) {
    				attr_dev(span, "class", span_class_value);
    			}

    			if (/*$$slots*/ ctx[8].rightSection) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 256) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(36:0) <Box  use={[forwardEvents, [useActions, use]]}  bind:element  class={cx(className, variant, classes.root)}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[6], [useActions, /*use*/ ctx[1]]]
    		},
    		{
    			class: /*cx*/ ctx[5](/*className*/ ctx[2], /*variant*/ ctx[3], /*classes*/ ctx[4].root)
    		},
    		/*$$restProps*/ ctx[7]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[16](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$q] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*forwardEvents, useActions, use, cx, className, variant, classes, $$restProps*/ 254)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*forwardEvents, useActions, use*/ 66 && {
    						use: [/*forwardEvents*/ ctx[6], [useActions, /*use*/ ctx[1]]]
    					},
    					dirty & /*cx, className, variant, classes*/ 60 && {
    						class: /*cx*/ ctx[5](/*className*/ ctx[2], /*variant*/ ctx[3], /*classes*/ ctx[4].root)
    					},
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope, classes, $$slots*/ 131344) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;

    	const omit_props_names = [
    		"use","element","class","override","color","variant","gradient","size","radius","fullWidth"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, ['leftSection','default','rightSection']);
    	const $$slots = compute_slots(slots);
    	let { use = [], element = undefined, class: className = '', override = {}, color = 'blue', variant = 'light', gradient = { from: 'blue', to: 'cyan', deg: 45 }, size = 'md', radius = 'xl', fullWidth = false } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(9, override = $$new_props.override);
    		if ('color' in $$new_props) $$invalidate(10, color = $$new_props.color);
    		if ('variant' in $$new_props) $$invalidate(3, variant = $$new_props.variant);
    		if ('gradient' in $$new_props) $$invalidate(11, gradient = $$new_props.gradient);
    		if ('size' in $$new_props) $$invalidate(12, size = $$new_props.size);
    		if ('radius' in $$new_props) $$invalidate(13, radius = $$new_props.radius);
    		if ('fullWidth' in $$new_props) $$invalidate(14, fullWidth = $$new_props.fullWidth);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$f,
    		createEventForwarder,
    		useActions,
    		get_current_component,
    		Box: Box$1,
    		use,
    		element,
    		className,
    		override,
    		color,
    		variant,
    		gradient,
    		size,
    		radius,
    		fullWidth,
    		forwardEvents,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(9, override = $$new_props.override);
    		if ('color' in $$props) $$invalidate(10, color = $$new_props.color);
    		if ('variant' in $$props) $$invalidate(3, variant = $$new_props.variant);
    		if ('gradient' in $$props) $$invalidate(11, gradient = $$new_props.gradient);
    		if ('size' in $$props) $$invalidate(12, size = $$new_props.size);
    		if ('radius' in $$props) $$invalidate(13, radius = $$new_props.radius);
    		if ('fullWidth' in $$props) $$invalidate(14, fullWidth = $$new_props.fullWidth);
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(5, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*color, fullWidth, size, radius, gradient, override*/ 32256) {
    			$$invalidate(
    				5,
    				{ cx, classes } = useStyles$f(
    					{
    						color,
    						fullWidth,
    						size,
    						radius,
    						gradientDeg: gradient.deg,
    						gradientFrom: gradient.from,
    						gradientTo: gradient.to
    					},
    					{ override, name: 'Badge' }
    				),
    				cx,
    				(((((($$invalidate(4, classes), $$invalidate(10, color)), $$invalidate(14, fullWidth)), $$invalidate(12, size)), $$invalidate(13, radius)), $$invalidate(11, gradient)), $$invalidate(9, override))
    			);
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		variant,
    		classes,
    		cx,
    		forwardEvents,
    		$$restProps,
    		$$slots,
    		override,
    		color,
    		gradient,
    		size,
    		radius,
    		fullWidth,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Badge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 9,
    			color: 10,
    			variant: 3,
    			gradient: 11,
    			size: 12,
    			radius: 13,
    			fullWidth: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get use() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gradient() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gradient(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullWidth() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullWidth(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Badge$1 = Badge;

    var useStyles$e = createStyles((theme) => {
        return {
            root: {
                position: 'relative',
                overflow: 'hidden',
                backgroundColor: theme.colors.white.value
            }
        };
    });

    var useStyles$d = createStyles((theme, { radius, shadow, withBorder, padding }) => {
        return {
            root: {
                darkMode: {
                    backgroundColor: theme.fn.themeColor('dark', 7),
                    color: theme.fn.themeColor('dark')
                },
                padding: theme.fn.size({ size: padding, sizes: theme.space }),
                outline: 0,
                display: 'block',
                textDecoration: 'none',
                color: theme.colors.black.value,
                backgroundColor: theme.colors.white.value,
                boxSizing: 'border-box',
                borderRadius: `$${radius}`,
                WebkitTapHighlightColor: 'transparent',
                boxShadow: theme.shadows[shadow].value || shadow || 'none',
                border: undefined
            },
            withBorder: {
                darkMode: {
                    border: `1px solid ${theme.fn.themeColor('dark', 4)}`
                },
                border: `1px solid ${theme.fn.themeColor('gray', 3)}`
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Paper/Paper.svelte generated by Svelte v3.59.2 */

    // (8:0) <Box  bind:element  class={cx(   classes.root,   className,   withBorder && classes.withBorder,   getStyles({ css: override })  )}  {use}  {...$$restProps} >
    function create_default_slot$p(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(8:0) <Box  bind:element  class={cx(   classes.root,   className,   withBorder && classes.withBorder,   getStyles({ css: override })  )}  {use}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{
    			class: /*cx*/ ctx[7](/*classes*/ ctx[6].root, /*className*/ ctx[2], /*withBorder*/ ctx[4] && /*classes*/ ctx[6].withBorder, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[3] }))
    		},
    		{ use: /*use*/ ctx[1] },
    		/*$$restProps*/ ctx[8]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[13](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$p] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*cx, classes, className, withBorder, getStyles, override, use, $$restProps*/ 510)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*cx, classes, className, withBorder, getStyles, override*/ 252 && {
    						class: /*cx*/ ctx[7](/*classes*/ ctx[6].root, /*className*/ ctx[2], /*withBorder*/ ctx[4] && /*classes*/ ctx[6].withBorder, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 16384) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;
    	const omit_props_names = ["use","element","class","override","shadow","radius","withBorder","padding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Paper', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, shadow = 'xs', radius = 'sm', withBorder = false, padding = 'md' } = $$props;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('shadow' in $$new_props) $$invalidate(9, shadow = $$new_props.shadow);
    		if ('radius' in $$new_props) $$invalidate(10, radius = $$new_props.radius);
    		if ('withBorder' in $$new_props) $$invalidate(4, withBorder = $$new_props.withBorder);
    		if ('padding' in $$new_props) $$invalidate(11, padding = $$new_props.padding);
    		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$d,
    		Box: Box$1,
    		use,
    		element,
    		className,
    		override,
    		shadow,
    		radius,
    		withBorder,
    		padding,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('shadow' in $$props) $$invalidate(9, shadow = $$new_props.shadow);
    		if ('radius' in $$props) $$invalidate(10, radius = $$new_props.radius);
    		if ('withBorder' in $$props) $$invalidate(4, withBorder = $$new_props.withBorder);
    		if ('padding' in $$props) $$invalidate(11, padding = $$new_props.padding);
    		if ('getStyles' in $$props) $$invalidate(5, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(6, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(7, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*radius, shadow, withBorder, padding*/ 3600) {
    			$$invalidate(7, { cx, classes, getStyles } = useStyles$d({ radius, shadow, withBorder, padding }, { name: 'Paper' }), cx, (((($$invalidate(6, classes), $$invalidate(10, radius)), $$invalidate(9, shadow)), $$invalidate(4, withBorder)), $$invalidate(11, padding)), (((($$invalidate(5, getStyles), $$invalidate(10, radius)), $$invalidate(9, shadow)), $$invalidate(4, withBorder)), $$invalidate(11, padding)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		withBorder,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		shadow,
    		radius,
    		padding,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Paper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			shadow: 9,
    			radius: 10,
    			withBorder: 4,
    			padding: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Paper",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get use() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shadow() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shadow(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withBorder() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withBorder(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Paper$1 = Paper;

    /* node_modules/@svelteuidev/core/dist/components/Card/Card.svelte generated by Svelte v3.59.2 */

    // (22:0) <Paper  bind:element  class={cx(className, classes.root)}  override={{   [`${theme.dark} &`]: {    backgroundColor: theme.fn.themeColor('dark', 6)   },   ...override  }}  {padding}  {use}  {...$$restProps} >
    function create_default_slot$o(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(22:0) <Paper  bind:element  class={cx(className, classes.root)}  override={{   [`${theme.dark} &`]: {    backgroundColor: theme.fn.themeColor('dark', 6)   },   ...override  }}  {padding}  {use}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let paper;
    	let updating_element;
    	let current;

    	const paper_spread_levels = [
    		{
    			class: /*cx*/ ctx[7](/*className*/ ctx[2], /*classes*/ ctx[6].root)
    		},
    		{
    			override: {
    				[`${/*theme*/ ctx[5].dark} &`]: {
    					backgroundColor: /*theme*/ ctx[5].fn.themeColor('dark', 6)
    				},
    				.../*override*/ ctx[3]
    			}
    		},
    		{ padding: /*padding*/ ctx[4] },
    		{ use: /*use*/ ctx[1] },
    		/*$$restProps*/ ctx[8]
    	];

    	function paper_element_binding(value) {
    		/*paper_element_binding*/ ctx[10](value);
    	}

    	let paper_props = {
    		$$slots: { default: [create_default_slot$o] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < paper_spread_levels.length; i += 1) {
    		paper_props = assign(paper_props, paper_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		paper_props.element = /*element*/ ctx[0];
    	}

    	paper = new Paper$1({ props: paper_props, $$inline: true });
    	binding_callbacks.push(() => bind(paper, 'element', paper_element_binding));

    	const block = {
    		c: function create() {
    			create_component(paper.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(paper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const paper_changes = (dirty & /*cx, className, classes, theme, override, padding, use, $$restProps*/ 510)
    			? get_spread_update(paper_spread_levels, [
    					dirty & /*cx, className, classes*/ 196 && {
    						class: /*cx*/ ctx[7](/*className*/ ctx[2], /*classes*/ ctx[6].root)
    					},
    					dirty & /*theme, override*/ 40 && {
    						override: {
    							[`${/*theme*/ ctx[5].dark} &`]: {
    								backgroundColor: /*theme*/ ctx[5].fn.themeColor('dark', 6)
    							},
    							.../*override*/ ctx[3]
    						}
    					},
    					dirty & /*padding*/ 16 && { padding: /*padding*/ ctx[4] },
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 2048) {
    				paper_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				paper_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			paper.$set(paper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(paper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(paper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(paper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let theme;
    	const omit_props_names = ["use","element","class","override","padding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, padding = 'md' } = $$props;

    	/** can only get access to children at runtime */
    	onMount(() => {
    		const nodeLength = element.children.length;
    		const firstChild = element.children[0];
    		const lastChild = element.children[nodeLength - 1];

    		if (firstChild?.id === 'svelteui_card_section') {
    			firstChild.style.marginTop = `${-1 * theme.fn.size({ size: padding, sizes: theme.space })}px`;
    		}

    		if (lastChild?.id === 'svelteui_card_section') {
    			// prettier-ignore
    			lastChild.style.marginBottom = `${-1 * theme.fn.size({ size: padding, sizes: theme.space })}px`;
    		}
    	});

    	function paper_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('padding' in $$new_props) $$invalidate(4, padding = $$new_props.padding);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$e,
    		Paper: Paper$1,
    		onMount,
    		use,
    		element,
    		className,
    		override,
    		padding,
    		theme,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('padding' in $$props) $$invalidate(4, padding = $$new_props.padding);
    		if ('theme' in $$props) $$invalidate(5, theme = $$new_props.theme);
    		if ('classes' in $$props) $$invalidate(6, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(7, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(7, { cx, classes, theme } = useStyles$e(null, { name: 'Card' }), cx, $$invalidate(6, classes), $$invalidate(5, theme));

    	return [
    		element,
    		use,
    		className,
    		override,
    		padding,
    		theme,
    		classes,
    		cx,
    		$$restProps,
    		slots,
    		paper_element_binding,
    		$$scope
    	];
    }

    let Card$1 = class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			padding: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get use() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    var _Card = Card$1;

    var useStyles$c = createStyles((theme, { padding }) => {
        return {
            root: {
                display: 'block',
                marginLeft: -1 * theme.fn.size({ size: padding, sizes: theme.space }),
                marginRight: -1 * theme.fn.size({ size: padding, sizes: theme.space })
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Card/CardSection/CardSection.svelte generated by Svelte v3.59.2 */

    // (8:0) <Box  id="svelteui_card_section"  bind:element  class={cx(className, classes.root, getStyles({ css: override }))}  {use}  {...$$restProps} >
    function create_default_slot$n(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(8:0) <Box  id=\\\"svelteui_card_section\\\"  bind:element  class={cx(className, classes.root, getStyles({ css: override }))}  {use}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ id: "svelteui_card_section" },
    		{
    			class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    		},
    		{ use: /*use*/ ctx[1] },
    		/*$$restProps*/ ctx[7]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[10](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$n] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*cx, className, classes, getStyles, override, use, $$restProps*/ 254)
    			? get_spread_update(box_spread_levels, [
    					box_spread_levels[0],
    					dirty & /*cx, className, classes, getStyles, override*/ 124 && {
    						class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 2048) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;
    	const omit_props_names = ["use","element","class","override","padding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardSection', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, padding = 'md' } = $$props;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('padding' in $$new_props) $$invalidate(8, padding = $$new_props.padding);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$c,
    		Box: Box$1,
    		use,
    		element,
    		className,
    		override,
    		padding,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('padding' in $$props) $$invalidate(8, padding = $$new_props.padding);
    		if ('getStyles' in $$props) $$invalidate(4, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(6, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*padding*/ 256) {
    			$$invalidate(6, { cx, classes, getStyles } = useStyles$c({ padding }), cx, ($$invalidate(5, classes), $$invalidate(8, padding)), ($$invalidate(4, getStyles), $$invalidate(8, padding)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		padding,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class CardSection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			padding: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardSection",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get use() {
    		throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Section = CardSection;

    // Combine Card and Section
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    _Card.Section = Section;
    const Card = _Card;

    var useStyles$b = createStyles((_, { inline }) => {
        return {
            root: {
                display: inline ? 'inline-flex' : 'flex',
                alignItems: 'center',
                justifyContent: 'center'
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Center/Center.svelte generated by Svelte v3.59.2 */

    // (21:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >
    function create_default_slot$m(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(21:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{
    			class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    		},
    		/*$$restProps*/ ctx[7]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[10](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$m] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/ 254)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*cx, className, classes, getStyles, override*/ 124 && {
    						class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 2048) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;
    	const omit_props_names = ["use","element","class","override","inline"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Center', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, inline = false } = $$props;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('inline' in $$new_props) $$invalidate(8, inline = $$new_props.inline);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$b,
    		Box: Box$1,
    		use,
    		element,
    		className,
    		override,
    		inline,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('inline' in $$props) $$invalidate(8, inline = $$new_props.inline);
    		if ('getStyles' in $$props) $$invalidate(4, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(6, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*inline*/ 256) {
    			$$invalidate(6, { cx, classes, getStyles } = useStyles$b({ inline }, { name: 'Center' }), cx, ($$invalidate(5, classes), $$invalidate(8, inline)), ($$invalidate(4, getStyles), $$invalidate(8, inline)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		inline,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Center extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			inline: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Center",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get use() {
    		throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inline() {
    		throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inline(value) {
    		throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Center$1 = Center;

    var useStyles$a = createStyles((theme, { size }) => {
        return {
            root: {
                lineHeight: theme.lineHeights.md.value
            },
            label: {
                [`${theme.dark} &`]: {
                    color: theme.fn.themeColor('dark', 0)
                },
                display: 'inline-block',
                marginBottom: 4,
                fontSize: theme.fontSizes[size].value,
                fontWeight: 500,
                color: theme.fn.themeColor('gray', 9),
                wordBreak: 'break-word',
                cursor: 'default',
                WebkitTapHighlightColor: 'transparent'
            },
            error: {
                [`${theme.dark} &`]: {
                    color: theme.fn.themeColor('red', 6)
                },
                marginTop: 5,
                wordBreak: 'break-word',
                color: theme.fn.themeColor('red', 7)
            },
            description: {
                [`${theme.dark} &`]: {
                    color: `${theme.fn.themeColor('dark', 2)} !important`
                },
                marginTop: -3,
                marginBottom: 7,
                wordBreak: 'break-word',
                color: `${theme.fn.themeColor('gray', 6)} !important`,
                fontSize: theme.fontSizes[size].value,
                lineHeight: 1.2
            },
            required: {
                [`${theme.dark} &`]: {
                    color: '$red500'
                },
                color: theme.fn.themeColor('red', 7)
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/InputWrapper/LabelElement.svelte generated by Svelte v3.59.2 */
    const file$f = "node_modules/@svelteuidev/core/dist/components/InputWrapper/LabelElement.svelte";

    // (12:1) {#if required}
    function create_if_block$d(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = `${' *'}`;
    			attr_dev(span, "class", "required");
    			attr_dev(span, "aria-hidden", "");
    			add_location(span, file$f, 12, 2, 318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(12:1) {#if required}",
    		ctx
    	});

    	return block;
    }

    // (10:0) <Box for={id} root={labelElement} class={className}>
    function create_default_slot$l(ctx) {
    	let t0;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*required*/ ctx[3] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			t0 = text(/*label*/ ctx[1]);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);

    			if (/*required*/ ctx[3]) {
    				if (if_block) ; else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(10:0) <Box for={id} root={labelElement} class={className}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let box;
    	let current;

    	box = new Box$1({
    			props: {
    				for: /*id*/ ctx[4],
    				root: /*labelElement*/ ctx[2],
    				class: /*className*/ ctx[0],
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = {};
    			if (dirty & /*id*/ 16) box_changes.for = /*id*/ ctx[4];
    			if (dirty & /*labelElement*/ 4) box_changes.root = /*labelElement*/ ctx[2];
    			if (dirty & /*className*/ 1) box_changes.class = /*className*/ ctx[0];

    			if (dirty & /*$$scope, required, label*/ 42) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LabelElement', slots, []);
    	let { class: className = 'label' } = $$props;
    	let { label = 'label' } = $$props;
    	let { labelElement = 'label' } = $$props;
    	let { required = false } = $$props;
    	let { id = undefined } = $$props;
    	const writable_props = ['class', 'label', 'labelElement', 'required', 'id'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LabelElement> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('class' in $$props) $$invalidate(0, className = $$props.class);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('labelElement' in $$props) $$invalidate(2, labelElement = $$props.labelElement);
    		if ('required' in $$props) $$invalidate(3, required = $$props.required);
    		if ('id' in $$props) $$invalidate(4, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		Box: Box$1,
    		className,
    		label,
    		labelElement,
    		required,
    		id
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('labelElement' in $$props) $$invalidate(2, labelElement = $$props.labelElement);
    		if ('required' in $$props) $$invalidate(3, required = $$props.required);
    		if ('id' in $$props) $$invalidate(4, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, label, labelElement, required, id];
    }

    class LabelElement extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			class: 0,
    			label: 1,
    			labelElement: 2,
    			required: 3,
    			id: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LabelElement",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get class() {
    		throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelElement() {
    		throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelElement(value) {
    		throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var LabelElement$1 = LabelElement;

    /* node_modules/@svelteuidev/core/dist/components/InputWrapper/InputWrapper.svelte generated by Svelte v3.59.2 */

    // (20:1) {#if label}
    function create_if_block_2$4(ctx) {
    	let labelelement;
    	let current;

    	const labelelement_spread_levels = [
    		{ class: /*classes*/ ctx[15].label },
    		/*_labelProps*/ ctx[13],
    		{ label: /*label*/ ctx[4] },
    		{ id: /*id*/ ctx[10] },
    		{ labelElement: /*labelElement*/ ctx[11] },
    		{ required: /*required*/ ctx[7] }
    	];

    	let labelelement_props = {};

    	for (let i = 0; i < labelelement_spread_levels.length; i += 1) {
    		labelelement_props = assign(labelelement_props, labelelement_spread_levels[i]);
    	}

    	labelelement = new LabelElement$1({
    			props: labelelement_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(labelelement.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(labelelement, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const labelelement_changes = (dirty & /*classes, _labelProps, label, id, labelElement, required*/ 44176)
    			? get_spread_update(labelelement_spread_levels, [
    					dirty & /*classes*/ 32768 && { class: /*classes*/ ctx[15].label },
    					dirty & /*_labelProps*/ 8192 && get_spread_object(/*_labelProps*/ ctx[13]),
    					dirty & /*label*/ 16 && { label: /*label*/ ctx[4] },
    					dirty & /*id*/ 1024 && { id: /*id*/ ctx[10] },
    					dirty & /*labelElement*/ 2048 && { labelElement: /*labelElement*/ ctx[11] },
    					dirty & /*required*/ 128 && { required: /*required*/ ctx[7] }
    				])
    			: {};

    			labelelement.$set(labelelement_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(labelelement.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(labelelement.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(labelelement, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(20:1) {#if label}",
    		ctx
    	});

    	return block;
    }

    // (23:1) {#if description}
    function create_if_block_1$8(ctx) {
    	let text_1;
    	let current;

    	const text_1_spread_levels = [
    		/*descriptionProps*/ ctx[8],
    		{ color: "gray" },
    		{ class: /*classes*/ ctx[15].description }
    	];

    	let text_1_props = {
    		$$slots: { default: [create_default_slot_2$8] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < text_1_spread_levels.length; i += 1) {
    		text_1_props = assign(text_1_props, text_1_spread_levels[i]);
    	}

    	text_1 = new Text$1({ props: text_1_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = (dirty & /*descriptionProps, classes*/ 33024)
    			? get_spread_update(text_1_spread_levels, [
    					dirty & /*descriptionProps*/ 256 && get_spread_object(/*descriptionProps*/ ctx[8]),
    					text_1_spread_levels[1],
    					dirty & /*classes*/ 32768 && { class: /*classes*/ ctx[15].description }
    				])
    			: {};

    			if (dirty & /*$$scope, description*/ 2097184) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(23:1) {#if description}",
    		ctx
    	});

    	return block;
    }

    // (24:2) <Text {...descriptionProps} color="gray" class={classes.description}>
    function create_default_slot_2$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*description*/ ctx[5]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*description*/ 32) set_data_dev(t, /*description*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(24:2) <Text {...descriptionProps} color=\\\"gray\\\" class={classes.description}>",
    		ctx
    	});

    	return block;
    }

    // (29:1) {#if typeof error !== 'boolean' && error}
    function create_if_block$c(ctx) {
    	let text_1;
    	let current;

    	const text_1_spread_levels = [
    		/*errorProps*/ ctx[9],
    		{ size: /*size*/ ctx[12] },
    		{ class: /*classes*/ ctx[15].error }
    	];

    	let text_1_props = {
    		$$slots: { default: [create_default_slot_1$b] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < text_1_spread_levels.length; i += 1) {
    		text_1_props = assign(text_1_props, text_1_spread_levels[i]);
    	}

    	text_1 = new Text$1({ props: text_1_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = (dirty & /*errorProps, size, classes*/ 37376)
    			? get_spread_update(text_1_spread_levels, [
    					dirty & /*errorProps*/ 512 && get_spread_object(/*errorProps*/ ctx[9]),
    					dirty & /*size*/ 4096 && { size: /*size*/ ctx[12] },
    					dirty & /*classes*/ 32768 && { class: /*classes*/ ctx[15].error }
    				])
    			: {};

    			if (dirty & /*$$scope, error*/ 2097216) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(29:1) {#if typeof error !== 'boolean' && error}",
    		ctx
    	});

    	return block;
    }

    // (30:2) <Text {...errorProps} {size} class={classes.error}>
    function create_default_slot_1$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*error*/ ctx[6]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 64) set_data_dev(t, /*error*/ ctx[6]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(30:2) <Text {...errorProps} {size} class={classes.error}>",
    		ctx
    	});

    	return block;
    }

    // (14:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >
    function create_default_slot$k(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*label*/ ctx[4] && create_if_block_2$4(ctx);
    	let if_block1 = /*description*/ ctx[5] && create_if_block_1$8(ctx);
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
    	let if_block2 = typeof /*error*/ ctx[6] !== 'boolean' && /*error*/ ctx[6] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*label*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*label*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*description*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*description*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[21],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
    						null
    					);
    				}
    			}

    			if (typeof /*error*/ ctx[6] !== 'boolean' && /*error*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*error*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$c(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(14:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{
    			class: /*cx*/ ctx[16](/*className*/ ctx[2], /*classes*/ ctx[15].root, /*getStyles*/ ctx[14]({ css: /*override*/ ctx[3] }))
    		},
    		/*$$restProps*/ ctx[17]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[20](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$k] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/ 245774)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*cx, className, classes, getStyles, override*/ 114700 && {
    						class: /*cx*/ ctx[16](/*className*/ ctx[2], /*classes*/ ctx[15].root, /*getStyles*/ ctx[14]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*$$restProps*/ 131072 && get_spread_object(/*$$restProps*/ ctx[17])
    				])
    			: {};

    			if (dirty & /*$$scope, errorProps, size, classes, error, descriptionProps, description, _labelProps, label, id, labelElement, required*/ 2146288) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","label","description","error","required","labelProps","descriptionProps","errorProps","id","labelElement","size"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InputWrapper', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, label = 'label', description = null, error = null, required = false, labelProps = {}, descriptionProps = {}, errorProps = {}, id = 'input-id', labelElement = 'label', size = 'sm' } = $$props;
    	let _labelProps;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('label' in $$new_props) $$invalidate(4, label = $$new_props.label);
    		if ('description' in $$new_props) $$invalidate(5, description = $$new_props.description);
    		if ('error' in $$new_props) $$invalidate(6, error = $$new_props.error);
    		if ('required' in $$new_props) $$invalidate(7, required = $$new_props.required);
    		if ('labelProps' in $$new_props) $$invalidate(18, labelProps = $$new_props.labelProps);
    		if ('descriptionProps' in $$new_props) $$invalidate(8, descriptionProps = $$new_props.descriptionProps);
    		if ('errorProps' in $$new_props) $$invalidate(9, errorProps = $$new_props.errorProps);
    		if ('id' in $$new_props) $$invalidate(10, id = $$new_props.id);
    		if ('labelElement' in $$new_props) $$invalidate(11, labelElement = $$new_props.labelElement);
    		if ('size' in $$new_props) $$invalidate(12, size = $$new_props.size);
    		if ('$$scope' in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$a,
    		Box: Box$1,
    		Text: Text$1,
    		LabelElement: LabelElement$1,
    		use,
    		element,
    		className,
    		override,
    		label,
    		description,
    		error,
    		required,
    		labelProps,
    		descriptionProps,
    		errorProps,
    		id,
    		labelElement,
    		size,
    		_labelProps,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('label' in $$props) $$invalidate(4, label = $$new_props.label);
    		if ('description' in $$props) $$invalidate(5, description = $$new_props.description);
    		if ('error' in $$props) $$invalidate(6, error = $$new_props.error);
    		if ('required' in $$props) $$invalidate(7, required = $$new_props.required);
    		if ('labelProps' in $$props) $$invalidate(18, labelProps = $$new_props.labelProps);
    		if ('descriptionProps' in $$props) $$invalidate(8, descriptionProps = $$new_props.descriptionProps);
    		if ('errorProps' in $$props) $$invalidate(9, errorProps = $$new_props.errorProps);
    		if ('id' in $$props) $$invalidate(10, id = $$new_props.id);
    		if ('labelElement' in $$props) $$invalidate(11, labelElement = $$new_props.labelElement);
    		if ('size' in $$props) $$invalidate(12, size = $$new_props.size);
    		if ('_labelProps' in $$props) $$invalidate(13, _labelProps = $$new_props._labelProps);
    		if ('getStyles' in $$props) $$invalidate(14, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(15, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(16, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*labelElement, id, labelProps*/ 265216) {
    			{
    				$$invalidate(13, _labelProps = labelElement === 'label'
    				? { htmlFor: id, ...labelProps }
    				: { ...labelProps });
    			}
    		}

    		if ($$self.$$.dirty & /*size*/ 4096) {
    			$$invalidate(16, { cx, classes, getStyles } = useStyles$a({ size }, { name: 'InputWrapper' }), cx, ($$invalidate(15, classes), $$invalidate(12, size)), ($$invalidate(14, getStyles), $$invalidate(12, size)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		label,
    		description,
    		error,
    		required,
    		descriptionProps,
    		errorProps,
    		id,
    		labelElement,
    		size,
    		_labelProps,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		labelProps,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class InputWrapper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			label: 4,
    			description: 5,
    			error: 6,
    			required: 7,
    			labelProps: 18,
    			descriptionProps: 8,
    			errorProps: 9,
    			id: 10,
    			labelElement: 11,
    			size: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InputWrapper",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get use() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelProps() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelProps(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get descriptionProps() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set descriptionProps(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorProps() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorProps(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelElement() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelElement(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var InputWrapper$1 = InputWrapper;

    const POSITIONS = {
        left: 'flex-start',
        center: 'center',
        right: 'flex-end',
        apart: 'space-between'
    };
    var useStyles$9 = createStyles((theme, { align, direction, grow, noWrap, position, spacing, children }) => {
        return {
            root: {
                boxSizing: 'border-box',
                display: 'flex',
                flexDirection: direction,
                alignItems: align ||
                    (direction === 'row'
                        ? 'center'
                        : grow
                            ? 'stretch'
                            : position === 'apart'
                                ? 'flex-start'
                                : POSITIONS[position]),
                flexWrap: noWrap ? 'nowrap' : 'wrap',
                justifyContent: direction === 'row' ? POSITIONS[position] : undefined,
                gap: theme.fn.size({ size: spacing, sizes: theme.space }),
                '& > *': {
                    boxSizing: 'border-box',
                    maxWidth: grow && direction === 'row'
                        ? `calc(${100 / children}% - ${theme.fn.size({ size: spacing, sizes: theme.space }) -
                        theme.fn.size({ size: spacing, sizes: theme.space }) / children}px)`
                        : undefined,
                    flexGrow: grow ? 1 : 0
                }
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Group/Group.svelte generated by Svelte v3.59.2 */

    // (39:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >
    function create_default_slot$j(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(39:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{
    			class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    		},
    		/*$$restProps*/ ctx[7]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[16](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$j] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/ 254)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*cx, className, classes, getStyles, override*/ 124 && {
    						class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 131072) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","position","noWrap","grow","spacing","direction","align"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Group', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, position = 'left', noWrap = false, grow = false, spacing = 'md', direction = 'row', align = 'center' } = $$props;

    	/** The children being rendered */
    	let children;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('position' in $$new_props) $$invalidate(8, position = $$new_props.position);
    		if ('noWrap' in $$new_props) $$invalidate(9, noWrap = $$new_props.noWrap);
    		if ('grow' in $$new_props) $$invalidate(10, grow = $$new_props.grow);
    		if ('spacing' in $$new_props) $$invalidate(11, spacing = $$new_props.spacing);
    		if ('direction' in $$new_props) $$invalidate(12, direction = $$new_props.direction);
    		if ('align' in $$new_props) $$invalidate(13, align = $$new_props.align);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$9,
    		onMount,
    		Box: Box$1,
    		use,
    		element,
    		className,
    		override,
    		position,
    		noWrap,
    		grow,
    		spacing,
    		direction,
    		align,
    		children,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('position' in $$props) $$invalidate(8, position = $$new_props.position);
    		if ('noWrap' in $$props) $$invalidate(9, noWrap = $$new_props.noWrap);
    		if ('grow' in $$props) $$invalidate(10, grow = $$new_props.grow);
    		if ('spacing' in $$props) $$invalidate(11, spacing = $$new_props.spacing);
    		if ('direction' in $$props) $$invalidate(12, direction = $$new_props.direction);
    		if ('align' in $$props) $$invalidate(13, align = $$new_props.align);
    		if ('children' in $$props) $$invalidate(14, children = $$new_props.children);
    		if ('getStyles' in $$props) $$invalidate(4, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(6, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*element*/ 1) {
    			/** can only get access to children at runtime */
    			onMount(() => {
    				$$invalidate(14, children = element.childElementCount);
    			});
    		}

    		if ($$self.$$.dirty & /*align, children, direction, grow, noWrap, position, spacing*/ 32512) {
    			$$invalidate(
    				6,
    				{ cx, classes, getStyles } = useStyles$9(
    					{
    						align,
    						children,
    						direction,
    						grow,
    						noWrap,
    						position,
    						spacing
    					},
    					{ name: 'Group' }
    				),
    				cx,
    				(((((((($$invalidate(5, classes), $$invalidate(13, align)), $$invalidate(14, children)), $$invalidate(12, direction)), $$invalidate(10, grow)), $$invalidate(9, noWrap)), $$invalidate(8, position)), $$invalidate(11, spacing)), $$invalidate(0, element)),
    				(((((((($$invalidate(4, getStyles), $$invalidate(13, align)), $$invalidate(14, children)), $$invalidate(12, direction)), $$invalidate(10, grow)), $$invalidate(9, noWrap)), $$invalidate(8, position)), $$invalidate(11, spacing)), $$invalidate(0, element))
    			);
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		position,
    		noWrap,
    		grow,
    		spacing,
    		direction,
    		align,
    		children,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Group extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			position: 8,
    			noWrap: 9,
    			grow: 10,
    			spacing: 11,
    			direction: 12,
    			align: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Group",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get use() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noWrap() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noWrap(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grow() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grow(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spacing() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spacing(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Group$1 = Group;

    var useStyles$8 = createStyles((theme, { fluid, size, sizes }) => {
        return {
            root: {
                paddingLeft: theme.fn.size({ size, sizes: theme.space }),
                paddingRight: theme.fn.size({ size, sizes: theme.space }),
                maxWidth: fluid ? '100%' : typeof size === 'number' ? `${size}px` : sizes[size] ?? sizes.md,
                marginLeft: 'auto',
                marginRight: 'auto'
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Container/Container.svelte generated by Svelte v3.59.2 */

    // (35:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >
    function create_default_slot$i(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(35:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{
    			class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    		},
    		/*$$restProps*/ ctx[7]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[12](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$i] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/ 254)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*cx, className, classes, getStyles, override*/ 124 && {
    						class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 8192) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;
    	const omit_props_names = ["use","element","class","override","size","fluid","sizes"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Container', slots, ['default']);

    	let { use = [], element = undefined, class: className = '', override = {}, size = 'md', fluid = false, sizes = {
    		xs: 540,
    		sm: 720,
    		md: 960,
    		lg: 1140,
    		xl: 1320
    	} } = $$props;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('size' in $$new_props) $$invalidate(8, size = $$new_props.size);
    		if ('fluid' in $$new_props) $$invalidate(9, fluid = $$new_props.fluid);
    		if ('sizes' in $$new_props) $$invalidate(10, sizes = $$new_props.sizes);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$8,
    		Box: Box$1,
    		use,
    		element,
    		className,
    		override,
    		size,
    		fluid,
    		sizes,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('size' in $$props) $$invalidate(8, size = $$new_props.size);
    		if ('fluid' in $$props) $$invalidate(9, fluid = $$new_props.fluid);
    		if ('sizes' in $$props) $$invalidate(10, sizes = $$new_props.sizes);
    		if ('getStyles' in $$props) $$invalidate(4, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(6, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*fluid, size, sizes*/ 1792) {
    			$$invalidate(6, { cx, classes, getStyles } = useStyles$8({ fluid, size, sizes }, { name: 'Container' }), cx, ((($$invalidate(5, classes), $$invalidate(9, fluid)), $$invalidate(8, size)), $$invalidate(10, sizes)), ((($$invalidate(4, getStyles), $$invalidate(9, fluid)), $$invalidate(8, size)), $$invalidate(10, sizes)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		size,
    		fluid,
    		sizes,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Container extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			size: 8,
    			fluid: 9,
    			sizes: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Container",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get use() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fluid() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fluid(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sizes() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sizes(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Container$1 = Container;

    const sizes$2 = {
        xs: 1,
        sm: 2,
        md: 3,
        lg: 4,
        xl: 5
    };
    var useStyles$7 = createStyles((theme, { color, size, variant }) => {
        const { size: sizeFn, themeColor } = theme.fn;
        return {
            root: {},
            horizontal: {
                border: 0,
                borderTopWidth: typeof size === 'number' ? `${size}px` : sizeFn({ size, sizes: sizes$2 }),
                borderTopColor: themeColor(color, 4),
                borderTopStyle: variant,
                margin: '12px 0px 12px 0px'
            },
            vertical: {
                border: 0,
                alignSelf: 'stretch',
                height: '100%',
                borderLeftWidth: typeof size === 'number' ? `${size}px` : sizeFn({ size, sizes: sizes$2 }),
                borderLeftColor: themeColor(color, 4),
                borderLeftStyle: variant
            },
            showsLabel: {
                borderTop: '0 !important'
            },
            label: {
                display: 'flex',
                alignItems: 'center',
                color: color === 'dark' ? themeColor('dark', 1) : themeColor(color, 6),
                [`${theme.dark} &`]: {
                    color: color === 'dark' ? themeColor('dark', 1) : themeColor(color, 5)
                },
                '&.left': {
                    '&::before': {
                        display: 'none'
                    }
                },
                '&.right': {
                    '&::after': {
                        display: 'none'
                    }
                },
                '&::before': {
                    content: '""',
                    flex: 1,
                    height: 1,
                    borderTopWidth: typeof size === 'number' ? `${size}px` : sizeFn({ size, sizes: sizes$2 }),
                    borderTopStyle: `${variant}`,
                    borderTopColor: themeColor(color, 4),
                    marginRight: '10px',
                    [`${theme.dark} &`]: {
                        borderTopColor: themeColor(color, 3)
                    }
                },
                '&::after': {
                    content: '""',
                    flex: 1,
                    borderTopWidth: typeof size === 'number' ? `${size}px` : sizeFn({ size, sizes: sizes$2 }),
                    borderTopStyle: `${variant}`,
                    borderTopColor: themeColor(color, 3),
                    marginLeft: '10px'
                }
            }
        };
    });

    /** Error codes for component
     *
     * `Object.freeze` is needed to keep modification outside of the object unavailable
     *
     * ## Code 1:
     * If using label or slot label, it cannot use orientation 'vertical'
     */
    const DividerErrors = Object.freeze([
        {
            error: true,
            message: "If using label or label slot, it cannot use orientation 'vertical'",
            solution: `
                If your component looks like this:
                
                &lt;Divider orientation='vertical' label='text...'&lt;/Divider&gt;
                                        ^^^^^^^^^ - Try changing orientation to 'horizontal'
                `
        }
    ]);

    /* node_modules/@svelteuidev/core/dist/components/Divider/Divider.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1$1 } = globals;
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});

    // (57:1) {#if showsLabel}
    function create_if_block$b(ctx) {
    	let text_1;
    	let current;

    	const text_1_spread_levels = [
    		{
    			class: /*cx*/ ctx[12](/*classes*/ ctx[11].label, /*labelPosition*/ ctx[6])
    		},
    		/*labelProps*/ ctx[7],
    		{
    			size: /*labelProps*/ ctx[7]?.size || /*size*/ ctx[4]
    		}
    	];

    	let text_1_props = {
    		$$slots: { default: [create_default_slot_1$a] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < text_1_spread_levels.length; i += 1) {
    		text_1_props = assign(text_1_props, text_1_spread_levels[i]);
    	}

    	text_1 = new Text$1({ props: text_1_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = (dirty & /*cx, classes, labelPosition, labelProps, size*/ 6352)
    			? get_spread_update(text_1_spread_levels, [
    					dirty & /*cx, classes, labelPosition*/ 6208 && {
    						class: /*cx*/ ctx[12](/*classes*/ ctx[11].label, /*labelPosition*/ ctx[6])
    					},
    					dirty & /*labelProps*/ 128 && get_spread_object(/*labelProps*/ ctx[7]),
    					dirty & /*labelProps, size*/ 144 && {
    						size: /*labelProps*/ ctx[7]?.size || /*size*/ ctx[4]
    					}
    				])
    			: {};

    			if (dirty & /*$$scope, label*/ 4194336) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(57:1) {#if showsLabel}",
    		ctx
    	});

    	return block;
    }

    // (59:22)      
    function fallback_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[5]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 32) set_data_dev(t, /*label*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$3.name,
    		type: "fallback",
    		source: "(59:22)      ",
    		ctx
    	});

    	return block;
    }

    // (58:2) <Text class={cx(classes.label, labelPosition)} {...labelProps} size={labelProps?.size || size}>
    function create_default_slot_1$a(ctx) {
    	let current;
    	const label_slot_template = /*#slots*/ ctx[20].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[22], get_label_slot_context);
    	const label_slot_or_fallback = label_slot || fallback_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (label_slot_or_fallback) label_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (label_slot_or_fallback) {
    				label_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (label_slot) {
    				if (label_slot.p && (!current || dirty & /*$$scope*/ 4194304)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[22],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[22])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[22], dirty, get_label_slot_changes),
    						get_label_slot_context
    					);
    				}
    			} else {
    				if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & /*label*/ 32)) {
    					label_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(58:2) <Text class={cx(classes.label, labelPosition)} {...labelProps} size={labelProps?.size || size}>",
    		ctx
    	});

    	return block;
    }

    // (44:0) <Box  bind:element  {use}  class={cx(   className,   classes.root,   isHorizontal ? classes.horizontal : {},   isVertical ? classes.vertical : {},   showsLabel ? classes.showsLabel : {},   getStyles({ css: override })  )}  {...$$restProps} >
    function create_default_slot$h(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*showsLabel*/ ctx[15] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*showsLabel*/ ctx[15]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showsLabel*/ 32768) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(44:0) <Box  bind:element  {use}  class={cx(   className,   classes.root,   isHorizontal ? classes.horizontal : {},   isVertical ? classes.vertical : {},   showsLabel ? classes.showsLabel : {},   getStyles({ css: override })  )}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let error;
    	let t;
    	let box;
    	let updating_element;
    	let current;

    	error = new Error$2({
    			props: {
    				observable: /*observable*/ ctx[8],
    				component: "Divider",
    				code: /*err*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[2] },
    		{
    			class: /*cx*/ ctx[12](
    				/*className*/ ctx[3],
    				/*classes*/ ctx[11].root,
    				/*isHorizontal*/ ctx[14]
    				? /*classes*/ ctx[11].horizontal
    				: {},
    				/*isVertical*/ ctx[13]
    				? /*classes*/ ctx[11].vertical
    				: {},
    				/*showsLabel*/ ctx[15]
    				? /*classes*/ ctx[11].showsLabel
    				: {},
    				/*getStyles*/ ctx[10]({ css: /*override*/ ctx[1] })
    			)
    		},
    		/*$$restProps*/ ctx[16]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[21](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$h] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(error.$$.fragment);
    			t = space();
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const error_changes = {};
    			if (dirty & /*observable*/ 256) error_changes.observable = /*observable*/ ctx[8];
    			if (dirty & /*err*/ 512) error_changes.code = /*err*/ ctx[9];
    			error.$set(error_changes);

    			const box_changes = (dirty & /*use, cx, className, classes, isHorizontal, isVertical, showsLabel, getStyles, override, $$restProps*/ 130062)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 4 && { use: /*use*/ ctx[2] },
    					dirty & /*cx, className, classes, isHorizontal, isVertical, showsLabel, getStyles, override*/ 64522 && {
    						class: /*cx*/ ctx[12](
    							/*className*/ ctx[3],
    							/*classes*/ ctx[11].root,
    							/*isHorizontal*/ ctx[14]
    							? /*classes*/ ctx[11].horizontal
    							: {},
    							/*isVertical*/ ctx[13]
    							? /*classes*/ ctx[11].vertical
    							: {},
    							/*showsLabel*/ ctx[15]
    							? /*classes*/ ctx[11].showsLabel
    							: {},
    							/*getStyles*/ ctx[10]({ css: /*override*/ ctx[1] })
    						)
    					},
    					dirty & /*$$restProps*/ 65536 && get_spread_object(/*$$restProps*/ ctx[16])
    				])
    			: {};

    			if (dirty & /*$$scope, cx, classes, labelPosition, labelProps, size, label, showsLabel*/ 4233456) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let showsLabel;
    	let isVertical;
    	let isHorizontal;
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","color","orientation","size","label","labelPosition","labelProps","variant"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Divider', slots, ['label']);
    	const $$slots = compute_slots(slots);
    	let { use = [], element = undefined, class: className = '', override = {}, color = 'gray', orientation = 'horizontal', size = 'xs', label = null, labelPosition = 'left', labelProps = null, variant = 'solid' } = $$props;

    	// --------------Error Handling-------------------
    	let observable = false;

    	let err;

    	if (isVertical && (label || $$slots.label)) {
    		observable = true;
    		err = DividerErrors[0];
    	}

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(1, override = $$new_props.override);
    		if ('color' in $$new_props) $$invalidate(17, color = $$new_props.color);
    		if ('orientation' in $$new_props) $$invalidate(18, orientation = $$new_props.orientation);
    		if ('size' in $$new_props) $$invalidate(4, size = $$new_props.size);
    		if ('label' in $$new_props) $$invalidate(5, label = $$new_props.label);
    		if ('labelPosition' in $$new_props) $$invalidate(6, labelPosition = $$new_props.labelPosition);
    		if ('labelProps' in $$new_props) $$invalidate(7, labelProps = $$new_props.labelProps);
    		if ('variant' in $$new_props) $$invalidate(19, variant = $$new_props.variant);
    		if ('$$scope' in $$new_props) $$invalidate(22, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Error: Error$2,
    		Box: Box$1,
    		Text: Text$1,
    		useStyles: useStyles$7,
    		DividerErrors,
    		use,
    		element,
    		className,
    		override,
    		color,
    		orientation,
    		size,
    		label,
    		labelPosition,
    		labelProps,
    		variant,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx,
    		isVertical,
    		isHorizontal,
    		showsLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(1, override = $$new_props.override);
    		if ('color' in $$props) $$invalidate(17, color = $$new_props.color);
    		if ('orientation' in $$props) $$invalidate(18, orientation = $$new_props.orientation);
    		if ('size' in $$props) $$invalidate(4, size = $$new_props.size);
    		if ('label' in $$props) $$invalidate(5, label = $$new_props.label);
    		if ('labelPosition' in $$props) $$invalidate(6, labelPosition = $$new_props.labelPosition);
    		if ('labelProps' in $$props) $$invalidate(7, labelProps = $$new_props.labelProps);
    		if ('variant' in $$props) $$invalidate(19, variant = $$new_props.variant);
    		if ('observable' in $$props) $$invalidate(8, observable = $$new_props.observable);
    		if ('err' in $$props) $$invalidate(9, err = $$new_props.err);
    		if ('getStyles' in $$props) $$invalidate(10, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(11, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(12, cx = $$new_props.cx);
    		if ('isVertical' in $$props) $$invalidate(13, isVertical = $$new_props.isVertical);
    		if ('isHorizontal' in $$props) $$invalidate(14, isHorizontal = $$new_props.isHorizontal);
    		if ('showsLabel' in $$props) $$invalidate(15, showsLabel = $$new_props.showsLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*label, orientation*/ 262176) {
    			$$invalidate(15, showsLabel = (label || $$slots.label) && orientation === 'horizontal');
    		}

    		if ($$self.$$.dirty & /*orientation*/ 262144) {
    			$$invalidate(13, isVertical = orientation === 'vertical');
    		}

    		if ($$self.$$.dirty & /*orientation*/ 262144) {
    			$$invalidate(14, isHorizontal = orientation === 'horizontal');
    		}

    		if ($$self.$$.dirty & /*observable*/ 256) {
    			if (observable) $$invalidate(1, override = { display: 'none' });
    		}

    		if ($$self.$$.dirty & /*color, size, variant*/ 655376) {
    			$$invalidate(12, { cx, classes, getStyles } = useStyles$7({ color, size, variant }, { name: 'Divider' }), cx, ((($$invalidate(11, classes), $$invalidate(17, color)), $$invalidate(4, size)), $$invalidate(19, variant)), ((($$invalidate(10, getStyles), $$invalidate(17, color)), $$invalidate(4, size)), $$invalidate(19, variant)));
    		}
    	};

    	return [
    		element,
    		override,
    		use,
    		className,
    		size,
    		label,
    		labelPosition,
    		labelProps,
    		observable,
    		err,
    		getStyles,
    		classes,
    		cx,
    		isVertical,
    		isHorizontal,
    		showsLabel,
    		$$restProps,
    		color,
    		orientation,
    		variant,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Divider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			use: 2,
    			element: 0,
    			class: 3,
    			override: 1,
    			color: 17,
    			orientation: 18,
    			size: 4,
    			label: 5,
    			labelPosition: 6,
    			labelProps: 7,
    			variant: 19
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Divider",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get use() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get orientation() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set orientation(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelPosition() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelPosition(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelProps() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelProps(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error_1$1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error_1$1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Divider$1 = Divider;

    var useStyles$6 = createStyles((theme, { gap, rowGap, columnGap, align, justify, wrap, direction }) => {
        return {
            root: {
                boxSizing: 'border-box',
                display: 'flex',
                flexDirection: direction,
                alignItems: align,
                flexWrap: wrap,
                justifyContent: justify,
                gap: gap ? theme.fn.size({ size: gap, sizes: theme.space }) : undefined,
                rowGap: rowGap ? theme.fn.size({ size: rowGap, sizes: theme.space }) : undefined,
                columnGap: columnGap
                    ? theme.fn.size({ size: columnGap, sizes: theme.space })
                    : undefined
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Flex/Flex.svelte generated by Svelte v3.59.2 */

    // (32:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >
    function create_default_slot$g(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(32:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{
    			class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    		},
    		/*$$restProps*/ ctx[7]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[16](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$g] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/ 254)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*cx, className, classes, getStyles, override*/ 124 && {
    						class: /*cx*/ ctx[6](/*className*/ ctx[2], /*classes*/ ctx[5].root, /*getStyles*/ ctx[4]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 131072) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","gap","rowGap","columnGap","align","justify","wrap","direction"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Flex', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, gap = undefined, rowGap = undefined, columnGap = undefined, align = undefined, justify = undefined, wrap = undefined, direction = undefined } = $$props;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('gap' in $$new_props) $$invalidate(8, gap = $$new_props.gap);
    		if ('rowGap' in $$new_props) $$invalidate(9, rowGap = $$new_props.rowGap);
    		if ('columnGap' in $$new_props) $$invalidate(10, columnGap = $$new_props.columnGap);
    		if ('align' in $$new_props) $$invalidate(11, align = $$new_props.align);
    		if ('justify' in $$new_props) $$invalidate(12, justify = $$new_props.justify);
    		if ('wrap' in $$new_props) $$invalidate(13, wrap = $$new_props.wrap);
    		if ('direction' in $$new_props) $$invalidate(14, direction = $$new_props.direction);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		useStyles: useStyles$6,
    		Box: Box$1,
    		use,
    		element,
    		className,
    		override,
    		gap,
    		rowGap,
    		columnGap,
    		align,
    		justify,
    		wrap,
    		direction,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('gap' in $$props) $$invalidate(8, gap = $$new_props.gap);
    		if ('rowGap' in $$props) $$invalidate(9, rowGap = $$new_props.rowGap);
    		if ('columnGap' in $$props) $$invalidate(10, columnGap = $$new_props.columnGap);
    		if ('align' in $$props) $$invalidate(11, align = $$new_props.align);
    		if ('justify' in $$props) $$invalidate(12, justify = $$new_props.justify);
    		if ('wrap' in $$props) $$invalidate(13, wrap = $$new_props.wrap);
    		if ('direction' in $$props) $$invalidate(14, direction = $$new_props.direction);
    		if ('getStyles' in $$props) $$invalidate(4, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(6, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*gap, rowGap, columnGap, align, justify, wrap, direction*/ 32512) {
    			$$invalidate(
    				6,
    				{ cx, classes, getStyles } = useStyles$6(
    					{
    						gap,
    						rowGap,
    						columnGap,
    						align,
    						justify,
    						wrap,
    						direction
    					},
    					{ name: 'Flex' }
    				),
    				cx,
    				((((((($$invalidate(5, classes), $$invalidate(8, gap)), $$invalidate(9, rowGap)), $$invalidate(10, columnGap)), $$invalidate(11, align)), $$invalidate(12, justify)), $$invalidate(13, wrap)), $$invalidate(14, direction)),
    				((((((($$invalidate(4, getStyles), $$invalidate(8, gap)), $$invalidate(9, rowGap)), $$invalidate(10, columnGap)), $$invalidate(11, align)), $$invalidate(12, justify)), $$invalidate(13, wrap)), $$invalidate(14, direction))
    			);
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		gap,
    		rowGap,
    		columnGap,
    		align,
    		justify,
    		wrap,
    		direction,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Flex extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			gap: 8,
    			rowGap: 9,
    			columnGap: 10,
    			align: 11,
    			justify: 12,
    			wrap: 13,
    			direction: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Flex",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get use() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gap() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gap(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowGap() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowGap(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get columnGap() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columnGap(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get justify() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set justify(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrap() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrap(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Flex$1 = Flex;

    const fade = keyframes({
        'from, to': { opacity: 0.4 },
        '50%': { opacity: 1 }
    });
    var useStyles$5 = createStyles((theme, { animate, circle, height, radius, width }) => {
        return {
            root: {
                [`${theme.dark} &`]: {
                    '&.visible': {
                        '&::before': {
                            background: theme.fn.themeColor('dark', 7)
                        },
                        '&::after': {
                            background: theme.fn.themeColor('dark', 4)
                        }
                    }
                },
                height,
                width: circle ? height : `${width}%`,
                borderRadius: circle ? height : `$${radius}`,
                position: 'relative',
                overflow: 'hidden',
                '&.visible': {
                    '&::before': {
                        content: '""',
                        position: 'absolute',
                        background: 'white',
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        zIndex: 10
                    },
                    '&::after': {
                        content: '""',
                        position: 'absolute',
                        background: theme.fn.themeColor('gray', 3),
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        animation: animate ? `${fade} 1500ms linear infinite` : 'none',
                        zIndex: 11
                    }
                }
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Skeleton/Skeleton.svelte generated by Svelte v3.59.2 */

    // (8:0) <Box  bind:element  class={cx(className, classes.root, { visible }, getStyles({ css: override }))}  {use}  {...$$restProps} >
    function create_default_slot$f(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(8:0) <Box  bind:element  class={cx(className, classes.root, { visible }, getStyles({ css: override }))}  {use}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{
    			class: /*cx*/ ctx[7](/*className*/ ctx[2], /*classes*/ ctx[6].root, { visible: /*visible*/ ctx[4] }, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[3] }))
    		},
    		{ use: /*use*/ ctx[1] },
    		/*$$restProps*/ ctx[8]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[15](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$f] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*cx, className, classes, visible, getStyles, override, use, $$restProps*/ 510)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*cx, className, classes, visible, getStyles, override*/ 252 && {
    						class: /*cx*/ ctx[7](/*className*/ ctx[2], /*classes*/ ctx[6].root, { visible: /*visible*/ ctx[4] }, /*getStyles*/ ctx[5]({ css: /*override*/ ctx[3] }))
    					},
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 65536) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","visible","height","width","circle","radius","animate"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Skeleton', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, visible = true, height = 'auto', width = 100, circle = null, radius = null, animate = true } = $$props;

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('visible' in $$new_props) $$invalidate(4, visible = $$new_props.visible);
    		if ('height' in $$new_props) $$invalidate(9, height = $$new_props.height);
    		if ('width' in $$new_props) $$invalidate(10, width = $$new_props.width);
    		if ('circle' in $$new_props) $$invalidate(11, circle = $$new_props.circle);
    		if ('radius' in $$new_props) $$invalidate(12, radius = $$new_props.radius);
    		if ('animate' in $$new_props) $$invalidate(13, animate = $$new_props.animate);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Box: Box$1,
    		useStyles: useStyles$5,
    		use,
    		element,
    		className,
    		override,
    		visible,
    		height,
    		width,
    		circle,
    		radius,
    		animate,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('visible' in $$props) $$invalidate(4, visible = $$new_props.visible);
    		if ('height' in $$props) $$invalidate(9, height = $$new_props.height);
    		if ('width' in $$props) $$invalidate(10, width = $$new_props.width);
    		if ('circle' in $$props) $$invalidate(11, circle = $$new_props.circle);
    		if ('radius' in $$props) $$invalidate(12, radius = $$new_props.radius);
    		if ('animate' in $$props) $$invalidate(13, animate = $$new_props.animate);
    		if ('getStyles' in $$props) $$invalidate(5, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(6, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(7, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*animate, circle, height, radius, width*/ 15872) {
    			$$invalidate(7, { cx, classes, getStyles } = useStyles$5({ animate, circle, height, radius, width }, { name: 'Skeleton' }), cx, ((((($$invalidate(6, classes), $$invalidate(13, animate)), $$invalidate(11, circle)), $$invalidate(9, height)), $$invalidate(12, radius)), $$invalidate(10, width)), ((((($$invalidate(5, getStyles), $$invalidate(13, animate)), $$invalidate(11, circle)), $$invalidate(9, height)), $$invalidate(12, radius)), $$invalidate(10, width)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		visible,
    		getStyles,
    		classes,
    		cx,
    		$$restProps,
    		height,
    		width,
    		circle,
    		radius,
    		animate,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class Skeleton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			visible: 4,
    			height: 9,
    			width: 10,
    			circle: 11,
    			radius: 12,
    			animate: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Skeleton",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get use() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get circle() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set circle(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animate() {
    		throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animate(value) {
    		throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Skeleton$1 = Skeleton;

    var useStyles$4 = createStyles((theme, { radius, height, width, fit }) => {
        return {
            root: {},
            imageWrapper: {
                position: 'relative'
            },
            figure: {
                margin: 0
            },
            image: {
                width,
                height,
                fontFamily: '$standard',
                display: 'block',
                border: 0,
                borderRadius: theme.fn.radius(radius),
                objectFit: fit
            },
            caption: {
                [`${theme.dark} &`]: {
                    color: theme.fn.themeColor('dark', 2)
                },
                color: theme.fn.themeColor('gray', 7),
                marginTop: theme.space.xsPX.value
            },
            placeholder: {
                [`${theme.dark} &`]: {
                    color: theme.fn.themeColor('dark', 2),
                    backgroundColor: theme.fn.themeColor('dark', 8)
                },
                width,
                height,
                position: 'absolute',
                top: 0,
                right: 0,
                left: 0,
                bottom: 0,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: theme.fn.themeColor('gray', 6),
                backgroundColor: theme.fn.themeColor('gray', 0),
                borderRadius: theme.fn.radius(radius)
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Image/ImageIcon.svelte generated by Svelte v3.59.2 */

    const file$e = "node_modules/@svelteuidev/core/dist/components/Image/ImageIcon.svelte";

    function create_fragment$i(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			add_location(path, file$e, 11, 1, 200);
    			attr_dev(svg, "width", "15");
    			attr_dev(svg, "height", "15");
    			attr_dev(svg, "viewBox", "0 0 15 15");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			set_style(svg, "width", /*style*/ ctx[0].width);
    			set_style(svg, "height", /*style*/ ctx[0].height);
    			add_location(svg, file$e, 3, 0, 42);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				set_style(svg, "width", /*style*/ ctx[0].width);
    			}

    			if (dirty & /*style*/ 1) {
    				set_style(svg, "height", /*style*/ ctx[0].height);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImageIcon', slots, []);
    	let { style = {} } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImageIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class ImageIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageIcon",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get style() {
    		throw new Error("<ImageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ImageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var ImageIcon$1 = ImageIcon;

    /* node_modules/@svelteuidev/core/dist/components/Image/Image.svelte generated by Svelte v3.59.2 */
    const file$d = "node_modules/@svelteuidev/core/dist/components/Image/Image.svelte";
    const get_placeholder_slot_changes = dirty => ({});
    const get_placeholder_slot_context = ctx => ({});

    // (37:3) <Skeleton visible={loader ? loaded : false}>
    function create_default_slot_2$7(ctx) {
    	let img;
    	let img_class_value;
    	let img_src_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let img_levels = [
    		{
    			class: img_class_value = /*classes*/ ctx[11].image
    		},
    		{ src: img_src_value = /*src*/ ctx[4] },
    		{ alt: /*alt*/ ctx[5] },
    		/*$$restProps*/ ctx[16]
    	];

    	let img_data = {};

    	for (let i = 0; i < img_levels.length; i += 1) {
    		img_data = assign(img_data, img_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			img = element("img");
    			set_attributes(img, img_data);
    			add_location(img, file$d, 37, 4, 1684);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			/*img_binding*/ ctx[24](img);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, img, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[13].call(null, img)),
    					listen_dev(img, "load", /*onLoad*/ ctx[14], false, false, false, false),
    					listen_dev(img, "error", /*onError*/ ctx[15], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(img, img_data = get_spread_update(img_levels, [
    				dirty & /*classes*/ 2048 && img_class_value !== (img_class_value = /*classes*/ ctx[11].image) && { class: img_class_value },
    				dirty & /*src*/ 16 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[4]) && { src: img_src_value },
    				dirty & /*alt*/ 32 && { alt: /*alt*/ ctx[5] },
    				dirty & /*$$restProps*/ 65536 && /*$$restProps*/ ctx[16]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			/*img_binding*/ ctx[24](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(37:3) <Skeleton visible={loader ? loaded : false}>",
    		ctx
    	});

    	return block;
    }

    // (50:3) {#if showPlaceholder}
    function create_if_block_1$7(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const placeholder_slot_template = /*#slots*/ ctx[23].placeholder;
    	const placeholder_slot = create_slot(placeholder_slot_template, ctx, /*$$scope*/ ctx[25], get_placeholder_slot_context);
    	const placeholder_slot_or_fallback = placeholder_slot || fallback_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (placeholder_slot_or_fallback) placeholder_slot_or_fallback.c();
    			attr_dev(div, "class", div_class_value = /*classes*/ ctx[11].placeholder);
    			attr_dev(div, "title", /*alt*/ ctx[5]);
    			add_location(div, file$d, 50, 4, 1931);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (placeholder_slot_or_fallback) {
    				placeholder_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (placeholder_slot) {
    				if (placeholder_slot.p && (!current || dirty & /*$$scope*/ 33554432)) {
    					update_slot_base(
    						placeholder_slot,
    						placeholder_slot_template,
    						ctx,
    						/*$$scope*/ ctx[25],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
    						: get_slot_changes(placeholder_slot_template, /*$$scope*/ ctx[25], dirty, get_placeholder_slot_changes),
    						get_placeholder_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 2048 && div_class_value !== (div_class_value = /*classes*/ ctx[11].placeholder)) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*alt*/ 32) {
    				attr_dev(div, "title", /*alt*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(placeholder_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(placeholder_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (placeholder_slot_or_fallback) placeholder_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(50:3) {#if showPlaceholder}",
    		ctx
    	});

    	return block;
    }

    // (52:30)        
    function fallback_block$2(ctx) {
    	let imageicon;
    	let current;

    	imageicon = new ImageIcon$1({
    			props: { style: { width: 40, height: 40 } },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(imageicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(imageicon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imageicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imageicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(imageicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(52:30)        ",
    		ctx
    	});

    	return block;
    }

    // (58:2) {#if caption}
    function create_if_block$a(ctx) {
    	let text_1;
    	let current;

    	text_1 = new Text$1({
    			props: {
    				class: /*classes*/ ctx[11].caption,
    				root: "figcaption",
    				size: "sm",
    				align: "center",
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};
    			if (dirty & /*classes*/ 2048) text_1_changes.class = /*classes*/ ctx[11].caption;

    			if (dirty & /*$$scope, caption*/ 33554496) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(58:2) {#if caption}",
    		ctx
    	});

    	return block;
    }

    // (59:3) <Text class={classes.caption} root="figcaption" size="sm" align="center">
    function create_default_slot_1$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*caption*/ ctx[6]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*caption*/ 64) set_data_dev(t, /*caption*/ ctx[6]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(59:3) <Text class={classes.caption} root=\\\"figcaption\\\" size=\\\"sm\\\" align=\\\"center\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:0) <Box class={cx(className, classes.root, getStyles({ css: override }))}>
    function create_default_slot$e(ctx) {
    	let figure;
    	let div;
    	let skeleton;
    	let t0;
    	let div_class_value;
    	let t1;
    	let figure_class_value;
    	let current;

    	skeleton = new Skeleton$1({
    			props: {
    				visible: /*loader*/ ctx[7] ? /*loaded*/ ctx[8] : false,
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block0 = /*showPlaceholder*/ ctx[9] && create_if_block_1$7(ctx);
    	let if_block1 = /*caption*/ ctx[6] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			figure = element("figure");
    			div = element("div");
    			create_component(skeleton.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", div_class_value = /*classes*/ ctx[11].imageWrapper);
    			add_location(div, file$d, 35, 2, 1597);
    			attr_dev(figure, "class", figure_class_value = /*classes*/ ctx[11].figure);
    			add_location(figure, file$d, 34, 1, 1563);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figure, anchor);
    			append_dev(figure, div);
    			mount_component(skeleton, div, null);
    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(figure, t1);
    			if (if_block1) if_block1.m(figure, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const skeleton_changes = {};
    			if (dirty & /*loader, loaded*/ 384) skeleton_changes.visible = /*loader*/ ctx[7] ? /*loaded*/ ctx[8] : false;

    			if (dirty & /*$$scope, classes, src, alt, $$restProps, element, use*/ 33622067) {
    				skeleton_changes.$$scope = { dirty, ctx };
    			}

    			skeleton.$set(skeleton_changes);

    			if (/*showPlaceholder*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*showPlaceholder*/ 512) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*classes*/ 2048 && div_class_value !== (div_class_value = /*classes*/ ctx[11].imageWrapper)) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (/*caption*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*caption*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$a(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(figure, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*classes*/ 2048 && figure_class_value !== (figure_class_value = /*classes*/ ctx[11].figure)) {
    				attr_dev(figure, "class", figure_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(skeleton.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(skeleton.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figure);
    			destroy_component(skeleton);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(34:0) <Box class={cx(className, classes.root, getStyles({ css: override }))}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let box;
    	let current;

    	box = new Box$1({
    			props: {
    				class: /*cx*/ ctx[12](/*className*/ ctx[3], /*classes*/ ctx[11].root, /*getStyles*/ ctx[10]({ css: /*override*/ ctx[2] })),
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = {};
    			if (dirty & /*cx, className, classes, getStyles, override*/ 7180) box_changes.class = /*cx*/ ctx[12](/*className*/ ctx[3], /*classes*/ ctx[11].root, /*getStyles*/ ctx[10]({ css: /*override*/ ctx[2] }));

    			if (dirty & /*$$scope, classes, caption, alt, showPlaceholder, loader, loaded, src, $$restProps, element, use*/ 33623027) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","override","radius","class","src","alt","fit","width","height","caption","usePlaceholder","loader"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Image', slots, ['placeholder']);
    	let { use = [], element = undefined, override = {}, radius = 0, class: className = '', src = undefined, alt = '', fit = 'cover', width = '100%', height = 'auto', caption = undefined, usePlaceholder = false, loader = false } = $$props;
    	const forwardEvents = createEventForwarder(get_current_component());
    	let loaded = false;
    	let error = false;
    	let showPlaceholder = false;
    	const onLoad = () => $$invalidate(8, loaded = true);
    	const onError = () => $$invalidate(22, error = true);

    	function img_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('override' in $$new_props) $$invalidate(2, override = $$new_props.override);
    		if ('radius' in $$new_props) $$invalidate(17, radius = $$new_props.radius);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('src' in $$new_props) $$invalidate(4, src = $$new_props.src);
    		if ('alt' in $$new_props) $$invalidate(5, alt = $$new_props.alt);
    		if ('fit' in $$new_props) $$invalidate(18, fit = $$new_props.fit);
    		if ('width' in $$new_props) $$invalidate(19, width = $$new_props.width);
    		if ('height' in $$new_props) $$invalidate(20, height = $$new_props.height);
    		if ('caption' in $$new_props) $$invalidate(6, caption = $$new_props.caption);
    		if ('usePlaceholder' in $$new_props) $$invalidate(21, usePlaceholder = $$new_props.usePlaceholder);
    		if ('loader' in $$new_props) $$invalidate(7, loader = $$new_props.loader);
    		if ('$$scope' in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		Box: Box$1,
    		Skeleton: Skeleton$1,
    		Text: Text$1,
    		useStyles: useStyles$4,
    		ImageIcon: ImageIcon$1,
    		use,
    		element,
    		override,
    		radius,
    		className,
    		src,
    		alt,
    		fit,
    		width,
    		height,
    		caption,
    		usePlaceholder,
    		loader,
    		forwardEvents,
    		loaded,
    		error,
    		showPlaceholder,
    		onLoad,
    		onError,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('override' in $$props) $$invalidate(2, override = $$new_props.override);
    		if ('radius' in $$props) $$invalidate(17, radius = $$new_props.radius);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('src' in $$props) $$invalidate(4, src = $$new_props.src);
    		if ('alt' in $$props) $$invalidate(5, alt = $$new_props.alt);
    		if ('fit' in $$props) $$invalidate(18, fit = $$new_props.fit);
    		if ('width' in $$props) $$invalidate(19, width = $$new_props.width);
    		if ('height' in $$props) $$invalidate(20, height = $$new_props.height);
    		if ('caption' in $$props) $$invalidate(6, caption = $$new_props.caption);
    		if ('usePlaceholder' in $$props) $$invalidate(21, usePlaceholder = $$new_props.usePlaceholder);
    		if ('loader' in $$props) $$invalidate(7, loader = $$new_props.loader);
    		if ('loaded' in $$props) $$invalidate(8, loaded = $$new_props.loaded);
    		if ('error' in $$props) $$invalidate(22, error = $$new_props.error);
    		if ('showPlaceholder' in $$props) $$invalidate(9, showPlaceholder = $$new_props.showPlaceholder);
    		if ('getStyles' in $$props) $$invalidate(10, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(11, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(12, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*usePlaceholder, loaded, error*/ 6291712) {
    			$$invalidate(9, showPlaceholder = usePlaceholder && (!loaded || error));
    		}

    		if ($$self.$$.dirty & /*radius, fit, height, width*/ 1966080) {
    			$$invalidate(12, { cx, classes, getStyles } = useStyles$4({ radius, fit, height, width }, { name: 'Image' }), cx, (((($$invalidate(11, classes), $$invalidate(17, radius)), $$invalidate(18, fit)), $$invalidate(20, height)), $$invalidate(19, width)), (((($$invalidate(10, getStyles), $$invalidate(17, radius)), $$invalidate(18, fit)), $$invalidate(20, height)), $$invalidate(19, width)));
    		}
    	};

    	return [
    		element,
    		use,
    		override,
    		className,
    		src,
    		alt,
    		caption,
    		loader,
    		loaded,
    		showPlaceholder,
    		getStyles,
    		classes,
    		cx,
    		forwardEvents,
    		onLoad,
    		onError,
    		$$restProps,
    		radius,
    		fit,
    		width,
    		height,
    		usePlaceholder,
    		error,
    		slots,
    		img_binding,
    		$$scope
    	];
    }

    let Image$1 = class Image extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			use: 1,
    			element: 0,
    			override: 2,
    			radius: 17,
    			class: 3,
    			src: 4,
    			alt: 5,
    			fit: 18,
    			width: 19,
    			height: 20,
    			caption: 6,
    			usePlaceholder: 21,
    			loader: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Image",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get use() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get src() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set src(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get alt() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set alt(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fit() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fit(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caption() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caption(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get usePlaceholder() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usePlaceholder(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loader() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loader(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    var Image$2 = Image$1;

    const sizes$1 = {
        xs: 30,
        sm: 36,
        md: 42,
        lg: 50,
        xl: 60
    };
    var useStyles$3 = createStyles((theme, { icon, iconWidth, invalid, multiline, radius, rightSectionWidth, size, resize, variant, showRightSection }) => {
        return {
            root: {
                darkMode: {
                    '&:disabled': {
                        backgroundColor: theme.fn.themeColor('dark', 6)
                    },
                    '&::placeholder': {
                        color: theme.fn.themeColor('dark', 3)
                    }
                },
                position: 'relative'
            },
            input: variant !== 'headless'
                ? {
                    height: multiline
                        ? 'auto'
                        : typeof size === 'number'
                            ? `${size}px`
                            : sizes$1[size] ?? sizes$1.md,
                    WebkitTapHighlightColor: 'transparent',
                    lineHeight: multiline ? '$md' : `${sizes$1[size] - 2}px`,
                    appearance: 'none',
                    resize,
                    boxSizing: 'border-box',
                    fontSize: typeof size === 'number' ? `${size}px` : `${size}`,
                    width: '100%',
                    color: 'Black',
                    display: 'block',
                    textAlign: 'left',
                    minHeight: variant === 'default' || variant === 'filled' ? sizes$1[size] ?? sizes$1.md : null,
                    paddingLeft: (variant === 'default' && icon) || (variant === 'filled' && icon)
                        ? sizes$1[size] ?? sizes$1.md / 3
                        : 12,
                    paddingRight: variant === 'default' || variant === 'filled'
                        ? showRightSection
                            ? rightSectionWidth
                            : null
                        : null,
                    borderRadius: variant === 'default' || variant === 'filled' ? `$${radius}` : null,
                    '&:disabled': {
                        backgroundColor: theme.fn.themeColor('gray', 1),
                        color: theme.fn.themeColor('dark', 2),
                        opacity: 0.6,
                        cursor: 'not-allowed',
                        '&::placeholder': {
                            color: theme.fn.themeColor('dark', 2)
                        }
                    },
                    '&::placeholder': {
                        opacity: 1,
                        userSelect: 'none',
                        color: theme.fn.themeColor('gray', 5)
                    },
                    '&::-webkit-inner-spin-button, &::-webkit-outer-spin-button, &::-webkit-search-decoration, &::-webkit-search-cancel-button, &::-webkit-search-results-button, &::-webkit-search-results-decoration': {
                        appearance: 'none'
                    },
                    '&[type=number]': {
                        MozAppearance: 'textfield'
                    },
                    darkMode: {
                        color: theme.fn.themeColor('dark', 0)
                    }
                }
                : {},
            defaultVariant: {
                border: `1px solid ${theme.fn.themeColor('gray', 4)}`,
                backgroundColor: 'White',
                transition: 'border-color 100ms ease',
                minHeight: sizes$1[size] ?? sizes$1.md,
                '&:focus, &:focus-within': {
                    outline: 'none',
                    borderColor: theme.fn.themeColor('blue', 5)
                },
                darkMode: {
                    border: `1px solid ${theme.fn.themeColor('dark', 5)}`,
                    backgroundColor: theme.fn.themeColor('dark', 8),
                    '&:focus, &:focus-within': {
                        borderColor: theme.fn.themeColor('blue', 8)
                    }
                }
            },
            filledVariant: {
                border: '1px solid transparent',
                backgroundColor: theme.fn.themeColor('gray', 1),
                minHeight: sizes$1[size] ?? sizes$1.md,
                '&:focus, &:focus-within': {
                    outline: 'none',
                    borderColor: `${theme.fn.themeColor('blue', 5)} !important`
                },
                darkMode: {
                    backgroundColor: theme.fn.themeColor('dark', 5),
                    '&:focus, &:focus-within': {
                        borderColor: `${theme.fn.themeColor('blue', 8)} !important`
                    }
                }
            },
            unstyledVariant: {
                height: multiline ? undefined : 'auto',
                borderWidth: 0,
                color: 'Black',
                backgroundColor: 'transparent',
                minHeight: 28,
                outline: 0,
                '&:focus, &:focus-within': {
                    outline: 'none',
                    borderColor: 'transparent'
                },
                '&:disabled': {
                    backgroundColor: 'transparent',
                    '&:focus, &:focus-within': {
                        outline: 'none',
                        borderColor: 'transparent'
                    }
                }
            },
            withIcon: {
                paddingLeft: typeof iconWidth === 'number' ? `${iconWidth}px` : sizes$1[size] ?? sizes$1.md
            },
            disabled: {
                backgroundColor: theme.fn.themeColor('gray', 1),
                color: theme.fn.themeColor('dark', 2),
                opacity: 0.6,
                cursor: 'not-allowed',
                '&::placeholder': {
                    color: theme.fn.themeColor('dark', 2)
                },
                darkMode: {
                    backgroundColor: theme.fn.themeColor('dark', 6),
                    borderColor: theme.fn.themeColor('dark', 4)
                }
            },
            invalid: {
                color: theme.fn.themeColor('red', 7),
                borderColor: theme.fn.themeColor('red', 7),
                '&::placeholder': {
                    opacity: 1,
                    color: theme.fn.themeColor('red', 7)
                },
                darkMode: {
                    color: theme.fn.themeColor('red', 6),
                    borderColor: theme.fn.themeColor('red', 6),
                    '&::placeholder': {
                        color: theme.fn.themeColor('red', 6)
                    }
                }
            },
            icon: {
                pointerEvents: 'none',
                position: 'absolute',
                zIndex: 1,
                left: 0,
                top: 0,
                bottom: 0,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                width: iconWidth ? `${iconWidth}px` : sizes$1[size] ?? sizes$1.md,
                color: invalid ? theme.fn.themeColor('red', 7) : theme.fn.themeColor('gray', 5),
                darkMode: {
                    color: invalid ? theme.fn.themeColor('red', 6) : theme.fn.themeColor('dark', 2)
                }
            },
            rightSection: {
                position: 'absolute',
                top: 0,
                bottom: 0,
                right: 0,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                width: rightSectionWidth
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Input/Input.svelte generated by Svelte v3.59.2 */
    const file$c = "node_modules/@svelteuidev/core/dist/components/Input/Input.svelte";
    const get_rightSection_slot_changes$2 = dirty => ({});
    const get_rightSection_slot_context$2 = ctx => ({});

    // (76:1) {#if icon}
    function create_if_block_4$1(ctx) {
    	let div;
    	let iconrenderer;
    	let div_class_value;
    	let current;

    	iconrenderer = new IconRenderer$1({
    			props: {
    				icon: /*icon*/ ctx[6],
    				iconProps: /*iconProps*/ ctx[7],
    				iconSize: 16
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(iconrenderer.$$.fragment);
    			attr_dev(div, "class", div_class_value = /*classes*/ ctx[23].icon);
    			add_location(div, file$c, 76, 2, 2638);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(iconrenderer, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const iconrenderer_changes = {};
    			if (dirty[0] & /*icon*/ 64) iconrenderer_changes.icon = /*icon*/ ctx[6];
    			if (dirty[0] & /*iconProps*/ 128) iconrenderer_changes.iconProps = /*iconProps*/ ctx[7];
    			iconrenderer.$set(iconrenderer_changes);

    			if (!current || dirty[0] & /*classes*/ 8388608 && div_class_value !== (div_class_value = /*classes*/ ctx[23].icon)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconrenderer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconrenderer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(iconrenderer);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(76:1) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (137:51) 
    function create_if_block_3$1(ctx) {
    	let switch_instance;
    	let updating_element;
    	let updating_value;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[25], [useActions, /*use*/ ctx[2]]]
    		},
    		{ "aria-invalid": /*invalid*/ ctx[15] },
    		{
    			class: /*cx*/ ctx[24](
    				/*className*/ ctx[3],
    				{
    					[/*classes*/ ctx[23].disabled]: /*disabled*/ ctx[14],
    					[/*classes*/ ctx[23].invalid]: /*invalid*/ ctx[15],
    					[/*classes*/ ctx[23].withIcon]: /*icon*/ ctx[6]
    				},
    				/*classes*/ ctx[23][`${/*variant*/ ctx[13]}Variant`] ?? {}
    			)
    		},
    		{ disabled: /*disabled*/ ctx[14] },
    		{ required: /*required*/ ctx[12] },
    		{ id: /*id*/ ctx[11] },
    		{ type: /*type*/ ctx[17] },
    		{ autofocus: /*autofocus*/ ctx[19] },
    		/*$$restProps*/ ctx[29]
    	];

    	function switch_instance_element_binding(value) {
    		/*switch_instance_element_binding*/ ctx[39](value);
    	}

    	function switch_instance_value_binding(value) {
    		/*switch_instance_value_binding*/ ctx[40](value);
    	}

    	var switch_value = /*root*/ ctx[5];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot_1$8] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		if (/*element*/ ctx[0] !== void 0) {
    			switch_instance_props.element = /*element*/ ctx[0];
    		}

    		if (/*value*/ ctx[1] !== void 0) {
    			switch_instance_props.value = /*value*/ ctx[1];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'element', switch_instance_element_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*forwardEvents, use, invalid, cx, className, classes, disabled, icon, variant, required, id, type, autofocus, $$restProps*/ 596310092)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty[0] & /*forwardEvents, use*/ 33554436 && {
    						use: [/*forwardEvents*/ ctx[25], [useActions, /*use*/ ctx[2]]]
    					},
    					dirty[0] & /*invalid*/ 32768 && { "aria-invalid": /*invalid*/ ctx[15] },
    					dirty[0] & /*cx, className, classes, disabled, invalid, icon, variant*/ 25223240 && {
    						class: /*cx*/ ctx[24](
    							/*className*/ ctx[3],
    							{
    								[/*classes*/ ctx[23].disabled]: /*disabled*/ ctx[14],
    								[/*classes*/ ctx[23].invalid]: /*invalid*/ ctx[15],
    								[/*classes*/ ctx[23].withIcon]: /*icon*/ ctx[6]
    							},
    							/*classes*/ ctx[23][`${/*variant*/ ctx[13]}Variant`] ?? {}
    						)
    					},
    					dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
    					dirty[0] & /*required*/ 4096 && { required: /*required*/ ctx[12] },
    					dirty[0] & /*id*/ 2048 && { id: /*id*/ ctx[11] },
    					dirty[0] & /*type*/ 131072 && { type: /*type*/ ctx[17] },
    					dirty[0] & /*autofocus*/ 524288 && { autofocus: /*autofocus*/ ctx[19] },
    					dirty[0] & /*$$restProps*/ 536870912 && get_spread_object(/*$$restProps*/ ctx[29])
    				])
    			: {};

    			if (dirty[1] & /*$$scope*/ 1024) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty[0] & /*element*/ 1) {
    				updating_element = true;
    				switch_instance_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			if (!updating_value && dirty[0] & /*value*/ 2) {
    				updating_value = true;
    				switch_instance_changes.value = /*value*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (dirty[0] & /*root*/ 32 && switch_value !== (switch_value = /*root*/ ctx[5])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'element', switch_instance_element_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(137:51) ",
    		ctx
    	});

    	return block;
    }

    // (105:50) 
    function create_if_block_2$3(ctx) {
    	let current;
    	validate_dynamic_element(/*castRoot*/ ctx[26]());
    	validate_void_dynamic_element(/*castRoot*/ ctx[26]());
    	let svelte_element = /*castRoot*/ ctx[26]() && create_dynamic_element(ctx);

    	const block = {
    		c: function create() {
    			if (svelte_element) svelte_element.c();
    		},
    		m: function mount(target, anchor) {
    			if (svelte_element) svelte_element.m(target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*castRoot*/ ctx[26]()) {
    				svelte_element.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svelte_element);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svelte_element);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (svelte_element) svelte_element.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(105:50) ",
    		ctx
    	});

    	return block;
    }

    // (81:1) {#if isHTMLElement && root === 'input'}
    function create_if_block_1$6(ctx) {
    	let input;
    	let input_class_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{ value: /*value*/ ctx[1] },
    		{ type: /*type*/ ctx[17] },
    		{ required: /*required*/ ctx[12] },
    		{ disabled: /*disabled*/ ctx[14] },
    		{ id: /*id*/ ctx[11] },
    		{ placeholder: /*placeholder*/ ctx[18] },
    		{ autocomplete: /*autocomplete*/ ctx[16] },
    		{ autofocus: /*autofocus*/ ctx[19] },
    		{ "aria-invalid": /*invalid*/ ctx[15] },
    		{
    			class: input_class_value = /*cx*/ ctx[24](
    				/*className*/ ctx[3],
    				/*classes*/ ctx[23].input,
    				{
    					[/*classes*/ ctx[23].disabled]: /*disabled*/ ctx[14],
    					[/*classes*/ ctx[23].invalid]: /*invalid*/ ctx[15]
    				},
    				/*classes*/ ctx[23][`${/*variant*/ ctx[13]}Variant`] ?? {}
    			)
    		},
    		/*$$restProps*/ ctx[29]
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			toggle_class(input, "withIcon", /*icon*/ ctx[6]);
    			add_location(input, file$c, 81, 2, 2777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);

    			if ('value' in input_data) {
    				input.value = input_data.value;
    			}

    			if (input.autofocus) input.focus();
    			/*input_binding*/ ctx[37](input);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, input, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[25].call(null, input)),
    					listen_dev(input, "input", /*onInput*/ ctx[28], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1] && { value: /*value*/ ctx[1] },
    				dirty[0] & /*type*/ 131072 && { type: /*type*/ ctx[17] },
    				dirty[0] & /*required*/ 4096 && { required: /*required*/ ctx[12] },
    				dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
    				dirty[0] & /*id*/ 2048 && { id: /*id*/ ctx[11] },
    				dirty[0] & /*placeholder*/ 262144 && { placeholder: /*placeholder*/ ctx[18] },
    				dirty[0] & /*autocomplete*/ 65536 && { autocomplete: /*autocomplete*/ ctx[16] },
    				dirty[0] & /*autofocus*/ 524288 && { autofocus: /*autofocus*/ ctx[19] },
    				dirty[0] & /*invalid*/ 32768 && { "aria-invalid": /*invalid*/ ctx[15] },
    				dirty[0] & /*cx, className, classes, disabled, invalid, variant*/ 25223176 && input_class_value !== (input_class_value = /*cx*/ ctx[24](
    					/*className*/ ctx[3],
    					/*classes*/ ctx[23].input,
    					{
    						[/*classes*/ ctx[23].disabled]: /*disabled*/ ctx[14],
    						[/*classes*/ ctx[23].invalid]: /*invalid*/ ctx[15]
    					},
    					/*classes*/ ctx[23][`${/*variant*/ ctx[13]}Variant`] ?? {}
    				)) && { class: input_class_value },
    				dirty[0] & /*$$restProps*/ 536870912 && /*$$restProps*/ ctx[29]
    			]));

    			if ('value' in input_data) {
    				input.value = input_data.value;
    			}

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    			toggle_class(input, "withIcon", /*icon*/ ctx[6]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[37](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(81:1) {#if isHTMLElement && root === 'input'}",
    		ctx
    	});

    	return block;
    }

    // (138:2) <svelte:component    this={root}    bind:element    bind:value    use={[forwardEvents, [useActions, use]]}    aria-invalid={invalid}    class={cx(     className,     {      [classes.disabled]: disabled,      [classes.invalid]: invalid,      [classes.withIcon]: icon     },     classes[`${variant}Variant`] ?? {}    )}    {disabled}    {required}    {id}    {type}    {autofocus}    {...$$restProps}   >
    function create_default_slot_1$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[36].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[41], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[41],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[41])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[41], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(138:2) <svelte:component    this={root}    bind:element    bind:value    use={[forwardEvents, [useActions, use]]}    aria-invalid={invalid}    class={cx(     className,     {      [classes.disabled]: disabled,      [classes.invalid]: invalid,      [classes.withIcon]: icon     },     classes[`${variant}Variant`] ?? {}    )}    {disabled}    {required}    {id}    {type}    {autofocus}    {...$$restProps}   >",
    		ctx
    	});

    	return block;
    }

    // (109:2) <svelte:element    this={castRoot()}    bind:this={element}    {value}    {required}    {disabled}    {id}    {placeholder}    {autocomplete}    {type}    {autofocus}    aria-invalid={invalid}    class:disabled    class:invalid    class:withIcon={icon}    class={cx(     className,     classes.input,     { [classes.disabled]: disabled, [classes.invalid]: invalid },     classes[`${variant}Variant`] ?? {}    )}    on:change={onChange}    use:useActions={use}    use:forwardEvents    {...$$restProps}   >
    function create_dynamic_element(ctx) {
    	let svelte_element;
    	let svelte_element_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[36].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[41], null);

    	let svelte_element_levels = [
    		{ value: /*value*/ ctx[1] },
    		{ required: /*required*/ ctx[12] },
    		{ disabled: /*disabled*/ ctx[14] },
    		{ id: /*id*/ ctx[11] },
    		{ placeholder: /*placeholder*/ ctx[18] },
    		{ autocomplete: /*autocomplete*/ ctx[16] },
    		{ type: /*type*/ ctx[17] },
    		{ autofocus: /*autofocus*/ ctx[19] },
    		{ "aria-invalid": /*invalid*/ ctx[15] },
    		{
    			class: svelte_element_class_value = /*cx*/ ctx[24](
    				/*className*/ ctx[3],
    				/*classes*/ ctx[23].input,
    				{
    					[/*classes*/ ctx[23].disabled]: /*disabled*/ ctx[14],
    					[/*classes*/ ctx[23].invalid]: /*invalid*/ ctx[15]
    				},
    				/*classes*/ ctx[23][`${/*variant*/ ctx[13]}Variant`] ?? {}
    			)
    		},
    		/*$$restProps*/ ctx[29]
    	];

    	let svelte_element_data = {};

    	for (let i = 0; i < svelte_element_levels.length; i += 1) {
    		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svelte_element = element(/*castRoot*/ ctx[26]());
    			if (default_slot) default_slot.c();
    			set_dynamic_element_data(/*castRoot*/ ctx[26]())(svelte_element, svelte_element_data);
    			toggle_class(svelte_element, "disabled", /*disabled*/ ctx[14]);
    			toggle_class(svelte_element, "invalid", /*invalid*/ ctx[15]);
    			toggle_class(svelte_element, "withIcon", /*icon*/ ctx[6]);
    			add_location(svelte_element, file$c, 108, 2, 3453);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_element, anchor);

    			if (default_slot) {
    				default_slot.m(svelte_element, null);
    			}

    			/*svelte_element_binding*/ ctx[38](svelte_element);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svelte_element, "change", /*onChange*/ ctx[27], false, false, false, false),
    					action_destroyer(useActions_action = useActions.call(null, svelte_element, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[25].call(null, svelte_element))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[41],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[41])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[41], dirty, null),
    						null
    					);
    				}
    			}

    			set_dynamic_element_data(/*castRoot*/ ctx[26]())(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
    				(!current || dirty[0] & /*value*/ 2) && { value: /*value*/ ctx[1] },
    				(!current || dirty[0] & /*required*/ 4096) && { required: /*required*/ ctx[12] },
    				(!current || dirty[0] & /*disabled*/ 16384) && { disabled: /*disabled*/ ctx[14] },
    				(!current || dirty[0] & /*id*/ 2048) && { id: /*id*/ ctx[11] },
    				(!current || dirty[0] & /*placeholder*/ 262144) && { placeholder: /*placeholder*/ ctx[18] },
    				(!current || dirty[0] & /*autocomplete*/ 65536) && { autocomplete: /*autocomplete*/ ctx[16] },
    				(!current || dirty[0] & /*type*/ 131072) && { type: /*type*/ ctx[17] },
    				(!current || dirty[0] & /*autofocus*/ 524288) && { autofocus: /*autofocus*/ ctx[19] },
    				(!current || dirty[0] & /*invalid*/ 32768) && { "aria-invalid": /*invalid*/ ctx[15] },
    				(!current || dirty[0] & /*cx, className, classes, disabled, invalid, variant*/ 25223176 && svelte_element_class_value !== (svelte_element_class_value = /*cx*/ ctx[24](
    					/*className*/ ctx[3],
    					/*classes*/ ctx[23].input,
    					{
    						[/*classes*/ ctx[23].disabled]: /*disabled*/ ctx[14],
    						[/*classes*/ ctx[23].invalid]: /*invalid*/ ctx[15]
    					},
    					/*classes*/ ctx[23][`${/*variant*/ ctx[13]}Variant`] ?? {}
    				))) && { class: svelte_element_class_value },
    				dirty[0] & /*$$restProps*/ 536870912 && /*$$restProps*/ ctx[29]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    			toggle_class(svelte_element, "disabled", /*disabled*/ ctx[14]);
    			toggle_class(svelte_element, "invalid", /*invalid*/ ctx[15]);
    			toggle_class(svelte_element, "withIcon", /*icon*/ ctx[6]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_element);
    			if (default_slot) default_slot.d(detaching);
    			/*svelte_element_binding*/ ctx[38](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_dynamic_element.name,
    		type: "child_dynamic_element",
    		source: "(109:2) <svelte:element    this={castRoot()}    bind:this={element}    {value}    {required}    {disabled}    {id}    {placeholder}    {autocomplete}    {type}    {autofocus}    aria-invalid={invalid}    class:disabled    class:invalid    class:withIcon={icon}    class={cx(     className,     classes.input,     { [classes.disabled]: disabled, [classes.invalid]: invalid },     classes[`${variant}Variant`] ?? {}    )}    on:change={onChange}    use:useActions={use}    use:forwardEvents    {...$$restProps}   >",
    		ctx
    	});

    	return block;
    }

    // (163:1) {#if showRightSection}
    function create_if_block$9(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const rightSection_slot_template = /*#slots*/ ctx[36].rightSection;
    	const rightSection_slot = create_slot(rightSection_slot_template, ctx, /*$$scope*/ ctx[41], get_rightSection_slot_context$2);

    	let div_levels = [
    		/*rightSectionProps*/ ctx[9],
    		{
    			class: div_class_value = /*classes*/ ctx[23].rightSection
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (rightSection_slot) rightSection_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$c, 163, 2, 4514);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (rightSection_slot) {
    				rightSection_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (rightSection_slot) {
    				if (rightSection_slot.p && (!current || dirty[1] & /*$$scope*/ 1024)) {
    					update_slot_base(
    						rightSection_slot,
    						rightSection_slot_template,
    						ctx,
    						/*$$scope*/ ctx[41],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[41])
    						: get_slot_changes(rightSection_slot_template, /*$$scope*/ ctx[41], dirty, get_rightSection_slot_changes$2),
    						get_rightSection_slot_context$2
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty[0] & /*rightSectionProps*/ 512 && /*rightSectionProps*/ ctx[9],
    				(!current || dirty[0] & /*classes*/ 8388608 && div_class_value !== (div_class_value = /*classes*/ ctx[23].rightSection)) && { class: div_class_value }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rightSection_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rightSection_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (rightSection_slot) rightSection_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(163:1) {#if showRightSection}",
    		ctx
    	});

    	return block;
    }

    // (75:0) <Box {...wrapperProps} class={cx(classes.root, getStyles({ css: override }))} {...$$restProps}>
    function create_default_slot$d(ctx) {
    	let t0;
    	let show_if;
    	let current_block_type_index;
    	let if_block1;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*icon*/ ctx[6] && create_if_block_4$1(ctx);
    	const if_block_creators = [create_if_block_1$6, create_if_block_2$3, create_if_block_3$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*isHTMLElement, root*/ 1048608) show_if = null;
    		if (/*isHTMLElement*/ ctx[20] && /*root*/ ctx[5] === 'input') return 0;
    		if (show_if == null) show_if = !!(/*isHTMLElement*/ ctx[20] && isInput(String(/*root*/ ctx[5])));
    		if (show_if) return 1;
    		if (/*isComponent*/ ctx[21] && typeof /*root*/ ctx[5] !== 'string') return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let if_block2 = /*showRightSection*/ ctx[8] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[6]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 64) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];

    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					} else {
    						if_block1.p(ctx, dirty);
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				} else {
    					if_block1 = null;
    				}
    			}

    			if (/*showRightSection*/ ctx[8]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*showRightSection*/ 256) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$9(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(75:0) <Box {...wrapperProps} class={cx(classes.root, getStyles({ css: override }))} {...$$restProps}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let box;
    	let current;

    	const box_spread_levels = [
    		/*wrapperProps*/ ctx[10],
    		{
    			class: /*cx*/ ctx[24](/*classes*/ ctx[23].root, /*getStyles*/ ctx[22]({ css: /*override*/ ctx[4] }))
    		},
    		/*$$restProps*/ ctx[29]
    	];

    	let box_props = {
    		$$slots: { default: [create_default_slot$d] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	box = new Box$1({ props: box_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const box_changes = (dirty[0] & /*wrapperProps, cx, classes, getStyles, override, $$restProps*/ 566232080)
    			? get_spread_update(box_spread_levels, [
    					dirty[0] & /*wrapperProps*/ 1024 && get_spread_object(/*wrapperProps*/ ctx[10]),
    					dirty[0] & /*cx, classes, getStyles, override*/ 29360144 && {
    						class: /*cx*/ ctx[24](/*classes*/ ctx[23].root, /*getStyles*/ ctx[22]({ css: /*override*/ ctx[4] }))
    					},
    					dirty[0] & /*$$restProps*/ 536870912 && get_spread_object(/*$$restProps*/ ctx[29])
    				])
    			: {};

    			if (dirty[0] & /*rightSectionProps, classes, showRightSection, value, type, required, disabled, id, placeholder, autocomplete, autofocus, invalid, cx, className, variant, $$restProps, element, use, icon, isHTMLElement, root, isComponent, iconProps*/ 566229999 | dirty[1] & /*$$scope*/ 1024) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isInput(root) {
    	return ['input', 'select', 'textarea', 'datalist'].includes(root);
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","root","icon","iconWidth","iconProps","showRightSection","rightSectionWidth","rightSectionProps","wrapperProps","id","required","radius","variant","disabled","size","value","invalid","multiline","autocomplete","type","placeholder","autofocus","resize"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Input', slots, ['default','rightSection']);
    	const $$slots = compute_slots(slots);
    	let { use = [], element = undefined, class: className = '', override = {}, root = 'input', icon = null, iconWidth = 36, iconProps = { size: 20, color: 'currentColor' }, showRightSection = $$slots.rightSection, rightSectionWidth = 36, rightSectionProps = {}, wrapperProps = {}, id = 'input-id', required = false, radius = 'sm', variant = 'default', disabled = false, size = 'sm', value = '', invalid = false, multiline = false, autocomplete = 'on', type = 'text', placeholder = undefined, autofocus = undefined, resize = 'none' } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	function castRoot() {
    		return root;
    	}

    	let isHTMLElement = true;
    	let isComponent = false;

    	function onChange() {
    		// the 'this' keyword in this case is the
    		// HTML element provided in prop 'root'
    		$$invalidate(1, value = this.value);
    	}

    	function onInput(event) {
    		if (event.target.type === 'checkbox') {
    			$$invalidate(1, value = event.target.checked);
    		} else if (event.target.type === 'number' || event.target.type === 'range') {
    			$$invalidate(1, value = +event.target.value);
    		} else {
    			$$invalidate(1, value = event.target.value);
    		}
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	function svelte_element_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	function switch_instance_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	function switch_instance_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(1, value);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(4, override = $$new_props.override);
    		if ('root' in $$new_props) $$invalidate(5, root = $$new_props.root);
    		if ('icon' in $$new_props) $$invalidate(6, icon = $$new_props.icon);
    		if ('iconWidth' in $$new_props) $$invalidate(30, iconWidth = $$new_props.iconWidth);
    		if ('iconProps' in $$new_props) $$invalidate(7, iconProps = $$new_props.iconProps);
    		if ('showRightSection' in $$new_props) $$invalidate(8, showRightSection = $$new_props.showRightSection);
    		if ('rightSectionWidth' in $$new_props) $$invalidate(31, rightSectionWidth = $$new_props.rightSectionWidth);
    		if ('rightSectionProps' in $$new_props) $$invalidate(9, rightSectionProps = $$new_props.rightSectionProps);
    		if ('wrapperProps' in $$new_props) $$invalidate(10, wrapperProps = $$new_props.wrapperProps);
    		if ('id' in $$new_props) $$invalidate(11, id = $$new_props.id);
    		if ('required' in $$new_props) $$invalidate(12, required = $$new_props.required);
    		if ('radius' in $$new_props) $$invalidate(32, radius = $$new_props.radius);
    		if ('variant' in $$new_props) $$invalidate(13, variant = $$new_props.variant);
    		if ('disabled' in $$new_props) $$invalidate(14, disabled = $$new_props.disabled);
    		if ('size' in $$new_props) $$invalidate(33, size = $$new_props.size);
    		if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
    		if ('invalid' in $$new_props) $$invalidate(15, invalid = $$new_props.invalid);
    		if ('multiline' in $$new_props) $$invalidate(34, multiline = $$new_props.multiline);
    		if ('autocomplete' in $$new_props) $$invalidate(16, autocomplete = $$new_props.autocomplete);
    		if ('type' in $$new_props) $$invalidate(17, type = $$new_props.type);
    		if ('placeholder' in $$new_props) $$invalidate(18, placeholder = $$new_props.placeholder);
    		if ('autofocus' in $$new_props) $$invalidate(19, autofocus = $$new_props.autofocus);
    		if ('resize' in $$new_props) $$invalidate(35, resize = $$new_props.resize);
    		if ('$$scope' in $$new_props) $$invalidate(41, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		Box: Box$1,
    		IconRenderer: IconRenderer$1,
    		useStyles: useStyles$3,
    		use,
    		element,
    		className,
    		override,
    		root,
    		icon,
    		iconWidth,
    		iconProps,
    		showRightSection,
    		rightSectionWidth,
    		rightSectionProps,
    		wrapperProps,
    		id,
    		required,
    		radius,
    		variant,
    		disabled,
    		size,
    		value,
    		invalid,
    		multiline,
    		autocomplete,
    		type,
    		placeholder,
    		autofocus,
    		resize,
    		forwardEvents,
    		castRoot,
    		isInput,
    		isHTMLElement,
    		isComponent,
    		onChange,
    		onInput,
    		getStyles,
    		classes,
    		cx
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(4, override = $$new_props.override);
    		if ('root' in $$props) $$invalidate(5, root = $$new_props.root);
    		if ('icon' in $$props) $$invalidate(6, icon = $$new_props.icon);
    		if ('iconWidth' in $$props) $$invalidate(30, iconWidth = $$new_props.iconWidth);
    		if ('iconProps' in $$props) $$invalidate(7, iconProps = $$new_props.iconProps);
    		if ('showRightSection' in $$props) $$invalidate(8, showRightSection = $$new_props.showRightSection);
    		if ('rightSectionWidth' in $$props) $$invalidate(31, rightSectionWidth = $$new_props.rightSectionWidth);
    		if ('rightSectionProps' in $$props) $$invalidate(9, rightSectionProps = $$new_props.rightSectionProps);
    		if ('wrapperProps' in $$props) $$invalidate(10, wrapperProps = $$new_props.wrapperProps);
    		if ('id' in $$props) $$invalidate(11, id = $$new_props.id);
    		if ('required' in $$props) $$invalidate(12, required = $$new_props.required);
    		if ('radius' in $$props) $$invalidate(32, radius = $$new_props.radius);
    		if ('variant' in $$props) $$invalidate(13, variant = $$new_props.variant);
    		if ('disabled' in $$props) $$invalidate(14, disabled = $$new_props.disabled);
    		if ('size' in $$props) $$invalidate(33, size = $$new_props.size);
    		if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
    		if ('invalid' in $$props) $$invalidate(15, invalid = $$new_props.invalid);
    		if ('multiline' in $$props) $$invalidate(34, multiline = $$new_props.multiline);
    		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$new_props.autocomplete);
    		if ('type' in $$props) $$invalidate(17, type = $$new_props.type);
    		if ('placeholder' in $$props) $$invalidate(18, placeholder = $$new_props.placeholder);
    		if ('autofocus' in $$props) $$invalidate(19, autofocus = $$new_props.autofocus);
    		if ('resize' in $$props) $$invalidate(35, resize = $$new_props.resize);
    		if ('isHTMLElement' in $$props) $$invalidate(20, isHTMLElement = $$new_props.isHTMLElement);
    		if ('isComponent' in $$props) $$invalidate(21, isComponent = $$new_props.isComponent);
    		if ('getStyles' in $$props) $$invalidate(22, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(23, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(24, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*root*/ 32) {
    			{
    				$$invalidate(20, isHTMLElement = root && typeof root === 'string');
    				$$invalidate(21, isComponent = root && typeof root === 'function');
    			}
    		}

    		if ($$self.$$.dirty[0] & /*icon, iconWidth, invalid, showRightSection, variant*/ 1073783104 | $$self.$$.dirty[1] & /*multiline, radius, rightSectionWidth, size, resize*/ 31) {
    			$$invalidate(
    				24,
    				{ cx, classes, getStyles } = useStyles$3(
    					{
    						icon,
    						iconWidth,
    						invalid,
    						multiline,
    						radius,
    						rightSectionWidth,
    						showRightSection,
    						size,
    						resize,
    						variant
    					},
    					{ name: 'Input' }
    				),
    				cx,
    				(((((((((($$invalidate(23, classes), $$invalidate(6, icon)), $$invalidate(30, iconWidth)), $$invalidate(15, invalid)), $$invalidate(34, multiline)), $$invalidate(32, radius)), $$invalidate(31, rightSectionWidth)), $$invalidate(8, showRightSection)), $$invalidate(33, size)), $$invalidate(35, resize)), $$invalidate(13, variant)),
    				(((((((((($$invalidate(22, getStyles), $$invalidate(6, icon)), $$invalidate(30, iconWidth)), $$invalidate(15, invalid)), $$invalidate(34, multiline)), $$invalidate(32, radius)), $$invalidate(31, rightSectionWidth)), $$invalidate(8, showRightSection)), $$invalidate(33, size)), $$invalidate(35, resize)), $$invalidate(13, variant))
    			);
    		}
    	};

    	return [
    		element,
    		value,
    		use,
    		className,
    		override,
    		root,
    		icon,
    		iconProps,
    		showRightSection,
    		rightSectionProps,
    		wrapperProps,
    		id,
    		required,
    		variant,
    		disabled,
    		invalid,
    		autocomplete,
    		type,
    		placeholder,
    		autofocus,
    		isHTMLElement,
    		isComponent,
    		getStyles,
    		classes,
    		cx,
    		forwardEvents,
    		castRoot,
    		onChange,
    		onInput,
    		$$restProps,
    		iconWidth,
    		rightSectionWidth,
    		radius,
    		size,
    		multiline,
    		resize,
    		slots,
    		input_binding,
    		svelte_element_binding,
    		switch_instance_element_binding,
    		switch_instance_value_binding,
    		$$scope
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$g,
    			create_fragment$g,
    			safe_not_equal,
    			{
    				use: 2,
    				element: 0,
    				class: 3,
    				override: 4,
    				root: 5,
    				icon: 6,
    				iconWidth: 30,
    				iconProps: 7,
    				showRightSection: 8,
    				rightSectionWidth: 31,
    				rightSectionProps: 9,
    				wrapperProps: 10,
    				id: 11,
    				required: 12,
    				radius: 32,
    				variant: 13,
    				disabled: 14,
    				size: 33,
    				value: 1,
    				invalid: 15,
    				multiline: 34,
    				autocomplete: 16,
    				type: 17,
    				placeholder: 18,
    				autofocus: 19,
    				resize: 35
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get use() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get root() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set root(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconWidth() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconWidth(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconProps() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconProps(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showRightSection() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showRightSection(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rightSectionWidth() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rightSectionWidth(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rightSectionProps() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rightSectionProps(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapperProps() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapperProps(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiline() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiline(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocomplete() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocomplete(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autofocus() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autofocus(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resize() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resize(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Input$1 = Input;

    const elevations = {
        app: 100,
        modal: 200,
        popover: 300,
        overlay: 400
    };
    function getDefaultZIndex(level) {
        return elevations[level];
    }

    /* node_modules/@svelteuidev/core/dist/components/Overlay/Overlay.svelte generated by Svelte v3.59.2 */

    // (52:0) {:else}
    function create_else_block$6(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[10], [useActions, /*use*/ ctx[1]]]
    		},
    		{
    			css: {
    				.../*background*/ ctx[9],
    				.../*baseStyles*/ ctx[8],
    				opacity: /*opacity*/ ctx[4],
    				borderRadius: `${/*radius*/ ctx[6]}`,
    				.../*override*/ ctx[3]
    			}
    		},
    		/*$$restProps*/ ctx[11],
    		{ class: /*className*/ ctx[2] }
    	];

    	function box_element_binding_1(value) {
    		/*box_element_binding_1*/ ctx[17](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot_1$7] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding_1));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const box_changes = (dirty & /*forwardEvents, useActions, use, background, baseStyles, opacity, radius, override, $$restProps, className*/ 3934)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*forwardEvents, useActions, use*/ 1026 && {
    						use: [/*forwardEvents*/ ctx[10], [useActions, /*use*/ ctx[1]]]
    					},
    					dirty & /*background, baseStyles, opacity, radius, override*/ 856 && {
    						css: {
    							.../*background*/ ctx[9],
    							.../*baseStyles*/ ctx[8],
    							opacity: /*opacity*/ ctx[4],
    							borderRadius: `${/*radius*/ ctx[6]}`,
    							.../*override*/ ctx[3]
    						}
    					},
    					dirty & /*$$restProps*/ 2048 && get_spread_object(/*$$restProps*/ ctx[11]),
    					dirty & /*className*/ 4 && { class: /*className*/ ctx[2] }
    				])
    			: {};

    			if (dirty & /*$$scope, center*/ 262272) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(52:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:0) {#if blur}
    function create_if_block$8(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[10], [useActions, /*use*/ ctx[1]]]
    		},
    		{
    			css: {
    				.../*baseStyles*/ ctx[8],
    				backdropFilter: `blur(${/*blur*/ ctx[5]}px)`
    			}
    		},
    		{ class: /*className*/ ctx[2] },
    		/*$$restProps*/ ctx[11]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[16](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$c] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const box_changes = (dirty & /*forwardEvents, useActions, use, baseStyles, blur, className, $$restProps*/ 3366)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*forwardEvents, useActions, use*/ 1026 && {
    						use: [/*forwardEvents*/ ctx[10], [useActions, /*use*/ ctx[1]]]
    					},
    					dirty & /*baseStyles, blur*/ 288 && {
    						css: {
    							.../*baseStyles*/ ctx[8],
    							backdropFilter: `blur(${/*blur*/ ctx[5]}px)`
    						}
    					},
    					dirty & /*className*/ 4 && { class: /*className*/ ctx[2] },
    					dirty & /*$$restProps*/ 2048 && get_spread_object(/*$$restProps*/ ctx[11])
    				])
    			: {};

    			if (dirty & /*$$scope, background, baseStyles, opacity, radius, override*/ 263000) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(42:0) {#if blur}",
    		ctx
    	});

    	return block;
    }

    // (64:2) {:else}
    function create_else_block_1$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(64:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:2) {#if center}
    function create_if_block_1$5(ctx) {
    	let center_1;
    	let current;

    	center_1 = new Center$1({
    			props: {
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(center_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(center_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const center_1_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				center_1_changes.$$scope = { dirty, ctx };
    			}

    			center_1.$set(center_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(center_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(center_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(center_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(60:2) {#if center}",
    		ctx
    	});

    	return block;
    }

    // (61:3) <Center>
    function create_default_slot_2$6(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(61:3) <Center>",
    		ctx
    	});

    	return block;
    }

    // (53:1) <Box   use={[forwardEvents, [useActions, use]]}   bind:element   css={{ ...background, ...baseStyles, opacity, borderRadius: `${radius}`, ...override }}   {...$$restProps}   class={className}  >
    function create_default_slot_1$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$5, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*center*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(53:1) <Box   use={[forwardEvents, [useActions, use]]}   bind:element   css={{ ...background, ...baseStyles, opacity, borderRadius: `${radius}`, ...override }}   {...$$restProps}   class={className}  >",
    		ctx
    	});

    	return block;
    }

    // (43:1) <Box   use={[forwardEvents, [useActions, use]]}   bind:element   css={{ ...baseStyles, backdropFilter: `blur(${blur}px)` }}   class={className}   {...$$restProps}  >
    function create_default_slot$c(ctx) {
    	let box;
    	let current;

    	box = new Box$1({
    			props: {
    				css: {
    					.../*background*/ ctx[9],
    					.../*baseStyles*/ ctx[8],
    					opacity: /*opacity*/ ctx[4],
    					borderRadius: `${/*radius*/ ctx[6]}`,
    					.../*override*/ ctx[3]
    				}
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const box_changes = {};

    			if (dirty & /*background, baseStyles, opacity, radius, override*/ 856) box_changes.css = {
    				.../*background*/ ctx[9],
    				.../*baseStyles*/ ctx[8],
    				opacity: /*opacity*/ ctx[4],
    				borderRadius: `${/*radius*/ ctx[6]}`,
    				.../*override*/ ctx[3]
    			};

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(43:1) <Box   use={[forwardEvents, [useActions, use]]}   bind:element   css={{ ...baseStyles, backdropFilter: `blur(${blur}px)` }}   class={className}   {...$$restProps}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*blur*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let background;
    	let baseStyles;

    	const omit_props_names = [
    		"use","element","class","override","opacity","color","blur","gradient","zIndex","radius","center"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Overlay', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, opacity = 0.6, color = '#fff', blur = 0, gradient = '', zIndex = getDefaultZIndex('modal'), radius = 0, center = false } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	function box_element_binding_1(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('opacity' in $$new_props) $$invalidate(4, opacity = $$new_props.opacity);
    		if ('color' in $$new_props) $$invalidate(12, color = $$new_props.color);
    		if ('blur' in $$new_props) $$invalidate(5, blur = $$new_props.blur);
    		if ('gradient' in $$new_props) $$invalidate(13, gradient = $$new_props.gradient);
    		if ('zIndex' in $$new_props) $$invalidate(14, zIndex = $$new_props.zIndex);
    		if ('radius' in $$new_props) $$invalidate(6, radius = $$new_props.radius);
    		if ('center' in $$new_props) $$invalidate(7, center = $$new_props.center);
    		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		Box: Box$1,
    		Center: Center$1,
    		getDefaultZIndex,
    		use,
    		element,
    		className,
    		override,
    		opacity,
    		color,
    		blur,
    		gradient,
    		zIndex,
    		radius,
    		center,
    		forwardEvents,
    		baseStyles,
    		background
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('opacity' in $$props) $$invalidate(4, opacity = $$new_props.opacity);
    		if ('color' in $$props) $$invalidate(12, color = $$new_props.color);
    		if ('blur' in $$props) $$invalidate(5, blur = $$new_props.blur);
    		if ('gradient' in $$props) $$invalidate(13, gradient = $$new_props.gradient);
    		if ('zIndex' in $$props) $$invalidate(14, zIndex = $$new_props.zIndex);
    		if ('radius' in $$props) $$invalidate(6, radius = $$new_props.radius);
    		if ('center' in $$props) $$invalidate(7, center = $$new_props.center);
    		if ('baseStyles' in $$props) $$invalidate(8, baseStyles = $$new_props.baseStyles);
    		if ('background' in $$props) $$invalidate(9, background = $$new_props.background);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*gradient, color*/ 12288) {
    			$$invalidate(9, background = gradient
    			? { backgroundImage: gradient }
    			: { backgroundColor: color });
    		}

    		if ($$self.$$.dirty & /*zIndex*/ 16384) {
    			$$invalidate(8, baseStyles = {
    				position: 'absolute',
    				top: 0,
    				bottom: 0,
    				left: 0,
    				right: 0,
    				zIndex
    			});
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		opacity,
    		blur,
    		radius,
    		center,
    		baseStyles,
    		background,
    		forwardEvents,
    		$$restProps,
    		color,
    		gradient,
    		zIndex,
    		slots,
    		box_element_binding,
    		box_element_binding_1,
    		$$scope
    	];
    }

    class Overlay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 3,
    			opacity: 4,
    			color: 12,
    			blur: 5,
    			gradient: 13,
    			zIndex: 14,
    			radius: 6,
    			center: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Overlay",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get use() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blur() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blur(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gradient() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gradient(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zIndex() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zIndex(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get center() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Overlay$1 = Overlay;

    const sizes = {
        xs: 320,
        sm: 380,
        md: 440,
        lg: 620,
        xl: 780,
        full: '100%'
    };
    var useStyles$2 = createStyles((theme, { centered, overflow, size, zIndex }) => {
        const customSize = size in sizes === false;
        return {
            close: {},
            overlay: {},
            root: {
                position: 'fixed',
                zIndex,
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            },
            inner: {
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                overflowY: 'auto',
                padding: `${+theme.space.xl.value * 2}px ${+theme.space.md.value}px`,
                display: 'flex',
                justifyContent: 'center',
                alignItems: centered ? 'center' : 'flex-start'
            },
            title: {
                marginRight: +theme.space.md.value,
                textOverflow: 'ellipsis',
                display: 'block',
                wordBreak: 'break-word'
            },
            modal: {
                [`${theme.dark} &`]: {
                    backgroundColor: theme.fn.themeColor('dark', 7)
                },
                position: 'relative',
                width: typeof size === 'string' && customSize ? size : theme.fn.size({ sizes, size }),
                outline: 0,
                backgroundColor: 'white',
                marginTop: centered ? 'auto' : undefined,
                marginBottom: centered ? 'auto' : undefined,
                zIndex: 1,
                marginLeft: 'calc(var(--removed-scroll-width, 0px) * -1)'
            },
            header: {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                marginBottom: parseInt(theme.space.md.value),
                marginRight: -9
            },
            body: {
                maxHeight: overflow === 'inside' ? 'calc(100vh - 185px)' : null,
                overflowY: overflow === 'inside' ? 'auto' : null,
                wordBreak: 'break-word'
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Modal/Modal.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1 } = globals;
    const file$b = "node_modules/@svelteuidev/core/dist/components/Modal/Modal.svelte";

    // (49:0) {#if opened}
    function create_if_block$7(ctx) {
    	let optionalportal;
    	let current;

    	optionalportal = new OptionalPortal$1({
    			props: {
    				class: /*zIndexStyles*/ ctx[28](),
    				withinPortal: /*withinPortal*/ ctx[17],
    				target: /*target*/ ctx[16],
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(optionalportal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(optionalportal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const optionalportal_changes = {};
    			if (dirty[0] & /*withinPortal*/ 131072) optionalportal_changes.withinPortal = /*withinPortal*/ ctx[17];
    			if (dirty[0] & /*target*/ 65536) optionalportal_changes.target = /*target*/ ctx[16];

    			if (dirty[0] & /*use, $$restProps, cx, className, classes, getStyles, override, element, lockScroll, closeOnEscape, overlayBlur, overlayColor, closeOnClickOutside, shadow, padding, radius, trapFocus, closeButtonLabel, withCloseButton, title*/ 540868591 | dirty[1] & /*$$scope*/ 512) {
    				optionalportal_changes.$$scope = { dirty, ctx };
    			}

    			optionalportal.$set(optionalportal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(optionalportal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(optionalportal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(optionalportal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(49:0) {#if opened}",
    		ctx
    	});

    	return block;
    }

    // (81:6) {#if title || withCloseButton}
    function create_if_block_1$4(ctx) {
    	let div;
    	let text_1;
    	let t;
    	let div_class_value;
    	let current;

    	text_1 = new Text$1({
    			props: {
    				id: /*titleId*/ ctx[24],
    				class: /*classes*/ ctx[19].title,
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*withCloseButton*/ ctx[6] && create_if_block_2$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(text_1.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = /*classes*/ ctx[19].header);
    			add_location(div, file$b, 81, 7, 3189);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(text_1, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};
    			if (dirty[0] & /*classes*/ 524288) text_1_changes.class = /*classes*/ ctx[19].title;

    			if (dirty[0] & /*title*/ 32 | dirty[1] & /*$$scope*/ 512) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);

    			if (/*withCloseButton*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*withCloseButton*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*classes*/ 524288 && div_class_value !== (div_class_value = /*classes*/ ctx[19].header)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(text_1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(81:6) {#if title || withCloseButton}",
    		ctx
    	});

    	return block;
    }

    // (83:8) <Text id={titleId} class={classes.title}>
    function create_default_slot_3$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*title*/ ctx[5]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*title*/ 32) set_data_dev(t, /*title*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(83:8) <Text id={titleId} class={classes.title}>",
    		ctx
    	});

    	return block;
    }

    // (87:8) {#if withCloseButton}
    function create_if_block_2$2(ctx) {
    	let closebutton;
    	let current;

    	closebutton = new CloseButton$1({
    			props: {
    				iconSize: 16,
    				"aria-label": /*closeButtonLabel*/ ctx[10],
    				class: /*classes*/ ctx[19].close
    			},
    			$$inline: true
    		});

    	closebutton.$on("click", /*onClose*/ ctx[27]);

    	const block = {
    		c: function create() {
    			create_component(closebutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(closebutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const closebutton_changes = {};
    			if (dirty[0] & /*closeButtonLabel*/ 1024) closebutton_changes["aria-label"] = /*closeButtonLabel*/ ctx[10];
    			if (dirty[0] & /*classes*/ 524288) closebutton_changes.class = /*classes*/ ctx[19].close;
    			closebutton.$set(closebutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(closebutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(closebutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(closebutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(87:8) {#if withCloseButton}",
    		ctx
    	});

    	return block;
    }

    // (98:13) Place some content
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Place some content");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(98:13) Place some content",
    		ctx
    	});

    	return block;
    }

    // (69:5) <Paper       class={classes.modal}       {shadow}       {padding}       {radius}       role="dialog"       aria-labelledby={titleId}       aria-describedby={bodyId}       aria-modal       tabindex={-1}       use={[[focustrap, trapFocus]]}      >
    function create_default_slot_2$5(ctx) {
    	let t;
    	let div;
    	let div_class_value;
    	let current;
    	let if_block = (/*title*/ ctx[5] || /*withCloseButton*/ ctx[6]) && create_if_block_1$4(ctx);
    	const default_slot_template = /*#slots*/ ctx[36].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[40], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(div, "id", /*bodyId*/ ctx[25]);
    			attr_dev(div, "class", div_class_value = /*classes*/ ctx[19].body);
    			add_location(div, file$b, 96, 6, 3537);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[5] || /*withCloseButton*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*title, withCloseButton*/ 96) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[40],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[40])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[40], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*classes*/ 524288 && div_class_value !== (div_class_value = /*classes*/ ctx[19].body)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(69:5) <Paper       class={classes.modal}       {shadow}       {padding}       {radius}       role=\\\"dialog\\\"       aria-labelledby={titleId}       aria-describedby={bodyId}       aria-modal       tabindex={-1}       use={[[focustrap, trapFocus]]}      >",
    		ctx
    	});

    	return block;
    }

    // (51:2) <Box    id={baseId}    bind:element    {use}    {...$$restProps}    class={cx(className, classes.root, getStyles({ css: override }))}   >
    function create_default_slot_1$6(ctx) {
    	let div2;
    	let div0;
    	let paper;
    	let div0_transition;
    	let t;
    	let div1;
    	let overlay;
    	let div1_transition;
    	let div2_class_value;
    	let lockscroll_action;
    	let current;
    	let mounted;
    	let dispose;

    	paper = new Paper$1({
    			props: {
    				class: /*classes*/ ctx[19].modal,
    				shadow: /*shadow*/ ctx[11],
    				padding: /*padding*/ ctx[12],
    				radius: /*radius*/ ctx[9],
    				role: "dialog",
    				"aria-labelledby": /*titleId*/ ctx[24],
    				"aria-describedby": /*bodyId*/ ctx[25],
    				"aria-modal": true,
    				tabindex: -1,
    				use: [[focustrap, /*trapFocus*/ ctx[15]]],
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	overlay = new Overlay$1({
    			props: {
    				class: /*classes*/ ctx[19].overlay,
    				override: { position: 'fixed' },
    				zIndex: 0,
    				blur: /*overlayBlur*/ ctx[8],
    				color: /*overlayColor*/ ctx[7] || 'black',
    				opacity: /*_overlayOpacity*/ ctx[26]
    			},
    			$$inline: true
    		});

    	overlay.$on("mousedown", /*mousedown_handler*/ ctx[37]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(paper.$$.fragment);
    			t = space();
    			div1 = element("div");
    			create_component(overlay.$$.fragment);
    			add_location(div0, file$b, 67, 4, 2832);
    			add_location(div1, file$b, 101, 4, 3657);
    			attr_dev(div2, "role", "presentation");
    			attr_dev(div2, "class", div2_class_value = /*classes*/ ctx[19].inner);
    			add_location(div2, file$b, 57, 3, 2500);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(paper, div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			mount_component(overlay, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(lockscroll_action = lockscroll.call(null, div2, /*lockScroll*/ ctx[21])),
    					listen_dev(div2, "keydown", /*keydown_handler*/ ctx[38], true, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const paper_changes = {};
    			if (dirty[0] & /*classes*/ 524288) paper_changes.class = /*classes*/ ctx[19].modal;
    			if (dirty[0] & /*shadow*/ 2048) paper_changes.shadow = /*shadow*/ ctx[11];
    			if (dirty[0] & /*padding*/ 4096) paper_changes.padding = /*padding*/ ctx[12];
    			if (dirty[0] & /*radius*/ 512) paper_changes.radius = /*radius*/ ctx[9];
    			if (dirty[0] & /*trapFocus*/ 32768) paper_changes.use = [[focustrap, /*trapFocus*/ ctx[15]]];

    			if (dirty[0] & /*classes, closeButtonLabel, withCloseButton, title*/ 525408 | dirty[1] & /*$$scope*/ 512) {
    				paper_changes.$$scope = { dirty, ctx };
    			}

    			paper.$set(paper_changes);
    			const overlay_changes = {};
    			if (dirty[0] & /*classes*/ 524288) overlay_changes.class = /*classes*/ ctx[19].overlay;
    			if (dirty[0] & /*overlayBlur*/ 256) overlay_changes.blur = /*overlayBlur*/ ctx[8];
    			if (dirty[0] & /*overlayColor*/ 128) overlay_changes.color = /*overlayColor*/ ctx[7] || 'black';
    			overlay.$set(overlay_changes);

    			if (!current || dirty[0] & /*classes*/ 524288 && div2_class_value !== (div2_class_value = /*classes*/ ctx[19].inner)) {
    				attr_dev(div2, "class", div2_class_value);
    			}

    			if (lockscroll_action && is_function(lockscroll_action.update) && dirty[0] & /*lockScroll*/ 2097152) lockscroll_action.update.call(null, /*lockScroll*/ ctx[21]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(paper.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, scale, { duration: 100, easing: sineInOut }, true);
    				div0_transition.run(1);
    			});

    			transition_in(overlay.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade$1, { duration: 200, easing: sineInOut }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(paper.$$.fragment, local);
    			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, scale, { duration: 100, easing: sineInOut }, false);
    			div0_transition.run(0);
    			transition_out(overlay.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade$1, { duration: 200, easing: sineInOut }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(paper);
    			if (detaching && div0_transition) div0_transition.end();
    			destroy_component(overlay);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(51:2) <Box    id={baseId}    bind:element    {use}    {...$$restProps}    class={cx(className, classes.root, getStyles({ css: override }))}   >",
    		ctx
    	});

    	return block;
    }

    // (50:1) <OptionalPortal class={zIndexStyles()} {withinPortal} {target}>
    function create_default_slot$b(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ id: /*baseId*/ ctx[23] },
    		{ use: /*use*/ ctx[1] },
    		/*$$restProps*/ ctx[29],
    		{
    			class: /*cx*/ ctx[20](/*className*/ ctx[2], /*classes*/ ctx[19].root, /*getStyles*/ ctx[18]({ css: /*override*/ ctx[3] }))
    		}
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[39](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot_1$6] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const box_changes = (dirty[0] & /*baseId, use, $$restProps, cx, className, classes, getStyles, override*/ 547094542)
    			? get_spread_update(box_spread_levels, [
    					dirty[0] & /*baseId*/ 8388608 && { id: /*baseId*/ ctx[23] },
    					dirty[0] & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty[0] & /*$$restProps*/ 536870912 && get_spread_object(/*$$restProps*/ ctx[29]),
    					dirty[0] & /*cx, className, classes, getStyles, override*/ 1835020 && {
    						class: /*cx*/ ctx[20](/*className*/ ctx[2], /*classes*/ ctx[19].root, /*getStyles*/ ctx[18]({ css: /*override*/ ctx[3] }))
    					}
    				])
    			: {};

    			if (dirty[0] & /*classes, lockScroll, closeOnEscape, overlayBlur, overlayColor, closeOnClickOutside, shadow, padding, radius, trapFocus, closeButtonLabel, withCloseButton, title*/ 2686944 | dirty[1] & /*$$scope*/ 512) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty[0] & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(50:1) <OptionalPortal class={zIndexStyles()} {withinPortal} {target}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*opened*/ ctx[4] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*opened*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*opened*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let lockScroll;
    	let cx;
    	let classes;
    	let getStyles;

    	const omit_props_names = [
    		"use","element","class","override","opened","title","zIndex","overflow","withCloseButton","overlayOpacity","overlayColor","overlayBlur","radius","size","closeButtonLabel","id","shadow","padding","closeOnClickOutside","closeOnEscape","trapFocus","centered","target","withinPortal"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $colorScheme;
    	validate_store(colorScheme, 'colorScheme');
    	component_subscribe($$self, colorScheme, $$value => $$invalidate(41, $colorScheme = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, opened = false, title = '', zIndex = 200, overflow = 'outside', withCloseButton = true, overlayOpacity = null, overlayColor = null, overlayBlur = 0, radius = 'sm', size = 'md', closeButtonLabel = 'svelteui-close-button', id = 'svelteui', shadow = 'lg', padding = 'lg', closeOnClickOutside = true, closeOnEscape = true, trapFocus = true, centered = null, target = '#SVELTEUI_PROVIDER', withinPortal = true } = $$props;
    	const dispatch = createEventDispatcher();
    	const castAny = self => self;
    	const baseId = randomID(id);
    	const titleId = `${baseId}-title`;
    	const bodyId = `${baseId}-body`;

    	const _overlayOpacity = typeof overlayOpacity === 'number'
    	? overlayOpacity
    	: $colorScheme === 'dark' ? 0.85 : 0.75;

    	const { handleFocusReturn } = useFocusReturn();

    	const closeOnEscapePress = event => {
    		if (!trapFocus && event.code === 'Escape' && closeOnEscape) {
    			onClose();
    		}
    	};

    	function onClose() {
    		dispatch('close');
    	}

    	// Temporary, just add zIndex to Portal component
    	const zIndexStyles = css({ zIndex });

    	const mousedown_handler = () => closeOnClickOutside && onClose();

    	const keydown_handler = event => {
    		const shouldTrigger = castAny(event.target)?.getAttribute('data-svelteui-stop-propagation') !== 'true';
    		shouldTrigger && event.code === 'Escape' && closeOnEscape && onClose();
    	};

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(3, override = $$new_props.override);
    		if ('opened' in $$new_props) $$invalidate(4, opened = $$new_props.opened);
    		if ('title' in $$new_props) $$invalidate(5, title = $$new_props.title);
    		if ('zIndex' in $$new_props) $$invalidate(30, zIndex = $$new_props.zIndex);
    		if ('overflow' in $$new_props) $$invalidate(31, overflow = $$new_props.overflow);
    		if ('withCloseButton' in $$new_props) $$invalidate(6, withCloseButton = $$new_props.withCloseButton);
    		if ('overlayOpacity' in $$new_props) $$invalidate(32, overlayOpacity = $$new_props.overlayOpacity);
    		if ('overlayColor' in $$new_props) $$invalidate(7, overlayColor = $$new_props.overlayColor);
    		if ('overlayBlur' in $$new_props) $$invalidate(8, overlayBlur = $$new_props.overlayBlur);
    		if ('radius' in $$new_props) $$invalidate(9, radius = $$new_props.radius);
    		if ('size' in $$new_props) $$invalidate(33, size = $$new_props.size);
    		if ('closeButtonLabel' in $$new_props) $$invalidate(10, closeButtonLabel = $$new_props.closeButtonLabel);
    		if ('id' in $$new_props) $$invalidate(34, id = $$new_props.id);
    		if ('shadow' in $$new_props) $$invalidate(11, shadow = $$new_props.shadow);
    		if ('padding' in $$new_props) $$invalidate(12, padding = $$new_props.padding);
    		if ('closeOnClickOutside' in $$new_props) $$invalidate(13, closeOnClickOutside = $$new_props.closeOnClickOutside);
    		if ('closeOnEscape' in $$new_props) $$invalidate(14, closeOnEscape = $$new_props.closeOnEscape);
    		if ('trapFocus' in $$new_props) $$invalidate(15, trapFocus = $$new_props.trapFocus);
    		if ('centered' in $$new_props) $$invalidate(35, centered = $$new_props.centered);
    		if ('target' in $$new_props) $$invalidate(16, target = $$new_props.target);
    		if ('withinPortal' in $$new_props) $$invalidate(17, withinPortal = $$new_props.withinPortal);
    		if ('$$scope' in $$new_props) $$invalidate(40, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		fade: fade$1,
    		scale,
    		sineInOut,
    		focustrap,
    		lockscroll,
    		useFocusReturn,
    		randomID,
    		colorScheme,
    		css,
    		CloseButton: CloseButton$1,
    		Box: Box$1,
    		Overlay: Overlay$1,
    		Paper: Paper$1,
    		OptionalPortal: OptionalPortal$1,
    		Text: Text$1,
    		useStyles: useStyles$2,
    		use,
    		element,
    		className,
    		override,
    		opened,
    		title,
    		zIndex,
    		overflow,
    		withCloseButton,
    		overlayOpacity,
    		overlayColor,
    		overlayBlur,
    		radius,
    		size,
    		closeButtonLabel,
    		id,
    		shadow,
    		padding,
    		closeOnClickOutside,
    		closeOnEscape,
    		trapFocus,
    		centered,
    		target,
    		withinPortal,
    		dispatch,
    		castAny,
    		baseId,
    		titleId,
    		bodyId,
    		_overlayOpacity,
    		handleFocusReturn,
    		closeOnEscapePress,
    		onClose,
    		zIndexStyles,
    		getStyles,
    		classes,
    		cx,
    		lockScroll,
    		$colorScheme
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(3, override = $$new_props.override);
    		if ('opened' in $$props) $$invalidate(4, opened = $$new_props.opened);
    		if ('title' in $$props) $$invalidate(5, title = $$new_props.title);
    		if ('zIndex' in $$props) $$invalidate(30, zIndex = $$new_props.zIndex);
    		if ('overflow' in $$props) $$invalidate(31, overflow = $$new_props.overflow);
    		if ('withCloseButton' in $$props) $$invalidate(6, withCloseButton = $$new_props.withCloseButton);
    		if ('overlayOpacity' in $$props) $$invalidate(32, overlayOpacity = $$new_props.overlayOpacity);
    		if ('overlayColor' in $$props) $$invalidate(7, overlayColor = $$new_props.overlayColor);
    		if ('overlayBlur' in $$props) $$invalidate(8, overlayBlur = $$new_props.overlayBlur);
    		if ('radius' in $$props) $$invalidate(9, radius = $$new_props.radius);
    		if ('size' in $$props) $$invalidate(33, size = $$new_props.size);
    		if ('closeButtonLabel' in $$props) $$invalidate(10, closeButtonLabel = $$new_props.closeButtonLabel);
    		if ('id' in $$props) $$invalidate(34, id = $$new_props.id);
    		if ('shadow' in $$props) $$invalidate(11, shadow = $$new_props.shadow);
    		if ('padding' in $$props) $$invalidate(12, padding = $$new_props.padding);
    		if ('closeOnClickOutside' in $$props) $$invalidate(13, closeOnClickOutside = $$new_props.closeOnClickOutside);
    		if ('closeOnEscape' in $$props) $$invalidate(14, closeOnEscape = $$new_props.closeOnEscape);
    		if ('trapFocus' in $$props) $$invalidate(15, trapFocus = $$new_props.trapFocus);
    		if ('centered' in $$props) $$invalidate(35, centered = $$new_props.centered);
    		if ('target' in $$props) $$invalidate(16, target = $$new_props.target);
    		if ('withinPortal' in $$props) $$invalidate(17, withinPortal = $$new_props.withinPortal);
    		if ('getStyles' in $$props) $$invalidate(18, getStyles = $$new_props.getStyles);
    		if ('classes' in $$props) $$invalidate(19, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(20, cx = $$new_props.cx);
    		if ('lockScroll' in $$props) $$invalidate(21, lockScroll = $$new_props.lockScroll);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*opened*/ 16) {
    			handleFocusReturn(opened);
    		}

    		if ($$self.$$.dirty[0] & /*trapFocus*/ 32768) {
    			{
    				onMount(() => {
    					if (!trapFocus) {
    						typeof window !== 'undefined'
    						? window.addEventListener('keydown', closeOnEscapePress)
    						: null;
    					}
    				});
    			}
    		}

    		if ($$self.$$.dirty[0] & /*opened, target*/ 65552) {
    			if (opened && (typeof target === 'string' && !document.querySelector(target) || !target)) {
    				throw new Error('Wrap your app in the SvelteUIProvider, or provide a sufficent target throught the "target={\'\'}" prop ');
    			}
    		}

    		if ($$self.$$.dirty[0] & /*opened*/ 16) {
    			$$invalidate(21, lockScroll = opened);
    		}

    		if ($$self.$$.dirty[0] & /*zIndex*/ 1073741824 | $$self.$$.dirty[1] & /*centered, overflow, size*/ 21) {
    			$$invalidate(20, { cx, classes, getStyles } = useStyles$2({ centered, overflow, size, zIndex }, { name: 'Modal' }), cx, (((($$invalidate(19, classes), $$invalidate(35, centered)), $$invalidate(31, overflow)), $$invalidate(33, size)), $$invalidate(30, zIndex)), (((($$invalidate(18, getStyles), $$invalidate(35, centered)), $$invalidate(31, overflow)), $$invalidate(33, size)), $$invalidate(30, zIndex)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		override,
    		opened,
    		title,
    		withCloseButton,
    		overlayColor,
    		overlayBlur,
    		radius,
    		closeButtonLabel,
    		shadow,
    		padding,
    		closeOnClickOutside,
    		closeOnEscape,
    		trapFocus,
    		target,
    		withinPortal,
    		getStyles,
    		classes,
    		cx,
    		lockScroll,
    		castAny,
    		baseId,
    		titleId,
    		bodyId,
    		_overlayOpacity,
    		onClose,
    		zIndexStyles,
    		$$restProps,
    		zIndex,
    		overflow,
    		overlayOpacity,
    		size,
    		id,
    		centered,
    		slots,
    		mousedown_handler,
    		keydown_handler,
    		box_element_binding,
    		$$scope
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$e,
    			create_fragment$e,
    			safe_not_equal,
    			{
    				use: 1,
    				element: 0,
    				class: 2,
    				override: 3,
    				opened: 4,
    				title: 5,
    				zIndex: 30,
    				overflow: 31,
    				withCloseButton: 6,
    				overlayOpacity: 32,
    				overlayColor: 7,
    				overlayBlur: 8,
    				radius: 9,
    				size: 33,
    				closeButtonLabel: 10,
    				id: 34,
    				shadow: 11,
    				padding: 12,
    				closeOnClickOutside: 13,
    				closeOnEscape: 14,
    				trapFocus: 15,
    				centered: 35,
    				target: 16,
    				withinPortal: 17
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get use() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opened() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opened(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zIndex() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zIndex(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get overflow() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set overflow(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withCloseButton() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withCloseButton(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get overlayOpacity() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set overlayOpacity(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get overlayColor() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set overlayColor(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get overlayBlur() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set overlayBlur(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeButtonLabel() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeButtonLabel(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shadow() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shadow(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnClickOutside() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnClickOutside(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnEscape() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnEscape(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trapFocus() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trapFocus(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get centered() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set centered(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withinPortal() {
    		throw new Error_1("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withinPortal(value) {
    		throw new Error_1("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Modal$1 = Modal;

    /* node_modules/@svelteuidev/core/dist/components/TextInput/TextInput.svelte generated by Svelte v3.59.2 */
    const get_rightSection_slot_changes$1 = dirty => ({});
    const get_rightSection_slot_context$1 = ctx => ({ slot: "rightSection" });

    // (66:2) 
    function create_rightSection_slot$1(ctx) {
    	let current;
    	const rightSection_slot_template = /*#slots*/ ctx[23].rightSection;
    	const rightSection_slot = create_slot(rightSection_slot_template, ctx, /*$$scope*/ ctx[26], get_rightSection_slot_context$1);

    	const block = {
    		c: function create() {
    			if (rightSection_slot) rightSection_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (rightSection_slot) {
    				rightSection_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (rightSection_slot) {
    				if (rightSection_slot.p && (!current || dirty & /*$$scope*/ 67108864)) {
    					update_slot_base(
    						rightSection_slot,
    						rightSection_slot_template,
    						ctx,
    						/*$$scope*/ ctx[26],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[26])
    						: get_slot_changes(rightSection_slot_template, /*$$scope*/ ctx[26], dirty, get_rightSection_slot_changes$1),
    						get_rightSection_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rightSection_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rightSection_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (rightSection_slot) rightSection_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_rightSection_slot$1.name,
    		type: "slot",
    		source: "(66:2) ",
    		ctx
    	});

    	return block;
    }

    // (40:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  id={baseId}  {labelElement}  {size} >
    function create_default_slot$a(ctx) {
    	let input;
    	let updating_value;
    	let current;

    	const input_spread_levels = [
    		{ required: /*required*/ ctx[8] },
    		{ size: /*size*/ ctx[13] },
    		{ id: /*baseId*/ ctx[17] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		/*$$restProps*/ ctx[19],
    		{
    			use: [/*forwardEvents*/ ctx[16], [useActions, /*use*/ ctx[2]]]
    		},
    		{ invalid: /*_invalid*/ ctx[15] },
    		{
    			showRightSection: /*_showRightSection*/ ctx[18]
    		}
    	];

    	function input_value_binding(value) {
    		/*input_value_binding*/ ctx[24](value);
    	}

    	let input_props = {
    		$$slots: { rightSection: [create_rightSection_slot$1] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < input_spread_levels.length; i += 1) {
    		input_props = assign(input_props, input_spread_levels[i]);
    	}

    	if (/*value*/ ctx[1] !== void 0) {
    		input_props.value = /*value*/ ctx[1];
    	}

    	input = new Input$1({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = (dirty & /*required, size, baseId, placeholder, $$restProps, forwardEvents, useActions, use, _invalid, _showRightSection*/ 1040644)
    			? get_spread_update(input_spread_levels, [
    					dirty & /*required*/ 256 && { required: /*required*/ ctx[8] },
    					dirty & /*size*/ 8192 && { size: /*size*/ ctx[13] },
    					dirty & /*baseId*/ 131072 && { id: /*baseId*/ ctx[17] },
    					dirty & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    					dirty & /*$$restProps*/ 524288 && get_spread_object(/*$$restProps*/ ctx[19]),
    					dirty & /*forwardEvents, useActions, use*/ 65540 && {
    						use: [/*forwardEvents*/ ctx[16], [useActions, /*use*/ ctx[2]]]
    					},
    					dirty & /*_invalid*/ 32768 && { invalid: /*_invalid*/ ctx[15] },
    					dirty & /*_showRightSection*/ 262144 && {
    						showRightSection: /*_showRightSection*/ ctx[18]
    					}
    				])
    			: {};

    			if (dirty & /*$$scope*/ 67108864) {
    				input_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*value*/ 2) {
    				updating_value = true;
    				input_changes.value = /*value*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(40:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  id={baseId}  {labelElement}  {size} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let inputwrapper;
    	let updating_element;
    	let current;

    	function inputwrapper_element_binding(value) {
    		/*inputwrapper_element_binding*/ ctx[25](value);
    	}

    	let inputwrapper_props = {
    		class: /*className*/ ctx[3],
    		override: /*override*/ ctx[4],
    		label: /*label*/ ctx[5],
    		description: /*description*/ ctx[6],
    		error: /*error*/ ctx[7],
    		required: /*required*/ ctx[8],
    		labelProps: /*labelProps*/ ctx[9],
    		descriptionProps: /*descriptionProps*/ ctx[10],
    		errorProps: /*errorProps*/ ctx[11],
    		id: /*baseId*/ ctx[17],
    		labelElement: /*labelElement*/ ctx[12],
    		size: /*size*/ ctx[13],
    		$$slots: { default: [create_default_slot$a] },
    		$$scope: { ctx }
    	};

    	if (/*element*/ ctx[0] !== void 0) {
    		inputwrapper_props.element = /*element*/ ctx[0];
    	}

    	inputwrapper = new InputWrapper$1({
    			props: inputwrapper_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputwrapper, 'element', inputwrapper_element_binding));

    	const block = {
    		c: function create() {
    			create_component(inputwrapper.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(inputwrapper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const inputwrapper_changes = {};
    			if (dirty & /*className*/ 8) inputwrapper_changes.class = /*className*/ ctx[3];
    			if (dirty & /*override*/ 16) inputwrapper_changes.override = /*override*/ ctx[4];
    			if (dirty & /*label*/ 32) inputwrapper_changes.label = /*label*/ ctx[5];
    			if (dirty & /*description*/ 64) inputwrapper_changes.description = /*description*/ ctx[6];
    			if (dirty & /*error*/ 128) inputwrapper_changes.error = /*error*/ ctx[7];
    			if (dirty & /*required*/ 256) inputwrapper_changes.required = /*required*/ ctx[8];
    			if (dirty & /*labelProps*/ 512) inputwrapper_changes.labelProps = /*labelProps*/ ctx[9];
    			if (dirty & /*descriptionProps*/ 1024) inputwrapper_changes.descriptionProps = /*descriptionProps*/ ctx[10];
    			if (dirty & /*errorProps*/ 2048) inputwrapper_changes.errorProps = /*errorProps*/ ctx[11];
    			if (dirty & /*labelElement*/ 4096) inputwrapper_changes.labelElement = /*labelElement*/ ctx[12];
    			if (dirty & /*size*/ 8192) inputwrapper_changes.size = /*size*/ ctx[13];

    			if (dirty & /*$$scope, required, size, placeholder, $$restProps, use, _invalid, value*/ 67690758) {
    				inputwrapper_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				inputwrapper_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			inputwrapper.$set(inputwrapper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inputwrapper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inputwrapper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(inputwrapper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let _invalid;

    	const omit_props_names = [
    		"use","element","class","override","label","description","error","required","labelProps","descriptionProps","errorProps","invalid","id","labelElement","size","showRightSection","value","placeholder"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextInput', slots, ['rightSection']);
    	const $$slots = compute_slots(slots);
    	let { use = [], element = undefined, class: className = '', override = {}, label = '', description = null, error = null, required = false, labelProps = {}, descriptionProps = {}, errorProps = {}, invalid = false, id = 'input-id', labelElement = 'label', size = 'sm', showRightSection = undefined, value = '', placeholder = '' } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	const baseId = randomID(id);

    	// Flag that enables the override of the right section slot
    	// of the Input component only if it was provided
    	const _showRightSection = showRightSection === undefined
    	? !!$$slots.rightSection
    	: showRightSection;

    	function input_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(1, value);
    	}

    	function inputwrapper_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(4, override = $$new_props.override);
    		if ('label' in $$new_props) $$invalidate(5, label = $$new_props.label);
    		if ('description' in $$new_props) $$invalidate(6, description = $$new_props.description);
    		if ('error' in $$new_props) $$invalidate(7, error = $$new_props.error);
    		if ('required' in $$new_props) $$invalidate(8, required = $$new_props.required);
    		if ('labelProps' in $$new_props) $$invalidate(9, labelProps = $$new_props.labelProps);
    		if ('descriptionProps' in $$new_props) $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    		if ('errorProps' in $$new_props) $$invalidate(11, errorProps = $$new_props.errorProps);
    		if ('invalid' in $$new_props) $$invalidate(20, invalid = $$new_props.invalid);
    		if ('id' in $$new_props) $$invalidate(21, id = $$new_props.id);
    		if ('labelElement' in $$new_props) $$invalidate(12, labelElement = $$new_props.labelElement);
    		if ('size' in $$new_props) $$invalidate(13, size = $$new_props.size);
    		if ('showRightSection' in $$new_props) $$invalidate(22, showRightSection = $$new_props.showRightSection);
    		if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
    		if ('placeholder' in $$new_props) $$invalidate(14, placeholder = $$new_props.placeholder);
    		if ('$$scope' in $$new_props) $$invalidate(26, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		randomID,
    		Input: Input$1,
    		InputWrapper: InputWrapper$1,
    		use,
    		element,
    		className,
    		override,
    		label,
    		description,
    		error,
    		required,
    		labelProps,
    		descriptionProps,
    		errorProps,
    		invalid,
    		id,
    		labelElement,
    		size,
    		showRightSection,
    		value,
    		placeholder,
    		forwardEvents,
    		baseId,
    		_showRightSection,
    		_invalid
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(4, override = $$new_props.override);
    		if ('label' in $$props) $$invalidate(5, label = $$new_props.label);
    		if ('description' in $$props) $$invalidate(6, description = $$new_props.description);
    		if ('error' in $$props) $$invalidate(7, error = $$new_props.error);
    		if ('required' in $$props) $$invalidate(8, required = $$new_props.required);
    		if ('labelProps' in $$props) $$invalidate(9, labelProps = $$new_props.labelProps);
    		if ('descriptionProps' in $$props) $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    		if ('errorProps' in $$props) $$invalidate(11, errorProps = $$new_props.errorProps);
    		if ('invalid' in $$props) $$invalidate(20, invalid = $$new_props.invalid);
    		if ('id' in $$props) $$invalidate(21, id = $$new_props.id);
    		if ('labelElement' in $$props) $$invalidate(12, labelElement = $$new_props.labelElement);
    		if ('size' in $$props) $$invalidate(13, size = $$new_props.size);
    		if ('showRightSection' in $$props) $$invalidate(22, showRightSection = $$new_props.showRightSection);
    		if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
    		if ('placeholder' in $$props) $$invalidate(14, placeholder = $$new_props.placeholder);
    		if ('_invalid' in $$props) $$invalidate(15, _invalid = $$new_props._invalid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*invalid, error*/ 1048704) {
    			$$invalidate(15, _invalid = invalid || !!error);
    		}
    	};

    	return [
    		element,
    		value,
    		use,
    		className,
    		override,
    		label,
    		description,
    		error,
    		required,
    		labelProps,
    		descriptionProps,
    		errorProps,
    		labelElement,
    		size,
    		placeholder,
    		_invalid,
    		forwardEvents,
    		baseId,
    		_showRightSection,
    		$$restProps,
    		invalid,
    		id,
    		showRightSection,
    		slots,
    		input_value_binding,
    		inputwrapper_element_binding,
    		$$scope
    	];
    }

    class TextInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			use: 2,
    			element: 0,
    			class: 3,
    			override: 4,
    			label: 5,
    			description: 6,
    			error: 7,
    			required: 8,
    			labelProps: 9,
    			descriptionProps: 10,
    			errorProps: 11,
    			invalid: 20,
    			id: 21,
    			labelElement: 12,
    			size: 13,
    			showRightSection: 22,
    			value: 1,
    			placeholder: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextInput",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get use() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelProps() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelProps(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get descriptionProps() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set descriptionProps(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorProps() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorProps(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelElement() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelElement(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showRightSection() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showRightSection(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var TextInput$1 = TextInput;

    /* node_modules/@svelteuidev/core/dist/components/Textarea/Textarea.svelte generated by Svelte v3.59.2 */
    const get_rightSection_slot_changes = dirty => ({});
    const get_rightSection_slot_context = ctx => ({ slot: "rightSection" });

    // (60:2) 
    function create_rightSection_slot(ctx) {
    	let current;
    	const rightSection_slot_template = /*#slots*/ ctx[22].rightSection;
    	const rightSection_slot = create_slot(rightSection_slot_template, ctx, /*$$scope*/ ctx[25], get_rightSection_slot_context);

    	const block = {
    		c: function create() {
    			if (rightSection_slot) rightSection_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (rightSection_slot) {
    				rightSection_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (rightSection_slot) {
    				if (rightSection_slot.p && (!current || dirty & /*$$scope*/ 33554432)) {
    					update_slot_base(
    						rightSection_slot,
    						rightSection_slot_template,
    						ctx,
    						/*$$scope*/ ctx[25],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
    						: get_slot_changes(rightSection_slot_template, /*$$scope*/ ctx[25], dirty, get_rightSection_slot_changes),
    						get_rightSection_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rightSection_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rightSection_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (rightSection_slot) rightSection_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_rightSection_slot.name,
    		type: "slot",
    		source: "(60:2) ",
    		ctx
    	});

    	return block;
    }

    // (34:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  id={baseId}  {labelElement} >
    function create_default_slot$9(ctx) {
    	let input;
    	let updating_value;
    	let current;

    	const input_spread_levels = [
    		{ required: /*required*/ ctx[8] },
    		{ id: /*baseId*/ ctx[16] },
    		{ placeholder: /*placeholder*/ ctx[13] },
    		/*$$restProps*/ ctx[18],
    		{
    			use: [/*forwardEvents*/ ctx[15], [useActions, /*use*/ ctx[2]]]
    		},
    		{ invalid: /*_invalid*/ ctx[14] },
    		{
    			showRightSection: /*_showRightSection*/ ctx[17]
    		},
    		{ root: "textarea" },
    		{ multiline: true }
    	];

    	function input_value_binding(value) {
    		/*input_value_binding*/ ctx[23](value);
    	}

    	let input_props = {
    		$$slots: { rightSection: [create_rightSection_slot] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < input_spread_levels.length; i += 1) {
    		input_props = assign(input_props, input_spread_levels[i]);
    	}

    	if (/*value*/ ctx[1] !== void 0) {
    		input_props.value = /*value*/ ctx[1];
    	}

    	input = new Input$1({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = (dirty & /*required, baseId, placeholder, $$restProps, forwardEvents, useActions, use, _invalid, _showRightSection*/ 516356)
    			? get_spread_update(input_spread_levels, [
    					dirty & /*required*/ 256 && { required: /*required*/ ctx[8] },
    					dirty & /*baseId*/ 65536 && { id: /*baseId*/ ctx[16] },
    					dirty & /*placeholder*/ 8192 && { placeholder: /*placeholder*/ ctx[13] },
    					dirty & /*$$restProps*/ 262144 && get_spread_object(/*$$restProps*/ ctx[18]),
    					dirty & /*forwardEvents, useActions, use*/ 32772 && {
    						use: [/*forwardEvents*/ ctx[15], [useActions, /*use*/ ctx[2]]]
    					},
    					dirty & /*_invalid*/ 16384 && { invalid: /*_invalid*/ ctx[14] },
    					dirty & /*_showRightSection*/ 131072 && {
    						showRightSection: /*_showRightSection*/ ctx[17]
    					},
    					input_spread_levels[7],
    					input_spread_levels[8]
    				])
    			: {};

    			if (dirty & /*$$scope*/ 33554432) {
    				input_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*value*/ 2) {
    				updating_value = true;
    				input_changes.value = /*value*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(34:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  id={baseId}  {labelElement} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let inputwrapper;
    	let updating_element;
    	let current;

    	function inputwrapper_element_binding(value) {
    		/*inputwrapper_element_binding*/ ctx[24](value);
    	}

    	let inputwrapper_props = {
    		class: /*className*/ ctx[3],
    		override: /*override*/ ctx[4],
    		label: /*label*/ ctx[5],
    		description: /*description*/ ctx[6],
    		error: /*error*/ ctx[7],
    		required: /*required*/ ctx[8],
    		labelProps: /*labelProps*/ ctx[9],
    		descriptionProps: /*descriptionProps*/ ctx[10],
    		errorProps: /*errorProps*/ ctx[11],
    		id: /*baseId*/ ctx[16],
    		labelElement: /*labelElement*/ ctx[12],
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};

    	if (/*element*/ ctx[0] !== void 0) {
    		inputwrapper_props.element = /*element*/ ctx[0];
    	}

    	inputwrapper = new InputWrapper$1({
    			props: inputwrapper_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputwrapper, 'element', inputwrapper_element_binding));

    	const block = {
    		c: function create() {
    			create_component(inputwrapper.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(inputwrapper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const inputwrapper_changes = {};
    			if (dirty & /*className*/ 8) inputwrapper_changes.class = /*className*/ ctx[3];
    			if (dirty & /*override*/ 16) inputwrapper_changes.override = /*override*/ ctx[4];
    			if (dirty & /*label*/ 32) inputwrapper_changes.label = /*label*/ ctx[5];
    			if (dirty & /*description*/ 64) inputwrapper_changes.description = /*description*/ ctx[6];
    			if (dirty & /*error*/ 128) inputwrapper_changes.error = /*error*/ ctx[7];
    			if (dirty & /*required*/ 256) inputwrapper_changes.required = /*required*/ ctx[8];
    			if (dirty & /*labelProps*/ 512) inputwrapper_changes.labelProps = /*labelProps*/ ctx[9];
    			if (dirty & /*descriptionProps*/ 1024) inputwrapper_changes.descriptionProps = /*descriptionProps*/ ctx[10];
    			if (dirty & /*errorProps*/ 2048) inputwrapper_changes.errorProps = /*errorProps*/ ctx[11];
    			if (dirty & /*labelElement*/ 4096) inputwrapper_changes.labelElement = /*labelElement*/ ctx[12];

    			if (dirty & /*$$scope, required, placeholder, $$restProps, use, _invalid, value*/ 33841414) {
    				inputwrapper_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				inputwrapper_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			inputwrapper.$set(inputwrapper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inputwrapper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inputwrapper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(inputwrapper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let _invalid;

    	const omit_props_names = [
    		"use","element","class","override","label","description","error","required","labelProps","descriptionProps","errorProps","invalid","id","labelElement","showRightSection","value","placeholder"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Textarea', slots, ['rightSection']);
    	const $$slots = compute_slots(slots);
    	let { use = [], element = undefined, class: className = '', override = {}, label = '', description = null, error = null, required = false, labelProps = {}, descriptionProps = {}, errorProps = {}, invalid = false, id = 'input-id', labelElement = 'label', showRightSection = undefined, value = '', placeholder = '' } = $$props;

    	/** An action that forwards inner dom node events from parent component */
    	const forwardEvents = createEventForwarder(get_current_component());

    	const baseId = randomID(id);

    	// Flag that enables the override of the right section slot
    	// of the Input component only if it was provided
    	const _showRightSection = showRightSection === undefined
    	? !!$$slots.rightSection
    	: showRightSection;

    	function input_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(1, value);
    	}

    	function inputwrapper_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(4, override = $$new_props.override);
    		if ('label' in $$new_props) $$invalidate(5, label = $$new_props.label);
    		if ('description' in $$new_props) $$invalidate(6, description = $$new_props.description);
    		if ('error' in $$new_props) $$invalidate(7, error = $$new_props.error);
    		if ('required' in $$new_props) $$invalidate(8, required = $$new_props.required);
    		if ('labelProps' in $$new_props) $$invalidate(9, labelProps = $$new_props.labelProps);
    		if ('descriptionProps' in $$new_props) $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    		if ('errorProps' in $$new_props) $$invalidate(11, errorProps = $$new_props.errorProps);
    		if ('invalid' in $$new_props) $$invalidate(19, invalid = $$new_props.invalid);
    		if ('id' in $$new_props) $$invalidate(20, id = $$new_props.id);
    		if ('labelElement' in $$new_props) $$invalidate(12, labelElement = $$new_props.labelElement);
    		if ('showRightSection' in $$new_props) $$invalidate(21, showRightSection = $$new_props.showRightSection);
    		if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
    		if ('placeholder' in $$new_props) $$invalidate(13, placeholder = $$new_props.placeholder);
    		if ('$$scope' in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		createEventForwarder,
    		useActions,
    		randomID,
    		Input: Input$1,
    		InputWrapper: InputWrapper$1,
    		use,
    		element,
    		className,
    		override,
    		label,
    		description,
    		error,
    		required,
    		labelProps,
    		descriptionProps,
    		errorProps,
    		invalid,
    		id,
    		labelElement,
    		showRightSection,
    		value,
    		placeholder,
    		forwardEvents,
    		baseId,
    		_showRightSection,
    		_invalid
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(4, override = $$new_props.override);
    		if ('label' in $$props) $$invalidate(5, label = $$new_props.label);
    		if ('description' in $$props) $$invalidate(6, description = $$new_props.description);
    		if ('error' in $$props) $$invalidate(7, error = $$new_props.error);
    		if ('required' in $$props) $$invalidate(8, required = $$new_props.required);
    		if ('labelProps' in $$props) $$invalidate(9, labelProps = $$new_props.labelProps);
    		if ('descriptionProps' in $$props) $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    		if ('errorProps' in $$props) $$invalidate(11, errorProps = $$new_props.errorProps);
    		if ('invalid' in $$props) $$invalidate(19, invalid = $$new_props.invalid);
    		if ('id' in $$props) $$invalidate(20, id = $$new_props.id);
    		if ('labelElement' in $$props) $$invalidate(12, labelElement = $$new_props.labelElement);
    		if ('showRightSection' in $$props) $$invalidate(21, showRightSection = $$new_props.showRightSection);
    		if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
    		if ('placeholder' in $$props) $$invalidate(13, placeholder = $$new_props.placeholder);
    		if ('_invalid' in $$props) $$invalidate(14, _invalid = $$new_props._invalid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*invalid, error*/ 524416) {
    			$$invalidate(14, _invalid = invalid || !!error);
    		}
    	};

    	return [
    		element,
    		value,
    		use,
    		className,
    		override,
    		label,
    		description,
    		error,
    		required,
    		labelProps,
    		descriptionProps,
    		errorProps,
    		labelElement,
    		placeholder,
    		_invalid,
    		forwardEvents,
    		baseId,
    		_showRightSection,
    		$$restProps,
    		invalid,
    		id,
    		showRightSection,
    		slots,
    		input_value_binding,
    		inputwrapper_element_binding,
    		$$scope
    	];
    }

    class Textarea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			use: 2,
    			element: 0,
    			class: 3,
    			override: 4,
    			label: 5,
    			description: 6,
    			error: 7,
    			required: 8,
    			labelProps: 9,
    			descriptionProps: 10,
    			errorProps: 11,
    			invalid: 19,
    			id: 20,
    			labelElement: 12,
    			showRightSection: 21,
    			value: 1,
    			placeholder: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textarea",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get use() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelProps() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelProps(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get descriptionProps() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set descriptionProps(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorProps() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorProps(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelElement() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelElement(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showRightSection() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showRightSection(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Textarea$1 = Textarea;

    var useStyles$1 = createStyles((_, { align, bulletSize, lineWidth }) => {
        return {
            root: {
                paddingLeft: align === 'left' ? bulletSize / 2 + lineWidth / 2 : 0,
                paddingRight: align === 'left' ? 0 : bulletSize / 2 + lineWidth / 2
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Timeline/Timeline.svelte generated by Svelte v3.59.2 */

    // (59:0) <Box bind:element {use} class={cx(className, classes.root)} {...$$restProps}>
    function create_default_slot$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(59:0) <Box bind:element {use} class={cx(className, classes.root)} {...$$restProps}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{
    			class: /*cx*/ ctx[4](/*className*/ ctx[2], /*classes*/ ctx[3].root)
    		},
    		/*$$restProps*/ ctx[6]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[16](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$8] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, classes, $$restProps*/ 94)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*cx, className, classes*/ 28 && {
    						class: /*cx*/ ctx[4](/*className*/ ctx[2], /*classes*/ ctx[3].root)
    					},
    					dirty & /*$$restProps*/ 64 && get_spread_object(/*$$restProps*/ ctx[6])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 131072) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const ctx = 'Timeline';

    function instance$b($$self, $$props, $$invalidate) {
    	let cx;
    	let classes;

    	const omit_props_names = [
    		"use","element","class","override","active","align","bulletSize","radius","color","lineWidth","reverseActive"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $contextStore;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Timeline', slots, ['default']);
    	let { use = [], element = undefined, class: className = '', override = {}, active = -1, align = 'left', bulletSize = 20, radius = 'xl', color = 'blue', lineWidth = 4, reverseActive = false } = $$props;

    	// initialize a 'reactive context' which is basically
    	// a store inside the context, so that all children
    	// components can react to changes made in props
    	const contextStore = writable({
    		active,
    		reverseActive,
    		align,
    		bulletSize,
    		radius,
    		color,
    		lineWidth
    	});

    	validate_store(contextStore, 'contextStore');
    	component_subscribe($$self, contextStore, value => $$invalidate(18, $contextStore = value));
    	setContext(ctx, contextStore);

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(7, override = $$new_props.override);
    		if ('active' in $$new_props) $$invalidate(8, active = $$new_props.active);
    		if ('align' in $$new_props) $$invalidate(9, align = $$new_props.align);
    		if ('bulletSize' in $$new_props) $$invalidate(10, bulletSize = $$new_props.bulletSize);
    		if ('radius' in $$new_props) $$invalidate(11, radius = $$new_props.radius);
    		if ('color' in $$new_props) $$invalidate(12, color = $$new_props.color);
    		if ('lineWidth' in $$new_props) $$invalidate(13, lineWidth = $$new_props.lineWidth);
    		if ('reverseActive' in $$new_props) $$invalidate(14, reverseActive = $$new_props.reverseActive);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ctx,
    		setContext,
    		writable,
    		Box: Box$1,
    		useStyles: useStyles$1,
    		use,
    		element,
    		className,
    		override,
    		active,
    		align,
    		bulletSize,
    		radius,
    		color,
    		lineWidth,
    		reverseActive,
    		contextStore,
    		classes,
    		cx,
    		$contextStore
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(7, override = $$new_props.override);
    		if ('active' in $$props) $$invalidate(8, active = $$new_props.active);
    		if ('align' in $$props) $$invalidate(9, align = $$new_props.align);
    		if ('bulletSize' in $$props) $$invalidate(10, bulletSize = $$new_props.bulletSize);
    		if ('radius' in $$props) $$invalidate(11, radius = $$new_props.radius);
    		if ('color' in $$props) $$invalidate(12, color = $$new_props.color);
    		if ('lineWidth' in $$props) $$invalidate(13, lineWidth = $$new_props.lineWidth);
    		if ('reverseActive' in $$props) $$invalidate(14, reverseActive = $$new_props.reverseActive);
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(4, cx = $$new_props.cx);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*active, reverseActive, align, bulletSize, radius, color, lineWidth*/ 32512) {
    			set_store_value(
    				contextStore,
    				$contextStore = {
    					active,
    					reverseActive,
    					align,
    					bulletSize,
    					radius,
    					color,
    					lineWidth
    				},
    				$contextStore
    			);
    		}

    		if ($$self.$$.dirty & /*align, bulletSize, lineWidth, override*/ 9856) {
    			$$invalidate(4, { cx, classes } = useStyles$1({ align, bulletSize, lineWidth }, { override, name: 'Timeline' }), cx, (((($$invalidate(3, classes), $$invalidate(9, align)), $$invalidate(10, bulletSize)), $$invalidate(13, lineWidth)), $$invalidate(7, override)));
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		classes,
    		cx,
    		contextStore,
    		$$restProps,
    		override,
    		active,
    		align,
    		bulletSize,
    		radius,
    		color,
    		lineWidth,
    		reverseActive,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    let Timeline$1 = class Timeline extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 7,
    			active: 8,
    			align: 9,
    			bulletSize: 10,
    			radius: 11,
    			color: 12,
    			lineWidth: 13,
    			reverseActive: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Timeline",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get use() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bulletSize() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bulletSize(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineWidth() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineWidth(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reverseActive() {
    		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set reverseActive(value) {
    		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    var _Timeline = Timeline$1;

    var useStyles = createStyles((theme, { align, bulletSize, radius, color, lineVariant, lineWidth }, getRef) => {
        const colors = vFunc(color).filled;
        return {
            root: {
                position: 'relative',
                boxSizing: 'border-box',
                color: theme.colors.black.value,
                paddingLeft: align === 'left' ? theme.space.xlPX.value : 0,
                paddingRight: align === 'right' ? theme.space.xlPX.value : 0,
                textAlign: align,
                darkMode: {
                    color: theme.fn.themeColor('dark', 0)
                },
                '&:not(:last-of-type)::before': {
                    display: 'block'
                },
                '&:not(:first-of-type)': {
                    marginTop: theme.space.xlPX.value
                },
                '&::before': {
                    boxSizing: 'border-box',
                    position: 'absolute',
                    top: 0,
                    bottom: `${-theme.space.xl.value}px`,
                    left: align === 'left' ? -lineWidth : 'auto',
                    right: align === 'right' ? -lineWidth : 'auto',
                    borderLeft: `${lineWidth}px ${lineVariant} ${theme.fn.themeColor('gray', 3)}`,
                    content: '""',
                    display: 'none',
                    darkMode: {
                        borderLeft: `${lineWidth}px ${lineVariant} ${theme.fn.themeColor('dark', 4)}`
                    }
                },
                '&.lineActive': {
                    '&::before': {
                        borderLeftColor: colors.backgroundColor
                    }
                },
                [`&.active .${getRef('bulletContainer')}`]: {
                    borderColor: colors.backgroundColor,
                    backgroundColor: theme.colors.white.value
                },
                [`&.active .${getRef('bulletContainerWithChild')}`]: {
                    backgroundColor: colors.backgroundColor,
                    color: theme.colors.white.value
                }
            },
            bulletContainer: {
                ref: getRef('bulletContainer'),
                boxSizing: 'border-box',
                width: bulletSize,
                height: bulletSize,
                borderRadius: theme.fn.radius(radius),
                border: `${lineWidth}px solid ${theme.fn.themeColor('gray', 3)}`,
                backgroundColor: theme.colors.white.value,
                position: 'absolute',
                top: 0,
                left: align === 'left' ? -bulletSize / 2 - lineWidth / 2 : 'auto',
                right: align === 'right' ? -bulletSize / 2 - lineWidth / 2 : 'auto',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: theme.colors.white.value,
                darkMode: {
                    border: `${lineWidth}px solid ${theme.fn.themeColor('dark', 4)}`,
                    backgroundColor: theme.fn.themeColor('dark', 7)
                }
            },
            bulletContainerWithChild: {
                ref: getRef('bulletContainerWithChild'),
                borderWidth: 1,
                backgroundColor: theme.fn.themeColor('gray', 3),
                color: theme.colors.black.value,
                darkMode: {
                    backgroundColor: theme.fn.themeColor('dark', 4),
                    color: theme.fn.themeColor('dark', 0)
                }
            },
            bullet: {},
            container: {},
            title: {
                fontWeight: 500,
                lineHeight: 1,
                marginBottom: `${+theme.space.xs.value / 2}px`,
                textAlign: align
            },
            content: {
                textAlign: align
            }
        };
    });

    /* node_modules/@svelteuidev/core/dist/components/Timeline/TimelineItem/TimelineItem.svelte generated by Svelte v3.59.2 */
    const file$a = "node_modules/@svelteuidev/core/dist/components/Timeline/TimelineItem/TimelineItem.svelte";
    const get_bullet_slot_changes = dirty => ({});
    const get_bullet_slot_context = ctx => ({});

    // (61:3) {#if bullet}
    function create_if_block_1$3(ctx) {
    	let iconrenderer;
    	let current;

    	iconrenderer = new IconRenderer$1({
    			props: {
    				icon: /*bullet*/ ctx[3],
    				className: /*classes*/ ctx[7].bullet,
    				iconSize: /*bulletSize*/ ctx[4],
    				color: /*color*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(iconrenderer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconrenderer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const iconrenderer_changes = {};
    			if (dirty & /*bullet*/ 8) iconrenderer_changes.icon = /*bullet*/ ctx[3];
    			if (dirty & /*classes*/ 128) iconrenderer_changes.className = /*classes*/ ctx[7].bullet;
    			if (dirty & /*bulletSize*/ 16) iconrenderer_changes.iconSize = /*bulletSize*/ ctx[4];
    			if (dirty & /*color*/ 32) iconrenderer_changes.color = /*color*/ ctx[5];
    			iconrenderer.$set(iconrenderer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconrenderer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconrenderer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconrenderer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(61:3) {#if bullet}",
    		ctx
    	});

    	return block;
    }

    // (60:22)     
    function fallback_block(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*bullet*/ ctx[3] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*bullet*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*bullet*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(60:22)     ",
    		ctx
    	});

    	return block;
    }

    // (67:2) {#if title}
    function create_if_block$6(ctx) {
    	let text_1;
    	let current;

    	text_1 = new Text$1({
    			props: {
    				class: /*classes*/ ctx[7].title,
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};
    			if (dirty & /*classes*/ 128) text_1_changes.class = /*classes*/ ctx[7].title;

    			if (dirty & /*$$scope, title*/ 268435520) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(67:2) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (68:3) <Text class={classes.title}>
    function create_default_slot_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*title*/ ctx[6]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 64) set_data_dev(t, /*title*/ ctx[6]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(68:3) <Text class={classes.title}>",
    		ctx
    	});

    	return block;
    }

    // (50:0) <Box  bind:element  {use}  class={cx(className, classes.root, {   lineActive: _lineActive,   active: _active  })}  {...$$restProps} >
    function create_default_slot$7(ctx) {
    	let div0;
    	let div0_class_value;
    	let t0;
    	let div2;
    	let t1;
    	let div1;
    	let div1_class_value;
    	let div2_class_value;
    	let current;
    	const bullet_slot_template = /*#slots*/ ctx[26].bullet;
    	const bullet_slot = create_slot(bullet_slot_template, ctx, /*$$scope*/ ctx[28], get_bullet_slot_context);
    	const bullet_slot_or_fallback = bullet_slot || fallback_block(ctx);
    	let if_block = /*title*/ ctx[6] && create_if_block$6(ctx);
    	const default_slot_template = /*#slots*/ ctx[26].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (bullet_slot_or_fallback) bullet_slot_or_fallback.c();
    			t0 = space();
    			div2 = element("div");
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", div0_class_value = /*cx*/ ctx[8](/*classes*/ ctx[7].bulletContainer, /*bullet*/ ctx[3] && /*classes*/ ctx[7].bulletContainerWithChild));
    			add_location(div0, file$a, 58, 1, 2192);
    			attr_dev(div1, "class", div1_class_value = /*classes*/ ctx[7].content);
    			add_location(div1, file$a, 69, 2, 2539);
    			attr_dev(div2, "class", div2_class_value = /*classes*/ ctx[7].container);
    			add_location(div2, file$a, 65, 1, 2437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);

    			if (bullet_slot_or_fallback) {
    				bullet_slot_or_fallback.m(div0, null);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			if (if_block) if_block.m(div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (bullet_slot) {
    				if (bullet_slot.p && (!current || dirty & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						bullet_slot,
    						bullet_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(bullet_slot_template, /*$$scope*/ ctx[28], dirty, get_bullet_slot_changes),
    						get_bullet_slot_context
    					);
    				}
    			} else {
    				if (bullet_slot_or_fallback && bullet_slot_or_fallback.p && (!current || dirty & /*bullet, classes, bulletSize, color*/ 184)) {
    					bullet_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			if (!current || dirty & /*cx, classes, bullet*/ 392 && div0_class_value !== (div0_class_value = /*cx*/ ctx[8](/*classes*/ ctx[7].bulletContainer, /*bullet*/ ctx[3] && /*classes*/ ctx[7].bulletContainerWithChild))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (/*title*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*title*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 128 && div1_class_value !== (div1_class_value = /*classes*/ ctx[7].content)) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty & /*classes*/ 128 && div2_class_value !== (div2_class_value = /*classes*/ ctx[7].container)) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bullet_slot_or_fallback, local);
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bullet_slot_or_fallback, local);
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (bullet_slot_or_fallback) bullet_slot_or_fallback.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(50:0) <Box  bind:element  {use}  class={cx(className, classes.root, {   lineActive: _lineActive,   active: _active  })}  {...$$restProps} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let box;
    	let updating_element;
    	let current;

    	const box_spread_levels = [
    		{ use: /*use*/ ctx[1] },
    		{
    			class: /*cx*/ ctx[8](/*className*/ ctx[2], /*classes*/ ctx[7].root, {
    				lineActive: /*_lineActive*/ ctx[9],
    				active: /*_active*/ ctx[10]
    			})
    		},
    		/*$$restProps*/ ctx[12]
    	];

    	function box_element_binding(value) {
    		/*box_element_binding*/ ctx[27](value);
    	}

    	let box_props = {
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < box_spread_levels.length; i += 1) {
    		box_props = assign(box_props, box_spread_levels[i]);
    	}

    	if (/*element*/ ctx[0] !== void 0) {
    		box_props.element = /*element*/ ctx[0];
    	}

    	box = new Box$1({ props: box_props, $$inline: true });
    	binding_callbacks.push(() => bind(box, 'element', box_element_binding));

    	const block = {
    		c: function create() {
    			create_component(box.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(box, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const box_changes = (dirty & /*use, cx, className, classes, _lineActive, _active, $$restProps*/ 6022)
    			? get_spread_update(box_spread_levels, [
    					dirty & /*use*/ 2 && { use: /*use*/ ctx[1] },
    					dirty & /*cx, className, classes, _lineActive, _active*/ 1924 && {
    						class: /*cx*/ ctx[8](/*className*/ ctx[2], /*classes*/ ctx[7].root, {
    							lineActive: /*_lineActive*/ ctx[9],
    							active: /*_active*/ ctx[10]
    						})
    					},
    					dirty & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12])
    				])
    			: {};

    			if (dirty & /*$$scope, classes, title, cx, bullet, bulletSize, color*/ 268435960) {
    				box_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				box_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			box.$set(box_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(box.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(box.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(box, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let _active;
    	let _lineActive;
    	let _align;
    	let _color;
    	let _radius;
    	let _bulletSize;
    	let _lineWidth;
    	let cx;
    	let classes;

    	const omit_props_names = [
    		"use","element","class","override","active","align","bullet","bulletSize","radius","color","lineActive","lineVariant","lineWidth","title"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $state;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TimelineItem', slots, ['bullet','default']);
    	let { use = [], element = undefined, class: className = '', override = {}, active = undefined, align = undefined, bullet = undefined, bulletSize = undefined, radius = undefined, color = undefined, lineActive = undefined, lineVariant = 'solid', lineWidth = undefined, title = undefined } = $$props;

    	// retrieves the reactive context so that TimelineItem has access
    	// to the Timeline parameters
    	const state = getContext(ctx);

    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(25, $state = value));

    	function calculateActive() {
    		if (!element) return;
    		const children = element.parentNode.children;
    		const index = Array.prototype.indexOf.call(children, element);

    		$$invalidate(10, _active = active !== undefined
    		? active
    		: $state.reverseActive
    			? $state.active >= children.length - index - 1
    			: $state.active >= index);

    		$$invalidate(9, _lineActive = lineActive !== undefined
    		? lineActive
    		: $state.reverseActive
    			? $state.active >= children.length - index - 1
    			: $state.active - 1 >= index);
    	}

    	onMount(() => calculateActive());

    	function box_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('override' in $$new_props) $$invalidate(13, override = $$new_props.override);
    		if ('active' in $$new_props) $$invalidate(14, active = $$new_props.active);
    		if ('align' in $$new_props) $$invalidate(15, align = $$new_props.align);
    		if ('bullet' in $$new_props) $$invalidate(3, bullet = $$new_props.bullet);
    		if ('bulletSize' in $$new_props) $$invalidate(4, bulletSize = $$new_props.bulletSize);
    		if ('radius' in $$new_props) $$invalidate(16, radius = $$new_props.radius);
    		if ('color' in $$new_props) $$invalidate(5, color = $$new_props.color);
    		if ('lineActive' in $$new_props) $$invalidate(17, lineActive = $$new_props.lineActive);
    		if ('lineVariant' in $$new_props) $$invalidate(18, lineVariant = $$new_props.lineVariant);
    		if ('lineWidth' in $$new_props) $$invalidate(19, lineWidth = $$new_props.lineWidth);
    		if ('title' in $$new_props) $$invalidate(6, title = $$new_props.title);
    		if ('$$scope' in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		onMount,
    		Box: Box$1,
    		IconRenderer: IconRenderer$1,
    		Text: Text$1,
    		ctx,
    		useStyles,
    		use,
    		element,
    		className,
    		override,
    		active,
    		align,
    		bullet,
    		bulletSize,
    		radius,
    		color,
    		lineActive,
    		lineVariant,
    		lineWidth,
    		title,
    		state,
    		calculateActive,
    		_lineWidth,
    		_color,
    		_radius,
    		_bulletSize,
    		_align,
    		classes,
    		cx,
    		_lineActive,
    		_active,
    		$state
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('override' in $$props) $$invalidate(13, override = $$new_props.override);
    		if ('active' in $$props) $$invalidate(14, active = $$new_props.active);
    		if ('align' in $$props) $$invalidate(15, align = $$new_props.align);
    		if ('bullet' in $$props) $$invalidate(3, bullet = $$new_props.bullet);
    		if ('bulletSize' in $$props) $$invalidate(4, bulletSize = $$new_props.bulletSize);
    		if ('radius' in $$props) $$invalidate(16, radius = $$new_props.radius);
    		if ('color' in $$props) $$invalidate(5, color = $$new_props.color);
    		if ('lineActive' in $$props) $$invalidate(17, lineActive = $$new_props.lineActive);
    		if ('lineVariant' in $$props) $$invalidate(18, lineVariant = $$new_props.lineVariant);
    		if ('lineWidth' in $$props) $$invalidate(19, lineWidth = $$new_props.lineWidth);
    		if ('title' in $$props) $$invalidate(6, title = $$new_props.title);
    		if ('_lineWidth' in $$props) $$invalidate(20, _lineWidth = $$new_props._lineWidth);
    		if ('_color' in $$props) $$invalidate(21, _color = $$new_props._color);
    		if ('_radius' in $$props) $$invalidate(22, _radius = $$new_props._radius);
    		if ('_bulletSize' in $$props) $$invalidate(23, _bulletSize = $$new_props._bulletSize);
    		if ('_align' in $$props) $$invalidate(24, _align = $$new_props._align);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    		if ('cx' in $$props) $$invalidate(8, cx = $$new_props.cx);
    		if ('_lineActive' in $$props) $$invalidate(9, _lineActive = $$new_props._lineActive);
    		if ('_active' in $$props) $$invalidate(10, _active = $$new_props._active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*active*/ 16384) {
    			$$invalidate(10, _active = active);
    		}

    		if ($$self.$$.dirty & /*lineActive*/ 131072) {
    			$$invalidate(9, _lineActive = lineActive);
    		}

    		if ($$self.$$.dirty & /*align, $state*/ 33587200) {
    			$$invalidate(24, _align = align !== undefined ? align : $state.align);
    		}

    		if ($$self.$$.dirty & /*color, $state*/ 33554464) {
    			$$invalidate(21, _color = color !== undefined ? color : $state.color);
    		}

    		if ($$self.$$.dirty & /*radius, $state*/ 33619968) {
    			$$invalidate(22, _radius = radius !== undefined ? radius : $state.radius);
    		}

    		if ($$self.$$.dirty & /*bulletSize, $state*/ 33554448) {
    			$$invalidate(23, _bulletSize = bulletSize !== undefined
    			? bulletSize
    			: $state.bulletSize);
    		}

    		if ($$self.$$.dirty & /*lineWidth, $state*/ 34078720) {
    			$$invalidate(20, _lineWidth = lineWidth !== undefined ? lineWidth : $state.lineWidth);
    		}

    		if ($$self.$$.dirty & /*$state*/ 33554432) {
    			// check if item is still checked when the context store updates
    			(calculateActive());
    		}

    		if ($$self.$$.dirty & /*_align, _bulletSize, _radius, _color, lineVariant, _lineWidth, override*/ 32776192) {
    			$$invalidate(
    				8,
    				{ cx, classes } = useStyles(
    					{
    						align: _align,
    						bulletSize: _bulletSize,
    						radius: _radius,
    						color: _color,
    						lineVariant,
    						lineWidth: _lineWidth
    					},
    					{ override, name: 'TimelineItem' }
    				),
    				cx,
    				((((((((((((($$invalidate(7, classes), $$invalidate(24, _align)), $$invalidate(23, _bulletSize)), $$invalidate(22, _radius)), $$invalidate(21, _color)), $$invalidate(18, lineVariant)), $$invalidate(20, _lineWidth)), $$invalidate(13, override)), $$invalidate(15, align)), $$invalidate(25, $state)), $$invalidate(4, bulletSize)), $$invalidate(16, radius)), $$invalidate(5, color)), $$invalidate(19, lineWidth))
    			);
    		}
    	};

    	return [
    		element,
    		use,
    		className,
    		bullet,
    		bulletSize,
    		color,
    		title,
    		classes,
    		cx,
    		_lineActive,
    		_active,
    		state,
    		$$restProps,
    		override,
    		active,
    		align,
    		radius,
    		lineActive,
    		lineVariant,
    		lineWidth,
    		_lineWidth,
    		_color,
    		_radius,
    		_bulletSize,
    		_align,
    		$state,
    		slots,
    		box_element_binding,
    		$$scope
    	];
    }

    class TimelineItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			use: 1,
    			element: 0,
    			class: 2,
    			override: 13,
    			active: 14,
    			align: 15,
    			bullet: 3,
    			bulletSize: 4,
    			radius: 16,
    			color: 5,
    			lineActive: 17,
    			lineVariant: 18,
    			lineWidth: 19,
    			title: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TimelineItem",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get use() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get override() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set override(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bullet() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bullet(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bulletSize() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bulletSize(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineActive() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineActive(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineVariant() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineVariant(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineWidth() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineWidth(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var TimelineItem$1 = TimelineItem;

    // Combine Timeline and TimelineItem
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    _Timeline.Item = TimelineItem$1;
    const Timeline = _Timeline;

    function formatAbiItem(abiItem, { includeName = false } = {}) {
        if (abiItem.type !== 'function' &&
            abiItem.type !== 'event' &&
            abiItem.type !== 'error')
            throw new InvalidDefinitionTypeError(abiItem.type);
        return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
    }
    function formatAbiParams(params, { includeName = false } = {}) {
        if (!params)
            return '';
        return params
            .map((param) => formatAbiParam(param, { includeName }))
            .join(includeName ? ', ' : ',');
    }
    function formatAbiParam(param, { includeName }) {
        if (param.type.startsWith('tuple')) {
            return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;
        }
        return param.type + (includeName && param.name ? ` ${param.name}` : '');
    }

    function isHex(value, { strict = true } = {}) {
        if (!value)
            return false;
        if (typeof value !== 'string')
            return false;
        return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
    }

    /**
     * @description Retrieves the size of the value (in bytes).
     *
     * @param value The value (hex or byte array) to retrieve the size of.
     * @returns The size of the value (in bytes).
     */
    function size$1(value) {
        if (isHex(value, { strict: false }))
            return Math.ceil((value.length - 2) / 2);
        return value.length;
    }

    const version = '1.4.2';

    const getContractAddress = (address) => address;
    const getUrl = (url) => url;
    const getVersion = () => `viem@${version}`;

    class BaseError extends Error {
        constructor(shortMessage, args = {}) {
            super();
            Object.defineProperty(this, "details", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "docsPath", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "metaMessages", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shortMessage", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ViemError'
            });
            Object.defineProperty(this, "version", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: getVersion()
            });
            const details = args.cause instanceof BaseError
                ? args.cause.details
                : args.cause?.message
                    ? args.cause.message
                    : args.details;
            const docsPath = args.cause instanceof BaseError
                ? args.cause.docsPath || args.docsPath
                : args.docsPath;
            this.message = [
                shortMessage || 'An error occurred.',
                '',
                ...(args.metaMessages ? [...args.metaMessages, ''] : []),
                ...(docsPath
                    ? [
                        `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ''}`,
                    ]
                    : []),
                ...(details ? [`Details: ${details}`] : []),
                `Version: ${this.version}`,
            ].join('\n');
            if (args.cause)
                this.cause = args.cause;
            this.details = details;
            this.docsPath = docsPath;
            this.metaMessages = args.metaMessages;
            this.shortMessage = shortMessage;
        }
        walk(fn) {
            return walk(this, fn);
        }
    }
    function walk(err, fn) {
        if (fn?.(err))
            return err;
        if (err && typeof err === 'object' && 'cause' in err)
            return walk(err.cause, fn);
        return fn ? null : err;
    }

    class AbiConstructorNotFoundError extends BaseError {
        constructor({ docsPath }) {
            super([
                'A constructor was not found on the ABI.',
                'Make sure you are using the correct ABI and that the constructor exists on it.',
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiConstructorNotFoundError'
            });
        }
    }
    class AbiConstructorParamsNotFoundError extends BaseError {
        constructor({ docsPath }) {
            super([
                'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
                'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiConstructorParamsNotFoundError'
            });
        }
    }
    class AbiDecodingDataSizeTooSmallError extends BaseError {
        constructor({ data, params, size, }) {
            super([`Data size of ${size} bytes is too small for given parameters.`].join('\n'), {
                metaMessages: [
                    `Params: (${formatAbiParams(params, { includeName: true })})`,
                    `Data:   ${data} (${size} bytes)`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiDecodingDataSizeTooSmallError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "params", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "size", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = data;
            this.params = params;
            this.size = size;
        }
    }
    class AbiDecodingZeroDataError extends BaseError {
        constructor() {
            super('Cannot decode zero data ("0x") with ABI parameters.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiDecodingZeroDataError'
            });
        }
    }
    class AbiEncodingArrayLengthMismatchError extends BaseError {
        constructor({ expectedLength, givenLength, type, }) {
            super([
                `ABI encoding array length mismatch for type ${type}.`,
                `Expected length: ${expectedLength}`,
                `Given length: ${givenLength}`,
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEncodingArrayLengthMismatchError'
            });
        }
    }
    class AbiEncodingBytesSizeMismatchError extends BaseError {
        constructor({ expectedSize, value }) {
            super(`Size of bytes "${value}" (bytes${size$1(value)}) does not match expected size (bytes${expectedSize}).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEncodingBytesSizeMismatchError'
            });
        }
    }
    class AbiEncodingLengthMismatchError extends BaseError {
        constructor({ expectedLength, givenLength, }) {
            super([
                'ABI encoding params/values length mismatch.',
                `Expected length (params): ${expectedLength}`,
                `Given length (values): ${givenLength}`,
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEncodingLengthMismatchError'
            });
        }
    }
    class AbiErrorSignatureNotFoundError extends BaseError {
        constructor(signature, { docsPath }) {
            super([
                `Encoded error signature "${signature}" not found on ABI.`,
                'Make sure you are using the correct ABI and that the error exists on it.',
                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiErrorSignatureNotFoundError'
            });
            Object.defineProperty(this, "signature", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.signature = signature;
        }
    }
    class AbiEventSignatureEmptyTopicsError extends BaseError {
        constructor({ docsPath }) {
            super('Cannot extract event signature from empty topics.', {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEventSignatureEmptyTopicsError'
            });
        }
    }
    class AbiEventSignatureNotFoundError extends BaseError {
        constructor(signature, { docsPath }) {
            super([
                `Encoded event signature "${signature}" not found on ABI.`,
                'Make sure you are using the correct ABI and that the event exists on it.',
                `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEventSignatureNotFoundError'
            });
        }
    }
    class AbiEventNotFoundError extends BaseError {
        constructor(eventName, { docsPath } = {}) {
            super([
                `Event ${eventName ? `"${eventName}" ` : ''}not found on ABI.`,
                'Make sure you are using the correct ABI and that the event exists on it.',
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEventNotFoundError'
            });
        }
    }
    class AbiFunctionNotFoundError extends BaseError {
        constructor(functionName, { docsPath } = {}) {
            super([
                `Function ${functionName ? `"${functionName}" ` : ''}not found on ABI.`,
                'Make sure you are using the correct ABI and that the function exists on it.',
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiFunctionNotFoundError'
            });
        }
    }
    class AbiFunctionOutputsNotFoundError extends BaseError {
        constructor(functionName, { docsPath }) {
            super([
                `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
                'Cannot decode function result without knowing what the parameter types are.',
                'Make sure you are using the correct ABI and that the function exists on it.',
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiFunctionOutputsNotFoundError'
            });
        }
    }
    class BytesSizeMismatchError extends BaseError {
        constructor({ expectedSize, givenSize, }) {
            super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'BytesSizeMismatchError'
            });
        }
    }
    class DecodeLogDataMismatch extends BaseError {
        constructor({ abiItem, data, params, size, }) {
            super([
                `Data size of ${size} bytes is too small for non-indexed event parameters.`,
            ].join('\n'), {
                metaMessages: [
                    `Params: (${formatAbiParams(params, { includeName: true })})`,
                    `Data:   ${data} (${size} bytes)`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'DecodeLogDataMismatch'
            });
            Object.defineProperty(this, "abiItem", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "params", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "size", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.abiItem = abiItem;
            this.data = data;
            this.params = params;
            this.size = size;
        }
    }
    class DecodeLogTopicsMismatch extends BaseError {
        constructor({ abiItem, param, }) {
            super([
                `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ''} on event "${formatAbiItem(abiItem, { includeName: true })}".`,
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'DecodeLogTopicsMismatch'
            });
            Object.defineProperty(this, "abiItem", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.abiItem = abiItem;
        }
    }
    class InvalidAbiEncodingTypeError extends BaseError {
        constructor(type, { docsPath }) {
            super([
                `Type "${type}" is not a valid encoding type.`,
                'Please provide a valid ABI type.',
            ].join('\n'), { docsPath });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidAbiEncodingType'
            });
        }
    }
    class InvalidAbiDecodingTypeError extends BaseError {
        constructor(type, { docsPath }) {
            super([
                `Type "${type}" is not a valid decoding type.`,
                'Please provide a valid ABI type.',
            ].join('\n'), { docsPath });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidAbiDecodingType'
            });
        }
    }
    class InvalidArrayError extends BaseError {
        constructor(value) {
            super([`Value "${value}" is not a valid array.`].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidArrayError'
            });
        }
    }
    class InvalidDefinitionTypeError extends BaseError {
        constructor(type) {
            super([
                `"${type}" is not a valid definition type.`,
                'Valid types: "function", "event", "error"',
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidDefinitionTypeError'
            });
        }
    }

    class FilterTypeNotSupportedError extends BaseError {
        constructor(type) {
            super(`Filter type "${type}" is not supported.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'FilterTypeNotSupportedError'
            });
        }
    }

    class SliceOffsetOutOfBoundsError extends BaseError {
        constructor({ offset, position, size, }) {
            super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SliceOffsetOutOfBoundsError'
            });
        }
    }
    class SizeExceedsPaddingSizeError extends BaseError {
        constructor({ size, targetSize, type, }) {
            super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SizeExceedsPaddingSizeError'
            });
        }
    }

    function pad(hexOrBytes, { dir, size = 32 } = {}) {
        if (typeof hexOrBytes === 'string')
            return padHex(hexOrBytes, { dir, size });
        return padBytes(hexOrBytes, { dir, size });
    }
    function padHex(hex_, { dir, size = 32 } = {}) {
        if (size === null)
            return hex_;
        const hex = hex_.replace('0x', '');
        if (hex.length > size * 2)
            throw new SizeExceedsPaddingSizeError({
                size: Math.ceil(hex.length / 2),
                targetSize: size,
                type: 'hex',
            });
        return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
    }
    function padBytes(bytes, { dir, size = 32 } = {}) {
        if (size === null)
            return bytes;
        if (bytes.length > size)
            throw new SizeExceedsPaddingSizeError({
                size: bytes.length,
                targetSize: size,
                type: 'bytes',
            });
        const paddedBytes = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            const padEnd = dir === 'right';
            paddedBytes[padEnd ? i : size - i - 1] =
                bytes[padEnd ? i : bytes.length - i - 1];
        }
        return paddedBytes;
    }

    class IntegerOutOfRangeError extends BaseError {
        constructor({ max, min, signed, size, value, }) {
            super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'IntegerOutOfRangeError'
            });
        }
    }
    class InvalidHexBooleanError extends BaseError {
        constructor(hex) {
            super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidHexBooleanError'
            });
        }
    }
    class SizeOverflowError extends BaseError {
        constructor({ givenSize, maxSize }) {
            super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SizeOverflowError'
            });
        }
    }

    function trim(hexOrBytes, { dir = 'left' } = {}) {
        let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
        let sliceLength = 0;
        for (let i = 0; i < data.length - 1; i++) {
            if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')
                sliceLength++;
            else
                break;
        }
        data =
            dir === 'left'
                ? data.slice(sliceLength)
                : data.slice(0, data.length - sliceLength);
        if (typeof hexOrBytes === 'string') {
            if (data.length === 1 && dir === 'right')
                data = `${data}0`;
            return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
        }
        return data;
    }

    function assertSize(hexOrBytes, { size }) {
        if (size$1(hexOrBytes) > size)
            throw new SizeOverflowError({
                givenSize: size$1(hexOrBytes),
                maxSize: size,
            });
    }
    /**
     * Decodes a hex value into a bigint.
     *
     * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint
     *
     * @param hex Hex value to decode.
     * @param opts Options.
     * @returns BigInt value.
     *
     * @example
     * import { hexToBigInt } from 'viem'
     * const data = hexToBigInt('0x1a4', { signed: true })
     * // 420n
     *
     * @example
     * import { hexToBigInt } from 'viem'
     * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
     * // 420n
     */
    function hexToBigInt(hex, opts = {}) {
        const { signed } = opts;
        if (opts.size)
            assertSize(hex, { size: opts.size });
        const value = BigInt(hex);
        if (!signed)
            return value;
        const size = (hex.length - 2) / 2;
        const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        if (value <= max)
            return value;
        return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
    }
    /**
     * Decodes a hex value into a boolean.
     *
     * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool
     *
     * @param hex Hex value to decode.
     * @param opts Options.
     * @returns Boolean value.
     *
     * @example
     * import { hexToBool } from 'viem'
     * const data = hexToBool('0x01')
     * // true
     *
     * @example
     * import { hexToBool } from 'viem'
     * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })
     * // true
     */
    function hexToBool(hex_, opts = {}) {
        let hex = hex_;
        if (opts.size) {
            assertSize(hex, { size: opts.size });
            hex = trim(hex);
        }
        if (trim(hex) === '0x00')
            return false;
        if (trim(hex) === '0x01')
            return true;
        throw new InvalidHexBooleanError(hex);
    }
    /**
     * Decodes a hex string into a number.
     *
     * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber
     *
     * @param hex Hex value to decode.
     * @param opts Options.
     * @returns Number value.
     *
     * @example
     * import { hexToNumber } from 'viem'
     * const data = hexToNumber('0x1a4')
     * // 420
     *
     * @example
     * import { hexToNumber } from 'viem'
     * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
     * // 420
     */
    function hexToNumber(hex, opts = {}) {
        return Number(hexToBigInt(hex, opts));
    }
    /**
     * Decodes a hex value into a UTF-8 string.
     *
     * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring
     *
     * @param hex Hex value to decode.
     * @param opts Options.
     * @returns String value.
     *
     * @example
     * import { hexToString } from 'viem'
     * const data = hexToString('0x48656c6c6f20576f726c6421')
     * // 'Hello world!'
     *
     * @example
     * import { hexToString } from 'viem'
     * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
     *  size: 32,
     * })
     * // 'Hello world'
     */
    function hexToString(hex, opts = {}) {
        let bytes = hexToBytes(hex);
        if (opts.size) {
            assertSize(bytes, { size: opts.size });
            bytes = trim(bytes, { dir: 'right' });
        }
        return new TextDecoder().decode(bytes);
    }

    const hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
    /**
     * Encodes a string, number, bigint, or ByteArray into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex.html
     * - Example: https://viem.sh/docs/utilities/toHex.html#usage
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { toHex } from 'viem'
     * const data = toHex('Hello world')
     * // '0x48656c6c6f20776f726c6421'
     *
     * @example
     * import { toHex } from 'viem'
     * const data = toHex(420)
     * // '0x1a4'
     *
     * @example
     * import { toHex } from 'viem'
     * const data = toHex('Hello world', { size: 32 })
     * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
     */
    function toHex(value, opts = {}) {
        if (typeof value === 'number' || typeof value === 'bigint')
            return numberToHex(value, opts);
        if (typeof value === 'string') {
            return stringToHex(value, opts);
        }
        if (typeof value === 'boolean')
            return boolToHex(value, opts);
        return bytesToHex(value, opts);
    }
    /**
     * Encodes a boolean into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { boolToHex } from 'viem'
     * const data = boolToHex(true)
     * // '0x1'
     *
     * @example
     * import { boolToHex } from 'viem'
     * const data = boolToHex(false)
     * // '0x0'
     *
     * @example
     * import { boolToHex } from 'viem'
     * const data = boolToHex(true, { size: 32 })
     * // '0x0000000000000000000000000000000000000000000000000000000000000001'
     */
    function boolToHex(value, opts = {}) {
        const hex = `0x${Number(value)}`;
        if (typeof opts.size === 'number') {
            assertSize(hex, { size: opts.size });
            return pad(hex, { size: opts.size });
        }
        return hex;
    }
    /**
     * Encodes a bytes array into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { bytesToHex } from 'viem'
     * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
     * // '0x48656c6c6f20576f726c6421'
     *
     * @example
     * import { bytesToHex } from 'viem'
     * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
     * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
     */
    function bytesToHex(value, opts = {}) {
        let hexString = '';
        for (let i = 0; i < value.length; i++) {
            hexString += hexes[value[i]];
        }
        const hex = `0x${hexString}`;
        if (typeof opts.size === 'number') {
            assertSize(hex, { size: opts.size });
            return pad(hex, { dir: 'right', size: opts.size });
        }
        return hex;
    }
    /**
     * Encodes a number or bigint into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { numberToHex } from 'viem'
     * const data = numberToHex(420)
     * // '0x1a4'
     *
     * @example
     * import { numberToHex } from 'viem'
     * const data = numberToHex(420, { size: 32 })
     * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
     */
    function numberToHex(value_, opts = {}) {
        const { signed, size } = opts;
        const value = BigInt(value_);
        let maxValue;
        if (size) {
            if (signed)
                maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
            else
                maxValue = 2n ** (BigInt(size) * 8n) - 1n;
        }
        else if (typeof value_ === 'number') {
            maxValue = BigInt(Number.MAX_SAFE_INTEGER);
        }
        const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
        if ((maxValue && value > maxValue) || value < minValue) {
            const suffix = typeof value_ === 'bigint' ? 'n' : '';
            throw new IntegerOutOfRangeError({
                max: maxValue ? `${maxValue}${suffix}` : undefined,
                min: `${minValue}${suffix}`,
                signed,
                size,
                value: `${value_}${suffix}`,
            });
        }
        const hex = `0x${(signed && value < 0
        ? (1n << BigInt(size * 8)) + BigInt(value)
        : value).toString(16)}`;
        if (size)
            return pad(hex, { size });
        return hex;
    }
    const encoder$1 = /*#__PURE__*/ new TextEncoder();
    /**
     * Encodes a UTF-8 string into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { stringToHex } from 'viem'
     * const data = stringToHex('Hello World!')
     * // '0x48656c6c6f20576f726c6421'
     *
     * @example
     * import { stringToHex } from 'viem'
     * const data = stringToHex('Hello World!', { size: 32 })
     * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
     */
    function stringToHex(value_, opts = {}) {
        const value = encoder$1.encode(value_);
        return bytesToHex(value, opts);
    }

    const encoder = /*#__PURE__*/ new TextEncoder();
    /**
     * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes.html
     * - Example: https://viem.sh/docs/utilities/toBytes.html#usage
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { toBytes } from 'viem'
     * const data = toBytes('Hello world')
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
     *
     * @example
     * import { toBytes } from 'viem'
     * const data = toBytes(420)
     * // Uint8Array([1, 164])
     *
     * @example
     * import { toBytes } from 'viem'
     * const data = toBytes(420, { size: 4 })
     * // Uint8Array([0, 0, 1, 164])
     */
    function toBytes$1(value, opts = {}) {
        if (typeof value === 'number' || typeof value === 'bigint')
            return numberToBytes(value, opts);
        if (typeof value === 'boolean')
            return boolToBytes(value, opts);
        if (isHex(value))
            return hexToBytes(value, opts);
        return stringToBytes(value, opts);
    }
    /**
     * Encodes a boolean into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes
     *
     * @param value Boolean value to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { boolToBytes } from 'viem'
     * const data = boolToBytes(true)
     * // Uint8Array([1])
     *
     * @example
     * import { boolToBytes } from 'viem'
     * const data = boolToBytes(true, { size: 32 })
     * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
     */
    function boolToBytes(value, opts = {}) {
        const bytes = new Uint8Array(1);
        bytes[0] = Number(value);
        if (typeof opts.size === 'number') {
            assertSize(bytes, { size: opts.size });
            return pad(bytes, { size: opts.size });
        }
        return bytes;
    }
    /**
     * Encodes a hex string into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes
     *
     * @param hex Hex string to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { hexToBytes } from 'viem'
     * const data = hexToBytes('0x48656c6c6f20776f726c6421')
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
     *
     * @example
     * import { hexToBytes } from 'viem'
     * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
     */
    function hexToBytes(hex_, opts = {}) {
        let hex = hex_;
        if (opts.size) {
            assertSize(hex, { size: opts.size });
            hex = pad(hex, { dir: 'right', size: opts.size });
        }
        let hexString = hex.slice(2);
        if (hexString.length % 2)
            hexString = `0${hexString}`;
        const bytes = new Uint8Array(hexString.length / 2);
        for (let index = 0; index < bytes.length; index++) {
            const start = index * 2;
            const hexByte = hexString.slice(start, start + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
                throw new BaseError(`Invalid byte sequence ("${hexByte}" in "${hexString}").`);
            bytes[index] = byte;
        }
        return bytes;
    }
    /**
     * Encodes a number into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes
     *
     * @param value Number to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { numberToBytes } from 'viem'
     * const data = numberToBytes(420)
     * // Uint8Array([1, 164])
     *
     * @example
     * import { numberToBytes } from 'viem'
     * const data = numberToBytes(420, { size: 4 })
     * // Uint8Array([0, 0, 1, 164])
     */
    function numberToBytes(value, opts) {
        const hex = numberToHex(value, opts);
        return hexToBytes(hex);
    }
    /**
     * Encodes a UTF-8 string into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes
     *
     * @param value String to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { stringToBytes } from 'viem'
     * const data = stringToBytes('Hello world!')
     * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
     *
     * @example
     * import { stringToBytes } from 'viem'
     * const data = stringToBytes('Hello world!', { size: 32 })
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
     */
    function stringToBytes(value, opts = {}) {
        const bytes = encoder.encode(value);
        if (typeof opts.size === 'number') {
            assertSize(bytes, { size: opts.size });
            return pad(bytes, { dir: 'right', size: opts.size });
        }
        return bytes;
    }

    const paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
    function extractFunctionParts(def) {
        const parts = def.match(paramsRegex);
        const type = parts?.[2] || undefined;
        const name = parts?.[3];
        const params = parts?.[5] || undefined;
        return { type, name, params };
    }
    function extractFunctionName(def) {
        return extractFunctionParts(def).name;
    }
    function extractFunctionParams(def) {
        const params = extractFunctionParts(def).params;
        const splitParams = params?.split(',').map((x) => x.trim().split(' '));
        return splitParams?.map((param) => ({
            type: param[0],
            name: param[1] === 'indexed' ? param[2] : param[1],
            ...(param[1] === 'indexed' ? { indexed: true } : {}),
        }));
    }

    function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`Wrong positive integer: ${n}`);
    }
    function bool(b) {
        if (typeof b !== 'boolean')
            throw new Error(`Expected boolean, not ${b}`);
    }
    function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
            throw new TypeError('Expected Uint8Array');
        if (lengths.length > 0 && !lengths.includes(b.length))
            throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    function hash$1(hash) {
        if (typeof hash !== 'function' || typeof hash.create !== 'function')
            throw new Error('Hash should be wrapped by utils.wrapConstructor');
        number(hash.outputLen);
        number(hash.blockLen);
    }
    function exists(instance, checkFinished = true) {
        if (instance.destroyed)
            throw new Error('Hash instance has been destroyed');
        if (checkFinished && instance.finished)
            throw new Error('Hash#digest() has already been called');
    }
    function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
            throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
    }
    const assert = {
        number,
        bool,
        bytes,
        hash: hash$1,
        exists,
        output,
    };

    const U32_MASK64 = BigInt(2 ** 32 - 1);
    const _32n = BigInt(32);
    // We are not using BigUint64Array, because they are extremely slow as per 2022
    function fromBig(n, le = false) {
        if (le)
            return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
        return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
            const { h, l } = fromBig(lst[i], le);
            [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
    }
    const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
    // for Shift in [0, 32)
    const shrSH = (h, l, s) => h >>> s;
    const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in [1, 32)
    const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
    const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
    const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
    // Right rotate for shift===32 (just swaps l&h)
    const rotr32H = (h, l) => l;
    const rotr32L = (h, l) => h;
    // Left rotate for Shift in [1, 32)
    const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
    const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
    // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
    const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
    // JS uses 32-bit signed integers for bitwise operations which means we cannot
    // simple take carry out of low bit sum by shift, we need to use division.
    // Removing "export" has 5% perf penalty -_-
    function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
    }
    // Addition with more than 2 elements
    const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
    const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
    const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
    // prettier-ignore
    const u64 = {
        fromBig, split, toBig,
        shrSH, shrSL,
        rotrSH, rotrSL, rotrBH, rotrBL,
        rotr32H, rotr32L,
        rotlSH, rotlSL, rotlBH, rotlBL,
        add, add3L, add3H, add4L, add4H, add5H, add5L,
    };

    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // We use `globalThis.crypto`, but node.js versions earlier than v19 don't
    // declare it in global scope. For node.js, package.json#exports field mapping
    // rewrites import from `crypto` to `cryptoNode`, which imports native module.
    // Makes the utils un-importable in browsers without a bundler.
    // Once node.js 18 is deprecated, we can just drop the import.
    const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    // big-endian hardware is rare. Just in case someone still decides to run hashes:
    // early-throw an error because we don't support BE yet.
    const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
    if (!isLE)
        throw new Error('Non little-endian hardware is not supported');
    Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
    function utf8ToBytes(str) {
        if (typeof str !== 'string') {
            throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
        }
        return new TextEncoder().encode(str);
    }
    function toBytes(data) {
        if (typeof data === 'string')
            data = utf8ToBytes(data);
        if (!(data instanceof Uint8Array))
            throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
        return data;
    }
    // For runtime check if class implements interface
    class Hash {
        // Safe version that clones internal state
        clone() {
            return this._cloneInto();
        }
    }
    function wrapConstructor(hashConstructor) {
        const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
        const tmp = hashConstructor();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashConstructor();
        return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
    }

    // Various per round constants calculations
    const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    const _2n = BigInt(2);
    const _7n = BigInt(7);
    const _256n = BigInt(256);
    const _0x71n = BigInt(0x71);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        // Pi
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        // Rotational
        SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
        // Iota
        let t = _0n;
        for (let j = 0; j < 7; j++) {
            R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
            if (R & _2n)
                t ^= _1n << ((_1n << BigInt(j)) - _1n);
        }
        _SHA3_IOTA.push(t);
    }
    const [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);
    // Left rotation (without 0, 32, 64)
    const rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);
    const rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);
    // Same as keccakf1600, but allows to skip some rounds
    function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
        for (let round = 24 - rounds; round < 24; round++) {
            // Theta θ
            for (let x = 0; x < 10; x++)
                B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
            for (let x = 0; x < 10; x += 2) {
                const idx1 = (x + 8) % 10;
                const idx0 = (x + 2) % 10;
                const B0 = B[idx0];
                const B1 = B[idx0 + 1];
                const Th = rotlH(B0, B1, 1) ^ B[idx1];
                const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
                for (let y = 0; y < 50; y += 10) {
                    s[x + y] ^= Th;
                    s[x + y + 1] ^= Tl;
                }
            }
            // Rho (ρ) and Pi (π)
            let curH = s[2];
            let curL = s[3];
            for (let t = 0; t < 24; t++) {
                const shift = SHA3_ROTL[t];
                const Th = rotlH(curH, curL, shift);
                const Tl = rotlL(curH, curL, shift);
                const PI = SHA3_PI[t];
                curH = s[PI];
                curL = s[PI + 1];
                s[PI] = Th;
                s[PI + 1] = Tl;
            }
            // Chi (χ)
            for (let y = 0; y < 50; y += 10) {
                for (let x = 0; x < 10; x++)
                    B[x] = s[y + x];
                for (let x = 0; x < 10; x++)
                    s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
            }
            // Iota (ι)
            s[0] ^= SHA3_IOTA_H[round];
            s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
    }
    class Keccak extends Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
            super();
            this.blockLen = blockLen;
            this.suffix = suffix;
            this.outputLen = outputLen;
            this.enableXOF = enableXOF;
            this.rounds = rounds;
            this.pos = 0;
            this.posOut = 0;
            this.finished = false;
            this.destroyed = false;
            // Can be passed from user as dkLen
            assert.number(outputLen);
            // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
            if (0 >= this.blockLen || this.blockLen >= 200)
                throw new Error('Sha3 supports only keccak-f1600 function');
            this.state = new Uint8Array(200);
            this.state32 = u32(this.state);
        }
        keccak() {
            keccakP(this.state32, this.rounds);
            this.posOut = 0;
            this.pos = 0;
        }
        update(data) {
            assert.exists(this);
            const { blockLen, state } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                for (let i = 0; i < take; i++)
                    state[this.pos++] ^= data[pos++];
                if (this.pos === blockLen)
                    this.keccak();
            }
            return this;
        }
        finish() {
            if (this.finished)
                return;
            this.finished = true;
            const { state, suffix, pos, blockLen } = this;
            // Do the padding
            state[pos] ^= suffix;
            if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
                this.keccak();
            state[blockLen - 1] ^= 0x80;
            this.keccak();
        }
        writeInto(out) {
            assert.exists(this, false);
            assert.bytes(out);
            this.finish();
            const bufferOut = this.state;
            const { blockLen } = this;
            for (let pos = 0, len = out.length; pos < len;) {
                if (this.posOut >= blockLen)
                    this.keccak();
                const take = Math.min(blockLen - this.posOut, len - pos);
                out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
                this.posOut += take;
                pos += take;
            }
            return out;
        }
        xofInto(out) {
            // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
            if (!this.enableXOF)
                throw new Error('XOF is not possible for this instance');
            return this.writeInto(out);
        }
        xof(bytes) {
            assert.number(bytes);
            return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
            assert.output(out, this);
            if (this.finished)
                throw new Error('digest() was already called');
            this.writeInto(out);
            this.destroy();
            return out;
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
            this.destroyed = true;
            this.state.fill(0);
        }
        _cloneInto(to) {
            const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
            to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
            to.state32.set(this.state32);
            to.pos = this.pos;
            to.posOut = this.posOut;
            to.finished = this.finished;
            to.rounds = rounds;
            // Suffix can change in cSHAKE
            to.suffix = suffix;
            to.outputLen = outputLen;
            to.enableXOF = enableXOF;
            to.destroyed = this.destroyed;
            return to;
        }
    }
    const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
    gen(0x06, 144, 224 / 8);
    /**
     * SHA3-256 hash function
     * @param message - that would be hashed
     */
    gen(0x06, 136, 256 / 8);
    gen(0x06, 104, 384 / 8);
    gen(0x06, 72, 512 / 8);
    gen(0x01, 144, 224 / 8);
    /**
     * keccak-256 hash function. Different from SHA3-256.
     * @param message - that would be hashed
     */
    const keccak_256 = gen(0x01, 136, 256 / 8);
    gen(0x01, 104, 384 / 8);
    gen(0x01, 72, 512 / 8);
    const genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
    genShake(0x1f, 168, 128 / 8);
    genShake(0x1f, 136, 256 / 8);

    function keccak256(value, to_) {
        const to = to_ || 'hex';
        const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes$1(value) : value);
        if (to === 'bytes')
            return bytes;
        return toHex(bytes);
    }

    const hash = (value) => keccak256(toBytes$1(value));
    function hashFunction(def) {
        const name = extractFunctionName(def);
        const params = extractFunctionParams(def) || [];
        return hash(`${name}(${params.map(({ type }) => type).join(',')})`);
    }
    function hashAbiItem(def) {
        return hash(`${def.name}(${def.inputs.map(({ type }) => type).join(',')})`);
    }

    const getEventSelector = (event) => {
        if (typeof event === 'string')
            return hashFunction(event);
        return hashAbiItem(event);
    };

    class InvalidAddressError extends BaseError {
        constructor({ address }) {
            super(`Address "${address}" is invalid.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidAddressError'
            });
        }
    }

    const addressRegex = /^0x[a-fA-F0-9]{40}$/;
    function isAddress(address) {
        return addressRegex.test(address);
    }

    function concat(values) {
        if (typeof values[0] === 'string')
            return concatHex(values);
        return concatBytes(values);
    }
    function concatBytes(values) {
        let length = 0;
        for (const arr of values) {
            length += arr.length;
        }
        const result = new Uint8Array(length);
        let offset = 0;
        for (const arr of values) {
            result.set(arr, offset);
            offset += arr.length;
        }
        return result;
    }
    function concatHex(values) {
        return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;
    }

    /**
     * @description Returns a section of the hex or byte array given a start/end bytes offset.
     *
     * @param value The hex or byte array to slice.
     * @param start The start offset (in bytes).
     * @param end The end offset (in bytes).
     */
    function slice(value, start, end, { strict } = {}) {
        if (isHex(value, { strict: false }))
            return sliceHex(value, start, end, {
                strict,
            });
        return sliceBytes(value, start, end, {
            strict,
        });
    }
    function assertStartOffset(value, start) {
        if (typeof start === 'number' && start > 0 && start > size$1(value) - 1)
            throw new SliceOffsetOutOfBoundsError({
                offset: start,
                position: 'start',
                size: size$1(value),
            });
    }
    function assertEndOffset(value, start, end) {
        if (typeof start === 'number' &&
            typeof end === 'number' &&
            size$1(value) !== end - start) {
            throw new SliceOffsetOutOfBoundsError({
                offset: end,
                position: 'end',
                size: size$1(value),
            });
        }
    }
    /**
     * @description Returns a section of the byte array given a start/end bytes offset.
     *
     * @param value The byte array to slice.
     * @param start The start offset (in bytes).
     * @param end The end offset (in bytes).
     */
    function sliceBytes(value_, start, end, { strict } = {}) {
        assertStartOffset(value_, start);
        const value = value_.slice(start, end);
        if (strict)
            assertEndOffset(value, start, end);
        return value;
    }
    /**
     * @description Returns a section of the hex value given a start/end bytes offset.
     *
     * @param value The hex value to slice.
     * @param start The start offset (in bytes).
     * @param end The end offset (in bytes).
     */
    function sliceHex(value_, start, end, { strict } = {}) {
        assertStartOffset(value_, start);
        const value = `0x${value_
        .replace('0x', '')
        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
        if (strict)
            assertEndOffset(value, start, end);
        return value;
    }

    /**
     * @description Encodes a list of primitive values into an ABI-encoded hex value.
     */
    function encodeAbiParameters(params, values) {
        if (params.length !== values.length)
            throw new AbiEncodingLengthMismatchError({
                expectedLength: params.length,
                givenLength: values.length,
            });
        // Prepare the parameters to determine dynamic types to encode.
        const preparedParams = prepareParams({
            params: params,
            values,
        });
        const data = encodeParams(preparedParams);
        if (data.length === 0)
            return '0x';
        return data;
    }
    function prepareParams({ params, values, }) {
        const preparedParams = [];
        for (let i = 0; i < params.length; i++) {
            preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
        }
        return preparedParams;
    }
    function prepareParam({ param, value, }) {
        const arrayComponents = getArrayComponents(param.type);
        if (arrayComponents) {
            const [length, type] = arrayComponents;
            return encodeArray(value, { length, param: { ...param, type } });
        }
        if (param.type === 'tuple') {
            return encodeTuple(value, {
                param: param,
            });
        }
        if (param.type === 'address') {
            return encodeAddress(value);
        }
        if (param.type === 'bool') {
            return encodeBool(value);
        }
        if (param.type.startsWith('uint') || param.type.startsWith('int')) {
            const signed = param.type.startsWith('int');
            return encodeNumber(value, { signed });
        }
        if (param.type.startsWith('bytes')) {
            return encodeBytes(value, { param });
        }
        if (param.type === 'string') {
            return encodeString(value);
        }
        throw new InvalidAbiEncodingTypeError(param.type, {
            docsPath: '/docs/contract/encodeAbiParameters',
        });
    }
    /////////////////////////////////////////////////////////////////
    function encodeParams(preparedParams) {
        // 1. Compute the size of the static part of the parameters.
        let staticSize = 0;
        for (let i = 0; i < preparedParams.length; i++) {
            const { dynamic, encoded } = preparedParams[i];
            if (dynamic)
                staticSize += 32;
            else
                staticSize += size$1(encoded);
        }
        // 2. Split the parameters into static and dynamic parts.
        const staticParams = [];
        const dynamicParams = [];
        let dynamicSize = 0;
        for (let i = 0; i < preparedParams.length; i++) {
            const { dynamic, encoded } = preparedParams[i];
            if (dynamic) {
                staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
                dynamicParams.push(encoded);
                dynamicSize += size$1(encoded);
            }
            else {
                staticParams.push(encoded);
            }
        }
        // 3. Concatenate static and dynamic parts.
        return concat([...staticParams, ...dynamicParams]);
    }
    /////////////////////////////////////////////////////////////////
    function encodeAddress(value) {
        if (!isAddress(value))
            throw new InvalidAddressError({ address: value });
        return { dynamic: false, encoded: padHex(value.toLowerCase()) };
    }
    function encodeArray(value, { length, param, }) {
        const dynamic = length === null;
        if (!Array.isArray(value))
            throw new InvalidArrayError(value);
        if (!dynamic && value.length !== length)
            throw new AbiEncodingArrayLengthMismatchError({
                expectedLength: length,
                givenLength: value.length,
                type: `${param.type}[${length}]`,
            });
        let dynamicChild = false;
        const preparedParams = [];
        for (let i = 0; i < value.length; i++) {
            const preparedParam = prepareParam({ param, value: value[i] });
            if (preparedParam.dynamic)
                dynamicChild = true;
            preparedParams.push(preparedParam);
        }
        if (dynamic || dynamicChild) {
            const data = encodeParams(preparedParams);
            if (dynamic) {
                const length = numberToHex(preparedParams.length, { size: 32 });
                return {
                    dynamic: true,
                    encoded: preparedParams.length > 0 ? concat([length, data]) : length,
                };
            }
            if (dynamicChild)
                return { dynamic: true, encoded: data };
        }
        return {
            dynamic: false,
            encoded: concat(preparedParams.map(({ encoded }) => encoded)),
        };
    }
    function encodeBytes(value, { param }) {
        const [_, size_] = param.type.split('bytes');
        if (!size_) {
            const partsLength = Math.ceil(size$1(value) / 32);
            const parts = [];
            for (let i = 0; i < partsLength; i++) {
                parts.push(padHex(slice(value, i * 32, (i + 1) * 32), {
                    dir: 'right',
                }));
            }
            return {
                dynamic: true,
                encoded: concat([
                    padHex(numberToHex(size$1(value), { size: 32 })),
                    ...parts,
                ]),
            };
        }
        if (size$1(value) !== parseInt(size_))
            throw new AbiEncodingBytesSizeMismatchError({
                expectedSize: parseInt(size_),
                value,
            });
        return { dynamic: false, encoded: padHex(value, { dir: 'right' }) };
    }
    function encodeBool(value) {
        return { dynamic: false, encoded: padHex(boolToHex(value)) };
    }
    function encodeNumber(value, { signed }) {
        return {
            dynamic: false,
            encoded: numberToHex(value, {
                size: 32,
                signed,
            }),
        };
    }
    function encodeString(value) {
        const hexValue = stringToHex(value);
        const partsLength = Math.ceil(size$1(hexValue) / 32);
        const parts = [];
        for (let i = 0; i < partsLength; i++) {
            parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
                dir: 'right',
            }));
        }
        return {
            dynamic: true,
            encoded: concat([
                padHex(numberToHex(size$1(hexValue), { size: 32 })),
                ...parts,
            ]),
        };
    }
    function encodeTuple(value, { param }) {
        let dynamic = false;
        const preparedParams = [];
        for (let i = 0; i < param.components.length; i++) {
            const param_ = param.components[i];
            const index = Array.isArray(value) ? i : param_.name;
            const preparedParam = prepareParam({
                param: param_,
                value: value[index],
            });
            preparedParams.push(preparedParam);
            if (preparedParam.dynamic)
                dynamic = true;
        }
        return {
            dynamic,
            encoded: dynamic
                ? encodeParams(preparedParams)
                : concat(preparedParams.map(({ encoded }) => encoded)),
        };
    }
    function getArrayComponents(type) {
        const matches = type.match(/^(.*)\[(\d+)?\]$/);
        return matches
            ? // Return `null` if the array is dynamic.
                [matches[2] ? Number(matches[2]) : null, matches[1]]
            : undefined;
    }

    function getAbiItem({ abi, args = [], name, }) {
        const abiItems = abi.filter((x) => 'name' in x && x.name === name);
        if (abiItems.length === 0)
            return undefined;
        if (abiItems.length === 1)
            return abiItems[0];
        for (const abiItem of abiItems) {
            if (!('inputs' in abiItem))
                continue;
            if (!args || args.length === 0) {
                if (!abiItem.inputs || abiItem.inputs.length === 0)
                    return abiItem;
                continue;
            }
            if (!abiItem.inputs)
                continue;
            if (abiItem.inputs.length === 0)
                continue;
            if (abiItem.inputs.length !== args.length)
                continue;
            const matched = args.every((arg, index) => {
                const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
                if (!abiParameter)
                    return false;
                return isArgOfType(arg, abiParameter);
            });
            if (matched)
                return abiItem;
        }
        return abiItems[0];
    }
    function isArgOfType(arg, abiParameter) {
        const argType = typeof arg;
        const abiParameterType = abiParameter.type;
        switch (abiParameterType) {
            case 'address':
                return isAddress(arg);
            case 'bool':
                return argType === 'boolean';
            case 'function':
                return argType === 'string';
            case 'string':
                return argType === 'string';
            default: {
                if (abiParameterType === 'tuple' && 'components' in abiParameter)
                    return Object.values(abiParameter.components).every((component, index) => {
                        return isArgOfType(Object.values(arg)[index], component);
                    });
                // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
                // https://regexr.com/6v8hp
                if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
                    return argType === 'number' || argType === 'bigint';
                // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
                // https://regexr.com/6va55
                if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
                    return argType === 'string' || arg instanceof Uint8Array;
                // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays
                // https://regexr.com/6va6i
                if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
                    return (Array.isArray(arg) &&
                        arg.every((x) => isArgOfType(x, {
                            ...abiParameter,
                            // Pop off `[]` or `[M]` from end of type
                            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, ''),
                        })));
                }
                return false;
            }
        }
    }

    function encodeEventTopics({ abi, eventName, args }) {
        let abiItem = abi[0];
        if (eventName) {
            abiItem = getAbiItem({
                abi,
                args,
                name: eventName,
            });
            if (!abiItem)
                throw new AbiEventNotFoundError(eventName, {
                    docsPath: '/docs/contract/encodeEventTopics',
                });
        }
        if (abiItem.type !== 'event')
            throw new AbiEventNotFoundError(undefined, {
                docsPath: '/docs/contract/encodeEventTopics',
            });
        const definition = formatAbiItem(abiItem);
        const signature = getEventSelector(definition);
        let topics = [];
        if (args && 'inputs' in abiItem) {
            const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);
            const args_ = Array.isArray(args)
                ? args
                : Object.values(args).length > 0
                    ? indexedInputs?.map((x) => args[x.name]) ?? []
                    : [];
            if (args_.length > 0) {
                topics =
                    indexedInputs?.map((param, i) => Array.isArray(args_[i])
                        ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }))
                        : args_[i]
                            ? encodeArg({ param, value: args_[i] })
                            : null) ?? [];
            }
        }
        return [signature, ...topics];
    }
    function encodeArg({ param, value, }) {
        if (param.type === 'string' || param.type === 'bytes')
            return keccak256(toBytes$1(value));
        if (param.type === 'tuple' || param.type.match(/^(.*)\[(\d+)?\]$/))
            throw new FilterTypeNotSupportedError(param.type);
        return encodeAbiParameters([param], [value]);
    }

    /**
     * Scopes `request` to the filter ID. If the client is a fallback, it will
     * listen for responses and scope the child transport `request` function
     * to the successful filter ID.
     */
    function createFilterRequestScope(client, { method }) {
        const requestMap = {};
        if (client.transport.type === 'fallback')
            client.transport.onResponse?.(({ method: method_, response: id, status, transport, }) => {
                if (status === 'success' && method === method_)
                    requestMap[id] = transport.request;
            });
        return ((id) => requestMap[id] || client.request);
    }

    /**
     * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html).
     *
     * - Docs: https://viem.sh/docs/contract/createContractEventFilter.html
     *
     * @param client - Client to use
     * @param parameters - {@link CreateContractEventFilterParameters}
     * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateContractEventFilterReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createContractEventFilter } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createContractEventFilter(client, {
     *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
     * })
     */
    async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock, }) {
        const getRequest = createFilterRequestScope(client, {
            method: 'eth_newFilter',
        });
        const topics = eventName
            ? encodeEventTopics({
                abi,
                args,
                eventName,
            })
            : undefined;
        const id = await client.request({
            method: 'eth_newFilter',
            params: [
                {
                    address,
                    fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,
                    toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,
                    topics,
                },
            ],
        });
        return {
            abi,
            args,
            eventName,
            id,
            request: getRequest(id),
            strict,
            type: 'event',
        };
    }

    function parseAccount(account) {
        if (typeof account === 'string')
            return { address: account, type: 'json-rpc' };
        return account;
    }

    const getFunctionSelector = (fn) => {
        if (typeof fn === 'string')
            return slice(hashFunction(fn), 0, 4);
        return slice(hashAbiItem(fn), 0, 4);
    };

    function encodeFunctionData({ abi, args, functionName, }) {
        let abiItem = abi[0];
        if (functionName) {
            abiItem = getAbiItem({
                abi,
                args,
                name: functionName,
            });
            if (!abiItem)
                throw new AbiFunctionNotFoundError(functionName, {
                    docsPath: '/docs/contract/encodeFunctionData',
                });
        }
        if (abiItem.type !== 'function')
            throw new AbiFunctionNotFoundError(undefined, {
                docsPath: '/docs/contract/encodeFunctionData',
            });
        const definition = formatAbiItem(abiItem);
        const signature = getFunctionSelector(definition);
        const data = 'inputs' in abiItem && abiItem.inputs
            ? encodeAbiParameters(abiItem.inputs, (args ?? []))
            : undefined;
        return concatHex([signature, data ?? '0x']);
    }

    // https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require
    const panicReasons = {
        1: 'An `assert` condition failed.',
        17: 'Arithmic operation resulted in underflow or overflow.',
        18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
        33: 'Attempted to convert to an invalid type.',
        34: 'Attempted to access a storage byte array that is incorrectly encoded.',
        49: 'Performed `.pop()` on an empty array',
        50: 'Array index is out of bounds.',
        65: 'Allocated too much memory or created an array which is too large.',
        81: 'Attempted to call a zero-initialized variable of internal function type.',
    };
    const solidityError = {
        inputs: [
            {
                name: 'message',
                type: 'string',
            },
        ],
        name: 'Error',
        type: 'error',
    };
    const solidityPanic = {
        inputs: [
            {
                name: 'reason',
                type: 'uint256',
            },
        ],
        name: 'Panic',
        type: 'error',
    };

    function checksumAddress(address_, chainId) {
        const hexAddress = chainId
            ? `${chainId}${address_.toLowerCase()}`
            : address_.substring(2).toLowerCase();
        const hash = keccak256(stringToBytes(hexAddress), 'bytes');
        const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
        for (let i = 0; i < 40; i += 2) {
            if (hash[i >> 1] >> 4 >= 8 && address[i]) {
                address[i] = address[i].toUpperCase();
            }
            if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
                address[i + 1] = address[i + 1].toUpperCase();
            }
        }
        return `0x${address.join('')}`;
    }
    function getAddress(address, chainId) {
        if (!isAddress(address))
            throw new InvalidAddressError({ address });
        return checksumAddress(address, chainId);
    }

    function decodeAbiParameters(params, data) {
        if (data === '0x' && params.length > 0)
            throw new AbiDecodingZeroDataError();
        if (size$1(data) && size$1(data) < 32)
            throw new AbiDecodingDataSizeTooSmallError({
                data,
                params: params,
                size: size$1(data),
            });
        return decodeParams({
            data,
            params: params,
        });
    }
    function decodeParams({ data, params, }) {
        const decodedValues = [];
        let position = 0;
        for (let i = 0; i < params.length; i++) {
            if (position >= size$1(data))
                throw new AbiDecodingDataSizeTooSmallError({
                    data,
                    params,
                    size: size$1(data),
                });
            const param = params[i];
            const { consumed, value } = decodeParam({ data, param, position });
            decodedValues.push(value);
            // Step across the data by the amount of data consumed by this parameter.
            position += consumed;
        }
        return decodedValues;
    }
    function decodeParam({ data, param, position, }) {
        const arrayComponents = getArrayComponents(param.type);
        if (arrayComponents) {
            const [length, type] = arrayComponents;
            return decodeArray(data, {
                length,
                param: { ...param, type: type },
                position,
            });
        }
        if (param.type === 'tuple') {
            return decodeTuple(data, { param: param, position });
        }
        if (param.type === 'string') {
            return decodeString(data, { position });
        }
        if (param.type.startsWith('bytes')) {
            return decodeBytes(data, { param, position });
        }
        const value = slice(data, position, position + 32, { strict: true });
        if (param.type.startsWith('uint') || param.type.startsWith('int')) {
            return decodeNumber(value, { param });
        }
        if (param.type === 'address') {
            return decodeAddress(value);
        }
        if (param.type === 'bool') {
            return decodeBool(value);
        }
        throw new InvalidAbiDecodingTypeError(param.type, {
            docsPath: '/docs/contract/decodeAbiParameters',
        });
    }
    ////////////////////////////////////////////////////////////////////
    function decodeAddress(value) {
        return { consumed: 32, value: checksumAddress(slice(value, -20)) };
    }
    function decodeArray(data, { param, length, position, }) {
        // If the length of the array is not known in advance (dynamic array),
        // we will need to decode the offset of the array data.
        if (!length) {
            // Get the offset of the array data.
            const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
            // Get the length of the array from the offset.
            const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }));
            let consumed = 0;
            const value = [];
            for (let i = 0; i < length; ++i) {
                const decodedChild = decodeParam({
                    data: slice(data, offset + 32),
                    param,
                    position: consumed,
                });
                consumed += decodedChild.consumed;
                value.push(decodedChild.value);
            }
            return { value, consumed: 32 };
        }
        // If the length of the array is known in advance,
        // and the length of an element deeply nested in the array is not known,
        // we need to decode the offset of the array data.
        if (hasDynamicChild(param)) {
            // Get the child type of the array.
            const arrayComponents = getArrayComponents(param.type);
            // If the child type is not known, the array is dynamic.
            const dynamicChild = !arrayComponents?.[0];
            let consumed = 0;
            const value = [];
            for (let i = 0; i < length; ++i) {
                const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
                const decodedChild = decodeParam({
                    data: slice(data, offset),
                    param,
                    position: dynamicChild ? consumed : i * 32,
                });
                consumed += decodedChild.consumed;
                value.push(decodedChild.value);
            }
            return { value, consumed: 32 };
        }
        // If the length of the array is known in advance,
        // and the length of each element in the array is known,
        // the array data is encoded contiguously after the array.
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            const decodedChild = decodeParam({
                data,
                param,
                position: position + consumed,
            });
            consumed += decodedChild.consumed;
            value.push(decodedChild.value);
        }
        return { value, consumed };
    }
    function decodeBool(value) {
        return { consumed: 32, value: hexToBool(value) };
    }
    function decodeBytes(data, { param, position }) {
        const [_, size] = param.type.split('bytes');
        if (!size) {
            // If we don't have a size, we're dealing with a dynamic-size array
            // so we need to read the offset of the data part first.
            const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
            const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }));
            // If there is no length, we have zero data.
            if (length === 0)
                return { consumed: 32, value: '0x' };
            const value = slice(data, offset + 32, offset + 32 + length, {
                strict: true,
            });
            return { consumed: 32, value };
        }
        const value = slice(data, position, position + parseInt(size), {
            strict: true,
        });
        return { consumed: 32, value };
    }
    function decodeNumber(value, { param }) {
        const signed = param.type.startsWith('int');
        const size = parseInt(param.type.split('int')[1] || '256');
        return {
            consumed: 32,
            value: size > 48
                ? hexToBigInt(value, { signed })
                : hexToNumber(value, { signed }),
        };
    }
    function decodeString(data, { position }) {
        const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
        const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }));
        // If there is no length, we have zero data (empty string).
        if (length === 0)
            return { consumed: 32, value: '' };
        const value = hexToString(trim(slice(data, offset + 32, offset + 32 + length, { strict: true })));
        return { consumed: 32, value };
    }
    function decodeTuple(data, { param, position }) {
        // Tuples can have unnamed components (i.e. they are arrays), so we must
        // determine whether the tuple is named or unnamed. In the case of a named
        // tuple, the value will be an object where each property is the name of the
        // component. In the case of an unnamed tuple, the value will be an array.
        const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
        // Initialize the value to an object or an array, depending on whether the
        // tuple is named or unnamed.
        const value = hasUnnamedChild ? [] : {};
        let consumed = 0;
        // If the tuple has a dynamic child, we must first decode the offset to the
        // tuple data.
        if (hasDynamicChild(param)) {
            const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
            // Decode each component of the tuple, starting at the offset.
            for (let i = 0; i < param.components.length; ++i) {
                const component = param.components[i];
                const decodedChild = decodeParam({
                    data: slice(data, offset),
                    param: component,
                    position: consumed,
                });
                consumed += decodedChild.consumed;
                value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
            }
            return { consumed: 32, value };
        }
        // If the tuple has static children, we can just decode each component
        // in sequence.
        for (let i = 0; i < param.components.length; ++i) {
            const component = param.components[i];
            const decodedChild = decodeParam({
                data,
                param: component,
                position: position + consumed,
            });
            consumed += decodedChild.consumed;
            value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return { consumed, value };
    }
    function hasDynamicChild(param) {
        const { type } = param;
        if (type === 'string')
            return true;
        if (type === 'bytes')
            return true;
        if (type.endsWith('[]'))
            return true;
        if (type === 'tuple')
            return param.components?.some(hasDynamicChild);
        const arrayComponents = getArrayComponents(param.type);
        if (arrayComponents &&
            hasDynamicChild({ ...param, type: arrayComponents[1] }))
            return true;
        return false;
    }

    function decodeErrorResult({ abi, data, }) {
        const signature = slice(data, 0, 4);
        if (signature === '0x')
            throw new AbiDecodingZeroDataError();
        const abi_ = [...(abi || []), solidityError, solidityPanic];
        const abiItem = abi_.find((x) => x.type === 'error' && signature === getFunctionSelector(formatAbiItem(x)));
        if (!abiItem)
            throw new AbiErrorSignatureNotFoundError(signature, {
                docsPath: '/docs/contract/decodeErrorResult',
            });
        return {
            abiItem,
            args: ('inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0
                ? decodeAbiParameters(abiItem.inputs, slice(data, 4))
                : undefined),
            errorName: abiItem.name,
        };
    }

    const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
        const value = typeof value_ === 'bigint' ? value_.toString() : value_;
        return typeof replacer === 'function' ? replacer(key, value) : value;
    }, space);

    function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false, }) {
        if (!('name' in abiItem))
            return;
        if (!('inputs' in abiItem))
            return;
        if (!abiItem.inputs)
            return;
        return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs
        .map((input, i) => `${includeName && input.name ? `${input.name}: ` : ''}${typeof args[i] === 'object' ? stringify(args[i]) : args[i]}`)
        .join(', ')})`;
    }

    const etherUnits = {
        gwei: 9,
        wei: 18,
    };
    const gweiUnits = {
        ether: -9,
        wei: 9,
    };

    function formatUnits(value, decimals) {
        let display = value.toString();
        const negative = display.startsWith('-');
        if (negative)
            display = display.slice(1);
        display = display.padStart(decimals, '0');
        let [integer, fraction] = [
            display.slice(0, display.length - decimals),
            display.slice(display.length - decimals),
        ];
        fraction = fraction.replace(/(0+)$/, '');
        return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
    }

    function formatEther(wei, unit = 'wei') {
        return formatUnits(wei, etherUnits[unit]);
    }

    function formatGwei(wei, unit = 'wei') {
        return formatUnits(wei, gweiUnits[unit]);
    }

    function prettyPrint(args) {
        const entries = Object.entries(args)
            .map(([key, value]) => {
            if (value === undefined || value === false)
                return null;
            return [key, value];
        })
            .filter(Boolean);
        const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
        return entries
            .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
            .join('\n');
    }
    class FeeConflictError extends BaseError {
        constructor() {
            super([
                'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
                'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'FeeConflictError'
            });
        }
    }
    class TransactionExecutionError extends BaseError {
        constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
            const prettyArgs = prettyPrint({
                chain: chain && `${chain?.name} (id: ${chain?.id})`,
                from: account?.address,
                to,
                value: typeof value !== 'undefined' &&
                    `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,
                data,
                gas,
                gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,
                maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                    `${formatGwei(maxFeePerGas)} gwei`,
                maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                    `${formatGwei(maxPriorityFeePerGas)} gwei`,
                nonce,
            });
            super(cause.shortMessage, {
                cause,
                docsPath,
                metaMessages: [
                    ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                    'Request Arguments:',
                    prettyArgs,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "cause", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TransactionExecutionError'
            });
            this.cause = cause;
        }
    }
    class TransactionNotFoundError extends BaseError {
        constructor({ blockHash, blockNumber, blockTag, hash, index, }) {
            let identifier = 'Transaction';
            if (blockTag && index !== undefined)
                identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
            if (blockHash && index !== undefined)
                identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
            if (blockNumber && index !== undefined)
                identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
            if (hash)
                identifier = `Transaction with hash "${hash}"`;
            super(`${identifier} could not be found.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TransactionNotFoundError'
            });
        }
    }
    class TransactionReceiptNotFoundError extends BaseError {
        constructor({ hash }) {
            super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TransactionReceiptNotFoundError'
            });
        }
    }
    class WaitForTransactionReceiptTimeoutError extends BaseError {
        constructor({ hash }) {
            super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'WaitForTransactionReceiptTimeoutError'
            });
        }
    }

    class CallExecutionError extends BaseError {
        constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
            const account = account_ ? parseAccount(account_) : undefined;
            const prettyArgs = prettyPrint({
                from: account?.address,
                to,
                value: typeof value !== 'undefined' &&
                    `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,
                data,
                gas,
                gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,
                maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                    `${formatGwei(maxFeePerGas)} gwei`,
                maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                    `${formatGwei(maxPriorityFeePerGas)} gwei`,
                nonce,
            });
            super(cause.shortMessage, {
                cause,
                docsPath,
                metaMessages: [
                    ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                    'Raw Call Arguments:',
                    prettyArgs,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "cause", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'CallExecutionError'
            });
            this.cause = cause;
        }
    }
    class ContractFunctionExecutionError extends BaseError {
        constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender, }) {
            const abiItem = getAbiItem({ abi, args, name: functionName });
            const formattedArgs = abiItem
                ? formatAbiItemWithArgs({
                    abiItem,
                    args,
                    includeFunctionName: false,
                    includeName: false,
                })
                : undefined;
            const functionWithParams = abiItem
                ? formatAbiItem(abiItem, { includeName: true })
                : undefined;
            const prettyArgs = prettyPrint({
                address: contractAddress && getContractAddress(contractAddress),
                function: functionWithParams,
                args: formattedArgs &&
                    formattedArgs !== '()' &&
                    `${[...Array(functionName?.length ?? 0).keys()]
                    .map(() => ' ')
                    .join('')}${formattedArgs}`,
                sender,
            });
            super(cause.shortMessage ||
                `An unknown error occurred while executing the contract function "${functionName}".`, {
                cause,
                docsPath,
                metaMessages: [
                    ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                    'Contract Call:',
                    prettyArgs,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "abi", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "args", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "cause", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "contractAddress", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "formattedArgs", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "functionName", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "sender", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ContractFunctionExecutionError'
            });
            this.abi = abi;
            this.args = args;
            this.cause = cause;
            this.contractAddress = contractAddress;
            this.functionName = functionName;
            this.sender = sender;
        }
    }
    class ContractFunctionRevertedError extends BaseError {
        constructor({ abi, data, functionName, message, }) {
            let cause;
            let decodedData = undefined;
            let metaMessages;
            let reason;
            if (data && data !== '0x') {
                try {
                    decodedData = decodeErrorResult({ abi, data });
                    const { abiItem, errorName, args: errorArgs } = decodedData;
                    if (errorName === 'Error') {
                        reason = errorArgs[0];
                    }
                    else if (errorName === 'Panic') {
                        const [firstArg] = errorArgs;
                        reason = panicReasons[firstArg];
                    }
                    else {
                        const errorWithParams = abiItem
                            ? formatAbiItem(abiItem, { includeName: true })
                            : undefined;
                        const formattedArgs = abiItem && errorArgs
                            ? formatAbiItemWithArgs({
                                abiItem,
                                args: errorArgs,
                                includeFunctionName: false,
                                includeName: false,
                            })
                            : undefined;
                        metaMessages = [
                            errorWithParams ? `Error: ${errorWithParams}` : '',
                            formattedArgs && formattedArgs !== '()'
                                ? `       ${[...Array(errorName?.length ?? 0).keys()]
                                .map(() => ' ')
                                .join('')}${formattedArgs}`
                                : '',
                        ];
                    }
                }
                catch (err) {
                    cause = err;
                }
            }
            else if (message)
                reason = message;
            let signature;
            if (cause instanceof AbiErrorSignatureNotFoundError) {
                signature = cause.signature;
                metaMessages = [
                    `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
                    'Make sure you are using the correct ABI and that the error exists on it.',
                    `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
                ];
            }
            super((reason && reason !== 'execution reverted') || signature
                ? [
                    `The contract function "${functionName}" reverted with the following ${signature ? 'signature' : 'reason'}:`,
                    reason || signature,
                ].join('\n')
                : `The contract function "${functionName}" reverted.`, {
                cause,
                metaMessages,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ContractFunctionRevertedError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "reason", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "signature", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = decodedData;
            this.reason = reason;
            this.signature = signature;
        }
    }
    class ContractFunctionZeroDataError extends BaseError {
        constructor({ functionName }) {
            super(`The contract function "${functionName}" returned no data ("0x").`, {
                metaMessages: [
                    'This could be due to any of the following:',
                    `  - The contract does not have the function "${functionName}",`,
                    '  - The parameters passed to the contract function may be invalid, or',
                    '  - The address is not a contract.',
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ContractFunctionZeroDataError'
            });
        }
    }
    class RawContractError extends BaseError {
        constructor({ data, message, }) {
            super(message || '');
            Object.defineProperty(this, "code", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 3
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'RawContractError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = data;
        }
    }

    const EXECUTION_REVERTED_ERROR_CODE = 3;
    function getContractError(err, { abi, address, args, docsPath, functionName, sender, }) {
        const { code, data, message, shortMessage } = (err instanceof RawContractError
            ? err
            : err instanceof BaseError
                ? err.walk((err) => 'data' in err) || err.walk()
                : {});
        let cause = err;
        if (err instanceof AbiDecodingZeroDataError) {
            cause = new ContractFunctionZeroDataError({ functionName });
        }
        else if (code === EXECUTION_REVERTED_ERROR_CODE &&
            (data || message || shortMessage)) {
            cause = new ContractFunctionRevertedError({
                abi,
                data: typeof data === 'object' ? data.data : data,
                functionName,
                message: shortMessage ?? message,
            });
        }
        return new ContractFunctionExecutionError(cause, {
            abi,
            args,
            contractAddress: address,
            docsPath,
            functionName,
            sender,
        });
    }

    class AccountNotFoundError extends BaseError {
        constructor({ docsPath } = {}) {
            super([
                'Could not find an Account to execute with this Action.',
                'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.',
            ].join('\n'), {
                docsPath,
                docsSlug: 'account',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AccountNotFoundError'
            });
        }
    }

    class EstimateGasExecutionError extends BaseError {
        constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
            const prettyArgs = prettyPrint({
                from: account?.address,
                to,
                value: typeof value !== 'undefined' &&
                    `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,
                data,
                gas,
                gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,
                maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                    `${formatGwei(maxFeePerGas)} gwei`,
                maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                    `${formatGwei(maxPriorityFeePerGas)} gwei`,
                nonce,
            });
            super(cause.shortMessage, {
                cause,
                docsPath,
                metaMessages: [
                    ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                    'Estimate Gas Arguments:',
                    prettyArgs,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "cause", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EstimateGasExecutionError'
            });
            this.cause = cause;
        }
    }

    /**
     * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go
     *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41
     *
     * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go
     *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46
     *
     * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108
     */
    class ExecutionRevertedError extends BaseError {
        constructor({ cause, message, } = {}) {
            const reason = message
                ?.replace('execution reverted: ', '')
                ?.replace('execution reverted', '');
            super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ExecutionRevertedError'
            });
        }
    }
    Object.defineProperty(ExecutionRevertedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /execution reverted/
    });
    class FeeCapTooHighError extends BaseError {
        constructor({ cause, maxFeePerGas, } = {}) {
            super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'FeeCapTooHigh'
            });
        }
    }
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    class FeeCapTooLowError extends BaseError {
        constructor({ cause, maxFeePerGas, } = {}) {
            super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'FeeCapTooLow'
            });
        }
    }
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    class NonceTooHighError extends BaseError {
        constructor({ cause, nonce } = {}) {
            super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, { cause });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'NonceTooHighError'
            });
        }
    }
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too high/
    });
    class NonceTooLowError extends BaseError {
        constructor({ cause, nonce } = {}) {
            super([
                `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`,
                'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',
            ].join('\n'), { cause });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'NonceTooLowError'
            });
        }
    }
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too low|transaction already imported/
    });
    class NonceMaxValueError extends BaseError {
        constructor({ cause, nonce } = {}) {
            super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, { cause });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'NonceMaxValueError'
            });
        }
    }
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce has max value/
    });
    class InsufficientFundsError extends BaseError {
        constructor({ cause } = {}) {
            super([
                'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',
            ].join('\n'), {
                cause,
                metaMessages: [
                    'This error could arise when the account does not have enough funds to:',
                    ' - pay for the total gas fee,',
                    ' - pay for the value to send.',
                    ' ',
                    'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
                    ' - `gas` is the amount of gas needed for transaction to execute,',
                    ' - `gas fee` is the gas fee,',
                    ' - `value` is the amount of ether to send to the recipient.',
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InsufficientFundsError'
            });
        }
    }
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /insufficient funds/
    });
    class IntrinsicGasTooHighError extends BaseError {
        constructor({ cause, gas } = {}) {
            super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'IntrinsicGasTooHighError'
            });
        }
    }
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too high|gas limit reached/
    });
    class IntrinsicGasTooLowError extends BaseError {
        constructor({ cause, gas } = {}) {
            super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'IntrinsicGasTooLowError'
            });
        }
    }
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too low/
    });
    class TransactionTypeNotSupportedError extends BaseError {
        constructor({ cause }) {
            super('The transaction type is not supported for this chain.', {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TransactionTypeNotSupportedError'
            });
        }
    }
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /transaction type not valid/
    });
    class TipAboveFeeCapError extends BaseError {
        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas, } = {}) {
            super([
                `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas
                ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`
                : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}).`,
            ].join('\n'), {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TipAboveFeeCapError'
            });
        }
    }
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    class UnknownNodeError extends BaseError {
        constructor({ cause }) {
            super(`An error occurred while executing: ${cause?.message}`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnknownNodeError'
            });
        }
    }

    class HttpRequestError extends BaseError {
        constructor({ body, details, headers, status, url, }) {
            super('HTTP request failed.', {
                details,
                metaMessages: [
                    status && `Status: ${status}`,
                    `URL: ${getUrl(url)}`,
                    body && `Request body: ${stringify(body)}`,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'HttpRequestError'
            });
            Object.defineProperty(this, "body", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "headers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "status", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "url", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.body = body;
            this.headers = headers;
            this.status = status;
            this.url = url;
        }
    }
    class WebSocketRequestError extends BaseError {
        constructor({ body, details, url, }) {
            super('WebSocket request failed.', {
                details,
                metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'WebSocketRequestError'
            });
        }
    }
    class RpcRequestError extends BaseError {
        constructor({ body, error, url, }) {
            super('RPC Request failed.', {
                cause: error,
                details: error.message,
                metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'RpcRequestError'
            });
            Object.defineProperty(this, "code", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.code = error.code;
        }
    }
    class TimeoutError extends BaseError {
        constructor({ body, url, }) {
            super('The request took too long to respond.', {
                details: 'The request timed out.',
                metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TimeoutError'
            });
        }
    }

    const unknownErrorCode = -1;
    /**
     * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.
     *
     * - EIP https://eips.ethereum.org/EIPS/eip-1474
     */
    class RpcError extends BaseError {
        constructor(cause, { code, docsPath, metaMessages, shortMessage }) {
            super(shortMessage, {
                cause,
                docsPath,
                metaMessages: metaMessages || cause?.metaMessages,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'RpcError'
            });
            Object.defineProperty(this, "code", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.name = cause.name;
            this.code = (cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode);
        }
    }
    /**
     * Error subclass implementing Ethereum Provider errors per EIP-1193.
     *
     * - EIP https://eips.ethereum.org/EIPS/eip-1193
     */
    class ProviderRpcError extends RpcError {
        constructor(cause, options) {
            super(cause, options);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ProviderRpcError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = options.data;
        }
    }
    /**
     * Subclass for a "Parse error" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class ParseRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: ParseRpcError.code,
                shortMessage: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ParseRpcError'
            });
        }
    }
    Object.defineProperty(ParseRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32700
    });
    /**
     * Subclass for a "Invalid request" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class InvalidRequestRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InvalidRequestRpcError.code,
                shortMessage: 'JSON is not a valid request object.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidRequestRpcError'
            });
        }
    }
    Object.defineProperty(InvalidRequestRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32600
    });
    /**
     * Subclass for a "Method not found" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class MethodNotFoundRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: MethodNotFoundRpcError.code,
                shortMessage: 'The method does not exist / is not available.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'MethodNotFoundRpcError'
            });
        }
    }
    Object.defineProperty(MethodNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32601
    });
    /**
     * Subclass for an "Invalid params" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class InvalidParamsRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InvalidParamsRpcError.code,
                shortMessage: [
                    'Invalid parameters were provided to the RPC method.',
                    'Double check you have provided the correct parameters.',
                ].join('\n'),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidParamsRpcError'
            });
        }
    }
    Object.defineProperty(InvalidParamsRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32602
    });
    /**
     * Subclass for an "Internal error" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class InternalRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InternalRpcError.code,
                shortMessage: 'An internal error was received.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InternalRpcError'
            });
        }
    }
    Object.defineProperty(InternalRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32603
    });
    /**
     * Subclass for an "Invalid input" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class InvalidInputRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InvalidInputRpcError.code,
                shortMessage: [
                    'Missing or invalid parameters.',
                    'Double check you have provided the correct parameters.',
                ].join('\n'),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidInputRpcError'
            });
        }
    }
    Object.defineProperty(InvalidInputRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32000
    });
    /**
     * Subclass for a "Resource not found" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class ResourceNotFoundRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: ResourceNotFoundRpcError.code,
                shortMessage: 'Requested resource not found.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ResourceNotFoundRpcError'
            });
        }
    }
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32001
    });
    /**
     * Subclass for a "Resource unavailable" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class ResourceUnavailableRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: ResourceUnavailableRpcError.code,
                shortMessage: 'Requested resource not available.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ResourceUnavailableRpcError'
            });
        }
    }
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32002
    });
    /**
     * Subclass for a "Transaction rejected" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class TransactionRejectedRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: TransactionRejectedRpcError.code,
                shortMessage: 'Transaction creation failed.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TransactionRejectedRpcError'
            });
        }
    }
    Object.defineProperty(TransactionRejectedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32003
    });
    /**
     * Subclass for a "Method not supported" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class MethodNotSupportedRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: MethodNotSupportedRpcError.code,
                shortMessage: 'Method is not implemented.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'MethodNotSupportedRpcError'
            });
        }
    }
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32004
    });
    /**
     * Subclass for a "Limit exceeded" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class LimitExceededRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: LimitExceededRpcError.code,
                shortMessage: 'Request exceeds defined limit.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'LimitExceededRpcError'
            });
        }
    }
    Object.defineProperty(LimitExceededRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32005
    });
    /**
     * Subclass for a "JSON-RPC version not supported" EIP-1474 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
     */
    class JsonRpcVersionUnsupportedError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: JsonRpcVersionUnsupportedError.code,
                shortMessage: 'Version of JSON-RPC protocol is not supported.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'JsonRpcVersionUnsupportedError'
            });
        }
    }
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32006
    });
    /**
     * Subclass for a "User Rejected Request" EIP-1193 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
     */
    class UserRejectedRequestError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: UserRejectedRequestError.code,
                shortMessage: 'User rejected the request.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UserRejectedRequestError'
            });
        }
    }
    Object.defineProperty(UserRejectedRequestError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4001
    });
    /**
     * Subclass for an "Unauthorized" EIP-1193 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
     */
    class UnauthorizedProviderError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: UnauthorizedProviderError.code,
                shortMessage: 'The requested method and/or account has not been authorized by the user.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnauthorizedProviderError'
            });
        }
    }
    Object.defineProperty(UnauthorizedProviderError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4100
    });
    /**
     * Subclass for an "Unsupported Method" EIP-1193 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
     */
    class UnsupportedProviderMethodError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: UnsupportedProviderMethodError.code,
                shortMessage: 'The Provider does not support the requested method.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnsupportedProviderMethodError'
            });
        }
    }
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4200
    });
    /**
     * Subclass for an "Disconnected" EIP-1193 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
     */
    class ProviderDisconnectedError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: ProviderDisconnectedError.code,
                shortMessage: 'The Provider is disconnected from all chains.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ProviderDisconnectedError'
            });
        }
    }
    Object.defineProperty(ProviderDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4900
    });
    /**
     * Subclass for an "Chain Disconnected" EIP-1193 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
     */
    class ChainDisconnectedError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: ChainDisconnectedError.code,
                shortMessage: 'The Provider is not connected to the requested chain.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ChainDisconnectedError'
            });
        }
    }
    Object.defineProperty(ChainDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4901
    });
    /**
     * Subclass for an "Switch Chain" EIP-1193 error.
     *
     * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
     */
    class SwitchChainError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: SwitchChainError.code,
                shortMessage: 'An error occurred when attempting to switch chain.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SwitchChainError'
            });
        }
    }
    Object.defineProperty(SwitchChainError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4902
    });
    /**
     * Subclass for an unknown RPC error.
     */
    class UnknownRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                shortMessage: 'An unknown RPC error occurred.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnknownRpcError'
            });
        }
    }

    function containsNodeError(err) {
        return (err instanceof TransactionRejectedRpcError ||
            err instanceof InvalidInputRpcError ||
            (err instanceof RpcRequestError && err.code === ExecutionRevertedError.code));
    }
    function getNodeError(err, args) {
        const message = err.details.toLowerCase();
        if (FeeCapTooHighError.nodeMessage.test(message))
            return new FeeCapTooHighError({
                cause: err,
                maxFeePerGas: args?.maxFeePerGas,
            });
        else if (FeeCapTooLowError.nodeMessage.test(message))
            return new FeeCapTooLowError({
                cause: err,
                maxFeePerGas: args?.maxFeePerGas,
            });
        else if (NonceTooHighError.nodeMessage.test(message))
            return new NonceTooHighError({ cause: err, nonce: args?.nonce });
        else if (NonceTooLowError.nodeMessage.test(message))
            return new NonceTooLowError({ cause: err, nonce: args?.nonce });
        else if (NonceMaxValueError.nodeMessage.test(message))
            return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
        else if (InsufficientFundsError.nodeMessage.test(message))
            return new InsufficientFundsError({ cause: err });
        else if (IntrinsicGasTooHighError.nodeMessage.test(message))
            return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
        else if (IntrinsicGasTooLowError.nodeMessage.test(message))
            return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
        else if (TransactionTypeNotSupportedError.nodeMessage.test(message))
            return new TransactionTypeNotSupportedError({ cause: err });
        else if (TipAboveFeeCapError.nodeMessage.test(message))
            return new TipAboveFeeCapError({
                cause: err,
                maxFeePerGas: args?.maxFeePerGas,
                maxPriorityFeePerGas: args?.maxPriorityFeePerGas,
            });
        else if (message.match(ExecutionRevertedError.nodeMessage) ||
            ('code' in err.cause &&
                err.cause?.code === ExecutionRevertedError.code))
            return new ExecutionRevertedError({
                cause: err,
                message: err.cause.details || err.details,
            });
        return new UnknownNodeError({
            cause: err.cause.cause,
        });
    }

    function getEstimateGasError(err, { docsPath, ...args }) {
        let cause = err;
        if (containsNodeError(err))
            cause = getNodeError(err, args);
        return new EstimateGasExecutionError(cause, {
            docsPath,
            ...args,
        });
    }

    /**
     * @description Picks out the keys from `value` that exist in the formatter.
     */
    function extract(value, { format }) {
        if (!format)
            return {};
        const keys = Object.keys(format({}));
        return keys.reduce((data, key) => {
            // rome-ignore lint/suspicious/noPrototypeBuiltins:
            if (value?.hasOwnProperty(key)) {
                data[key] = value[key];
            }
            return data;
        }, {});
    }

    function formatTransactionRequest(transactionRequest) {
        return {
            ...transactionRequest,
            gas: typeof transactionRequest.gas !== 'undefined'
                ? numberToHex(transactionRequest.gas)
                : undefined,
            gasPrice: typeof transactionRequest.gasPrice !== 'undefined'
                ? numberToHex(transactionRequest.gasPrice)
                : undefined,
            maxFeePerGas: typeof transactionRequest.maxFeePerGas !== 'undefined'
                ? numberToHex(transactionRequest.maxFeePerGas)
                : undefined,
            maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== 'undefined'
                ? numberToHex(transactionRequest.maxPriorityFeePerGas)
                : undefined,
            nonce: typeof transactionRequest.nonce !== 'undefined'
                ? numberToHex(transactionRequest.nonce)
                : undefined,
            value: typeof transactionRequest.value !== 'undefined'
                ? numberToHex(transactionRequest.value)
                : undefined,
        };
    }

    function assertRequest(args) {
        const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to, } = args;
        const account = account_ ? parseAccount(account_) : undefined;
        if (account && !isAddress(account.address))
            throw new InvalidAddressError({ address: account.address });
        if (to && !isAddress(to))
            throw new InvalidAddressError({ address: to });
        if (typeof gasPrice !== 'undefined' &&
            (typeof maxFeePerGas !== 'undefined' ||
                typeof maxPriorityFeePerGas !== 'undefined'))
            throw new FeeConflictError();
        if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
            throw new FeeCapTooHighError({ maxFeePerGas });
        if (maxPriorityFeePerGas &&
            maxFeePerGas &&
            maxPriorityFeePerGas > maxFeePerGas)
            throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }

    class BlockNotFoundError extends BaseError {
        constructor({ blockHash, blockNumber, }) {
            let identifier = 'Block';
            if (blockHash)
                identifier = `Block at hash "${blockHash}"`;
            if (blockNumber)
                identifier = `Block at number "${blockNumber}"`;
            super(`${identifier} could not be found.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'BlockNotFoundError'
            });
        }
    }

    const transactionType = {
        '0x0': 'legacy',
        '0x1': 'eip2930',
        '0x2': 'eip1559',
    };
    function formatTransaction(transaction) {
        const transaction_ = {
            ...transaction,
            blockHash: transaction.blockHash ? transaction.blockHash : null,
            blockNumber: transaction.blockNumber
                ? BigInt(transaction.blockNumber)
                : null,
            chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,
            gas: transaction.gas ? BigInt(transaction.gas) : undefined,
            gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
            maxFeePerGas: transaction.maxFeePerGas
                ? BigInt(transaction.maxFeePerGas)
                : undefined,
            maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
                ? BigInt(transaction.maxPriorityFeePerGas)
                : undefined,
            nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,
            to: transaction.to ? transaction.to : null,
            transactionIndex: transaction.transactionIndex
                ? Number(transaction.transactionIndex)
                : null,
            type: transaction.type ? transactionType[transaction.type] : undefined,
            typeHex: transaction.type ? transaction.type : undefined,
            value: transaction.value ? BigInt(transaction.value) : undefined,
            v: transaction.v ? BigInt(transaction.v) : undefined,
        };
        if (transaction_.type === 'legacy') {
            delete transaction_['accessList'];
            delete transaction_['maxFeePerGas'];
            delete transaction_['maxPriorityFeePerGas'];
        }
        if (transaction_.type === 'eip2930') {
            delete transaction_['maxFeePerGas'];
            delete transaction_['maxPriorityFeePerGas'];
        }
        return transaction_;
    }

    function formatBlock(block) {
        const transactions = block.transactions?.map((transaction) => {
            if (typeof transaction === 'string')
                return transaction;
            return formatTransaction(transaction);
        });
        return {
            ...block,
            baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
            difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
            gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
            gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
            hash: block.hash ? block.hash : null,
            logsBloom: block.logsBloom ? block.logsBloom : null,
            nonce: block.nonce ? block.nonce : null,
            number: block.number ? BigInt(block.number) : null,
            size: block.size ? BigInt(block.size) : undefined,
            timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
            transactions,
            totalDifficulty: block.totalDifficulty
                ? BigInt(block.totalDifficulty)
                : null,
        };
    }

    /**
     * Returns information about a block at a block number, hash, or tag.
     *
     * - Docs: https://viem.sh/docs/actions/public/getBlock.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks
     * - JSON-RPC Methods:
     *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.
     *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.
     *
     * @param client - Client to use
     * @param parameters - {@link GetBlockParameters}
     * @returns Information about the block. {@link GetBlockReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getBlock } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const block = await getBlock(client)
     */
    async function getBlock(client, { blockHash, blockNumber, blockTag = 'latest', includeTransactions = false, } = {}) {
        const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
        let block = null;
        if (blockHash) {
            block = await client.request({
                method: 'eth_getBlockByHash',
                params: [blockHash, includeTransactions],
            });
        }
        else {
            block = await client.request({
                method: 'eth_getBlockByNumber',
                params: [blockNumberHex || blockTag, includeTransactions],
            });
        }
        if (!block)
            throw new BlockNotFoundError({ blockHash, blockNumber });
        const format = client.chain?.formatters?.block?.format || formatBlock;
        return format(block);
    }

    /**
     * Returns the current price of gas (in wei).
     *
     * - Docs: https://viem.sh/docs/actions/public/getGasPrice.html
     * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)
     *
     * @param client - Client to use
     * @returns The gas price (in wei). {@link GetGasPriceReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getGasPrice } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const gasPrice = await getGasPrice(client)
     */
    async function getGasPrice(client) {
        const gasPrice = await client.request({
            method: 'eth_gasPrice',
        });
        return BigInt(gasPrice);
    }

    /**
     * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent.
     *
     * - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html
     * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)
     *
     * @param client - Client to use
     * @param parameters - {@link GetTransactionCountParameters}
     * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getTransactionCount } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const transactionCount = await getTransactionCount(client, {
     *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     * })
     */
    async function getTransactionCount(client, { address, blockTag = 'latest', blockNumber }) {
        const count = await client.request({
            method: 'eth_getTransactionCount',
            params: [address, blockNumber ? numberToHex(blockNumber) : blockTag],
        });
        return hexToNumber(count);
    }

    const defaultTip = 1500000000n; // 1.5 gwei
    async function prepareRequest(client, args) {
        const { account: account_, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, } = args;
        if (!account_)
            throw new AccountNotFoundError();
        const account = parseAccount(account_);
        const block = await getBlock(client, { blockTag: 'latest' });
        const request = { ...args, from: account.address };
        if (typeof nonce === 'undefined')
            request.nonce = await getTransactionCount(client, {
                address: account.address,
                blockTag: 'pending',
            });
        if (typeof block.baseFeePerGas === 'bigint') {
            if (typeof gasPrice !== 'undefined')
                throw new BaseError('Chain does not support legacy `gasPrice`.');
            // EIP-1559 fees
            if (typeof maxFeePerGas === 'undefined') {
                // Set a buffer of 1.2x on top of the base fee to account for fluctuations.
                request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
                request.maxFeePerGas =
                    (block.baseFeePerGas * 120n) / 100n + request.maxPriorityFeePerGas;
            }
            else {
                if (typeof maxPriorityFeePerGas === 'undefined' &&
                    maxFeePerGas < defaultTip)
                    throw new BaseError('`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).');
                request.maxFeePerGas = maxFeePerGas;
                request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
            }
        }
        else {
            if (typeof maxFeePerGas !== 'undefined' ||
                typeof maxPriorityFeePerGas !== 'undefined')
                throw new BaseError('Chain does not support EIP-1559 fees.');
            // Legacy fees
            if (typeof gasPrice === 'undefined')
                // Set a buffer of 1.2x on top of the base fee to account for fluctuations.
                request.gasPrice = ((await getGasPrice(client)) * 120n) / 100n;
        }
        if (typeof gas === 'undefined')
            request.gas = await estimateGas(client, {
                ...request,
                account: { address: account.address, type: 'json-rpc' },
            });
        assertRequest(request);
        return request;
    }

    /**
     * Estimates the gas necessary to complete a transaction without submitting it to the network.
     *
     * - Docs: https://viem.sh/docs/actions/public/estimateGas.html
     * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)
     *
     * @param client - Client to use
     * @param parameters - {@link EstimateGasParameters}
     * @returns The gas estimate (in wei). {@link EstimateGasReturnType}
     *
     * @example
     * import { createPublicClient, http, parseEther } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { estimateGas } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const gasEstimate = await estimateGas(client, {
     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
     *   value: parseEther('1'),
     * })
     */
    async function estimateGas(client, args) {
        const account_ = args.account ?? client.account;
        if (!account_)
            throw new AccountNotFoundError({
                docsPath: '/docs/actions/public/estimateGas',
            });
        const account = parseAccount(account_);
        try {
            const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === 'local' ? await prepareRequest(client, args) : args;
            const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
            const block = blockNumberHex || blockTag;
            assertRequest(args);
            const format = client.chain?.formatters?.transactionRequest?.format ||
                formatTransactionRequest;
            const request = format({
                // Pick out extra data that might exist on the chain's transaction request type.
                ...extract(rest, { format }),
                from: account.address,
                accessList,
                data,
                gas,
                gasPrice,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                value,
            });
            const balance = await client.request({
                method: 'eth_estimateGas',
                params: block ? [request, block] : [request],
            });
            return BigInt(balance);
        }
        catch (err) {
            throw getEstimateGasError(err, {
                ...args,
                account,
                chain: client.chain,
            });
        }
    }

    /**
     * Estimates the gas required to successfully execute a contract write function call.
     *
     * - Docs: https://viem.sh/docs/contract/estimateContractGas.html
     *
     * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
     *
     * @param client - Client to use
     * @param parameters - {@link EstimateContractGasParameters}
     * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { estimateContractGas } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const gas = await estimateContractGas(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi(['function mint() public']),
     *   functionName: 'mint',
     *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
     * })
     */
    async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
        const data = encodeFunctionData({
            abi,
            args,
            functionName,
        });
        try {
            const gas = await estimateGas(client, {
                data,
                to: address,
                ...request,
            });
            return gas;
        }
        catch (err) {
            const account = request.account ? parseAccount(request.account) : undefined;
            throw getContractError(err, {
                abi: abi,
                address,
                args,
                docsPath: '/docs/contract/simulateContract',
                functionName,
                sender: account?.address,
            });
        }
    }

    const docsPath$2 = '/docs/contract/decodeFunctionResult';
    function decodeFunctionResult({ abi, args, functionName, data, }) {
        let abiItem = abi[0];
        if (functionName) {
            abiItem = getAbiItem({
                abi,
                args,
                name: functionName,
            });
            if (!abiItem)
                throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$2 });
        }
        if (abiItem.type !== 'function')
            throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath$2 });
        if (!abiItem.outputs)
            throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$2 });
        const values = decodeAbiParameters(abiItem.outputs, data);
        if (values && values.length > 1)
            return values;
        if (values && values.length === 1)
            return values[0];
        return undefined;
    }

    /* [Multicall3](https://github.com/mds1/multicall) */
    const multicall3Abi = [
        {
            inputs: [
                {
                    components: [
                        {
                            name: 'target',
                            type: 'address',
                        },
                        {
                            name: 'allowFailure',
                            type: 'bool',
                        },
                        {
                            name: 'callData',
                            type: 'bytes',
                        },
                    ],
                    name: 'calls',
                    type: 'tuple[]',
                },
            ],
            name: 'aggregate3',
            outputs: [
                {
                    components: [
                        {
                            name: 'success',
                            type: 'bool',
                        },
                        {
                            name: 'returnData',
                            type: 'bytes',
                        },
                    ],
                    name: 'returnData',
                    type: 'tuple[]',
                },
            ],
            stateMutability: 'view',
            type: 'function',
        },
    ];
    const universalResolverErrors = [
        {
            inputs: [],
            name: 'ResolverNotFound',
            type: 'error',
        },
        {
            inputs: [],
            name: 'ResolverWildcardNotSupported',
            type: 'error',
        },
    ];
    const universalResolverResolveAbi = [
        ...universalResolverErrors,
        {
            name: 'resolve',
            type: 'function',
            stateMutability: 'view',
            inputs: [
                { name: 'name', type: 'bytes' },
                { name: 'data', type: 'bytes' },
            ],
            outputs: [
                { name: '', type: 'bytes' },
                { name: 'address', type: 'address' },
            ],
        },
    ];
    const universalResolverReverseAbi = [
        ...universalResolverErrors,
        {
            name: 'reverse',
            type: 'function',
            stateMutability: 'view',
            inputs: [{ type: 'bytes', name: 'reverseName' }],
            outputs: [
                { type: 'string', name: 'resolvedName' },
                { type: 'address', name: 'resolvedAddress' },
                { type: 'address', name: 'reverseResolver' },
                { type: 'address', name: 'resolver' },
            ],
        },
    ];
    const textResolverAbi = [
        {
            name: 'text',
            type: 'function',
            stateMutability: 'view',
            inputs: [
                { name: 'name', type: 'bytes32' },
                { name: 'key', type: 'string' },
            ],
            outputs: [{ name: '', type: 'string' }],
        },
    ];
    const addressResolverAbi = [
        {
            name: 'addr',
            type: 'function',
            stateMutability: 'view',
            inputs: [{ name: 'name', type: 'bytes32' }],
            outputs: [{ name: '', type: 'address' }],
        },
        {
            name: 'addr',
            type: 'function',
            stateMutability: 'view',
            inputs: [
                { name: 'name', type: 'bytes32' },
                { name: 'coinType', type: 'uint256' },
            ],
            outputs: [{ name: '', type: 'bytes' }],
        },
    ];
    // ERC-6492 - universal deployless signature validator contract
    // constructor(address _signer, bytes32 _hash, bytes _signature) → bytes4 returnValue
    // returnValue is either 0x1 (valid) or 0x0 (invalid)
    const universalSignatureValidatorAbi = [
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_signer',
                    type: 'address',
                },
                {
                    internalType: 'bytes32',
                    name: '_hash',
                    type: 'bytes32',
                },
                {
                    internalType: 'bytes',
                    name: '_signature',
                    type: 'bytes',
                },
            ],
            stateMutability: 'nonpayable',
            type: 'constructor',
        },
    ];

    const aggregate3Signature = '0x82ad56cb';

    class ChainDoesNotSupportContract extends BaseError {
        constructor({ blockNumber, chain, contract, }) {
            super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
                metaMessages: [
                    'This could be due to any of the following:',
                    ...(blockNumber &&
                        contract.blockCreated &&
                        contract.blockCreated > blockNumber
                        ? [
                            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,
                        ]
                        : [
                            `- The chain does not have the contract "${contract.name}" configured.`,
                        ]),
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ChainDoesNotSupportContract'
            });
        }
    }
    class ChainMismatchError extends BaseError {
        constructor({ chain, currentChainId, }) {
            super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {
                metaMessages: [
                    `Current Chain ID:  ${currentChainId}`,
                    `Expected Chain ID: ${chain.id} – ${chain.name}`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ChainMismatchError'
            });
        }
    }
    class ChainNotFoundError extends BaseError {
        constructor() {
            super([
                'No chain was provided to the request.',
                'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ChainNotFoundError'
            });
        }
    }
    class ClientChainNotConfiguredError extends BaseError {
        constructor() {
            super('No chain was provided to the Client.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ClientChainNotConfiguredError'
            });
        }
    }

    function assertCurrentChain({ chain, currentChainId, }) {
        if (!chain)
            throw new ChainNotFoundError();
        if (currentChainId !== chain.id)
            throw new ChainMismatchError({ chain, currentChainId });
    }
    function defineChain(chain, config) {
        return {
            ...chain,
            formatters: config?.formatters,
            serializers: config?.serializers,
        };
    }
    function getChainContractAddress({ blockNumber, chain, contract: name, }) {
        const contract = chain?.contracts?.[name];
        if (!contract)
            throw new ChainDoesNotSupportContract({
                chain,
                contract: { name },
            });
        if (blockNumber &&
            contract.blockCreated &&
            contract.blockCreated > blockNumber)
            throw new ChainDoesNotSupportContract({
                blockNumber,
                chain,
                contract: {
                    name,
                    blockCreated: contract.blockCreated,
                },
            });
        return contract.address;
    }

    function getCallError(err, { docsPath, ...args }) {
        let cause = err;
        if (containsNodeError(err))
            cause = getNodeError(err, args);
        return new CallExecutionError(cause, {
            docsPath,
            ...args,
        });
    }

    const schedulerCache = /*#__PURE__*/ new Map();
    function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, }) {
        const exec = async () => {
            const scheduler = getScheduler();
            flush();
            const args = scheduler.map(({ args }) => args);
            if (args.length === 0)
                return;
            fn(args)
                .then((data) => {
                scheduler.forEach(({ pendingPromise }, i) => pendingPromise.resolve?.([data[i], data]));
            })
                .catch((err) => {
                scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err));
            });
        };
        const flush = () => schedulerCache.delete(id);
        const getBatchedArgs = () => getScheduler().map(({ args }) => args);
        const getScheduler = () => schedulerCache.get(id) || [];
        const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
        return {
            flush,
            async schedule(args) {
                const pendingPromise = {};
                const promise = new Promise((resolve, reject) => {
                    pendingPromise.resolve = resolve;
                    pendingPromise.reject = reject;
                });
                const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
                if (split)
                    exec();
                const hasActiveScheduler = getScheduler().length > 0;
                if (hasActiveScheduler) {
                    setScheduler({ args, pendingPromise });
                    return promise;
                }
                setScheduler({ args, pendingPromise });
                setTimeout(exec, wait);
                return promise;
            },
        };
    }

    /**
     * Executes a new message call immediately without submitting a transaction to the network.
     *
     * - Docs: https://viem.sh/docs/actions/public/call.html
     * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)
     *
     * @param client - Client to use
     * @param parameters - {@link CallParameters}
     * @returns The call data. {@link CallReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { call } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const data = await call(client, {
     *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
     *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
     * })
     */
    async function call(client, args) {
        const { account: account_, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = 'latest', accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
        const account = account_ ? parseAccount(account_) : undefined;
        try {
            assertRequest(args);
            const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
            const block = blockNumberHex || blockTag;
            const format = client.chain?.formatters?.transactionRequest?.format ||
                formatTransactionRequest;
            const request = format({
                // Pick out extra data that might exist on the chain's transaction request type.
                ...extract(rest, { format }),
                from: account?.address,
                accessList,
                data,
                gas,
                gasPrice,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                value,
            });
            if (batch && shouldPerformMulticall({ request })) {
                try {
                    return await scheduleMulticall(client, {
                        ...request,
                        blockNumber,
                        blockTag,
                    });
                }
                catch (err) {
                    if (!(err instanceof ClientChainNotConfiguredError) &&
                        !(err instanceof ChainDoesNotSupportContract))
                        throw err;
                }
            }
            const response = await client.request({
                method: 'eth_call',
                params: block
                    ? [request, block]
                    : [request],
            });
            if (response === '0x')
                return { data: undefined };
            return { data: response };
        }
        catch (err) {
            const data = getRevertErrorData(err);
            const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(function () { return ccip; });
            if (data?.slice(0, 10) === offchainLookupSignature && to) {
                return { data: await offchainLookup(client, { data, to }) };
            }
            throw getCallError(err, {
                ...args,
                account,
                chain: client.chain,
            });
        }
    }
    // We only want to perform a scheduled multicall if:
    // - The request has calldata,
    // - The request has a target address,
    // - The target address is not already the aggregate3 signature,
    // - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).
    function shouldPerformMulticall({ request }) {
        const { data, to, ...request_ } = request;
        if (!data)
            return false;
        if (data.startsWith(aggregate3Signature))
            return false;
        if (!to)
            return false;
        if (Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0)
            return false;
        return true;
    }
    async function scheduleMulticall(client, args) {
        const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};
        const { blockNumber, blockTag = 'latest', data, multicallAddress: multicallAddress_, to, } = args;
        let multicallAddress = multicallAddress_;
        if (!multicallAddress) {
            if (!client.chain)
                throw new ClientChainNotConfiguredError();
            multicallAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'multicall3',
            });
        }
        const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const { schedule } = createBatchScheduler({
            id: `${client.uid}.${block}`,
            wait,
            shouldSplitBatch(args) {
                const size = args.reduce((size, { data }) => size + (data.length - 2), 0);
                return size > batchSize * 2;
            },
            fn: async (requests) => {
                const calls = requests.map((request) => ({
                    allowFailure: true,
                    callData: request.data,
                    target: request.to,
                }));
                const calldata = encodeFunctionData({
                    abi: multicall3Abi,
                    args: [calls],
                    functionName: 'aggregate3',
                });
                const data = await client.request({
                    method: 'eth_call',
                    params: [
                        {
                            data: calldata,
                            to: multicallAddress,
                        },
                        block,
                    ],
                });
                return decodeFunctionResult({
                    abi: multicall3Abi,
                    args: [calls],
                    functionName: 'aggregate3',
                    data: data || '0x',
                });
            },
        });
        const [{ returnData, success }] = await schedule({ data, to });
        if (!success)
            throw new RawContractError({ data: returnData });
        if (returnData === '0x')
            return { data: undefined };
        return { data: returnData };
    }
    function getRevertErrorData(err) {
        if (!(err instanceof BaseError))
            return undefined;
        const error = err.walk();
        return typeof error.data === 'object' ? error.data.data : error.data;
    }

    /**
     * Calls a read-only function on a contract, and returns the response.
     *
     * - Docs: https://viem.sh/docs/contract/readContract.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/reading-contracts
     *
     * A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.
     *
     * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
     *
     * @param client - Client to use
     * @param parameters - {@link ReadContractParameters}
     * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { readContract } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const result = await readContract(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
     *   functionName: 'balanceOf',
     *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
     * })
     * // 424122n
     */
    async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
        const calldata = encodeFunctionData({
            abi,
            args,
            functionName,
        });
        try {
            const { data } = await call(client, {
                data: calldata,
                to: address,
                ...callRequest,
            });
            return decodeFunctionResult({
                abi,
                args,
                functionName,
                data: data || '0x',
            });
        }
        catch (err) {
            throw getContractError(err, {
                abi: abi,
                address,
                args,
                docsPath: '/docs/contract/readContract',
                functionName,
            });
        }
    }

    /**
     * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.
     *
     * - Docs: https://viem.sh/docs/contract/simulateContract.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts
     *
     * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions.
     *
     * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
     *
     * @param client - Client to use
     * @param parameters - {@link SimulateContractParameters}
     * @returns The simulation result and write request. {@link SimulateContractReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { simulateContract } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const result = await simulateContract(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),
     *   functionName: 'mint',
     *   args: ['69420'],
     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     * })
     */
    async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
        const account = callRequest.account
            ? parseAccount(callRequest.account)
            : undefined;
        const calldata = encodeFunctionData({
            abi,
            args,
            functionName,
        });
        try {
            const { data } = await call(client, {
                batch: false,
                data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
                to: address,
                ...callRequest,
            });
            const result = decodeFunctionResult({
                abi,
                args,
                functionName,
                data: data || '0x',
            });
            return {
                result,
                request: {
                    abi,
                    address,
                    args,
                    dataSuffix,
                    functionName,
                    ...callRequest,
                },
            };
        }
        catch (err) {
            throw getContractError(err, {
                abi: abi,
                address,
                args,
                docsPath: '/docs/contract/simulateContract',
                functionName,
                sender: account?.address,
            });
        }
    }

    const listenersCache = /*#__PURE__*/ new Map();
    const cleanupCache = /*#__PURE__*/ new Map();
    let callbackCount = 0;
    /**
     * @description Sets up an observer for a given function. If another function
     * is set up under the same observer id, the function will only be called once
     * for both instances of the observer.
     */
    function observe(observerId, callbacks, fn) {
        const callbackId = ++callbackCount;
        const getListeners = () => listenersCache.get(observerId) || [];
        const unsubscribe = () => {
            const listeners = getListeners();
            listenersCache.set(observerId, listeners.filter((cb) => cb.id !== callbackId));
        };
        const unwatch = () => {
            const cleanup = cleanupCache.get(observerId);
            if (getListeners().length === 1 && cleanup)
                cleanup();
            unsubscribe();
        };
        const listeners = getListeners();
        listenersCache.set(observerId, [
            ...listeners,
            { id: callbackId, fns: callbacks },
        ]);
        if (listeners && listeners.length > 0)
            return unwatch;
        const emit = {};
        for (const key in callbacks) {
            emit[key] = ((...args) => {
                const listeners = getListeners();
                if (listeners.length === 0)
                    return;
                listeners.forEach((listener) => listener.fns[key]?.(...args));
            });
        }
        const cleanup = fn(emit);
        if (typeof cleanup === 'function')
            cleanupCache.set(observerId, cleanup);
        return unwatch;
    }

    async function wait(time) {
        return new Promise((res) => setTimeout(res, time));
    }

    /**
     * @description Polls a function at a specified interval.
     */
    function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
        let active = true;
        const unwatch = () => (active = false);
        const watch = async () => {
            let data;
            if (emitOnBegin)
                data = await fn({ unpoll: unwatch });
            const initialWait = (await initialWaitTime?.(data)) ?? interval;
            await wait(initialWait);
            const poll = async () => {
                if (!active)
                    return;
                await fn({ unpoll: unwatch });
                await wait(interval);
                poll();
            };
            poll();
        };
        watch();
        return unwatch;
    }

    const promiseCache = /*#__PURE__*/ new Map();
    const responseCache = /*#__PURE__*/ new Map();
    function getCache(cacheKey) {
        const buildCache = (cacheKey, cache) => ({
            clear: () => cache.delete(cacheKey),
            get: () => cache.get(cacheKey),
            set: (data) => cache.set(cacheKey, data),
        });
        const promise = buildCache(cacheKey, promiseCache);
        const response = buildCache(cacheKey, responseCache);
        return {
            clear: () => {
                promise.clear();
                response.clear();
            },
            promise,
            response,
        };
    }
    /**
     * @description Returns the result of a given promise, and caches the result for
     * subsequent invocations against a provided cache key.
     */
    async function withCache(fn, { cacheKey, maxAge = Infinity }) {
        const cache = getCache(cacheKey);
        // If a response exists in the cache, and it's not expired, return it
        // and do not invoke the promise.
        // If the max age is 0, the cache is disabled.
        const response = cache.response.get();
        if (response && maxAge > 0) {
            const age = new Date().getTime() - response.created.getTime();
            if (age < maxAge)
                return response.data;
        }
        let promise = cache.promise.get();
        if (!promise) {
            promise = fn();
            // Store the promise in the cache so that subsequent invocations
            // will wait for the same promise to resolve (deduping).
            cache.promise.set(promise);
        }
        try {
            const data = await promise;
            // Store the response in the cache so that subsequent invocations
            // will return the same response.
            cache.response.set({ created: new Date(), data });
            return data;
        }
        finally {
            // Clear the promise cache so that subsequent invocations will
            // invoke the promise again.
            cache.promise.clear();
        }
    }

    const cacheKey = (id) => `blockNumber.${id}`;
    /**
     * Returns the number of the most recent block seen.
     *
     * - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks
     * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)
     *
     * @param client - Client to use
     * @param parameters - {@link GetBlockNumberParameters}
     * @returns The number of the block. {@link GetBlockNumberReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getBlockNumber } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const blockNumber = await getBlockNumber(client)
     * // 69420n
     */
    async function getBlockNumber(client, { maxAge = client.pollingInterval } = {}) {
        const blockNumberHex = await withCache(() => client.request({
            method: 'eth_blockNumber',
        }), { cacheKey: cacheKey(client.uid), maxAge });
        return BigInt(blockNumberHex);
    }

    const docsPath$1 = '/docs/contract/decodeEventLog';
    function decodeEventLog({ abi, data, strict: strict_, topics, }) {
        const strict = strict_ ?? true;
        const [signature, ...argTopics] = topics;
        if (!signature)
            throw new AbiEventSignatureEmptyTopicsError({
                docsPath: docsPath$1,
            });
        const abiItem = abi.find((x) => x.type === 'event' &&
            signature === getEventSelector(formatAbiItem(x)));
        if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')
            throw new AbiEventSignatureNotFoundError(signature, {
                docsPath: docsPath$1,
            });
        const { name, inputs } = abiItem;
        const isUnnamed = inputs?.some((x) => !('name' in x && x.name));
        let args = isUnnamed ? [] : {};
        // Decode topics (indexed args).
        const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed);
        if (argTopics.length > 0) {
            for (let i = 0; i < indexedInputs.length; i++) {
                const param = indexedInputs[i];
                const topic = argTopics[i];
                if (!topic)
                    throw new DecodeLogTopicsMismatch({
                        abiItem,
                        param: param,
                    });
                args[param.name || i] = decodeTopic({ param, value: topic });
            }
        }
        // Decode data (non-indexed args).
        const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));
        if (nonIndexedInputs.length > 0) {
            if (data && data !== '0x') {
                try {
                    const decodedData = decodeAbiParameters(nonIndexedInputs, data);
                    if (decodedData) {
                        if (isUnnamed)
                            args = [...args, ...decodedData];
                        else {
                            for (let i = 0; i < nonIndexedInputs.length; i++) {
                                args[nonIndexedInputs[i].name] = decodedData[i];
                            }
                        }
                    }
                }
                catch (err) {
                    if (strict) {
                        if (err instanceof AbiDecodingDataSizeTooSmallError)
                            throw new DecodeLogDataMismatch({
                                abiItem,
                                data: err.data,
                                params: err.params,
                                size: err.size,
                            });
                        throw err;
                    }
                }
            }
            else if (strict) {
                throw new DecodeLogDataMismatch({
                    abiItem,
                    data: '0x',
                    params: nonIndexedInputs,
                    size: 0,
                });
            }
        }
        return {
            eventName: name,
            args: Object.values(args).length > 0 ? args : undefined,
        };
    }
    function decodeTopic({ param, value }) {
        if (param.type === 'string' ||
            param.type === 'bytes' ||
            param.type === 'tuple' ||
            param.type.match(/^(.*)\[(\d+)?\]$/))
            return value;
        const decodedArg = decodeAbiParameters([param], value) || [];
        return decodedArg[0];
    }

    function formatLog(log, { args, eventName } = {}) {
        return {
            ...log,
            blockHash: log.blockHash ? log.blockHash : null,
            blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
            logIndex: log.logIndex ? Number(log.logIndex) : null,
            transactionHash: log.transactionHash ? log.transactionHash : null,
            transactionIndex: log.transactionIndex
                ? Number(log.transactionIndex)
                : null,
            ...(eventName ? { args, eventName } : {}),
        };
    }

    /**
     * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.
     *
     * - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html
     * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)
     *
     * A Filter can be created from the following actions:
     *
     * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)
     * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html)
     * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)
     * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)
     *
     * Depending on the type of filter, the return value will be different:
     *
     * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.
     * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.
     * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.
     *
     * @param client - Client to use
     * @param parameters - {@link GetFilterChangesParameters}
     * @returns Logs or hashes. {@link GetFilterChangesReturnType}
     *
     * @example
     * // Blocks
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createBlockFilter, getFilterChanges } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createBlockFilter(client)
     * const hashes = await getFilterChanges(client, { filter })
     *
     * @example
     * // Contract Events
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createContractEventFilter, getFilterChanges } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createContractEventFilter(client, {
     *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
     *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
     *   eventName: 'Transfer',
     * })
     * const logs = await getFilterChanges(client, { filter })
     *
     * @example
     * // Raw Events
     * import { createPublicClient, http, parseAbiItem } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createEventFilter, getFilterChanges } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createEventFilter(client, {
     *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
     *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
     * })
     * const logs = await getFilterChanges(client, { filter })
     *
     * @example
     * // Transactions
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createPendingTransactionFilter, getFilterChanges } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createPendingTransactionFilter(client)
     * const hashes = await getFilterChanges(client, { filter })
     */
    async function getFilterChanges(_client, { filter, }) {
        const strict = 'strict' in filter && filter.strict;
        const logs = await filter.request({
            method: 'eth_getFilterChanges',
            params: [filter.id],
        });
        return logs
            .map((log) => {
            if (typeof log === 'string')
                return log;
            try {
                const { eventName, args } = 'abi' in filter && filter.abi
                    ? decodeEventLog({
                        abi: filter.abi,
                        data: log.data,
                        topics: log.topics,
                        strict,
                    })
                    : { eventName: undefined, args: undefined };
                return formatLog(log, { args, eventName });
            }
            catch (err) {
                let eventName;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch ||
                    err instanceof DecodeLogTopicsMismatch) {
                    // If strict mode is on, and log data/topics do not match event definition, skip.
                    if ('strict' in filter && filter.strict)
                        return;
                    eventName = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
                }
                // Set args undefined if there is an error decoding (e.g. indexed/non-indexed params mismatch).
                return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
            }
        })
            .filter(Boolean);
    }

    /**
     * Returns a list of event logs matching the provided parameters.
     *
     * - Docs: https://viem.sh/docs/actions/public/getLogs.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/filters-and-logs/event-logs
     * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
     *
     * @param client - Client to use
     * @param parameters - {@link GetLogsParameters}
     * @returns A list of event logs. {@link GetLogsReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbiItem } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getLogs } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const logs = await getLogs(client)
     */
    async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, args, strict: strict_, } = {}) {
        const strict = strict_ ?? false;
        let topics = [];
        if (event)
            topics = encodeEventTopics({
                abi: [event],
                eventName: event.name,
                args,
            });
        let logs;
        if (blockHash) {
            logs = await client.request({
                method: 'eth_getLogs',
                params: [{ address, topics, blockHash }],
            });
        }
        else {
            logs = await client.request({
                method: 'eth_getLogs',
                params: [
                    {
                        address,
                        topics,
                        fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,
                        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,
                    },
                ],
            });
        }
        return logs
            .map((log) => {
            try {
                const { eventName, args } = event
                    ? decodeEventLog({
                        abi: [event],
                        data: log.data,
                        topics: log.topics,
                        strict,
                    })
                    : { eventName: undefined, args: undefined };
                return formatLog(log, { args, eventName });
            }
            catch (err) {
                let eventName;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch ||
                    err instanceof DecodeLogTopicsMismatch) {
                    // If strict mode is on, and log data/topics do not match event definition, skip.
                    if (strict)
                        return;
                    eventName = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
                }
                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
                return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
            }
        })
            .filter(Boolean);
    }

    /**
     * Destroys a [`Filter`](https://viem.sh/docs/glossary/types.html#filter).
     *
     * - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html
     * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)
     *
     * Destroys a Filter that was created from one of the following Actions:
     * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)
     * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)
     * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)
     *
     * @param client - Client to use
     * @param parameters - {@link UninstallFilterParameters}
     * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'
     *
     * const filter = await createPendingTransactionFilter(client)
     * const uninstalled = await uninstallFilter(client, { filter })
     * // true
     */
    async function uninstallFilter(_client, { filter }) {
        return filter.request({
            method: 'eth_uninstallFilter',
            params: [filter.id],
        });
    }

    /**
     * Watches and returns emitted contract event logs.
     *
     * - Docs: https://viem.sh/docs/contract/watchContractEvent.html
     *
     * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).
     *
     * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.
     *
     * @param client - Client to use
     * @param parameters - {@link WatchContractEventParameters}
     * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { watchContractEvent } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const unwatch = watchContractEvent(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),
     *   eventName: 'Transfer',
     *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },
     *   onLogs: (logs) => console.log(logs),
     * })
     */
    function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, pollingInterval = client.pollingInterval, strict: strict_, }) {
        const observerId = stringify([
            'watchContractEvent',
            address,
            args,
            batch,
            client.uid,
            eventName,
            pollingInterval,
        ]);
        const strict = strict_ ?? false;
        return observe(observerId, { onLogs, onError }, (emit) => {
            let previousBlockNumber;
            let filter;
            let initialized = false;
            const unwatch = poll(async () => {
                if (!initialized) {
                    try {
                        filter = (await createContractEventFilter(client, {
                            abi,
                            address,
                            args,
                            eventName,
                            strict,
                        }));
                    }
                    catch { }
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) {
                        logs = await getFilterChanges(client, { filter });
                    }
                    else {
                        // If the filter doesn't exist, we will fall back to use `getLogs`.
                        // The fall back exists because some RPC Providers do not support filters.
                        // Fetch the block number to use for `getLogs`.
                        const blockNumber = await getBlockNumber(client);
                        // If the block number has changed, we will need to fetch the logs.
                        // If the block number doesn't exist, we are yet to reach the first poll interval,
                        // so do not emit any logs.
                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                            logs = await getLogs(client, {
                                address,
                                args,
                                fromBlock: previousBlockNumber + 1n,
                                toBlock: blockNumber,
                                event: getAbiItem({
                                    abi,
                                    name: eventName,
                                }),
                            });
                        }
                        else {
                            logs = [];
                        }
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0)
                        return;
                    if (batch)
                        emit.onLogs(logs);
                    else
                        logs.forEach((log) => emit.onLogs([log]));
                }
                catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await uninstallFilter(client, { filter });
                unwatch();
            };
        });
    }

    function getTransactionError(err, { docsPath, ...args }) {
        let cause = err;
        if (containsNodeError(err))
            cause = getNodeError(err, args);
        return new TransactionExecutionError(cause, {
            docsPath,
            ...args,
        });
    }

    /**
     * Returns the chain ID associated with the current network.
     *
     * - Docs: https://viem.sh/docs/actions/public/getChainId.html
     * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)
     *
     * @param client - Client to use
     * @returns The current chain ID. {@link GetChainIdReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getChainId } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const chainId = await getChainId(client)
     * // 1
     */
    async function getChainId(client) {
        const chainIdHex = await client.request({
            method: 'eth_chainId',
        });
        return hexToNumber(chainIdHex);
    }

    /**
     * Creates, signs, and sends a new transaction to the network.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions
     * - JSON-RPC Methods:
     *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)
     *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)
     *
     * @param client - Client to use
     * @param parameters - {@link SendTransactionParameters}
     * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link SendTransactionReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { sendTransaction } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const hash = await sendTransaction(client, {
     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
     *   value: 1000000000000000000n,
     * })
     *
     * @example
     * // Account Hoisting
     * import { createWalletClient, http } from 'viem'
     * import { privateKeyToAccount } from 'viem/accounts'
     * import { mainnet } from 'viem/chains'
     * import { sendTransaction } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   account: privateKeyToAccount('0x…'),
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const hash = await sendTransaction(client, {
     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
     *   value: 1000000000000000000n,
     * })
     */
    async function sendTransaction(client, args) {
        const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
        if (!account_)
            throw new AccountNotFoundError({
                docsPath: '/docs/actions/wallet/sendTransaction',
            });
        const account = parseAccount(account_);
        try {
            assertRequest(args);
            let chainId;
            if (chain !== null) {
                chainId = await getChainId(client);
                assertCurrentChain({
                    currentChainId: chainId,
                    chain,
                });
            }
            if (account.type === 'local') {
                // Prepare the request for signing (assign appropriate fees, etc.)
                const request = await prepareRequest(client, {
                    account,
                    accessList,
                    chain,
                    data,
                    gas,
                    gasPrice,
                    maxFeePerGas,
                    maxPriorityFeePerGas,
                    nonce,
                    to,
                    value,
                    ...rest,
                });
                if (!chainId)
                    chainId = await getChainId(client);
                const serializer = chain?.serializers?.transaction;
                const signedRequest = (await account.signTransaction({
                    ...request,
                    chainId,
                }, { serializer }));
                return await client.request({
                    method: 'eth_sendRawTransaction',
                    params: [signedRequest],
                });
            }
            const format = chain?.formatters?.transactionRequest?.format || formatTransactionRequest;
            const request = format({
                // Pick out extra data that might exist on the chain's transaction request type.
                ...extract(rest, { format }),
                accessList,
                data,
                from: account.address,
                gas,
                gasPrice,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                value,
            });
            return await client.request({
                method: 'eth_sendTransaction',
                params: [request],
            });
        }
        catch (err) {
            throw getTransactionError(err, {
                ...args,
                account,
                chain: args.chain || undefined,
            });
        }
    }

    /**
     * Executes a write function on a contract.
     *
     * - Docs: https://viem.sh/docs/contract/writeContract.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts
     *
     * A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.
     *
     * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
     *
     * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__
     *
     * @param client - Client to use
     * @param parameters - {@link WriteContractParameters}
     * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms.html#hash). {@link WriteContractReturnType}
     *
     * @example
     * import { createWalletClient, custom, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { writeContract } from 'viem/contract'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const hash = await writeContract(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
     *   functionName: 'mint',
     *   args: [69420],
     * })
     *
     * @example
     * // With Validation
     * import { createWalletClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { simulateContract, writeContract } from 'viem/contract'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const { request } = await simulateContract(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
     *   functionName: 'mint',
     *   args: [69420],
     * }
     * const hash = await writeContract(client, request)
     */
    async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
        const data = encodeFunctionData({
            abi,
            args,
            functionName,
        });
        const hash = await sendTransaction(client, {
            data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            ...request,
        });
        return hash;
    }

    /**
     * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.
     *
     * - Docs https://viem.sh/docs/contract/getContract.html
     *
     * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properites every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract.html), [`writeContract`](https://viem.sh/docs/contract/writeContract.html), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas.html), etc.
     *
     * @example
     * import { createPublicClient, getContract, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     *
     * const publicClient = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const contract = getContract({
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi([
     *     'function balanceOf(address owner) view returns (uint256)',
     *     'function ownerOf(uint256 tokenId) view returns (address)',
     *     'function totalSupply() view returns (uint256)',
     *   ]),
     *   publicClient,
     * })
     */
    function getContract({ abi, address, publicClient, walletClient, }) {
        const hasPublicClient = publicClient !== undefined && publicClient !== null;
        const hasWalletClient = walletClient !== undefined && walletClient !== null;
        const contract = {};
        let hasReadFunction = false;
        let hasWriteFunction = false;
        let hasEvent = false;
        for (const item of abi) {
            if (item.type === 'function')
                if (item.stateMutability === 'view' || item.stateMutability === 'pure')
                    hasReadFunction = true;
                else
                    hasWriteFunction = true;
            else if (item.type === 'event')
                hasEvent = true;
            // Exit early if all flags are `true`
            if (hasReadFunction && hasWriteFunction && hasEvent)
                break;
        }
        if (hasPublicClient) {
            if (hasReadFunction)
                contract.read = new Proxy({}, {
                    get(_, functionName) {
                        return (...parameters) => {
                            const { args, options } = getFunctionParameters(parameters);
                            return readContract(publicClient, {
                                abi,
                                address,
                                functionName,
                                args,
                                ...options,
                            });
                        };
                    },
                });
            if (hasWriteFunction)
                contract.simulate = new Proxy({}, {
                    get(_, functionName) {
                        return (...parameters) => {
                            const { args, options } = getFunctionParameters(parameters);
                            return simulateContract(publicClient, {
                                abi,
                                address,
                                functionName,
                                args,
                                ...options,
                            });
                        };
                    },
                });
            if (hasEvent) {
                contract.createEventFilter = new Proxy({}, {
                    get(_, eventName) {
                        return (...parameters) => {
                            const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                            const { args, options } = getEventParameters(parameters, abiEvent);
                            return createContractEventFilter(publicClient, {
                                abi,
                                address,
                                eventName,
                                args,
                                ...options,
                            });
                        };
                    },
                });
                contract.watchEvent = new Proxy({}, {
                    get(_, eventName) {
                        return (...parameters) => {
                            const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                            const { args, options } = getEventParameters(parameters, abiEvent);
                            return watchContractEvent(publicClient, {
                                abi,
                                address,
                                eventName,
                                args,
                                ...options,
                            });
                        };
                    },
                });
            }
        }
        if (hasWalletClient) {
            if (hasWriteFunction)
                contract.write = new Proxy({}, {
                    get(_, functionName) {
                        return (...parameters) => {
                            const { args, options } = getFunctionParameters(parameters);
                            return writeContract(walletClient, {
                                abi,
                                address,
                                functionName,
                                args,
                                ...options,
                            });
                        };
                    },
                });
        }
        if (hasPublicClient || hasWalletClient)
            if (hasWriteFunction)
                contract.estimateGas = new Proxy({}, {
                    get(_, functionName) {
                        return (...parameters) => {
                            const { args, options } = getFunctionParameters(parameters);
                            const client = (publicClient ?? walletClient);
                            return estimateContractGas(client, {
                                abi,
                                address,
                                functionName,
                                args,
                                ...options,
                                account: options.account ??
                                    walletClient.account,
                            });
                        };
                    },
                });
        contract.address = address;
        contract.abi = abi;
        return contract;
    }
    /**
     * @internal exporting for testing only
     */
    function getFunctionParameters(values) {
        const hasArgs = values.length && Array.isArray(values[0]);
        const args = hasArgs ? values[0] : [];
        const options = (hasArgs ? values[1] : values[0]) ?? {};
        return { args, options };
    }
    /**
     * @internal exporting for testing only
     */
    function getEventParameters(values, abiEvent) {
        let hasArgs = false;
        // If first item is array, must be `args`
        if (Array.isArray(values[0]))
            hasArgs = true;
        // Check if first item is `args` or `options`
        else if (values.length === 1) {
            // if event has indexed inputs, must have `args`
            hasArgs = abiEvent.inputs.some((x) => x.indexed);
            // If there are two items in array, must have `args`
        }
        else if (values.length === 2) {
            hasArgs = true;
        }
        const args = hasArgs ? values[0] : undefined;
        const options = (hasArgs ? values[1] : values[0]) ?? {};
        return { args, options };
    }

    /**
     * Adds an EVM chain to the wallet.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/addChain.html
     * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
     *
     * @param client - Client to use
     * @param parameters - {@link AddChainParameters}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { optimism } from 'viem/chains'
     * import { addChain } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   transport: custom(window.ethereum),
     * })
     * await addChain(client, { chain: optimism })
     */
    async function addChain(client, { chain }) {
        const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
        await client.request({
            method: 'wallet_addEthereumChain',
            params: [
                {
                    chainId: numberToHex(id),
                    chainName: name,
                    nativeCurrency,
                    rpcUrls: rpcUrls.default.http,
                    blockExplorerUrls: blockExplorers
                        ? Object.values(blockExplorers).map(({ url }) => url)
                        : undefined,
                },
            ],
        });
    }

    const size = 256;
    let index = size;
    let buffer;
    function uid(length = 11) {
        if (!buffer || index + length > size * 2) {
            buffer = '';
            index = 0;
            for (let i = 0; i < size; i++) {
                buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
            }
        }
        return buffer.substring(index, index++ + length);
    }

    function createClient(parameters) {
        const { batch, key = 'base', name = 'Base Client', pollingInterval = 4000, type = 'base', } = parameters;
        const chain = parameters.chain;
        const account = parameters.account
            ? parseAccount(parameters.account)
            : undefined;
        const { config, request, value } = parameters.transport({
            chain,
            pollingInterval,
        });
        const transport = { ...config, ...value };
        const client = {
            account,
            batch,
            chain,
            key,
            name,
            pollingInterval,
            request,
            transport,
            type,
            uid: uid(),
        };
        function extend(base) {
            return (extendFn) => {
                const extended = extendFn(base);
                for (const key in client)
                    delete extended[key];
                const combined = { ...base, ...extended };
                return Object.assign(combined, { extend: extend(combined) });
            };
        }
        return Object.assign(client, { extend: extend(client) });
    }

    function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true, } = {}) {
        return new Promise((resolve, reject) => {
            const attemptRetry = async ({ count = 0 } = {}) => {
                const retry = async ({ error }) => {
                    const delay = typeof delay_ === 'function' ? delay_({ count, error }) : delay_;
                    if (delay)
                        await wait(delay);
                    attemptRetry({ count: count + 1 });
                };
                try {
                    const data = await fn();
                    resolve(data);
                }
                catch (err) {
                    if (count < retryCount &&
                        (await shouldRetry({ count, error: err })))
                        return retry({ error: err });
                    reject(err);
                }
            };
            attemptRetry();
        });
    }

    const isDeterministicError = (error) => {
        if ('code' in error)
            return (error.code !== -1 &&
                error.code !== -32004 &&
                error.code !== -32005 &&
                error.code !== -32042 &&
                error.code !== -32603);
        if (error instanceof HttpRequestError && error.status)
            return (error.status !== 403 &&
                error.status !== 408 &&
                error.status !== 413 &&
                error.status !== 429 &&
                error.status !== 500 &&
                error.status !== 502 &&
                error.status !== 503 &&
                error.status !== 504);
        return false;
    };
    function buildRequest(request, { retryDelay = 150, retryCount = 3, } = {}) {
        return (async (args) => withRetry(async () => {
            try {
                return await request(args);
            }
            catch (err_) {
                const err = err_;
                switch (err.code) {
                    // -32700
                    case ParseRpcError.code:
                        throw new ParseRpcError(err);
                    // -32600
                    case InvalidRequestRpcError.code:
                        throw new InvalidRequestRpcError(err);
                    // -32601
                    case MethodNotFoundRpcError.code:
                        throw new MethodNotFoundRpcError(err);
                    // -32602
                    case InvalidParamsRpcError.code:
                        throw new InvalidParamsRpcError(err);
                    // -32603
                    case InternalRpcError.code:
                        throw new InternalRpcError(err);
                    // -32000
                    case InvalidInputRpcError.code:
                        throw new InvalidInputRpcError(err);
                    // -32001
                    case ResourceNotFoundRpcError.code:
                        throw new ResourceNotFoundRpcError(err);
                    // -32002
                    case ResourceUnavailableRpcError.code:
                        throw new ResourceUnavailableRpcError(err);
                    // -32003
                    case TransactionRejectedRpcError.code:
                        throw new TransactionRejectedRpcError(err);
                    // -32004
                    case MethodNotSupportedRpcError.code:
                        throw new MethodNotSupportedRpcError(err);
                    // -32005
                    case LimitExceededRpcError.code:
                        throw new LimitExceededRpcError(err);
                    // -32006
                    case JsonRpcVersionUnsupportedError.code:
                        throw new JsonRpcVersionUnsupportedError(err);
                    // 4001
                    case UserRejectedRequestError.code:
                        throw new UserRejectedRequestError(err);
                    // 4100
                    case UnauthorizedProviderError.code:
                        throw new UnauthorizedProviderError(err);
                    // 4200
                    case UnsupportedProviderMethodError.code:
                        throw new UnsupportedProviderMethodError(err);
                    // 4900
                    case ProviderDisconnectedError.code:
                        throw new ProviderDisconnectedError(err);
                    // 4901
                    case ChainDisconnectedError.code:
                        throw new ChainDisconnectedError(err);
                    // 4902
                    case SwitchChainError.code:
                        throw new SwitchChainError(err);
                    default:
                        if (err_ instanceof BaseError)
                            throw err_;
                        throw new UnknownRpcError(err);
                }
            }
        }, {
            delay: ({ count, error }) => {
                // If we find a Retry-After header, let's retry after the given time.
                if (error && error instanceof HttpRequestError) {
                    const retryAfter = error?.headers?.get('Retry-After');
                    if (retryAfter?.match(/\d/))
                        return parseInt(retryAfter) * 1000;
                }
                // Otherwise, let's retry with an exponential backoff.
                return ~~(1 << count) * retryDelay;
            },
            retryCount,
            shouldRetry: ({ error }) => !isDeterministicError(error),
        }));
    }

    /**
     * @description Creates an transport intended to be used with a client.
     */
    function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type, }, value) {
        return {
            config: { key, name, request, retryCount, retryDelay, timeout, type },
            request: buildRequest(request, { retryCount, retryDelay }),
            value,
        };
    }

    /**
     * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.
     */
    function custom(provider, config = {}) {
        const { key = 'custom', name = 'Custom Provider', retryDelay } = config;
        return ({ retryCount: defaultRetryCount }) => createTransport({
            key,
            name,
            request: provider.request.bind(provider),
            retryCount: config.retryCount ?? defaultRetryCount,
            retryDelay,
            type: 'custom',
        });
    }

    class UrlRequiredError extends BaseError {
        constructor() {
            super('No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.', {
                docsPath: '/docs/clients/intro',
            });
        }
    }

    function withTimeout(fn, { errorInstance, timeout, signal, }) {
        return new Promise((resolve, reject) => {
            (async () => {
                let timeoutId;
                try {
                    const controller = new AbortController();
                    if (timeout > 0) {
                        timeoutId = setTimeout(() => {
                            if (signal) {
                                controller.abort();
                            }
                            else {
                                reject(errorInstance);
                            }
                        }, timeout);
                    }
                    resolve(await fn({ signal: controller?.signal }));
                }
                catch (err) {
                    if (err.name === 'AbortError')
                        reject(errorInstance);
                    reject(err);
                }
                finally {
                    clearTimeout(timeoutId);
                }
            })();
        });
    }

    let id = 0;
    async function http$1(url, { body, fetchOptions = {}, timeout = 10000 }) {
        const { headers, method, signal: signal_ } = fetchOptions;
        try {
            const response = await withTimeout(async ({ signal }) => {
                const response = await fetch(url, {
                    ...fetchOptions,
                    body: Array.isArray(body)
                        ? stringify(body.map((body) => ({
                            jsonrpc: '2.0',
                            id: id++,
                            ...body,
                        })))
                        : stringify({ jsonrpc: '2.0', id: id++, ...body }),
                    headers: {
                        ...headers,
                        'Content-Type': 'application/json',
                    },
                    method: method || 'POST',
                    signal: signal_ || (timeout > 0 ? signal : undefined),
                });
                return response;
            }, {
                errorInstance: new TimeoutError({ body, url }),
                timeout,
                signal: true,
            });
            let data;
            if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                data = await response.json();
            }
            else {
                data = await response.text();
            }
            if (!response.ok) {
                throw new HttpRequestError({
                    body,
                    details: stringify(data.error) || response.statusText,
                    headers: response.headers,
                    status: response.status,
                    url,
                });
            }
            return data;
        }
        catch (err) {
            if (err instanceof HttpRequestError)
                throw err;
            if (err instanceof TimeoutError)
                throw err;
            throw new HttpRequestError({
                body,
                details: err.message,
                url,
            });
        }
    }
    function webSocket(socket, { body, onResponse }) {
        if (socket.readyState === socket.CLOSED ||
            socket.readyState === socket.CLOSING)
            throw new WebSocketRequestError({
                body,
                url: socket.url,
                details: 'Socket is closed.',
            });
        const id_ = id++;
        const callback = ({ data }) => {
            const message = JSON.parse(data);
            if (typeof message.id === 'number' && id_ !== message.id)
                return;
            onResponse?.(message);
            // If we are subscribing to a topic, we want to set up a listener for incoming
            // messages.
            if (body.method === 'eth_subscribe' && typeof message.result === 'string') {
                socket.subscriptions.set(message.result, callback);
            }
            // If we are unsubscribing from a topic, we want to remove the listener.
            if (body.method === 'eth_unsubscribe') {
                socket.subscriptions.delete(body.params?.[0]);
            }
        };
        socket.requests.set(id_, callback);
        socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }));
        return socket;
    }
    async function webSocketAsync(socket, { body, timeout = 10000 }) {
        return withTimeout(() => new Promise((onResponse) => rpc.webSocket(socket, {
            body,
            onResponse,
        })), {
            errorInstance: new TimeoutError({ body, url: socket.url }),
            timeout,
        });
    }
    ///////////////////////////////////////////////////
    const rpc = {
        http: http$1,
        webSocket,
        webSocketAsync,
    };

    /**
     * @description Creates a HTTP transport that connects to a JSON-RPC API.
     */
    function http(
    /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */
    url, config = {}) {
        const { batch, fetchOptions, key = 'http', name = 'HTTP JSON-RPC', retryDelay, } = config;
        return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
            const { batchSize = 1000, wait = 0 } = typeof batch === 'object' ? batch : {};
            const retryCount = config.retryCount ?? retryCount_;
            const timeout = timeout_ ?? config.timeout ?? 10000;
            const url_ = url || chain?.rpcUrls.default.http[0];
            if (!url_)
                throw new UrlRequiredError();
            return createTransport({
                key,
                name,
                async request({ method, params }) {
                    const body = { method, params };
                    const { schedule } = createBatchScheduler({
                        id: `${url}`,
                        wait,
                        shouldSplitBatch(requests) {
                            return requests.length > batchSize;
                        },
                        fn: (body) => rpc.http(url_, {
                            body,
                            fetchOptions,
                            timeout,
                        }),
                    });
                    const fn = async (body) => batch
                        ? schedule(body)
                        : [await rpc.http(url_, { body, fetchOptions, timeout })];
                    const [{ error, result }] = await fn(body);
                    if (error)
                        throw new RpcRequestError({
                            body,
                            error,
                            url: url_,
                        });
                    return result;
                },
                retryCount,
                retryDelay,
                timeout,
                type: 'http',
            }, {
                url,
            });
        };
    }

    /*
     * @description Checks if error is a valid null result UniversalResolver error
     */
    function isNullUniversalResolverError(err, callType) {
        if (!(err instanceof BaseError))
            return false;
        const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
        if (!(cause instanceof ContractFunctionRevertedError))
            return false;
        if (cause.data?.errorName === 'ResolverNotFound')
            return true;
        if (cause.data?.errorName === 'ResolverWildcardNotSupported')
            return true;
        // Backwards compatibility for older UniversalResolver contracts
        if (cause.reason?.includes('Wildcard on non-extended resolvers is not supported'))
            return true;
        // No primary name set for address.
        if (callType === 'reverse' && cause.reason === panicReasons[50])
            return true;
        return false;
    }

    class OffchainLookupError extends BaseError {
        constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {
            super(cause.shortMessage ||
                'An error occurred while fetching for an offchain result.', {
                cause,
                metaMessages: [
                    ...(cause.metaMessages || []),
                    cause.metaMessages?.length ? '' : [],
                    'Offchain Gateway Call:',
                    urls && [
                        '  Gateway URL(s):',
                        ...urls.map((url) => `    ${getUrl(url)}`),
                    ],
                    `  Sender: ${sender}`,
                    `  Data: ${data}`,
                    `  Callback selector: ${callbackSelector}`,
                    `  Extra data: ${extraData}`,
                ].flat(),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'OffchainLookupError'
            });
        }
    }
    class OffchainLookupResponseMalformedError extends BaseError {
        constructor({ result, url }) {
            super('Offchain gateway response is malformed. Response data must be a hex value.', {
                metaMessages: [
                    `Gateway URL: ${getUrl(url)}`,
                    `Response: ${stringify(result)}`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'OffchainLookupResponseMalformedError'
            });
        }
    }
    class OffchainLookupSenderMismatchError extends BaseError {
        constructor({ sender, to }) {
            super('Reverted sender address does not match target contract address (`to`).', {
                metaMessages: [
                    `Contract address: ${to}`,
                    `OffchainLookup sender address: ${sender}`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'OffchainLookupSenderMismatchError'
            });
        }
    }

    function isAddressEqual(a, b) {
        if (!isAddress(a))
            throw new InvalidAddressError({ address: a });
        if (!isAddress(b))
            throw new InvalidAddressError({ address: b });
        return a.toLowerCase() === b.toLowerCase();
    }

    const offchainLookupSignature = '0x556f1830';
    const offchainLookupAbiItem = {
        name: 'OffchainLookup',
        type: 'error',
        inputs: [
            {
                name: 'sender',
                type: 'address',
            },
            {
                name: 'urls',
                type: 'string[]',
            },
            {
                name: 'callData',
                type: 'bytes',
            },
            {
                name: 'callbackFunction',
                type: 'bytes4',
            },
            {
                name: 'extraData',
                type: 'bytes',
            },
        ],
    };
    async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {
        const { args } = decodeErrorResult({
            data,
            abi: [offchainLookupAbiItem],
        });
        const [sender, urls, callData, callbackSelector, extraData] = args;
        try {
            if (!isAddressEqual(to, sender))
                throw new OffchainLookupSenderMismatchError({ sender, to });
            const result = await ccipFetch({ data: callData, sender, urls });
            const { data: data_ } = await call(client, {
                blockNumber,
                blockTag,
                data: concat([
                    callbackSelector,
                    encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),
                ]),
                to,
            });
            return data_;
        }
        catch (err) {
            throw new OffchainLookupError({
                callbackSelector,
                cause: err,
                data,
                extraData,
                sender,
                urls,
            });
        }
    }
    async function ccipFetch({ data, sender, urls, }) {
        let error = new Error('An unknown error occurred.');
        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const method = url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST';
            const body = method === 'POST' ? { data, sender } : undefined;
            try {
                const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {
                    body: JSON.stringify(body),
                    method,
                });
                let result;
                if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                    result = (await response.json()).data;
                }
                else {
                    result = (await response.text());
                }
                if (!response.ok) {
                    error = new HttpRequestError({
                        body,
                        details: stringify(result.error) || response.statusText,
                        headers: response.headers,
                        status: response.status,
                        url,
                    });
                    continue;
                }
                if (!isHex(result)) {
                    error = new OffchainLookupResponseMalformedError({
                        result,
                        url,
                    });
                    continue;
                }
                return result;
            }
            catch (err) {
                error = new HttpRequestError({
                    body,
                    details: err.message,
                    url,
                });
            }
        }
        throw error;
    }

    var ccip = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ccipFetch: ccipFetch,
        offchainLookup: offchainLookup,
        offchainLookupAbiItem: offchainLookupAbiItem,
        offchainLookupSignature: offchainLookupSignature
    });

    // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
    // https://regexr.com/6va55
    const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
    // https://regexr.com/6v8hp
    const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

    function validateTypedData({ domain, message, primaryType, types: types_, }) {
        const types = types_;
        const validateData = (struct, value_) => {
            for (const param of struct) {
                const { name, type: type_ } = param;
                const type = type_;
                const value = value_[name];
                const integerMatch = type.match(integerRegex);
                if (integerMatch &&
                    (typeof value === 'number' || typeof value === 'bigint')) {
                    const [_type, base, size_] = integerMatch;
                    // If number cannot be cast to a sized hex value, it is out of range
                    // and will throw.
                    numberToHex(value, {
                        signed: base === 'int',
                        size: parseInt(size_) / 8,
                    });
                }
                if (type === 'address' && typeof value === 'string' && !isAddress(value))
                    throw new InvalidAddressError({ address: value });
                const bytesMatch = type.match(bytesRegex);
                if (bytesMatch) {
                    const [_type, size_] = bytesMatch;
                    if (size_ && size$1(value) !== parseInt(size_))
                        throw new BytesSizeMismatchError({
                            expectedSize: parseInt(size_),
                            givenSize: size$1(value),
                        });
                }
                const struct = types[type];
                if (struct)
                    validateData(struct, value);
            }
        };
        // Validate domain types.
        if (types['EIP712Domain'] && domain)
            validateData(types['EIP712Domain'], domain);
        if (primaryType !== 'EIP712Domain') {
            // Validate message types.
            const type = types[primaryType];
            validateData(type, message);
        }
    }

    const docsPath = '/docs/contract/encodeDeployData';
    function encodeDeployData({ abi, args, bytecode, }) {
        if (!args || args.length === 0)
            return bytecode;
        const description = abi.find((x) => 'type' in x && x.type === 'constructor');
        if (!description)
            throw new AbiConstructorNotFoundError({ docsPath });
        if (!('inputs' in description))
            throw new AbiConstructorParamsNotFoundError({ docsPath });
        if (!description.inputs || description.inputs.length === 0)
            throw new AbiConstructorParamsNotFoundError({ docsPath });
        const data = encodeAbiParameters(description.inputs, args);
        return concatHex([bytecode, data]);
    }

    const statuses = {
        '0x0': 'reverted',
        '0x1': 'success',
    };
    function formatTransactionReceipt(transactionReceipt) {
        return {
            ...transactionReceipt,
            blockNumber: transactionReceipt.blockNumber
                ? BigInt(transactionReceipt.blockNumber)
                : null,
            contractAddress: transactionReceipt.contractAddress
                ? transactionReceipt.contractAddress
                : null,
            cumulativeGasUsed: transactionReceipt.cumulativeGasUsed
                ? BigInt(transactionReceipt.cumulativeGasUsed)
                : null,
            effectiveGasPrice: transactionReceipt.effectiveGasPrice
                ? BigInt(transactionReceipt.effectiveGasPrice)
                : null,
            gasUsed: transactionReceipt.gasUsed
                ? BigInt(transactionReceipt.gasUsed)
                : null,
            logs: transactionReceipt.logs
                ? transactionReceipt.logs.map((log) => formatLog(log))
                : null,
            to: transactionReceipt.to ? transactionReceipt.to : null,
            transactionIndex: transactionReceipt.transactionIndex
                ? hexToNumber(transactionReceipt.transactionIndex)
                : null,
            status: transactionReceipt.status
                ? statuses[transactionReceipt.status]
                : null,
            type: transactionReceipt.type
                ? transactionType[transactionReceipt.type] || transactionReceipt.type
                : null,
        };
    }

    // Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts
    function hashTypedData({ domain: domain_, message, primaryType, types: types_, }) {
        const domain = typeof domain_ === 'undefined' ? {} : domain_;
        const types = {
            EIP712Domain: [
                typeof domain?.name === 'string' && { name: 'name', type: 'string' },
                domain?.version && { name: 'version', type: 'string' },
                typeof domain?.chainId === 'number' && {
                    name: 'chainId',
                    type: 'uint256',
                },
                domain?.verifyingContract && {
                    name: 'verifyingContract',
                    type: 'address',
                },
                domain?.salt && { name: 'salt', type: 'bytes32' },
            ].filter(Boolean),
            ...types_,
        };
        // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
        // as we can't statically check this with TypeScript.
        validateTypedData({
            domain,
            message,
            primaryType,
            types,
        });
        const parts = ['0x1901'];
        if (domain)
            parts.push(hashDomain({
                domain,
                types: types,
            }));
        if (primaryType !== 'EIP712Domain') {
            parts.push(hashStruct({
                data: message,
                primaryType: primaryType,
                types: types,
            }));
        }
        return keccak256(concat(parts));
    }
    function hashDomain({ domain, types, }) {
        return hashStruct({
            data: domain,
            primaryType: 'EIP712Domain',
            types,
        });
    }
    function hashStruct({ data, primaryType, types, }) {
        const encoded = encodeData({
            data,
            primaryType,
            types,
        });
        return keccak256(encoded);
    }
    function encodeData({ data, primaryType, types, }) {
        const encodedTypes = [{ type: 'bytes32' }];
        const encodedValues = [hashType({ primaryType, types })];
        for (const field of types[primaryType]) {
            const [type, value] = encodeField({
                types,
                name: field.name,
                type: field.type,
                value: data[field.name],
            });
            encodedTypes.push(type);
            encodedValues.push(value);
        }
        return encodeAbiParameters(encodedTypes, encodedValues);
    }
    function hashType({ primaryType, types, }) {
        const encodedHashType = toHex(encodeType({ primaryType, types }));
        return keccak256(encodedHashType);
    }
    function encodeType({ primaryType, types, }) {
        let result = '';
        const unsortedDeps = findTypeDependencies({ primaryType, types });
        unsortedDeps.delete(primaryType);
        const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
        for (const type of deps) {
            result += `${type}(${types[type]
            .map(({ name, type: t }) => `${t} ${name}`)
            .join(',')})`;
        }
        return result;
    }
    function findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {
        const match = primaryType_.match(/^\w*/u);
        const primaryType = match?.[0];
        if (results.has(primaryType) || types[primaryType] === undefined) {
            return results;
        }
        results.add(primaryType);
        for (const field of types[primaryType]) {
            findTypeDependencies({ primaryType: field.type, types }, results);
        }
        return results;
    }
    function encodeField({ types, name, type, value, }) {
        if (types[type] !== undefined) {
            return [
                { type: 'bytes32' },
                keccak256(encodeData({ data: value, primaryType: type, types })),
            ];
        }
        if (type === 'bytes') {
            const prepend = value.length % 2 ? '0' : '';
            value = `0x${prepend + value.slice(2)}`;
            return [{ type: 'bytes32' }, keccak256(value)];
        }
        if (type === 'string')
            return [{ type: 'bytes32' }, keccak256(toHex(value))];
        if (type.lastIndexOf(']') === type.length - 1) {
            const parsedType = type.slice(0, type.lastIndexOf('['));
            const typeValuePairs = value.map((item) => encodeField({
                name,
                type: parsedType,
                types,
                value: item,
            }));
            return [
                { type: 'bytes32' },
                keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
            ];
        }
        return [{ type }, value];
    }

    function hashMessage(message, to_) {
        const messageBytes = (() => {
            if (typeof message === 'string')
                return stringToBytes(message);
            if (message.raw instanceof Uint8Array)
                return message.raw;
            return toBytes$1(message.raw);
        })();
        const prefixBytes = stringToBytes(`\x19Ethereum Signed Message:\n${messageBytes.length}`);
        return keccak256(concat([prefixBytes, messageBytes]), to_);
    }

    function parseUnits(value, decimals) {
        let [integer, fraction = '0'] = value.split('.');
        const negative = integer.startsWith('-');
        if (negative)
            integer = integer.slice(1);
        // trim leading zeros.
        fraction = fraction.replace(/(0+)$/, '');
        // round off if the fraction is larger than the number of decimals.
        if (decimals === 0) {
            if (Math.round(Number(`.${fraction}`)) === 1)
                integer = `${BigInt(integer) + 1n}`;
            fraction = '';
        }
        else if (fraction.length > decimals) {
            const [left, unit, right] = [
                fraction.slice(0, decimals - 1),
                fraction.slice(decimals - 1, decimals),
                fraction.slice(decimals),
            ];
            const rounded = Math.round(Number(`${unit}.${right}`));
            if (rounded > 9)
                fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');
            else
                fraction = `${left}${rounded}`;
            if (fraction.length > decimals) {
                fraction = fraction.slice(1);
                integer = `${BigInt(integer) + 1n}`;
            }
            fraction = fraction.slice(0, decimals);
        }
        else {
            fraction = fraction.padEnd(decimals, '0');
        }
        return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);
    }

    function parseEther(ether, unit = 'wei') {
        return parseUnits(ether, etherUnits[unit]);
    }

    function encodedLabelToLabelhash(label) {
        if (label.length !== 66)
            return null;
        if (label.indexOf('[') !== 0)
            return null;
        if (label.indexOf(']') !== 65)
            return null;
        const hash = `0x${label.slice(1, 65)}`;
        if (!isHex(hash))
            return null;
        return hash;
    }

    /**
     * @description Hashes ENS name
     *
     * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
     *
     * @example
     * namehash('wagmi-dev.eth')
     * '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'
     *
     * @link https://eips.ethereum.org/EIPS/eip-137
     */
    function namehash(name) {
        let result = new Uint8Array(32).fill(0);
        if (!name)
            return bytesToHex(result);
        const labels = name.split('.');
        // Iterate in reverse order building up hash
        for (let i = labels.length - 1; i >= 0; i -= 1) {
            const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
            const hashed = hashFromEncodedLabel
                ? toBytes$1(hashFromEncodedLabel)
                : keccak256(stringToBytes(labels[i]), 'bytes');
            result = keccak256(concat([result, hashed]), 'bytes');
        }
        return bytesToHex(result);
    }

    function encodeLabelhash(hash) {
        return `[${hash.slice(2)}]`;
    }

    /**
     * @description Hashes ENS label
     *
     * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
     *
     * @example
     * labelhash('eth')
     * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'
     */
    function labelhash(label) {
        const result = new Uint8Array(32).fill(0);
        if (!label)
            return bytesToHex(result);
        return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
    }

    /*
     * @description Encodes a DNS packet into a ByteArray containing a UDP payload.
     */
    function packetToBytes(packet) {
        // strip leading and trailing `.`
        const value = packet.replace(/^\.|\.$/gm, '');
        if (value.length === 0)
            return new Uint8Array(1);
        const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
        let offset = 0;
        const list = value.split('.');
        for (let i = 0; i < list.length; i++) {
            let encoded = stringToBytes(list[i]);
            // if the length is > 255, make the encoded label value a labelhash
            // this is compatible with the universal resolver
            if (encoded.byteLength > 255)
                encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
            bytes[offset] = encoded.length;
            bytes.set(encoded, offset + 1);
            offset += encoded.length + 1;
        }
        if (bytes.byteLength !== offset + 1)
            return bytes.slice(0, offset + 1);
        return bytes;
    }

    /**
     * Gets address for ENS name.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
     *
     * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
     *
     * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsAddressParameters}
     * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsAddress, normalize } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const ensAddress = await getEnsAddress(client, {
     *   name: normalize('wagmi-dev.eth'),
     * })
     * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'
     */
    async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_, }) {
        let universalResolverAddress = universalResolverAddress_;
        if (!universalResolverAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. universalResolverAddress is required.');
            universalResolverAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'ensUniversalResolver',
            });
        }
        try {
            const functionData = encodeFunctionData({
                abi: addressResolverAbi,
                functionName: 'addr',
                ...(coinType != null
                    ? { args: [namehash(name), BigInt(coinType)] }
                    : { args: [namehash(name)] }),
            });
            const res = await readContract(client, {
                address: universalResolverAddress,
                abi: universalResolverResolveAbi,
                functionName: 'resolve',
                args: [toHex(packetToBytes(name)), functionData],
                blockNumber,
                blockTag,
            });
            if (res[0] === '0x')
                return null;
            const address = trim(decodeFunctionResult({
                abi: addressResolverAbi,
                args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,
                functionName: 'addr',
                data: res[0],
            }));
            if (address === '0x')
                return null;
            if (trim(address) === '0x00')
                return null;
            return address;
        }
        catch (err) {
            if (isNullUniversalResolverError(err, 'resolve'))
                return null;
            throw err;
        }
    }

    class EnsAvatarInvalidMetadataError extends BaseError {
        constructor({ data }) {
            super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
                metaMessages: [
                    '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
                    '',
                    `Provided data: ${JSON.stringify(data)}`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarInvalidMetadataError'
            });
        }
    }
    class EnsAvatarInvalidNftUriError extends BaseError {
        constructor({ reason }) {
            super(`ENS NFT avatar URI is invalid. ${reason}`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarInvalidNftUriError'
            });
        }
    }
    class EnsAvatarUriResolutionError extends BaseError {
        constructor({ uri }) {
            super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarUriResolutionError'
            });
        }
    }
    class EnsAvatarUnsupportedNamespaceError extends BaseError {
        constructor({ namespace }) {
            super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarUnsupportedNamespaceError'
            });
        }
    }

    const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri(uri) {
        try {
            const res = await fetch(uri, { method: 'HEAD' });
            // retrieve content type header to check if content is image
            if (res.status === 200) {
                const contentType = res.headers.get('content-type');
                return contentType?.startsWith('image/');
            }
            return false;
        }
        catch (error) {
            // if error is not cors related then fail
            if (typeof error === 'object' && typeof error.response !== 'undefined') {
                return false;
            }
            // fail in NodeJS, since the error is not cors but any other network issue
            // rome-ignore lint/suspicious/noPrototypeBuiltins:
            if (!globalThis.hasOwnProperty('Image'))
                return false;
            // in case of cors, use image api to validate if given url is an actual image
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    resolve(true);
                };
                img.onerror = () => {
                    resolve(false);
                };
                img.src = uri;
            });
        }
    }
    function getGateway(custom, defaultGateway) {
        if (!custom)
            return defaultGateway;
        if (custom.endsWith('/'))
            return custom.slice(0, -1);
        return custom;
    }
    function resolveAvatarUri({ uri, gatewayUrls, }) {
        const isEncoded = base64Regex.test(uri);
        if (isEncoded)
            return { uri, isOnChain: true, isEncoded };
        const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');
        const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');
        const networkRegexMatch = uri.match(networkRegex);
        const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};
        const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';
        const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);
        if (uri.startsWith('http') && !isIPNS && !isIPFS) {
            let replacedUri = uri;
            if (gatewayUrls?.arweave)
                replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
            return { uri: replacedUri, isOnChain: false, isEncoded: false };
        }
        if ((isIPNS || isIPFS) && target) {
            return {
                uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,
                isOnChain: false,
                isEncoded: false,
            };
        }
        else if (protocol === 'ar:/' && target) {
            return {
                uri: `${arweaveGateway}/${target}${subtarget || ''}`,
                isOnChain: false,
                isEncoded: false,
            };
        }
        let parsedUri = uri.replace(dataURIRegex, '');
        if (parsedUri.startsWith('<svg')) {
            // if svg, base64 encode
            parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
        }
        if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {
            return {
                uri: parsedUri,
                isOnChain: true,
                isEncoded: false,
            };
        }
        throw new EnsAvatarUriResolutionError({ uri });
    }
    function getJsonImage(data) {
        // validation check for json data, must include one of theses properties
        if (typeof data !== 'object' ||
            (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {
            throw new EnsAvatarInvalidMetadataError({ data });
        }
        return data.image || data.image_url || data.image_data;
    }
    async function getMetadataAvatarUri({ gatewayUrls, uri, }) {
        try {
            const res = await fetch(uri).then((res) => res.json());
            const image = await parseAvatarUri({
                gatewayUrls,
                uri: getJsonImage(res),
            });
            return image;
        }
        catch {
            throw new EnsAvatarUriResolutionError({ uri });
        }
    }
    async function parseAvatarUri({ gatewayUrls, uri, }) {
        const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
        if (isOnChain)
            return resolvedURI;
        // check if resolvedURI is an image, if it is return the url
        const isImage = await isImageUri(resolvedURI);
        if (isImage)
            return resolvedURI;
        throw new EnsAvatarUriResolutionError({ uri });
    }
    function parseNftUri(uri_) {
        let uri = uri_;
        // parse valid nft spec (CAIP-22/CAIP-29)
        // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs
        if (uri.startsWith('did:nft:')) {
            // convert DID to CAIP
            uri = uri.replace('did:nft:', '').replace(/_/g, '/');
        }
        const [reference, asset_namespace, tokenID] = uri.split('/');
        const [eip_namespace, chainID] = reference.split(':');
        const [erc_namespace, contractAddress] = asset_namespace.split(':');
        if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')
            throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });
        if (!chainID)
            throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });
        if (!contractAddress)
            throw new EnsAvatarInvalidNftUriError({
                reason: 'Contract address not found',
            });
        if (!tokenID)
            throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });
        if (!erc_namespace)
            throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });
        return {
            chainID: parseInt(chainID),
            namespace: erc_namespace.toLowerCase(),
            contractAddress: contractAddress,
            tokenID,
        };
    }
    async function getNftTokenUri(client, { nft }) {
        if (nft.namespace === 'erc721') {
            return readContract(client, {
                address: nft.contractAddress,
                abi: [
                    {
                        name: 'tokenURI',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'tokenId', type: 'uint256' }],
                        outputs: [{ name: '', type: 'string' }],
                    },
                ],
                functionName: 'tokenURI',
                args: [BigInt(nft.tokenID)],
            });
        }
        if (nft.namespace === 'erc1155') {
            return readContract(client, {
                address: nft.contractAddress,
                abi: [
                    {
                        name: 'uri',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: '_id', type: 'uint256' }],
                        outputs: [{ name: '', type: 'string' }],
                    },
                ],
                functionName: 'uri',
                args: [BigInt(nft.tokenID)],
            });
        }
        throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
    }

    async function parseAvatarRecord(client, { gatewayUrls, record, }) {
        if (/eip155:/i.test(record))
            return parseNftAvatarUri(client, { gatewayUrls, record });
        return parseAvatarUri({ uri: record, gatewayUrls });
    }
    async function parseNftAvatarUri(client, { gatewayUrls, record, }) {
        // parse NFT URI into properties
        const nft = parseNftUri(record);
        // fetch tokenURI from the NFT contract
        const nftUri = await getNftTokenUri(client, { nft });
        // resolve the URI from the fetched tokenURI
        const { uri: resolvedNftUri, isOnChain, isEncoded, } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
        // if the resolved URI is on chain, return the data
        if (isOnChain &&
            (resolvedNftUri.includes('data:application/json;base64,') ||
                resolvedNftUri.startsWith('{'))) {
            const encodedJson = isEncoded
                ? // if it is encoded, decode it
                    atob(resolvedNftUri.replace('data:application/json;base64,', ''))
                : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
                    resolvedNftUri;
            const decoded = JSON.parse(encodedJson);
            return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
        }
        let uriTokenId = nft.tokenID;
        if (nft.namespace === 'erc1155')
            uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');
        return getMetadataAvatarUri({
            gatewayUrls,
            uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),
        });
    }

    /**
     * Gets a text record for specified ENS name.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
     *
     * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
     *
     * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsTextParameters}
     * @returns Address for ENS resolver. {@link GetEnsTextReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsText, normalize } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const twitterRecord = await getEnsText(client, {
     *   name: normalize('wagmi-dev.eth'),
     *   key: 'com.twitter',
     * })
     * // 'wagmi_sh'
     */
    async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_, }) {
        let universalResolverAddress = universalResolverAddress_;
        if (!universalResolverAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. universalResolverAddress is required.');
            universalResolverAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'ensUniversalResolver',
            });
        }
        try {
            const res = await readContract(client, {
                address: universalResolverAddress,
                abi: universalResolverResolveAbi,
                functionName: 'resolve',
                args: [
                    toHex(packetToBytes(name)),
                    encodeFunctionData({
                        abi: textResolverAbi,
                        functionName: 'text',
                        args: [namehash(name), key],
                    }),
                ],
                blockNumber,
                blockTag,
            });
            if (res[0] === '0x')
                return null;
            const record = decodeFunctionResult({
                abi: textResolverAbi,
                functionName: 'text',
                data: res[0],
            });
            return record === '' ? null : record;
        }
        catch (err) {
            if (isNullUniversalResolverError(err, 'resolve'))
                return null;
            throw err;
        }
    }

    /**
     * Gets the avatar of an ENS name.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
     *
     * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`.
     *
     * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsAvatarParameters}
     * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsAvatar, normalize } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const ensAvatar = await getEnsAvatar(client, {
     *   name: normalize('wagmi-dev.eth'),
     * })
     * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'
     */
    async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress, }) {
        const record = await getEnsText(client, {
            blockNumber,
            blockTag,
            key: 'avatar',
            name,
            universalResolverAddress,
        });
        if (!record)
            return null;
        try {
            return await parseAvatarRecord(client, { record, gatewayUrls });
        }
        catch {
            return null;
        }
    }

    /**
     * Gets primary name for specified address.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsName.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
     *
     * Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsNameParameters}
     * @returns Name or `null` if not found. {@link GetEnsNameReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsName } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const ensName = await getEnsName(client, {
     *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
     * })
     * // 'wagmi-dev.eth'
     */
    async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_, }) {
        let universalResolverAddress = universalResolverAddress_;
        if (!universalResolverAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. universalResolverAddress is required.');
            universalResolverAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'ensUniversalResolver',
            });
        }
        const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
        try {
            const res = await readContract(client, {
                address: universalResolverAddress,
                abi: universalResolverReverseAbi,
                functionName: 'reverse',
                args: [toHex(packetToBytes(reverseNode))],
                blockNumber,
                blockTag,
            });
            return res[0];
        }
        catch (err) {
            if (isNullUniversalResolverError(err, 'reverse'))
                return null;
            throw err;
        }
    }

    /**
     * Gets resolver for ENS name.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
     *
     * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.
     *
     * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsResolverParameters}
     * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsResolver, normalize } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const resolverAddress = await getEnsResolver(client, {
     *   name: normalize('wagmi-dev.eth'),
     * })
     * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'
     */
    async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }) {
        let universalResolverAddress = universalResolverAddress_;
        if (!universalResolverAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. universalResolverAddress is required.');
            universalResolverAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'ensUniversalResolver',
            });
        }
        const [resolverAddress] = await readContract(client, {
            address: universalResolverAddress,
            abi: [
                {
                    inputs: [{ type: 'bytes' }],
                    name: 'findResolver',
                    outputs: [{ type: 'address' }, { type: 'bytes32' }],
                    stateMutability: 'view',
                    type: 'function',
                },
            ],
            functionName: 'findResolver',
            args: [toHex(packetToBytes(name))],
            blockNumber,
            blockTag,
        });
        return resolverAddress;
    }

    /**
     * Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).
     *
     * - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html
     * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)
     *
     * @param client - Client to use
     * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateBlockFilterReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createBlockFilter } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createBlockFilter(client)
     * // { id: "0x345a6572337856574a76364e457a4366", type: 'block' }
     */
    async function createBlockFilter(client) {
        const getRequest = createFilterRequestScope(client, {
            method: 'eth_newBlockFilter',
        });
        const id = await client.request({
            method: 'eth_newBlockFilter',
        });
        return { id, request: getRequest(id), type: 'block' };
    }

    /**
     * Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).
     *
     * - Docs: https://viem.sh/docs/actions/public/createEventFilter.html
     * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)
     *
     * @param client - Client to use
     * @param parameters - {@link CreateEventFilterParameters}
     * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateEventFilterReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createEventFilter } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createEventFilter(client, {
     *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
     * })
     */
    async function createEventFilter(client, { address, args, event, fromBlock, strict, toBlock, } = {}) {
        const getRequest = createFilterRequestScope(client, {
            method: 'eth_newFilter',
        });
        let topics = [];
        if (event)
            topics = encodeEventTopics({
                abi: [event],
                eventName: event.name,
                args,
            });
        const id = await client.request({
            method: 'eth_newFilter',
            params: [
                {
                    address,
                    fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,
                    toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,
                    ...(topics.length ? { topics } : {}),
                },
            ],
        });
        return {
            abi: event ? [event] : undefined,
            args,
            eventName: event ? event.name : undefined,
            id,
            request: getRequest(id),
            strict,
            type: 'event',
        };
    }

    /**
     * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).
     *
     * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html
     * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)
     *
     * @param client - Client to use
     * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateBlockFilterReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createPendingTransactionFilter } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createPendingTransactionFilter(client)
     * // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' }
     */
    async function createPendingTransactionFilter(client) {
        const getRequest = createFilterRequestScope(client, {
            method: 'eth_newPendingTransactionFilter',
        });
        const id = await client.request({
            method: 'eth_newPendingTransactionFilter',
        });
        return { id, request: getRequest(id), type: 'transaction' };
    }

    /**
     * Returns the balance of an address in wei.
     *
     * - Docs: https://viem.sh/docs/actions/public/getBalance.html
     * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)
     *
     * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html).
     *
     * ```ts
     * const balance = await getBalance(client, {
     *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     *   blockTag: 'safe'
     * })
     * const balanceAsEther = formatEther(balance)
     * // "6.942"
     * ```
     *
     * @param client - Client to use
     * @param parameters - {@link GetBalanceParameters}
     * @returns The balance of the address in wei. {@link GetBalanceReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getBalance } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const balance = await getBalance(client, {
     *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     * })
     * // 10000000000000000000000n (wei)
     */
    async function getBalance(client, { address, blockNumber, blockTag = 'latest' }) {
        const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
        const balance = await client.request({
            method: 'eth_getBalance',
            params: [address, blockNumberHex || blockTag],
        });
        return BigInt(balance);
    }

    /**
     * Returns the number of Transactions at a block number, hash, or tag.
     *
     * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html
     * - JSON-RPC Methods:
     *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.
     *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.
     *
     * @param client - Client to use
     * @param parameters - {@link GetBlockTransactionCountParameters}
     * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getBlockTransactionCount } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const count = await getBlockTransactionCount(client)
     */
    async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = 'latest', } = {}) {
        const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
        let count;
        if (blockHash) {
            count = await client.request({
                method: 'eth_getBlockTransactionCountByHash',
                params: [blockHash],
            });
        }
        else {
            count = await client.request({
                method: 'eth_getBlockTransactionCountByNumber',
                params: [blockNumberHex || blockTag],
            });
        }
        return hexToNumber(count);
    }

    /**
     * Retrieves the bytecode at an address.
     *
     * - Docs: https://viem.sh/docs/contract/getBytecode.html
     * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)
     *
     * @param client - Client to use
     * @param parameters - {@link GetBytecodeParameters}
     * @returns The contract's bytecode. {@link GetBytecodeReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getBytecode } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const code = await getBytecode(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     * })
     */
    async function getBytecode(client, { address, blockNumber, blockTag = 'latest' }) {
        const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
        const hex = await client.request({
            method: 'eth_getCode',
            params: [address, blockNumberHex || blockTag],
        });
        if (hex === '0x')
            return undefined;
        return hex;
    }

    function formatFeeHistory(feeHistory) {
        return {
            baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
            gasUsedRatio: feeHistory.gasUsedRatio,
            oldestBlock: BigInt(feeHistory.oldestBlock),
            reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value))),
        };
    }

    /**
     * Returns a collection of historical gas information.
     *
     * - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html
     * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)
     *
     * @param client - Client to use
     * @param parameters - {@link GetFeeHistoryParameters}
     * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getFeeHistory } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const feeHistory = await getFeeHistory(client, {
     *   blockCount: 4,
     *   rewardPercentiles: [25, 75],
     * })
     */
    async function getFeeHistory(client, { blockCount, blockNumber, blockTag = 'latest', rewardPercentiles, }) {
        const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
        const feeHistory = await client.request({
            method: 'eth_feeHistory',
            params: [
                numberToHex(blockCount),
                blockNumberHex || blockTag,
                rewardPercentiles,
            ],
        });
        return formatFeeHistory(feeHistory);
    }

    /**
     * Returns a list of event logs since the filter was created.
     *
     * - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html
     * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)
     *
     * `getFilterLogs` is only compatible with **event filters**.
     *
     * @param client - Client to use
     * @param parameters - {@link GetFilterLogsParameters}
     * @returns A list of event logs. {@link GetFilterLogsReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbiItem } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { createEventFilter, getFilterLogs } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const filter = await createEventFilter(client, {
     *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
     *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
     * })
     * const logs = await getFilterLogs(client, { filter })
     */
    async function getFilterLogs(_client, { filter }) {
        const strict = filter.strict ?? false;
        const logs = await filter.request({
            method: 'eth_getFilterLogs',
            params: [filter.id],
        });
        return logs
            .map((log) => {
            try {
                const { eventName, args } = 'abi' in filter && filter.abi
                    ? decodeEventLog({
                        abi: filter.abi,
                        data: log.data,
                        topics: log.topics,
                        strict,
                    })
                    : { eventName: undefined, args: undefined };
                return formatLog(log, { args, eventName });
            }
            catch (err) {
                let eventName;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch ||
                    err instanceof DecodeLogTopicsMismatch) {
                    // If strict mode is on, and log data/topics do not match event definition, skip.
                    if ('strict' in filter && filter.strict)
                        return;
                    eventName = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
                }
                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
                return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
            }
        })
            .filter(Boolean);
    }

    /**
     * Returns the value from a storage slot at a given address.
     *
     * - Docs: https://viem.sh/docs/contract/getStorageAt.html
     * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)
     *
     * @param client - Client to use
     * @param parameters - {@link GetStorageAtParameters}
     * @returns The value of the storage slot. {@link GetStorageAtReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getStorageAt } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const code = await getStorageAt(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   slot: toHex(0),
     * })
     */
    async function getStorageAt(client, { address, blockNumber, blockTag = 'latest', slot }) {
        const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
        const data = await client.request({
            method: 'eth_getStorageAt',
            params: [address, slot, blockNumberHex || blockTag],
        });
        return data;
    }

    /**
     * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier.
     *
     * - Docs: https://viem.sh/docs/actions/public/getTransaction.html
     * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions
     * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)
     *
     * @param client - Client to use
     * @param parameters - {@link GetTransactionParameters}
     * @returns The transaction information. {@link GetTransactionReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getTransaction } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const transaction = await getTransaction(client, {
     *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
     * })
     */
    async function getTransaction(client, { blockHash, blockNumber, blockTag = 'latest', hash, index, }) {
        const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
        let transaction = null;
        if (hash) {
            transaction = await client.request({
                method: 'eth_getTransactionByHash',
                params: [hash],
            });
        }
        else if (blockHash) {
            transaction = await client.request({
                method: 'eth_getTransactionByBlockHashAndIndex',
                params: [blockHash, numberToHex(index)],
            });
        }
        else if (blockNumberHex || blockTag) {
            transaction = await client.request({
                method: 'eth_getTransactionByBlockNumberAndIndex',
                params: [blockNumberHex || blockTag, numberToHex(index)],
            });
        }
        if (!transaction)
            throw new TransactionNotFoundError({
                blockHash,
                blockNumber,
                blockTag,
                hash,
                index,
            });
        const format = client.chain?.formatters?.transaction?.format || formatTransaction;
        return format(transaction);
    }

    /**
     * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.
     *
     * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html
     * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions
     * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)
     *
     * @param client - Client to use
     * @param parameters - {@link GetTransactionConfirmationsParameters}
     * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getTransactionConfirmations } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const confirmations = await getTransactionConfirmations(client, {
     *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
     * })
     */
    async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
        const [blockNumber, transaction] = await Promise.all([
            getBlockNumber(client),
            hash ? getTransaction(client, { hash }) : undefined,
        ]);
        const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
        if (!transactionBlockNumber)
            return 0n;
        return blockNumber - transactionBlockNumber + 1n;
    }

    /**
     * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.
     *
     * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html
     * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions
     * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)
     *
     * @param client - Client to use
     * @param parameters - {@link GetTransactionReceiptParameters}
     * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getTransactionReceipt } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const transactionReceipt = await getTransactionReceipt(client, {
     *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
     * })
     */
    async function getTransactionReceipt(client, { hash }) {
        const receipt = await client.request({
            method: 'eth_getTransactionReceipt',
            params: [hash],
        });
        if (!receipt)
            throw new TransactionReceiptNotFoundError({ hash });
        const format = client.chain?.formatters?.transactionReceipt?.format ||
            formatTransactionReceipt;
        return format(receipt);
    }

    /**
     * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).
     *
     * - Docs: https://viem.sh/docs/contract/multicall.html
     *
     * @param client - Client to use
     * @param parameters - {@link MulticallParameters}
     * @returns An array of results with accompanying status. {@link MulticallReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { multicall } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const abi = parseAbi([
     *   'function balanceOf(address) view returns (uint256)',
     *   'function totalSupply() view returns (uint256)',
     * ])
     * const results = await multicall(client, {
     *   contracts: [
     *     {
     *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *       abi,
     *       functionName: 'balanceOf',
     *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
     *     },
     *     {
     *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *       abi,
     *       functionName: 'totalSupply',
     *     },
     *   ],
     * })
     * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]
     */
    async function multicall(client, args) {
        const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_, } = args;
        const batchSize = batchSize_ ??
            ((typeof client.batch?.multicall === 'object' &&
                client.batch.multicall.batchSize) ||
                1024);
        // Fix type cast from `Narrow` in type definition.
        const contracts = contracts_;
        let multicallAddress = multicallAddress_;
        if (!multicallAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. multicallAddress is required.');
            multicallAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'multicall3',
            });
        }
        const chunkedCalls = [[]];
        let currentChunk = 0;
        let currentChunkSize = 0;
        for (let i = 0; i < contracts.length; i++) {
            const { abi, address, args, functionName } = contracts[i];
            try {
                const callData = encodeFunctionData({
                    abi,
                    args,
                    functionName,
                });
                currentChunkSize += callData.length;
                if (batchSize > 0 && currentChunkSize > batchSize) {
                    currentChunk++;
                    currentChunkSize = (callData.length - 2) / 2;
                    chunkedCalls[currentChunk] = [];
                }
                chunkedCalls[currentChunk] = [
                    ...chunkedCalls[currentChunk],
                    {
                        allowFailure: true,
                        callData,
                        target: address,
                    },
                ];
            }
            catch (err) {
                const error = getContractError(err, {
                    abi,
                    address,
                    args,
                    docsPath: '/docs/contract/multicall',
                    functionName,
                });
                if (!allowFailure)
                    throw error;
                chunkedCalls[currentChunk] = [
                    ...chunkedCalls[currentChunk],
                    {
                        allowFailure: true,
                        callData: '0x',
                        target: address,
                    },
                ];
            }
        }
        const results = await Promise.all(chunkedCalls.map((calls) => readContract(client, {
            abi: multicall3Abi,
            address: multicallAddress,
            args: [calls],
            blockNumber,
            blockTag,
            functionName: 'aggregate3',
        })));
        return results.flat().map(({ returnData, success }, i) => {
            const calls = chunkedCalls.flat();
            const { callData } = calls[i];
            const { abi, address, functionName, args } = contracts[i];
            try {
                if (callData === '0x')
                    throw new AbiDecodingZeroDataError();
                if (!success)
                    throw new RawContractError({ data: returnData });
                const result = decodeFunctionResult({
                    abi,
                    args,
                    data: returnData,
                    functionName: functionName,
                });
                return allowFailure ? { result, status: 'success' } : result;
            }
            catch (err) {
                const error = getContractError(err, {
                    abi,
                    address,
                    args,
                    docsPath: '/docs/contract/multicall',
                    functionName,
                });
                if (!allowFailure)
                    throw error;
                return { error, result: undefined, status: 'failure' };
            }
        });
    }

    const universalSignatureValidatorByteCode = '0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';

    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    BigInt(0);
    BigInt(1);
    BigInt(2);
    Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
    function equalBytes(b1, b2) {
        // We don't care about timing attacks here
        if (b1.length !== b2.length)
            return false;
        for (let i = 0; i < b1.length; i++)
            if (b1[i] !== b2[i])
                return false;
        return true;
    }
    // validate type tests
    // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
    // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
    // // Should fail type-check
    // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
    // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
    // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
    // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

    function isBytesEqual(a_, b_) {
        const a = isHex(a_) ? toBytes$1(a_) : a_;
        const b = isHex(b_) ? toBytes$1(b_) : b_;
        return equalBytes(a, b);
    }

    /**
     * Verifies a message hash on chain using ERC-6492.
     *
     * @param client - Client to use.
     * @param parameters - {@link VerifyHashParameters}
     * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}
     */
    async function verifyHash(client, { address, hash, signature, ...callRequest }) {
        const signatureHex = isHex(signature) ? signature : toHex(signature);
        try {
            const { data } = await call(client, {
                data: encodeDeployData({
                    abi: universalSignatureValidatorAbi,
                    args: [address, hash, signatureHex],
                    bytecode: universalSignatureValidatorByteCode,
                }),
                ...callRequest,
            });
            return isBytesEqual(data ?? '0x0', '0x1');
        }
        catch (error) {
            if (error instanceof CallExecutionError) {
                // if the execution fails, the signature was not valid and an internal method inside of the validator reverted
                // this can happen for many reasons, for example if signer can not be recovered from the signature
                // or if the signature has no valid format
                return false;
            }
            throw error;
        }
    }

    /**
     * Verify that a message was signed by the provided address.
     *
     * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).
     *
     * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage.html}
     *
     * @param client - Client to use.
     * @param parameters - {@link VerifyMessageParameters}
     * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
     */
    async function verifyMessage(client, { address, message, signature, ...callRequest }) {
        const hash = hashMessage(message);
        return verifyHash(client, {
            address,
            hash,
            signature,
            ...callRequest,
        });
    }

    /**
     * Verify that typed data was signed by the provided address.
     *
     * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData.html}
     *
     * @param client - Client to use.
     * @param parameters - {@link VerifyTypedDataParameters}
     * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}
     */
    async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
        const hash = hashTypedData({ message, primaryType, types, domain });
        return verifyHash(client, {
            address,
            hash,
            signature,
            ...callRequest,
        });
    }

    /**
     * Watches and returns incoming block numbers.
     *
     * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks
     * - JSON-RPC Methods:
     *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.
     *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
     *
     * @param client - Client to use
     * @param parameters - {@link WatchBlockNumberParameters}
     * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}
     *
     * @example
     * import { createPublicClient, watchBlockNumber, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const unwatch = watchBlockNumber(client, {
     *   onBlockNumber: (blockNumber) => console.log(blockNumber),
     * })
     */
    function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, }) {
        const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
        let prevBlockNumber;
        const pollBlockNumber = () => {
            const observerId = stringify([
                'watchBlockNumber',
                client.uid,
                emitOnBegin,
                emitMissed,
                pollingInterval,
            ]);
            return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
                try {
                    const blockNumber = await getBlockNumber(client, { maxAge: 0 });
                    if (prevBlockNumber) {
                        // If the current block number is the same as the previous,
                        // we can skip.
                        if (blockNumber === prevBlockNumber)
                            return;
                        // If we have missed out on some previous blocks, and the
                        // `emitMissed` flag is truthy, let's emit those blocks.
                        if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                                emit.onBlockNumber(i, prevBlockNumber);
                                prevBlockNumber = i;
                            }
                        }
                    }
                    // If the next block number is greater than the previous,
                    // it is not in the past, and we can emit the new block number.
                    if (!prevBlockNumber || blockNumber > prevBlockNumber) {
                        emit.onBlockNumber(blockNumber, prevBlockNumber);
                        prevBlockNumber = blockNumber;
                    }
                }
                catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin,
                interval: pollingInterval,
            }));
        };
        const subscribeBlockNumber = () => {
            let active = true;
            let unsubscribe = () => (active = false);
            (async () => {
                try {
                    const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                        params: ['newHeads'],
                        onData(data) {
                            if (!active)
                                return;
                            const blockNumber = hexToBigInt(data.result?.number);
                            onBlockNumber(blockNumber, prevBlockNumber);
                            prevBlockNumber = blockNumber;
                        },
                        onError(error) {
                            onError?.(error);
                        },
                    });
                    unsubscribe = unsubscribe_;
                    if (!active)
                        unsubscribe();
                }
                catch (err) {
                    onError?.(err);
                }
            })();
            return unsubscribe;
        };
        return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
    }

    /**
     * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.
     *
     * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html
     * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions
     * - JSON-RPC Methods:
     *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.
     *   - If a Transaction has been replaced:
     *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions
     *     - Checks if one of the Transactions is a replacement
     *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).
     *
     * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).
     *
     * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.
     *
     * There are 3 types of Transaction Replacement reasons:
     *
     * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)
     * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)
     * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)
     *
     * @param client - Client to use
     * @param parameters - {@link WaitForTransactionReceiptParameters}
     * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}
     *
     * @example
     * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const transactionReceipt = await waitForTransactionReceipt(client, {
     *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
     * })
     */
    async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout, }) {
        const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);
        let transaction;
        let replacedTransaction;
        let receipt;
        let retrying = false;
        return new Promise((resolve, reject) => {
            if (timeout)
                setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash })), timeout);
            const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
                const _unwatch = watchBlockNumber(client, {
                    emitMissed: true,
                    emitOnBegin: true,
                    poll: true,
                    pollingInterval,
                    async onBlockNumber(blockNumber_) {
                        if (retrying)
                            return;
                        let blockNumber = blockNumber_;
                        const done = (fn) => {
                            _unwatch();
                            fn();
                            _unobserve();
                        };
                        try {
                            // If we already have a valid receipt, let's check if we have enough
                            // confirmations. If we do, then we can resolve.
                            if (receipt) {
                                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                                    return;
                                done(() => emit.resolve(receipt));
                                return;
                            }
                            // Get the transaction to check if it's been replaced.
                            // We need to retry as some RPC Providers may be slow to sync
                            // up mined transactions.
                            if (!transaction) {
                                retrying = true;
                                await withRetry(async () => {
                                    transaction = await getTransaction(client, { hash });
                                    if (transaction.blockNumber)
                                        blockNumber = transaction.blockNumber;
                                }, {
                                    // exponential backoff
                                    delay: ({ count }) => ~~(1 << count) * 200,
                                    retryCount: 6,
                                });
                                retrying = false;
                            }
                            // Get the receipt to check if it's been processed.
                            receipt = await getTransactionReceipt(client, { hash });
                            // Check if we have enough confirmations. If not, continue polling.
                            if (confirmations > 0 &&
                                blockNumber - receipt.blockNumber + 1n < confirmations)
                                return;
                            done(() => emit.resolve(receipt));
                        }
                        catch (err) {
                            // If the receipt is not found, the transaction will be pending.
                            // We need to check if it has potentially been replaced.
                            if (transaction &&
                                (err instanceof TransactionNotFoundError ||
                                    err instanceof TransactionReceiptNotFoundError)) {
                                replacedTransaction = transaction;
                                // Let's retrieve the transactions from the current block.
                                const block = await getBlock(client, {
                                    blockNumber,
                                    includeTransactions: true,
                                });
                                const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from &&
                                    nonce === replacedTransaction.nonce);
                                // If we couldn't find a replacement transaction, continue polling.
                                if (!replacementTransaction)
                                    return;
                                // If we found a replacement transaction, return it's receipt.
                                receipt = await getTransactionReceipt(client, {
                                    hash: replacementTransaction.hash,
                                });
                                // Check if we have enough confirmations. If not, continue polling.
                                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                                    return;
                                let reason = 'replaced';
                                if (replacementTransaction.to === replacedTransaction.to &&
                                    replacementTransaction.value === replacedTransaction.value) {
                                    reason = 'repriced';
                                }
                                else if (replacementTransaction.from === replacementTransaction.to &&
                                    replacementTransaction.value === 0n) {
                                    reason = 'cancelled';
                                }
                                done(() => {
                                    emit.onReplaced?.({
                                        reason,
                                        replacedTransaction: replacedTransaction,
                                        transaction: replacementTransaction,
                                        transactionReceipt: receipt,
                                    });
                                    emit.resolve(receipt);
                                });
                            }
                            else {
                                done(() => emit.reject(err));
                            }
                        }
                    },
                });
            });
        });
    }

    /**
     * Watches and returns information for incoming blocks.
     *
     * - Docs: https://viem.sh/docs/actions/public/watchBlocks.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks
     * - JSON-RPC Methods:
     *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.
     *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
     *
     * @param client - Client to use
     * @param parameters - {@link WatchBlocksParameters}
     * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}
     *
     * @example
     * import { createPublicClient, watchBlocks, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const unwatch = watchBlocks(client, {
     *   onBlock: (block) => console.log(block),
     * })
     */
    function watchBlocks(client, { blockTag = 'latest', emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions = false, poll: poll_, pollingInterval = client.pollingInterval, }) {
        const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
        let prevBlock;
        const pollBlocks = () => {
            const observerId = stringify([
                'watchBlocks',
                client.uid,
                emitMissed,
                emitOnBegin,
                includeTransactions,
                pollingInterval,
            ]);
            return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
                try {
                    const block = await getBlock(client, {
                        blockTag,
                        includeTransactions,
                    });
                    if (block.number && prevBlock?.number) {
                        // If the current block number is the same as the previous,
                        // we can skip.
                        if (block.number === prevBlock.number)
                            return;
                        // If we have missed out on some previous blocks, and the
                        // `emitMissed` flag is truthy, let's emit those blocks.
                        if (block.number - prevBlock.number > 1 && emitMissed) {
                            for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                                const block = await getBlock(client, {
                                    blockNumber: i,
                                    includeTransactions,
                                });
                                emit.onBlock(block, prevBlock);
                                prevBlock = block;
                            }
                        }
                    }
                    if (
                    // If no previous block exists, emit.
                    !prevBlock?.number ||
                        // If the block tag is "pending" with no block number, emit.
                        (blockTag === 'pending' && !block?.number) ||
                        // If the next block number is greater than the previous block number, emit.
                        // We don't want to emit blocks in the past.
                        (block.number && block.number > prevBlock.number)) {
                        emit.onBlock(block, prevBlock);
                        prevBlock = block;
                    }
                }
                catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin,
                interval: pollingInterval,
            }));
        };
        const subscribeBlocks = () => {
            let active = true;
            let unsubscribe = () => (active = false);
            (async () => {
                try {
                    const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                        params: ['newHeads'],
                        onData(data) {
                            if (!active)
                                return;
                            const format = client.chain?.formatters?.block?.format || formatBlock;
                            const block = format(data.result);
                            onBlock(block, prevBlock);
                            prevBlock = block;
                        },
                        onError(error) {
                            onError?.(error);
                        },
                    });
                    unsubscribe = unsubscribe_;
                    if (!active)
                        unsubscribe();
                }
                catch (err) {
                    onError?.(err);
                }
            })();
            return unsubscribe;
        };
        return enablePolling ? pollBlocks() : subscribeBlocks();
    }

    /**
     * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log).
     *
     * - Docs: https://viem.sh/docs/actions/public/watchEvent.html
     * - JSON-RPC Methods:
     *   - **RPC Provider supports `eth_newFilter`:**
     *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).
     *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).
     *   - **RPC Provider does not support `eth_newFilter`:**
     *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.
     *
     * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs).
     *
     * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead.
     *
     * @param client - Client to use
     * @param parameters - {@link WatchEventParameters}
     * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { watchEvent } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const unwatch = watchEvent(client, {
     *   onLogs: (logs) => console.log(logs),
     * })
     */
    function watchEvent(client, { address, args, batch = true, event, onError, onLogs, pollingInterval = client.pollingInterval, strict: strict_, }) {
        const observerId = stringify([
            'watchEvent',
            address,
            args,
            batch,
            client.uid,
            event,
            pollingInterval,
        ]);
        const strict = strict_ ?? false;
        return observe(observerId, { onLogs, onError }, (emit) => {
            let previousBlockNumber;
            let filter;
            let initialized = false;
            const unwatch = poll(async () => {
                if (!initialized) {
                    try {
                        filter = (await createEventFilter(client, {
                            address,
                            args,
                            event: event,
                            strict,
                        }));
                    }
                    catch { }
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) {
                        logs = await getFilterChanges(client, { filter });
                    }
                    else {
                        // If the filter doesn't exist, we will fall back to use `getLogs`.
                        // The fall back exists because some RPC Providers do not support filters.
                        // Fetch the block number to use for `getLogs`.
                        const blockNumber = await getBlockNumber(client);
                        // If the block number has changed, we will need to fetch the logs.
                        // If the block number doesn't exist, we are yet to reach the first poll interval,
                        // so do not emit any logs.
                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                            logs = await getLogs(client, {
                                address,
                                args,
                                fromBlock: previousBlockNumber + 1n,
                                toBlock: blockNumber,
                                event: event,
                            });
                        }
                        else {
                            logs = [];
                        }
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0)
                        return;
                    if (batch)
                        emit.onLogs(logs);
                    else
                        logs.forEach((log) => emit.onLogs([log]));
                }
                catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await uninstallFilter(client, { filter });
                unwatch();
            };
        });
    }

    /**
     * Watches and returns pending transaction hashes.
     *
     * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html
     * - JSON-RPC Methods:
     *   - When `poll: true`
     *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.
     *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.
     *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event.
     *
     * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions).
     *
     * @param client - Client to use
     * @param parameters - {@link WatchPendingTransactionsParameters}
     * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { watchPendingTransactions } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const unwatch = await watchPendingTransactions(client, {
     *   onTransactions: (hashes) => console.log(hashes),
     * })
     */
    function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval, }) {
        const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
        const pollPendingTransactions = () => {
            const observerId = stringify([
                'watchPendingTransactions',
                client.uid,
                batch,
                pollingInterval,
            ]);
            return observe(observerId, { onTransactions, onError }, (emit) => {
                let filter;
                const unwatch = poll(async () => {
                    try {
                        if (!filter) {
                            try {
                                filter = await createPendingTransactionFilter(client);
                                return;
                            }
                            catch (err) {
                                unwatch();
                                throw err;
                            }
                        }
                        const hashes = await getFilterChanges(client, { filter });
                        if (hashes.length === 0)
                            return;
                        if (batch)
                            emit.onTransactions(hashes);
                        else
                            hashes.forEach((hash) => emit.onTransactions([hash]));
                    }
                    catch (err) {
                        emit.onError?.(err);
                    }
                }, {
                    emitOnBegin: true,
                    interval: pollingInterval,
                });
                return async () => {
                    if (filter)
                        await uninstallFilter(client, { filter });
                    unwatch();
                };
            });
        };
        const subscribePendingTransactions = () => {
            let active = true;
            let unsubscribe = () => (active = false);
            (async () => {
                try {
                    const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                        params: ['newPendingTransactions'],
                        onData(data) {
                            if (!active)
                                return;
                            const transaction = data.result;
                            onTransactions([transaction]);
                        },
                        onError(error) {
                            onError?.(error);
                        },
                    });
                    unsubscribe = unsubscribe_;
                    if (!active)
                        unsubscribe();
                }
                catch (err) {
                    onError?.(err);
                }
            })();
            return unsubscribe;
        };
        return enablePolling
            ? pollPendingTransactions()
            : subscribePendingTransactions();
    }

    function publicActions(client) {
        return {
            call: (args) => call(client, args),
            createBlockFilter: () => createBlockFilter(client),
            createContractEventFilter: (args) => createContractEventFilter(client, args),
            createEventFilter: (args) => createEventFilter(client, args),
            createPendingTransactionFilter: () => createPendingTransactionFilter(client),
            estimateContractGas: (args) => estimateContractGas(client, args),
            estimateGas: (args) => estimateGas(client, args),
            getBalance: (args) => getBalance(client, args),
            getBlock: (args) => getBlock(client, args),
            getBlockNumber: (args) => getBlockNumber(client, args),
            getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
            getBytecode: (args) => getBytecode(client, args),
            getChainId: () => getChainId(client),
            getEnsAddress: (args) => getEnsAddress(client, args),
            getEnsAvatar: (args) => getEnsAvatar(client, args),
            getEnsName: (args) => getEnsName(client, args),
            getEnsResolver: (args) => getEnsResolver(client, args),
            getEnsText: (args) => getEnsText(client, args),
            getFeeHistory: (args) => getFeeHistory(client, args),
            getFilterChanges: (args) => getFilterChanges(client, args),
            getFilterLogs: (args) => getFilterLogs(client, args),
            getGasPrice: () => getGasPrice(client),
            getLogs: (args) => getLogs(client, args),
            getStorageAt: (args) => getStorageAt(client, args),
            getTransaction: (args) => getTransaction(client, args),
            getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
            getTransactionCount: (args) => getTransactionCount(client, args),
            getTransactionReceipt: (args) => getTransactionReceipt(client, args),
            multicall: (args) => multicall(client, args),
            readContract: (args) => readContract(client, args),
            simulateContract: (args) => simulateContract(client, args),
            verifyMessage: (args) => verifyMessage(client, args),
            verifyTypedData: (args) => verifyTypedData(client, args),
            uninstallFilter: (args) => uninstallFilter(client, args),
            waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
            watchBlocks: (args) => watchBlocks(client, args),
            watchBlockNumber: (args) => watchBlockNumber(client, args),
            watchContractEvent: (args) => watchContractEvent(client, args),
            watchEvent: (args) => watchEvent(client, args),
            watchPendingTransactions: (args) => watchPendingTransactions(client, args),
        };
    }

    function createPublicClient(parameters) {
        const { key = 'public', name = 'Public Client' } = parameters;
        const client = createClient({
            ...parameters,
            key,
            name,
            type: 'publicClient',
        });
        return client.extend(publicActions);
    }

    /**
     * Deploys a contract to the network, given bytecode and constructor arguments.
     *
     * - Docs: https://viem.sh/docs/contract/deployContract.html
     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/deploying-contracts
     *
     * @param client - Client to use
     * @param parameters - {@link DeployContractParameters}
     * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link DeployContractReturnType}
     *
     * @example
     * import { createWalletClient, http } from 'viem'
     * import { privateKeyToAccount } from 'viem/accounts'
     * import { mainnet } from 'viem/chains'
     * import { deployContract } from 'viem/contract'
     *
     * const client = createWalletClient({
     *   account: privateKeyToAccount('0x…'),
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const hash = await deployContract(client, {
     *   abi: [],
     *   account: '0x…,
     *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
     * })
     */
    function deployContract(walletClient, { abi, args, bytecode, ...request }) {
        const calldata = encodeDeployData({
            abi,
            args,
            bytecode,
        });
        return sendTransaction(walletClient, {
            ...request,
            data: calldata,
        });
    }

    /**
     * Returns a list of account addresses owned by the wallet or client.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/getAddresses.html
     * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)
     *
     * @param client - Client to use
     * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getAddresses } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const accounts = await getAddresses(client)
     */
    async function getAddresses(client) {
        const addresses = await client.request({ method: 'eth_accounts' });
        return addresses.map((address) => checksumAddress(address));
    }

    /**
     * Gets the wallets current permissions.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/getPermissions.html
     * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
     *
     * @param client - Client to use
     * @returns The wallet permissions. {@link GetPermissionsReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getPermissions } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const permissions = await getPermissions(client)
     */
    async function getPermissions(client) {
        const permissions = await client.request({ method: 'wallet_getPermissions' });
        return permissions;
    }

    /**
     * Requests a list of accounts managed by a wallet.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses.html
     * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)
     *
     * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).
     *
     * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.
     *
     * @param client - Client to use
     * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { requestAddresses } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const accounts = await requestAddresses(client)
     */
    async function requestAddresses(client) {
        const addresses = await client.request({ method: 'eth_requestAccounts' });
        return addresses.map((address) => getAddress(address));
    }

    /**
     * Requests permissions for a wallet.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions.html
     * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
     *
     * @param client - Client to use
     * @param parameters - {@link RequestPermissionsParameters}
     * @returns The wallet permissions. {@link RequestPermissionsReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { requestPermissions } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const permissions = await requestPermissions(client, {
     *   eth_accounts: {}
     * })
     */
    async function requestPermissions(client, permissions) {
        return client.request({
            method: 'wallet_requestPermissions',
            params: [permissions],
        });
    }

    /**
     * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html
     * - JSON-RPC Methods:
     *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)
     *   - Local Accounts: Signs locally. No JSON-RPC request.
     *
     * With the calculated signature, you can:
     * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,
     * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.
     *
     * @param client - Client to use
     * @param parameters - {@link SignMessageParameters}
     * @returns The signed message. {@link SignMessageReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { signMessage } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const signature = await signMessage(client, {
     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     *   message: 'hello world',
     * })
     *
     * @example
     * // Account Hoisting
     * import { createWalletClient, custom } from 'viem'
     * import { privateKeyToAccount } from 'viem/accounts'
     * import { mainnet } from 'viem/chains'
     * import { signMessage } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   account: privateKeyToAccount('0x…'),
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const signature = await signMessage(client, {
     *   message: 'hello world',
     * })
     */
    async function signMessage(client, { account: account_ = client.account, message, }) {
        if (!account_)
            throw new AccountNotFoundError({
                docsPath: '/docs/actions/wallet/signMessage',
            });
        const account = parseAccount(account_);
        if (account.type === 'local')
            return account.signMessage({ message });
        const message_ = (() => {
            if (typeof message === 'string')
                return stringToHex(message);
            if (message.raw instanceof Uint8Array)
                return toHex(message.raw);
            return message.raw;
        })();
        return client.request({
            method: 'personal_sign',
            params: [message_, account.address],
        });
    }

    /**
     * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message)))`
     *
     * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html
     * - JSON-RPC Methods:
     *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)
     *   - Local Accounts: Signs locally. No JSON-RPC request.
     *
     * @param client - Client to use
     * @param parameters - {@link SignTypedDataParameters}
     * @returns The signed data. {@link SignTypedDataReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { signTypedData } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const signature = await signTypedData(client, {
     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     *   domain: {
     *     name: 'Ether Mail',
     *     version: '1',
     *     chainId: 1,
     *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
     *   },
     *   types: {
     *     Person: [
     *       { name: 'name', type: 'string' },
     *       { name: 'wallet', type: 'address' },
     *     ],
     *     Mail: [
     *       { name: 'from', type: 'Person' },
     *       { name: 'to', type: 'Person' },
     *       { name: 'contents', type: 'string' },
     *     ],
     *   },
     *   primaryType: 'Mail',
     *   message: {
     *     from: {
     *       name: 'Cow',
     *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
     *     },
     *     to: {
     *       name: 'Bob',
     *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
     *     },
     *     contents: 'Hello, Bob!',
     *   },
     * })
     *
     * @example
     * // Account Hoisting
     * import { createWalletClient, http } from 'viem'
     * import { privateKeyToAccount } from 'viem/accounts'
     * import { mainnet } from 'viem/chains'
     * import { signTypedData } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   account: privateKeyToAccount('0x…'),
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const signature = await signTypedData(client, {
     *   domain: {
     *     name: 'Ether Mail',
     *     version: '1',
     *     chainId: 1,
     *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
     *   },
     *   types: {
     *     Person: [
     *       { name: 'name', type: 'string' },
     *       { name: 'wallet', type: 'address' },
     *     ],
     *     Mail: [
     *       { name: 'from', type: 'Person' },
     *       { name: 'to', type: 'Person' },
     *       { name: 'contents', type: 'string' },
     *     ],
     *   },
     *   primaryType: 'Mail',
     *   message: {
     *     from: {
     *       name: 'Cow',
     *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
     *     },
     *     to: {
     *       name: 'Bob',
     *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
     *     },
     *     contents: 'Hello, Bob!',
     *   },
     * })
     */
    async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_, }) {
        if (!account_)
            throw new AccountNotFoundError({
                docsPath: '/docs/actions/wallet/signTypedData',
            });
        const account = parseAccount(account_);
        const types = {
            EIP712Domain: [
                typeof domain?.name === 'string' && { name: 'name', type: 'string' },
                domain?.version && { name: 'version', type: 'string' },
                typeof domain?.chainId === 'number' && {
                    name: 'chainId',
                    type: 'uint256',
                },
                domain?.verifyingContract && {
                    name: 'verifyingContract',
                    type: 'address',
                },
                domain?.salt && { name: 'salt', type: 'bytes32' },
            ].filter(Boolean),
            ...types_,
        };
        // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
        // as we can't statically check this with TypeScript.
        validateTypedData({
            domain,
            message,
            primaryType,
            types,
        });
        if (account.type === 'local')
            return account.signTypedData({
                domain,
                primaryType,
                types,
                message,
            });
        const typedData = stringify({ domain: domain ?? {}, primaryType, types, message }, (_, value) => (isHex(value) ? value.toLowerCase() : value));
        return client.request({
            method: 'eth_signTypedData_v4',
            params: [account.address, typedData],
        });
    }

    /**
     * Switch the target chain in a wallet.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/switchChain.html
     * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)
     *
     * @param client - Client to use
     * @param parameters - {@link SwitchChainParameters}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet, optimism } from 'viem/chains'
     * import { switchChain } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * await switchChain(client, { id: optimism.id })
     */
    async function switchChain(client, { id }) {
        await client.request({
            method: 'wallet_switchEthereumChain',
            params: [
                {
                    chainId: numberToHex(id),
                },
            ],
        });
    }

    /**
     * Adds an EVM chain to the wallet.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/watchAsset.html
     * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)
     *
     * @param client - Client to use
     * @param parameters - {@link WatchAssetParameters}
     * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { watchAsset } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const success = await watchAsset(client, {
     *   type: 'ERC20',
     *   options: {
     *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
     *     decimals: 18,
     *     symbol: 'WETH',
     *   },
     * })
     */
    async function watchAsset(client, params) {
        const added = await client.request({
            method: 'wallet_watchAsset',
            params,
        });
        return added;
    }

    function walletActions(client) {
        return {
            addChain: (args) => addChain(client, args),
            deployContract: (args) => deployContract(client, args),
            getAddresses: () => getAddresses(client),
            getChainId: () => getChainId(client),
            getPermissions: () => getPermissions(client),
            requestAddresses: () => requestAddresses(client),
            requestPermissions: (args) => requestPermissions(client, args),
            sendTransaction: (args) => sendTransaction(client, args),
            signMessage: (args) => signMessage(client, args),
            signTypedData: (args) => signTypedData(client, args),
            switchChain: (args) => switchChain(client, args),
            watchAsset: (args) => watchAsset(client, args),
            writeContract: (args) => writeContract(client, args),
        };
    }

    function createWalletClient(parameters) {
        const { key = 'wallet', name = 'Wallet Client', transport } = parameters;
        const client = createClient({
            ...parameters,
            key,
            name,
            transport: (opts) => transport({ ...opts, retryCount: 0 }),
            type: 'walletClient',
        });
        return client.extend(walletActions);
    }

    const contractAddress = "0x8276EF08D33D4D805f1d19F00851023660c0ae13";
    const NO_ONE = "0x0000000000000000000000000000000000000000";
    const xepdevnet = {
        id: 1440002,
        name: "XRPL EVM Sidechain Devnet",
        network: "XRPL EVM Sidechain Devnet",
        nativeCurrency: {
            name: "XRP",
            symbol: "XRP",
            decimals: 18,
        },
        rpcUrls: {
            default: {
                http: ["https://rpc-evm-sidechain.xrpl.org"],
            },
            public: {
                http: ["https://rpc-evm-sidechain.xrpl.org"],
            },
        },
        blockExplorers: {
            etherscan: {
                name: "EVM Sidechain Explorer",
                url: "https://evm-sidechain.xrpl.org",
            },
            default: {
                name: "EVM Sidechain Explorer",
                url: "https://evm-sidechain.xrpl.org",
            },
        },
        contracts: {},
    };
    const xrpEVMDevNet = /*#__PURE__*/ defineChain(xepdevnet);

    const abi = [
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
                {
                    indexed: true,
                    internalType: "address",
                    name: "_from",
                    type: "address",
                },
                {
                    indexed: false,
                    internalType: "uint256",
                    name: "_value",
                    type: "uint256",
                },
            ],
            name: "Deposit",
            type: "event",
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
            ],
            name: "EscrowCancelled",
            type: "event",
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
                {
                    indexed: true,
                    internalType: "address",
                    name: "_merchant",
                    type: "address",
                },
                {
                    indexed: false,
                    internalType: "uint256",
                    name: "_value",
                    type: "uint256",
                },
            ],
            name: "EscrowCreated",
            type: "event",
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
                {
                    indexed: true,
                    internalType: "address",
                    name: "_from",
                    type: "address",
                },
            ],
            name: "TradeCompleted",
            type: "event",
        },
        {
            inputs: [
                {
                    internalType: "address",
                    name: "",
                    type: "address",
                },
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            name: "buyerEscrows",
            outputs: [
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
            ],
            name: "cancelEscrow",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
            ],
            name: "completeTrade",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "uint256",
                    name: "_amount",
                    type: "uint256",
                },
                {
                    internalType: "string",
                    name: "_details",
                    type: "string",
                },
            ],
            name: "createEscrow",
            outputs: [
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            stateMutability: "payable",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
            ],
            name: "deposit",
            outputs: [],
            stateMutability: "payable",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            name: "escrows",
            outputs: [
                {
                    internalType: "address",
                    name: "buyer",
                    type: "address",
                },
                {
                    internalType: "address",
                    name: "merchant",
                    type: "address",
                },
                {
                    internalType: "uint256",
                    name: "amount",
                    type: "uint256",
                },
                {
                    internalType: "string",
                    name: "details",
                    type: "string",
                },
                {
                    internalType: "bool",
                    name: "isDead",
                    type: "bool",
                },
                {
                    internalType: "bool",
                    name: "complete",
                    type: "bool",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "address",
                    name: "_buyer",
                    type: "address",
                },
            ],
            name: "getBuyerEscrows",
            outputs: [
                {
                    internalType: "uint256[]",
                    name: "",
                    type: "uint256[]",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "uint256",
                    name: "_escrowId",
                    type: "uint256",
                },
            ],
            name: "getEscrow",
            outputs: [
                {
                    components: [
                        {
                            internalType: "address",
                            name: "buyer",
                            type: "address",
                        },
                        {
                            internalType: "address",
                            name: "merchant",
                            type: "address",
                        },
                        {
                            internalType: "uint256",
                            name: "amount",
                            type: "uint256",
                        },
                        {
                            internalType: "string",
                            name: "details",
                            type: "string",
                        },
                        {
                            internalType: "bool",
                            name: "isDead",
                            type: "bool",
                        },
                        {
                            internalType: "bool",
                            name: "complete",
                            type: "bool",
                        },
                    ],
                    internalType: "struct StakedEscrow.Escrow",
                    name: "",
                    type: "tuple",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "address",
                    name: "_merchant",
                    type: "address",
                },
            ],
            name: "getMerchantEscrows",
            outputs: [
                {
                    internalType: "uint256[]",
                    name: "",
                    type: "uint256[]",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                {
                    internalType: "address",
                    name: "",
                    type: "address",
                },
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            name: "merchantEscrows",
            outputs: [
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "name",
            outputs: [
                {
                    internalType: "string",
                    name: "",
                    type: "string",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "nextEscrowId",
            outputs: [
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
    ];

    /* node_modules/radix-icons-svelte/Icons/CaretLeft.svelte generated by Svelte v3.59.2 */

    const file$9 = "node_modules/radix-icons-svelte/Icons/CaretLeft.svelte";

    function create_fragment$9(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ width: /*size*/ ctx[1] },
    		{ height: /*size*/ ctx[1] },
    		{ viewBox: "0 0 15 15" },
    		{ fill: "none" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		/*$$restProps*/ ctx[2]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			attr_dev(path, "d", "M8.81809 4.18179C8.99383 4.35753 8.99383 4.64245 8.81809 4.81819L6.13629 7.49999L8.81809 10.1818C8.99383 10.3575 8.99383 10.6424 8.81809 10.8182C8.64236 10.9939 8.35743 10.9939 8.1817 10.8182L5.1817 7.81819C5.09731 7.73379 5.0499 7.61933 5.0499 7.49999C5.0499 7.38064 5.09731 7.26618 5.1817 7.18179L8.1817 4.18179C8.35743 4.00605 8.64236 4.00605 8.81809 4.18179Z");
    			attr_dev(path, "fill", /*color*/ ctx[0]);
    			add_location(path, file$9, 13, 1, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$9, 5, 0, 79);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 1) {
    				attr_dev(path, "fill", /*color*/ ctx[0]);
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				dirty & /*size*/ 2 && { width: /*size*/ ctx[1] },
    				dirty & /*size*/ 2 && { height: /*size*/ ctx[1] },
    				{ viewBox: "0 0 15 15" },
    				{ fill: "none" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	const omit_props_names = ["color","size"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CaretLeft', slots, []);
    	let { color = 'currentColor' } = $$props;
    	let { size = 15 } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
    		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
    	};

    	$$self.$capture_state = () => ({ color, size });

    	$$self.$inject_state = $$new_props => {
    		if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
    		if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [color, size, $$restProps];
    }

    class CaretLeft extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { color: 0, size: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CaretLeft",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get color() {
    		throw new Error("<CaretLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<CaretLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<CaretLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<CaretLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var CaretLeft$1 = CaretLeft;

    /* node_modules/radix-icons-svelte/Icons/Person.svelte generated by Svelte v3.59.2 */

    const file$8 = "node_modules/radix-icons-svelte/Icons/Person.svelte";

    function create_fragment$8(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ width: /*size*/ ctx[1] },
    		{ height: /*size*/ ctx[1] },
    		{ viewBox: "0 0 15 15" },
    		{ fill: "none" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		/*$$restProps*/ ctx[2]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			attr_dev(path, "d", "M7.5 0.875C5.49797 0.875 3.875 2.49797 3.875 4.5C3.875 6.15288 4.98124 7.54738 6.49373 7.98351C5.2997 8.12901 4.27557 8.55134 3.50407 9.31167C2.52216 10.2794 2.02502 11.72 2.02502 13.5999C2.02502 13.8623 2.23769 14.0749 2.50002 14.0749C2.76236 14.0749 2.97502 13.8623 2.97502 13.5999C2.97502 11.8799 3.42786 10.7206 4.17091 9.9883C4.91536 9.25463 6.02674 8.87499 7.49995 8.87499C8.97317 8.87499 10.0846 9.25463 10.8291 9.98831C11.5721 10.7206 12.025 11.8799 12.025 13.5999C12.025 13.8623 12.2376 14.0749 12.5 14.0749C12.7623 14.075 12.975 13.8623 12.975 13.6C12.975 11.72 12.4778 10.2794 11.4959 9.31166C10.7244 8.55135 9.70025 8.12903 8.50625 7.98352C10.0187 7.5474 11.125 6.15289 11.125 4.5C11.125 2.49797 9.50203 0.875 7.5 0.875ZM4.825 4.5C4.825 3.02264 6.02264 1.825 7.5 1.825C8.97736 1.825 10.175 3.02264 10.175 4.5C10.175 5.97736 8.97736 7.175 7.5 7.175C6.02264 7.175 4.825 5.97736 4.825 4.5Z");
    			attr_dev(path, "fill", /*color*/ ctx[0]);
    			add_location(path, file$8, 13, 1, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$8, 5, 0, 79);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 1) {
    				attr_dev(path, "fill", /*color*/ ctx[0]);
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				dirty & /*size*/ 2 && { width: /*size*/ ctx[1] },
    				dirty & /*size*/ 2 && { height: /*size*/ ctx[1] },
    				{ viewBox: "0 0 15 15" },
    				{ fill: "none" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	const omit_props_names = ["color","size"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Person', slots, []);
    	let { color = 'currentColor' } = $$props;
    	let { size = 15 } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
    		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
    	};

    	$$self.$capture_state = () => ({ color, size });

    	$$self.$inject_state = $$new_props => {
    		if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
    		if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [color, size, $$restProps];
    }

    class Person extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { color: 0, size: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Person",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get color() {
    		throw new Error("<Person>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Person>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Person>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Person>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Person$1 = Person;

    /* node_modules/radix-icons-svelte/Icons/Plus.svelte generated by Svelte v3.59.2 */

    const file$7 = "node_modules/radix-icons-svelte/Icons/Plus.svelte";

    function create_fragment$7(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ width: /*size*/ ctx[1] },
    		{ height: /*size*/ ctx[1] },
    		{ viewBox: "0 0 15 15" },
    		{ fill: "none" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		/*$$restProps*/ ctx[2]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			attr_dev(path, "d", "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z");
    			attr_dev(path, "fill", /*color*/ ctx[0]);
    			add_location(path, file$7, 13, 1, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$7, 5, 0, 79);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 1) {
    				attr_dev(path, "fill", /*color*/ ctx[0]);
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				dirty & /*size*/ 2 && { width: /*size*/ ctx[1] },
    				dirty & /*size*/ 2 && { height: /*size*/ ctx[1] },
    				{ viewBox: "0 0 15 15" },
    				{ fill: "none" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	const omit_props_names = ["color","size"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Plus', slots, []);
    	let { color = 'currentColor' } = $$props;
    	let { size = 15 } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
    		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
    	};

    	$$self.$capture_state = () => ({ color, size });

    	$$self.$inject_state = $$new_props => {
    		if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
    		if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [color, size, $$restProps];
    }

    class Plus extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { color: 0, size: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Plus",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get color() {
    		throw new Error("<Plus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Plus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Plus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Plus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Plus$1 = Plus;

    // src/arbitrum.ts

    // src/sepolia.ts
    var sepolia$1 = {
      id: 11155111,
      network: "sepolia",
      name: "Sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-sepolia.g.alchemy.com/v2"],
          webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://sepolia.infura.io/v3"],
          webSocket: ["wss://sepolia.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.sepolia.org"]
        },
        public: {
          http: ["https://rpc.sepolia.org"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 6507670
        }
      },
      testnet: true
    };

    const sepolia = /*#__PURE__*/ defineChain(sepolia$1);

    /* src/components/AccountInfo.svelte generated by Svelte v3.59.2 */
    const file$6 = "src/components/AccountInfo.svelte";

    // (33:4) <Button       radius="lg"       size="xs"       compact       on:click={() => (opened = true)}       color="dark"     >
    function create_default_slot_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("My Wallet");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(33:4) <Button       radius=\\\"lg\\\"       size=\\\"xs\\\"       compact       on:click={() => (opened = true)}       color=\\\"dark\\\"     >",
    		ctx
    	});

    	return block;
    }

    // (40:6) 
    function create_leftIcon_slot$1(ctx) {
    	let person;
    	let current;

    	person = new Person$1({
    			props: { slot: "leftIcon" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(person.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(person, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(person.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(person.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(person, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_leftIcon_slot$1.name,
    		type: "slot",
    		source: "(40:6) ",
    		ctx
    	});

    	return block;
    }

    // (32:2) <Group position="center">
    function create_default_slot_4$3(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				radius: "lg",
    				size: "xs",
    				compact: true,
    				color: "dark",
    				$$slots: {
    					leftIcon: [create_leftIcon_slot$1],
    					default: [create_default_slot_5$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(32:2) <Group position=\\\"center\\\">",
    		ctx
    	});

    	return block;
    }

    // (47:4) {:else}
    function create_else_block$5(ctx) {
    	let badge;
    	let t0;
    	let p;
    	let t1;
    	let strong;
    	let t2;
    	let current;

    	badge = new Badge$1({
    			props: {
    				variant: "filled",
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    			t0 = space();
    			p = element("p");
    			t1 = text("Balance: ");
    			strong = element("strong");
    			t2 = text(/*balance*/ ctx[2]);
    			add_location(strong, file$6, 49, 17, 1442);
    			add_location(p, file$6, 48, 6, 1421);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t1);
    			append_dev(p, strong);
    			append_dev(strong, t2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_changes = {};

    			if (dirty & /*$$scope, account*/ 65) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    			if (!current || dirty & /*balance*/ 4) set_data_dev(t2, /*balance*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(47:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:4) {#if !account || !balance}
    function create_if_block$5(ctx) {
    	let badge;
    	let current;

    	badge = new Badge$1({
    			props: {
    				variant: "filled",
    				color: "red",
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(45:4) {#if !account || !balance}",
    		ctx
    	});

    	return block;
    }

    // (48:6) <Badge variant="filled">
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*account*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*account*/ 1) set_data_dev(t, /*account*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(48:6) <Badge variant=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (46:6) <Badge variant="filled" color={"red"}>
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("not connected");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(46:6) <Badge variant=\\\"filled\\\" color={\\\"red\\\"}>",
    		ctx
    	});

    	return block;
    }

    // (43:2) <Modal {opened} on:close={closeModal} withCloseButton={false}>
    function create_default_slot_1$4(ctx) {
    	let h3;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*account*/ ctx[0] || !/*balance*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Account Information";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(h3, file$6, 43, 4, 1229);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(43:2) <Modal {opened} on:close={closeModal} withCloseButton={false}>",
    		ctx
    	});

    	return block;
    }

    // (31:0) <SvelteUIProvider>
    function create_default_slot$6(ctx) {
    	let group;
    	let t;
    	let modal;
    	let current;

    	group = new Group$1({
    			props: {
    				position: "center",
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modal = new Modal$1({
    			props: {
    				opened: /*opened*/ ctx[1],
    				withCloseButton: false,
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modal.$on("close", /*closeModal*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(group.$$.fragment);
    			t = space();
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(group, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const group_changes = {};

    			if (dirty & /*$$scope, opened*/ 66) {
    				group_changes.$$scope = { dirty, ctx };
    			}

    			group.$set(group_changes);
    			const modal_changes = {};
    			if (dirty & /*opened*/ 2) modal_changes.opened = /*opened*/ ctx[1];

    			if (dirty & /*$$scope, account, balance*/ 69) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(group.$$.fragment, local);
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(group.$$.fragment, local);
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(group, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(31:0) <SvelteUIProvider>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let svelteuiprovider;
    	let current;

    	svelteuiprovider = new SvelteUIProvider$1({
    			props: {
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(svelteuiprovider.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(svelteuiprovider, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const svelteuiprovider_changes = {};

    			if (dirty & /*$$scope, opened, account, balance*/ 71) {
    				svelteuiprovider_changes.$$scope = { dirty, ctx };
    			}

    			svelteuiprovider.$set(svelteuiprovider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svelteuiprovider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svelteuiprovider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(svelteuiprovider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountInfo', slots, []);
    	let { ethereum } = $$props;
    	let { account } = $$props;
    	let opened = false;

    	function closeModal() {
    		$$invalidate(1, opened = false);
    	}

    	let balance = null;

    	onMount(() => {
    		const publicClient = createPublicClient({
    			chain: xrpEVMDevNet,
    			transport: custom(ethereum)
    		});

    		publicClient.getBalance({ address: account }).then(balWei => {
    			$$invalidate(2, balance = Number(balWei) / 10 ** 18);
    		});
    	}); // const walletClient = createWalletClient({
    	//   account,
    	//   chain: sepolia,
    	//   transport: custom(ethereum),

    	$$self.$$.on_mount.push(function () {
    		if (ethereum === undefined && !('ethereum' in $$props || $$self.$$.bound[$$self.$$.props['ethereum']])) {
    			console.warn("<AccountInfo> was created without expected prop 'ethereum'");
    		}

    		if (account === undefined && !('account' in $$props || $$self.$$.bound[$$self.$$.props['account']])) {
    			console.warn("<AccountInfo> was created without expected prop 'account'");
    		}
    	});

    	const writable_props = ['ethereum', 'account'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccountInfo> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(1, opened = true);

    	$$self.$$set = $$props => {
    		if ('ethereum' in $$props) $$invalidate(4, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(0, account = $$props.account);
    	};

    	$$self.$capture_state = () => ({
    		Badge: Badge$1,
    		Button: Button$1,
    		Card,
    		SvelteUIProvider: SvelteUIProvider$1,
    		onMount,
    		Modal: Modal$1,
    		Group: Group$1,
    		Person: Person$1,
    		createPublicClient,
    		createWalletClient,
    		custom,
    		sepolia,
    		xrpEVMDevNet,
    		ethereum,
    		account,
    		opened,
    		closeModal,
    		balance
    	});

    	$$self.$inject_state = $$props => {
    		if ('ethereum' in $$props) $$invalidate(4, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(0, account = $$props.account);
    		if ('opened' in $$props) $$invalidate(1, opened = $$props.opened);
    		if ('balance' in $$props) $$invalidate(2, balance = $$props.balance);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [account, opened, balance, closeModal, ethereum, click_handler];
    }

    class AccountInfo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { ethereum: 4, account: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountInfo",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get ethereum() {
    		throw new Error("<AccountInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ethereum(value) {
    		throw new Error("<AccountInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get account() {
    		throw new Error("<AccountInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<AccountInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/CreateEscrowComp.svelte generated by Svelte v3.59.2 */

    const { console: console_1$3 } = globals;
    const file$5 = "src/components/CreateEscrowComp.svelte";

    // (77:2) {:else}
    function create_else_block$4(ctx) {
    	let h3;
    	let t1;
    	let textinput0;
    	let updating_value;
    	let t2;
    	let textinput1;
    	let updating_value_1;
    	let t3;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	function textinput0_value_binding(value) {
    		/*textinput0_value_binding*/ ctx[8](value);
    	}

    	let textinput0_props = { placeholder: "Escrow Details" };

    	if (/*details*/ ctx[0] !== void 0) {
    		textinput0_props.value = /*details*/ ctx[0];
    	}

    	textinput0 = new TextInput$1({ props: textinput0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textinput0, 'value', textinput0_value_binding));

    	function textinput1_value_binding(value) {
    		/*textinput1_value_binding*/ ctx[9](value);
    	}

    	let textinput1_props = {
    		type: "Amount",
    		placeholder: "Escrow amount"
    	};

    	if (/*escrowAmount*/ ctx[1] !== void 0) {
    		textinput1_props.value = /*escrowAmount*/ ctx[1];
    	}

    	textinput1 = new TextInput$1({ props: textinput1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textinput1, 'value', textinput1_value_binding));
    	const if_block_creators = [create_if_block_2$1, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*createProgressMsg*/ ctx[3] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Create Escrow";
    			t1 = space();
    			create_component(textinput0.$$.fragment);
    			t2 = space();
    			create_component(textinput1.$$.fragment);
    			t3 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(h3, file$5, 77, 4, 2661);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textinput0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(textinput1, target, anchor);
    			insert_dev(target, t3, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textinput0_changes = {};

    			if (!updating_value && dirty & /*details*/ 1) {
    				updating_value = true;
    				textinput0_changes.value = /*details*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textinput0.$set(textinput0_changes);
    			const textinput1_changes = {};

    			if (!updating_value_1 && dirty & /*escrowAmount*/ 2) {
    				updating_value_1 = true;
    				textinput1_changes.value = /*escrowAmount*/ ctx[1];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textinput1.$set(textinput1_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textinput0.$$.fragment, local);
    			transition_in(textinput1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textinput0.$$.fragment, local);
    			transition_out(textinput1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			destroy_component(textinput0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(textinput1, detaching);
    			if (detaching) detach_dev(t3);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(77:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:2) {#if newEscrowNumber}
    function create_if_block_1$2(ctx) {
    	let h3;
    	let t1;
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				href: `${window.location.href}?escrowID=${/*newEscrowNumber*/ ctx[4]}`,
    				target: "_blank",
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Escrow created!";
    			t1 = space();
    			create_component(button.$$.fragment);
    			add_location(h3, file$5, 71, 4, 2477);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};
    			if (dirty & /*newEscrowNumber*/ 16) button_changes.href = `${window.location.href}?escrowID=${/*newEscrowNumber*/ ctx[4]}`;

    			if (dirty & /*$$scope, newEscrowNumber*/ 8208) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(71:2) {#if newEscrowNumber}",
    		ctx
    	});

    	return block;
    }

    // (100:4) {:else}
    function create_else_block_1$1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				fullSize: true,
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*createEscrow*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(100:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (97:4) {#if createProgressMsg !== null}
    function create_if_block_2$1(ctx) {
    	let button;
    	let t;
    	let alert;
    	let current;

    	button = new Button$1({
    			props: {
    				loading: true,
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert = new Alert$1({
    			props: {
    				title: "Status",
    				color: "blue",
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t = space();
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const alert_changes = {};

    			if (dirty & /*$$scope, createProgressMsg*/ 8200) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(97:4) {#if createProgressMsg !== null}",
    		ctx
    	});

    	return block;
    }

    // (101:6) <Button fullSize on:click={createEscrow}>
    function create_default_slot_5$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create Escrow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(101:6) <Button fullSize on:click={createEscrow}>",
    		ctx
    	});

    	return block;
    }

    // (98:6) <Button loading>
    function create_default_slot_4$2(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Create Escrow";
    			add_location(h2, file$5, 97, 22, 3207);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(98:6) <Button loading>",
    		ctx
    	});

    	return block;
    }

    // (99:6) <Alert title="Status" color="blue">
    function create_default_slot_3$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*createProgressMsg*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*createProgressMsg*/ 8) set_data_dev(t, /*createProgressMsg*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(99:6) <Alert title=\\\"Status\\\" color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:4) <Button       href={`${window.location.href}?escrowID=${newEscrowNumber}`}       target="_blank">
    function create_default_slot_2$3(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("View Escrow ");
    			t1 = text(/*newEscrowNumber*/ ctx[4]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*newEscrowNumber*/ 16) set_data_dev(t1, /*newEscrowNumber*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(73:4) <Button       href={`${window.location.href}?escrowID=${newEscrowNumber}`}       target=\\\"_blank\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:2) {#if createErrorMsg}
    function create_if_block$4(ctx) {
    	let alert;
    	let current;

    	alert = new Alert$1({
    			props: {
    				title: "Error!",
    				color: "red",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};

    			if (dirty & /*$$scope, createErrorMsg*/ 8196) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(105:2) {#if createErrorMsg}",
    		ctx
    	});

    	return block;
    }

    // (106:4) <Alert title="Error!" color="red">
    function create_default_slot_1$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*createErrorMsg*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*createErrorMsg*/ 4) set_data_dev(t, /*createErrorMsg*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(106:4) <Alert title=\\\"Error!\\\" color=\\\"red\\\">",
    		ctx
    	});

    	return block;
    }

    // (70:0) <Container size="xs" override={{ px: "xs" }}>
    function create_default_slot$5(ctx) {
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$2, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*newEscrowNumber*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*createErrorMsg*/ ctx[2] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(t.parentNode, t);
    			}

    			if (/*createErrorMsg*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*createErrorMsg*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(70:0) <Container size=\\\"xs\\\" override={{ px: \\\"xs\\\" }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let container;
    	let current;

    	container = new Container$1({
    			props: {
    				size: "xs",
    				override: { px: "xs" },
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope, createErrorMsg, newEscrowNumber, createProgressMsg, escrowAmount, details*/ 8223) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CreateEscrowComp', slots, []);
    	let { ethereum } = $$props;
    	let { account } = $$props;

    	const publicClient = createPublicClient({
    		chain: xrpEVMDevNet,
    		transport: custom(ethereum)
    	});

    	const walletClient = createWalletClient({
    		account,
    		chain: xrpEVMDevNet,
    		transport: custom(ethereum)
    	});

    	const contract = getContract({
    		address: contractAddress,
    		abi,
    		publicClient,
    		walletClient
    	});

    	let details = null;
    	let escrowAmount = null;
    	let createErrorMsg = null;
    	let createProgressMsg = null;
    	let newEscrowNumber = null;

    	async function createEscrow() {
    		$$invalidate(2, createErrorMsg = null);
    		$$invalidate(3, createProgressMsg = "Creating escrow...");

    		if (!details || !escrowAmount) {
    			console.log("Please enter details and amount");
    			$$invalidate(2, createErrorMsg = "Please enter details and amount");
    			$$invalidate(3, createProgressMsg = null);
    			return;
    		}

    		const amount = parseEther(escrowAmount.toString());

    		const account = await (ethereum === null || ethereum === void 0
    		? void 0
    		: ethereum.request({ method: "eth_requestAccounts" }));

    		let merchantLogs = [];

    		contract.watchEvent.EscrowCreated({ _merchant: account }, {
    			onLogs: logs => {
    				merchantLogs = logs;
    			}
    		});

    		const hash = await contract.write.createEscrow([amount, details], {
    			value: parseEther((escrowAmount / 4).toString())
    		});

    		$$invalidate(3, createProgressMsg = `Escrow request signed and sent. Waiting for confirmation... \n Transaction hash: ${hash}`);
    		const transaction = await publicClient.waitForTransactionReceipt({ hash });
    		$$invalidate(3, createProgressMsg = `Escrow created in block ${transaction.blockNumber}`);

    		if (merchantLogs) {
    			merchantLogs.forEach(log => {
    				if (log.blockNumber === transaction.blockNumber) {
    					const eLog = log;
    					$$invalidate(4, newEscrowNumber = Number(eLog.args._escrowId));
    				}
    			});
    		}

    		$$invalidate(3, createProgressMsg = `Escrow created with ID ${newEscrowNumber}`);

    		// sleep 2 seconds
    		await new Promise(resolve => setTimeout(resolve, 2000));

    		$$invalidate(3, createProgressMsg = null);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (ethereum === undefined && !('ethereum' in $$props || $$self.$$.bound[$$self.$$.props['ethereum']])) {
    			console_1$3.warn("<CreateEscrowComp> was created without expected prop 'ethereum'");
    		}

    		if (account === undefined && !('account' in $$props || $$self.$$.bound[$$self.$$.props['account']])) {
    			console_1$3.warn("<CreateEscrowComp> was created without expected prop 'account'");
    		}
    	});

    	const writable_props = ['ethereum', 'account'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<CreateEscrowComp> was created with unknown prop '${key}'`);
    	});

    	function textinput0_value_binding(value) {
    		details = value;
    		$$invalidate(0, details);
    	}

    	function textinput1_value_binding(value) {
    		escrowAmount = value;
    		$$invalidate(1, escrowAmount);
    	}

    	$$self.$$set = $$props => {
    		if ('ethereum' in $$props) $$invalidate(6, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(7, account = $$props.account);
    	};

    	$$self.$capture_state = () => ({
    		Container: Container$1,
    		Button: Button$1,
    		Alert: Alert$1,
    		Textarea: Textarea$1,
    		TextInput: TextInput$1,
    		parseEther,
    		createPublicClient,
    		createWalletClient,
    		custom,
    		getContract,
    		abi,
    		contractAddress,
    		xrpEVMDevNet,
    		ethereum,
    		account,
    		publicClient,
    		walletClient,
    		contract,
    		details,
    		escrowAmount,
    		createErrorMsg,
    		createProgressMsg,
    		newEscrowNumber,
    		createEscrow
    	});

    	$$self.$inject_state = $$props => {
    		if ('ethereum' in $$props) $$invalidate(6, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(7, account = $$props.account);
    		if ('details' in $$props) $$invalidate(0, details = $$props.details);
    		if ('escrowAmount' in $$props) $$invalidate(1, escrowAmount = $$props.escrowAmount);
    		if ('createErrorMsg' in $$props) $$invalidate(2, createErrorMsg = $$props.createErrorMsg);
    		if ('createProgressMsg' in $$props) $$invalidate(3, createProgressMsg = $$props.createProgressMsg);
    		if ('newEscrowNumber' in $$props) $$invalidate(4, newEscrowNumber = $$props.newEscrowNumber);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		details,
    		escrowAmount,
    		createErrorMsg,
    		createProgressMsg,
    		newEscrowNumber,
    		createEscrow,
    		ethereum,
    		account,
    		textinput0_value_binding,
    		textinput1_value_binding
    	];
    }

    class CreateEscrowComp extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { ethereum: 6, account: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CreateEscrowComp",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get ethereum() {
    		throw new Error("<CreateEscrowComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ethereum(value) {
    		throw new Error("<CreateEscrowComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get account() {
    		throw new Error("<CreateEscrowComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<CreateEscrowComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/ViewEscrowComp.svelte generated by Svelte v3.59.2 */

    const { console: console_1$2 } = globals;
    const file$4 = "src/components/ViewEscrowComp.svelte";

    // (194:2) {#if fetchedEscrow}
    function create_if_block_1$1(ctx) {
    	let card;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let br;
    	let t4;
    	let center;
    	let current;

    	card = new Card({
    			props: {
    				shadow: "sm",
    				padding: "lg",
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block0 = /*isMerchant*/ ctx[4] && !/*fetchedEscrow*/ ctx[2].isDead && create_if_block_7(ctx);
    	let if_block1 = !/*isMerchant*/ ctx[4] && !/*isBuyer*/ ctx[6] && !/*fetchedEscrow*/ ctx[2].isDead && create_if_block_5(ctx);
    	let if_block2 = !/*isMerchant*/ ctx[4] && /*isBuyer*/ ctx[6] && !/*fetchedEscrow*/ ctx[2].isDead && create_if_block_3(ctx);

    	center = new Center$1({
    			props: {
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			br = element("br");
    			t4 = space();
    			create_component(center.$$.fragment);
    			add_location(br, file$4, 265, 4, 8625);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(center, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, escrowEth, hasBuyer, fetchedEscrow, escrowID*/ 8388653) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);

    			if (/*isMerchant*/ ctx[4] && !/*fetchedEscrow*/ ctx[2].isDead) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isMerchant, fetchedEscrow*/ 20) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isMerchant*/ ctx[4] && !/*isBuyer*/ ctx[6] && !/*fetchedEscrow*/ ctx[2].isDead) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isMerchant, isBuyer, fetchedEscrow*/ 84) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t2.parentNode, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*isMerchant*/ ctx[4] && /*isBuyer*/ ctx[6] && !/*fetchedEscrow*/ ctx[2].isDead) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*isMerchant, isBuyer, fetchedEscrow*/ 84) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t3.parentNode, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			const center_changes = {};

    			if (dirty & /*$$scope, progress, completeItemData, buyItemData, escrowEth, fetchedEscrow, escrowID*/ 8389517) {
    				center_changes.$$scope = { dirty, ctx };
    			}

    			center.$set(center_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(center.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(center.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t4);
    			destroy_component(center, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(194:2) {#if fetchedEscrow}",
    		ctx
    	});

    	return block;
    }

    // (205:12) {:else}
    function create_else_block_3(ctx) {
    	let badge;
    	let current;

    	badge = new Badge$1({
    			props: {
    				variant: "filled",
    				color: "blue",
    				$$slots: { default: [create_default_slot_29] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(205:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (203:43) 
    function create_if_block_10(ctx) {
    	let badge;
    	let current;

    	badge = new Badge$1({
    			props: {
    				variant: "filled",
    				color: "red",
    				$$slots: { default: [create_default_slot_28] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(203:43) ",
    		ctx
    	});

    	return block;
    }

    // (201:12) {#if fetchedEscrow.complete}
    function create_if_block_9(ctx) {
    	let badge;
    	let current;

    	badge = new Badge$1({
    			props: {
    				variant: "filled",
    				color: "green",
    				$$slots: { default: [create_default_slot_27] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(201:12) {#if fetchedEscrow.complete}",
    		ctx
    	});

    	return block;
    }

    // (206:14) <Badge variant="filled" color={"blue"}>
    function create_default_slot_29(ctx) {
    	let t_value = "active" + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29.name,
    		type: "slot",
    		source: "(206:14) <Badge variant=\\\"filled\\\" color={\\\"blue\\\"}>",
    		ctx
    	});

    	return block;
    }

    // (204:14) <Badge variant="filled" color={"red"}>
    function create_default_slot_28(ctx) {
    	let t_value = "cancelled" + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28.name,
    		type: "slot",
    		source: "(204:14) <Badge variant=\\\"filled\\\" color={\\\"red\\\"}>",
    		ctx
    	});

    	return block;
    }

    // (202:14) <Badge variant="filled" color={"green"}>
    function create_default_slot_27(ctx) {
    	let t_value = "complete" + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27.name,
    		type: "slot",
    		source: "(202:14) <Badge variant=\\\"filled\\\" color={\\\"green\\\"}>",
    		ctx
    	});

    	return block;
    }

    // (196:6) <Flex justify="space-between">
    function create_default_slot_26(ctx) {
    	let p0;
    	let t0;
    	let strong;
    	let t1;
    	let t2;
    	let div;
    	let p1;
    	let t3;
    	let current_block_type_index;
    	let if_block;
    	let t4;
    	let br;
    	let current;
    	const if_block_creators = [create_if_block_9, create_if_block_10, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*fetchedEscrow*/ ctx[2].complete) return 0;
    		if (/*fetchedEscrow*/ ctx[2].isDead) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			t0 = text("Escrow #");
    			strong = element("strong");
    			t1 = text(/*escrowID*/ ctx[0]);
    			t2 = space();
    			div = element("div");
    			p1 = element("p");
    			t3 = text("status\n            ");
    			if_block.c();
    			t4 = space();
    			br = element("br");
    			add_location(strong, file$4, 196, 41, 6366);
    			set_style(p0, "margin-top", "0");
    			add_location(p0, file$4, 196, 8, 6333);
    			add_location(br, file$4, 207, 12, 6823);
    			set_style(p1, "margin-top", "0");
    			add_location(p1, file$4, 198, 10, 6422);
    			add_location(div, file$4, 197, 8, 6406);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t0);
    			append_dev(p0, strong);
    			append_dev(strong, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p1);
    			append_dev(p1, t3);
    			if_blocks[current_block_type_index].m(p1, null);
    			append_dev(p1, t4);
    			append_dev(p1, br);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*escrowID*/ 1) set_data_dev(t1, /*escrowID*/ ctx[0]);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(p1, t4);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26.name,
    		type: "slot",
    		source: "(196:6) <Flex justify=\\\"space-between\\\">",
    		ctx
    	});

    	return block;
    }

    // (215:8) <Badge size="md" variant="outline" color={"blue"}           >
    function create_default_slot_25(ctx) {
    	let t_value = /*fetchedEscrow*/ ctx[2].merchant + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchedEscrow*/ 4 && t_value !== (t_value = /*fetchedEscrow*/ ctx[2].merchant + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25.name,
    		type: "slot",
    		source: "(215:8) <Badge size=\\\"md\\\" variant=\\\"outline\\\" color={\\\"blue\\\"}           >",
    		ctx
    	});

    	return block;
    }

    // (220:15) <Badge variant="outline" color={hasBuyer ? "purple" : "orange"}           >
    function create_default_slot_24(ctx) {
    	let t_value = (/*hasBuyer*/ ctx[5]
    	? /*fetchedEscrow*/ ctx[2].buyer
    	: "waiting for buyer") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*hasBuyer, fetchedEscrow*/ 36 && t_value !== (t_value = (/*hasBuyer*/ ctx[5]
    			? /*fetchedEscrow*/ ctx[2].buyer
    			: "waiting for buyer") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24.name,
    		type: "slot",
    		source: "(220:15) <Badge variant=\\\"outline\\\" color={hasBuyer ? \\\"purple\\\" : \\\"orange\\\"}           >",
    		ctx
    	});

    	return block;
    }

    // (195:4) <Card shadow="sm" padding="lg">
    function create_default_slot_23(ctx) {
    	let flex;
    	let t0;
    	let h3;
    	let t1_value = /*fetchedEscrow*/ ctx[2].details + "";
    	let t1;
    	let t2;
    	let p0;
    	let t3;
    	let badge0;
    	let t4;
    	let p1;
    	let t5;
    	let badge1;
    	let t6;
    	let p2;
    	let t7;
    	let strong;
    	let t8;
    	let current;

    	flex = new Flex$1({
    			props: {
    				justify: "space-between",
    				$$slots: { default: [create_default_slot_26] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge0 = new Badge$1({
    			props: {
    				size: "md",
    				variant: "outline",
    				color: "blue",
    				$$slots: { default: [create_default_slot_25] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge1 = new Badge$1({
    			props: {
    				variant: "outline",
    				color: /*hasBuyer*/ ctx[5] ? "purple" : "orange",
    				$$slots: { default: [create_default_slot_24] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(flex.$$.fragment);
    			t0 = space();
    			h3 = element("h3");
    			t1 = text(t1_value);
    			t2 = space();
    			p0 = element("p");
    			t3 = text("merchant:\n        ");
    			create_component(badge0.$$.fragment);
    			t4 = space();
    			p1 = element("p");
    			t5 = text("buyer: ");
    			create_component(badge1.$$.fragment);
    			t6 = space();
    			p2 = element("p");
    			t7 = text("amount: ");
    			strong = element("strong");
    			t8 = text(/*escrowEth*/ ctx[3]);
    			add_location(h3, file$4, 211, 6, 6880);
    			add_location(p0, file$4, 212, 6, 6919);
    			add_location(p1, file$4, 218, 6, 7069);
    			add_location(strong, file$4, 223, 17, 7263);
    			add_location(p2, file$4, 223, 6, 7252);
    		},
    		m: function mount(target, anchor) {
    			mount_component(flex, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t3);
    			mount_component(badge0, p0, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t5);
    			mount_component(badge1, p1, null);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t7);
    			append_dev(p2, strong);
    			append_dev(strong, t8);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const flex_changes = {};

    			if (dirty & /*$$scope, fetchedEscrow, escrowID*/ 8388613) {
    				flex_changes.$$scope = { dirty, ctx };
    			}

    			flex.$set(flex_changes);
    			if ((!current || dirty & /*fetchedEscrow*/ 4) && t1_value !== (t1_value = /*fetchedEscrow*/ ctx[2].details + "")) set_data_dev(t1, t1_value);
    			const badge0_changes = {};

    			if (dirty & /*$$scope, fetchedEscrow*/ 8388612) {
    				badge0_changes.$$scope = { dirty, ctx };
    			}

    			badge0.$set(badge0_changes);
    			const badge1_changes = {};
    			if (dirty & /*hasBuyer*/ 32) badge1_changes.color = /*hasBuyer*/ ctx[5] ? "purple" : "orange";

    			if (dirty & /*$$scope, hasBuyer, fetchedEscrow*/ 8388644) {
    				badge1_changes.$$scope = { dirty, ctx };
    			}

    			badge1.$set(badge1_changes);
    			if (!current || dirty & /*escrowEth*/ 8) set_data_dev(t8, /*escrowEth*/ ctx[3]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flex.$$.fragment, local);
    			transition_in(badge0.$$.fragment, local);
    			transition_in(badge1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flex.$$.fragment, local);
    			transition_out(badge0.$$.fragment, local);
    			transition_out(badge1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(flex, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(p0);
    			destroy_component(badge0);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p1);
    			destroy_component(badge1);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(p2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(195:4) <Card shadow=\\\"sm\\\" padding=\\\"lg\\\">",
    		ctx
    	});

    	return block;
    }

    // (230:4) {#if isMerchant && !fetchedEscrow.isDead}
    function create_if_block_7(ctx) {
    	let br;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_8, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*cancelProgressMsg*/ ctx[10] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			br = element("br");
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$4, 230, 6, 7532);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(230:4) {#if isMerchant && !fetchedEscrow.isDead}",
    		ctx
    	});

    	return block;
    }

    // (236:6) {:else}
    function create_else_block_2(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				variant: "subtle",
    				color: "red",
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*cancelEscrow*/ ctx[13]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(236:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (233:6) {#if cancelProgressMsg !== null}
    function create_if_block_8(ctx) {
    	let button;
    	let t;
    	let alert;
    	let current;

    	button = new Button$1({
    			props: {
    				loading: true,
    				color: "red",
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert = new Alert$1({
    			props: {
    				title: "Status",
    				color: "blue",
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t = space();
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const alert_changes = {};

    			if (dirty & /*$$scope, cancelProgressMsg*/ 8389632) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(233:6) {#if cancelProgressMsg !== null}",
    		ctx
    	});

    	return block;
    }

    // (237:8) <Button variant="subtle" color="red" on:click={cancelEscrow}           >
    function create_default_slot_22(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel Escrow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(237:8) <Button variant=\\\"subtle\\\" color=\\\"red\\\" on:click={cancelEscrow}           >",
    		ctx
    	});

    	return block;
    }

    // (234:8) <Button loading color="red">
    function create_default_slot_21(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel Escrow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(234:8) <Button loading color=\\\"red\\\">",
    		ctx
    	});

    	return block;
    }

    // (235:8) <Alert title="Status" color="blue">
    function create_default_slot_20(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*cancelProgressMsg*/ ctx[10]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cancelProgressMsg*/ 1024) set_data_dev(t, /*cancelProgressMsg*/ ctx[10]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(235:8) <Alert title=\\\"Status\\\" color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (243:4) {#if !isMerchant && !isBuyer && !fetchedEscrow.isDead}
    function create_if_block_5(ctx) {
    	let br;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_6, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*enterProgressMsg*/ ctx[11] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			br = element("br");
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$4, 243, 6, 7923);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(243:4) {#if !isMerchant && !isBuyer && !fetchedEscrow.isDead}",
    		ctx
    	});

    	return block;
    }

    // (249:6) {:else}
    function create_else_block_1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				color: "green",
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*enterEscrow*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(249:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (246:6) {#if enterProgressMsg !== null}
    function create_if_block_6(ctx) {
    	let button;
    	let t;
    	let alert;
    	let current;

    	button = new Button$1({
    			props: {
    				loading: true,
    				color: "green",
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert = new Alert$1({
    			props: {
    				title: "Status",
    				color: "blue",
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t = space();
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const alert_changes = {};

    			if (dirty & /*$$scope, enterProgressMsg*/ 8390656) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(246:6) {#if enterProgressMsg !== null}",
    		ctx
    	});

    	return block;
    }

    // (250:8) <Button color="green" on:click={enterEscrow}>
    function create_default_slot_19(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Enter Escrow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(250:8) <Button color=\\\"green\\\" on:click={enterEscrow}>",
    		ctx
    	});

    	return block;
    }

    // (247:8) <Button loading color="green">
    function create_default_slot_18(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Enter Escrow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(247:8) <Button loading color=\\\"green\\\">",
    		ctx
    	});

    	return block;
    }

    // (248:8) <Alert title="Status" color="blue">
    function create_default_slot_17(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*enterProgressMsg*/ ctx[11]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*enterProgressMsg*/ 2048) set_data_dev(t, /*enterProgressMsg*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(248:8) <Alert title=\\\"Status\\\" color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (254:4) {#if !isMerchant && isBuyer && !fetchedEscrow.isDead}
    function create_if_block_3(ctx) {
    	let br;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*completeProgressMsg*/ ctx[12] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			br = element("br");
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$4, 254, 6, 8275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(254:4) {#if !isMerchant && isBuyer && !fetchedEscrow.isDead}",
    		ctx
    	});

    	return block;
    }

    // (259:6) {:else}
    function create_else_block$3(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				color: "green",
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*completeEscrow*/ ctx[15]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(259:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (256:6) {#if completeProgressMsg !== null}
    function create_if_block_4(ctx) {
    	let button;
    	let t;
    	let alert;
    	let current;

    	button = new Button$1({
    			props: {
    				loading: true,
    				color: "green",
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert = new Alert$1({
    			props: {
    				title: "Status",
    				color: "blue",
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t = space();
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const alert_changes = {};

    			if (dirty & /*$$scope, completeProgressMsg*/ 8392704) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(256:6) {#if completeProgressMsg !== null}",
    		ctx
    	});

    	return block;
    }

    // (260:8) <Button color="green" on:click={completeEscrow}           >
    function create_default_slot_16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Release Payment to Merchant");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(260:8) <Button color=\\\"green\\\" on:click={completeEscrow}           >",
    		ctx
    	});

    	return block;
    }

    // (257:8) <Button loading color="green">
    function create_default_slot_15(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Release Payment to Merchant");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(257:8) <Button loading color=\\\"green\\\">",
    		ctx
    	});

    	return block;
    }

    // (258:8) <Alert title="Status" color="blue">
    function create_default_slot_14(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*completeProgressMsg*/ ctx[12]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*completeProgressMsg*/ 4096) set_data_dev(t, /*completeProgressMsg*/ ctx[12]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(258:8) <Alert title=\\\"Status\\\" color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (271:28) <Text variant="link" root="span" href="#" inherit               >
    function create_default_slot_13(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Escrow ");
    			t1 = text(/*escrowID*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*escrowID*/ 1) set_data_dev(t1, /*escrowID*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(271:28) <Text variant=\\\"link\\\" root=\\\"span\\\" href=\\\"#\\\" inherit               >",
    		ctx
    	});

    	return block;
    }

    // (270:10) <Text color="dimmed" size="sm">
    function create_default_slot_12(ctx) {
    	let t0;
    	let text_1;
    	let t1;
    	let t2_value = /*fetchedEscrow*/ ctx[2].details + "";
    	let t2;
    	let current;

    	text_1 = new Text$1({
    			props: {
    				variant: "link",
    				root: "span",
    				href: "#",
    				inherit: true,
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = text("Merchant created");
    			create_component(text_1.$$.fragment);
    			t1 = text(" for ");
    			t2 = text(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			mount_component(text_1, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};

    			if (dirty & /*$$scope, escrowID*/ 8388609) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    			if ((!current || dirty & /*fetchedEscrow*/ 4) && t2_value !== (t2_value = /*fetchedEscrow*/ ctx[2].details + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			destroy_component(text_1, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(270:10) <Text color=\\\"dimmed\\\" size=\\\"sm\\\">",
    		ctx
    	});

    	return block;
    }

    // (275:10) {#if escrowEth}
    function create_if_block_2(ctx) {
    	let text_1;
    	let current;

    	text_1 = new Text$1({
    			props: {
    				size: "xs",
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};

    			if (dirty & /*$$scope, escrowEth*/ 8388616) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(275:10) {#if escrowEth}",
    		ctx
    	});

    	return block;
    }

    // (276:12) <Text size="xs">
    function create_default_slot_11(ctx) {
    	let t0;
    	let t1_value = /*escrowEth*/ ctx[3] / 4 + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Merchant Deposited ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*escrowEth*/ 8 && t1_value !== (t1_value = /*escrowEth*/ ctx[3] / 4 + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(276:12) <Text size=\\\"xs\\\">",
    		ctx
    	});

    	return block;
    }

    // (269:8) <Timeline.Item title="New Escrow">
    function create_default_slot_10(ctx) {
    	let text_1;
    	let t;
    	let if_block_anchor;
    	let current;

    	text_1 = new Text$1({
    			props: {
    				color: "dimmed",
    				size: "sm",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*escrowEth*/ ctx[3] && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};

    			if (dirty & /*$$scope, fetchedEscrow, escrowID*/ 8388613) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);

    			if (/*escrowEth*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*escrowEth*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(269:8) <Timeline.Item title=\\\"New Escrow\\\">",
    		ctx
    	});

    	return block;
    }

    // (281:10) <Text size="sm" color={buyItemData.color}             >
    function create_default_slot_9(ctx) {
    	let t_value = /*buyItemData*/ ctx[8].description + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*buyItemData*/ 256 && t_value !== (t_value = /*buyItemData*/ ctx[8].description + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(281:10) <Text size=\\\"sm\\\" color={buyItemData.color}             >",
    		ctx
    	});

    	return block;
    }

    // (284:10) <Text size="xs">
    function create_default_slot_8(ctx) {
    	let t_value = /*buyItemData*/ ctx[8].extra + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*buyItemData*/ 256 && t_value !== (t_value = /*buyItemData*/ ctx[8].extra + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(284:10) <Text size=\\\"xs\\\">",
    		ctx
    	});

    	return block;
    }

    // (280:8) <Timeline.Item title={buyItemData.title} color={buyItemData.color}>
    function create_default_slot_7(ctx) {
    	let text0;
    	let t;
    	let text1;
    	let current;

    	text0 = new Text$1({
    			props: {
    				size: "sm",
    				color: /*buyItemData*/ ctx[8].color,
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	text1 = new Text$1({
    			props: {
    				size: "xs",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(text0.$$.fragment);
    			t = space();
    			create_component(text1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(text1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text0_changes = {};
    			if (dirty & /*buyItemData*/ 256) text0_changes.color = /*buyItemData*/ ctx[8].color;

    			if (dirty & /*$$scope, buyItemData*/ 8388864) {
    				text0_changes.$$scope = { dirty, ctx };
    			}

    			text0.$set(text0_changes);
    			const text1_changes = {};

    			if (dirty & /*$$scope, buyItemData*/ 8388864) {
    				text1_changes.$$scope = { dirty, ctx };
    			}

    			text1.$set(text1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text0.$$.fragment, local);
    			transition_in(text1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text0.$$.fragment, local);
    			transition_out(text1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(text1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(280:8) <Timeline.Item title={buyItemData.title} color={buyItemData.color}>",
    		ctx
    	});

    	return block;
    }

    // (291:10) <Text size="sm" color={completeItemData.color}             >
    function create_default_slot_6$1(ctx) {
    	let t_value = /*completeItemData*/ ctx[9].description + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*completeItemData*/ 512 && t_value !== (t_value = /*completeItemData*/ ctx[9].description + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(291:10) <Text size=\\\"sm\\\" color={completeItemData.color}             >",
    		ctx
    	});

    	return block;
    }

    // (294:10) <Text size="xs">
    function create_default_slot_5$1(ctx) {
    	let t_value = /*completeItemData*/ ctx[9].extra + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*completeItemData*/ 512 && t_value !== (t_value = /*completeItemData*/ ctx[9].extra + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(294:10) <Text size=\\\"xs\\\">",
    		ctx
    	});

    	return block;
    }

    // (287:8) <Timeline.Item           title={completeItemData.title}           color={completeItemData.color}         >
    function create_default_slot_4$1(ctx) {
    	let text0;
    	let t;
    	let text1;
    	let current;

    	text0 = new Text$1({
    			props: {
    				size: "sm",
    				color: /*completeItemData*/ ctx[9].color,
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	text1 = new Text$1({
    			props: {
    				size: "xs",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(text0.$$.fragment);
    			t = space();
    			create_component(text1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(text1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text0_changes = {};
    			if (dirty & /*completeItemData*/ 512) text0_changes.color = /*completeItemData*/ ctx[9].color;

    			if (dirty & /*$$scope, completeItemData*/ 8389120) {
    				text0_changes.$$scope = { dirty, ctx };
    			}

    			text0.$set(text0_changes);
    			const text1_changes = {};

    			if (dirty & /*$$scope, completeItemData*/ 8389120) {
    				text1_changes.$$scope = { dirty, ctx };
    			}

    			text1.$set(text1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text0.$$.fragment, local);
    			transition_in(text1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text0.$$.fragment, local);
    			transition_out(text1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(text1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(287:8) <Timeline.Item           title={completeItemData.title}           color={completeItemData.color}         >",
    		ctx
    	});

    	return block;
    }

    // (268:6) <Timeline active={progress} lineWidth={4} bulletSize={20}>
    function create_default_slot_3$2(ctx) {
    	let timeline_item0;
    	let t0;
    	let timeline_item1;
    	let t1;
    	let timeline_item2;
    	let current;

    	timeline_item0 = new Timeline.Item({
    			props: {
    				title: "New Escrow",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	timeline_item1 = new Timeline.Item({
    			props: {
    				title: /*buyItemData*/ ctx[8].title,
    				color: /*buyItemData*/ ctx[8].color,
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	timeline_item2 = new Timeline.Item({
    			props: {
    				title: /*completeItemData*/ ctx[9].title,
    				color: /*completeItemData*/ ctx[9].color,
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(timeline_item0.$$.fragment);
    			t0 = space();
    			create_component(timeline_item1.$$.fragment);
    			t1 = space();
    			create_component(timeline_item2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(timeline_item0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(timeline_item1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(timeline_item2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const timeline_item0_changes = {};

    			if (dirty & /*$$scope, escrowEth, fetchedEscrow, escrowID*/ 8388621) {
    				timeline_item0_changes.$$scope = { dirty, ctx };
    			}

    			timeline_item0.$set(timeline_item0_changes);
    			const timeline_item1_changes = {};
    			if (dirty & /*buyItemData*/ 256) timeline_item1_changes.title = /*buyItemData*/ ctx[8].title;
    			if (dirty & /*buyItemData*/ 256) timeline_item1_changes.color = /*buyItemData*/ ctx[8].color;

    			if (dirty & /*$$scope, buyItemData*/ 8388864) {
    				timeline_item1_changes.$$scope = { dirty, ctx };
    			}

    			timeline_item1.$set(timeline_item1_changes);
    			const timeline_item2_changes = {};
    			if (dirty & /*completeItemData*/ 512) timeline_item2_changes.title = /*completeItemData*/ ctx[9].title;
    			if (dirty & /*completeItemData*/ 512) timeline_item2_changes.color = /*completeItemData*/ ctx[9].color;

    			if (dirty & /*$$scope, completeItemData*/ 8389120) {
    				timeline_item2_changes.$$scope = { dirty, ctx };
    			}

    			timeline_item2.$set(timeline_item2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(timeline_item0.$$.fragment, local);
    			transition_in(timeline_item1.$$.fragment, local);
    			transition_in(timeline_item2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(timeline_item0.$$.fragment, local);
    			transition_out(timeline_item1.$$.fragment, local);
    			transition_out(timeline_item2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(timeline_item0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(timeline_item1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(timeline_item2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(268:6) <Timeline active={progress} lineWidth={4} bulletSize={20}>",
    		ctx
    	});

    	return block;
    }

    // (267:4) <Center>
    function create_default_slot_2$2(ctx) {
    	let timeline;
    	let current;

    	timeline = new Timeline({
    			props: {
    				active: /*progress*/ ctx[7],
    				lineWidth: 4,
    				bulletSize: 20,
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(timeline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(timeline, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const timeline_changes = {};
    			if (dirty & /*progress*/ 128) timeline_changes.active = /*progress*/ ctx[7];

    			if (dirty & /*$$scope, completeItemData, buyItemData, escrowEth, fetchedEscrow, escrowID*/ 8389389) {
    				timeline_changes.$$scope = { dirty, ctx };
    			}

    			timeline.$set(timeline_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(timeline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(timeline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(timeline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(267:4) <Center>",
    		ctx
    	});

    	return block;
    }

    // (300:2) {#if detailsErrorMsg}
    function create_if_block$3(ctx) {
    	let alert;
    	let current;

    	alert = new Alert$1({
    			props: {
    				title: "Error!",
    				color: "red",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};

    			if (dirty & /*$$scope, detailsErrorMsg*/ 8388610) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(300:2) {#if detailsErrorMsg}",
    		ctx
    	});

    	return block;
    }

    // (301:4) <Alert title="Error!" color="red">
    function create_default_slot_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*detailsErrorMsg*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*detailsErrorMsg*/ 2) set_data_dev(t, /*detailsErrorMsg*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(301:4) <Alert title=\\\"Error!\\\" color=\\\"red\\\">",
    		ctx
    	});

    	return block;
    }

    // (192:0) <Container size="xs" override={{ px: "xs" }}>
    function create_default_slot$4(ctx) {
    	let h2;
    	let t0_value = (/*isMerchant*/ ctx[4] ? "Merchant" : "Buyer") + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*fetchedEscrow*/ ctx[2] && create_if_block_1$1(ctx);
    	let if_block1 = /*detailsErrorMsg*/ ctx[1] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = text(" Portal");
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			add_location(h2, file$4, 192, 2, 6178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			append_dev(h2, t1);
    			insert_dev(target, t2, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*isMerchant*/ 16) && t0_value !== (t0_value = (/*isMerchant*/ ctx[4] ? "Merchant" : "Buyer") + "")) set_data_dev(t0, t0_value);

    			if (/*fetchedEscrow*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*fetchedEscrow*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t3.parentNode, t3);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*detailsErrorMsg*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*detailsErrorMsg*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t2);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(192:0) <Container size=\\\"xs\\\" override={{ px: \\\"xs\\\" }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let container;
    	let current;

    	container = new Container$1({
    			props: {
    				size: "xs",
    				override: { px: "xs" },
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope, detailsErrorMsg, progress, completeItemData, buyItemData, escrowEth, fetchedEscrow, escrowID, completeProgressMsg, isMerchant, isBuyer, enterProgressMsg, cancelProgressMsg, hasBuyer*/ 8396799) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ViewEscrowComp', slots, []);
    	let { ethereum } = $$props;
    	let { account } = $$props;
    	let { escrowID } = $$props;
    	const address = contractAddress;

    	const publicClient = createPublicClient({
    		chain: xrpEVMDevNet,
    		transport: custom(ethereum)
    	});

    	const walletClient = createWalletClient({
    		account,
    		chain: xrpEVMDevNet,
    		transport: custom(ethereum)
    	});

    	const contract = getContract({
    		address: contractAddress,
    		abi,
    		publicClient,
    		walletClient
    	});

    	onMount(() => {
    		if (parseInt(escrowID) === 0 || escrowID) {
    			getContractDetails();
    		}
    	});

    	let detailsErrorMsg = null;
    	let fetchedEscrow = null;
    	let escrowEth = null;
    	let isMerchant = false;
    	let hasBuyer = false;
    	let isBuyer = false;
    	let progress = 0;

    	let buyItemData = {
    		title: "Buyer Entered",
    		description: "",
    		extra: "",
    		color: "dimmed"
    	};

    	let completeItemData = {
    		title: "Complete",
    		description: "",
    		extra: "",
    		color: "dimmed"
    	};

    	async function getContractDetails() {
    		$$invalidate(1, detailsErrorMsg = null);
    		let escrowNum = null;

    		try {
    			escrowNum = Number(escrowID);
    		} catch(e) {
    			console.log("Please enter a valid escrow number");
    			$$invalidate(1, detailsErrorMsg = "Please enter a valid escrow number");
    			return;
    		}

    		if (!escrowNum && escrowNum !== 0) {
    			console.log("Please enter escrow number");
    			$$invalidate(1, detailsErrorMsg = "Please enter escrow number");
    			return;
    		}

    		const escrow = await publicClient.readContract({
    			address,
    			abi,
    			functionName: "getEscrow",
    			args: [BigInt(escrowNum)]
    		});

    		if (escrow.merchant === NO_ONE) {
    			console.log("Escrow does not exist");
    			$$invalidate(1, detailsErrorMsg = "Escrow does not exist");
    			return;
    		}

    		$$invalidate(2, fetchedEscrow = escrow);
    		$$invalidate(3, escrowEth = Number(formatEther(escrow.amount)));
    		const thisAccount = await walletClient.account.address;

    		if (thisAccount.toLowerCase() === escrow.merchant.toLowerCase()) {
    			$$invalidate(4, isMerchant = true);
    		}

    		if (thisAccount.toLowerCase() === escrow.buyer.toLowerCase()) {
    			$$invalidate(6, isBuyer = true);
    		}

    		if (escrow.buyer !== NO_ONE) {
    			$$invalidate(5, hasBuyer = true);
    		}

    		if (hasBuyer) {
    			$$invalidate(7, progress = 1);

    			$$invalidate(8, buyItemData = {
    				title: "Buyer Entered",
    				description: `The buyer ${escrow.buyer} has entered the escrow and paid ${escrowEth} ETH`,
    				extra: `Buyer has also deposited ${escrowEth / 4}`,
    				color: "blue"
    			});
    		} else if (escrow.isDead) {
    			$$invalidate(7, progress = 1);

    			$$invalidate(8, buyItemData = {
    				title: "Escrow Cancelled",
    				description: "The escrow was cancelled by the merchant",
    				extra: "No staked was deposited by a buyer",
    				color: "red"
    			});
    		}

    		if (hasBuyer && escrow.complete) {
    			$$invalidate(7, progress = 2);

    			$$invalidate(9, completeItemData = {
    				title: "Completed",
    				description: "The escrow has been completed",
    				extra: "The buyer has released the funds to the merchant",
    				color: "green"
    			});
    		} else if (hasBuyer && escrow.isDead) {
    			$$invalidate(7, progress = 2);

    			$$invalidate(9, completeItemData = {
    				title: "Escrow Cancelled",
    				description: "The escrow was cancelled by the merchant",
    				extra: "The buyer was refunded the full amount",
    				color: "red"
    			});
    		}
    	}

    	let cancelProgressMsg = null;

    	async function cancelEscrow() {
    		$$invalidate(10, cancelProgressMsg = "Canceling escrow...");
    		await ethereum.request({ method: "eth_requestAccounts" });
    		const hash = await contract.write.cancelEscrow([BigInt(escrowID)], {});
    		$$invalidate(10, cancelProgressMsg = "Cancel request signed and sent. Waiting for confirmation... \n Tx Hash: " + hash);
    		const transaction = await publicClient.waitForTransactionReceipt({ hash });
    		$$invalidate(10, cancelProgressMsg = `Escrow cancelled in block ${transaction.blockNumber}`);
    		window.location.reload();
    	}

    	let enterProgressMsg = null;

    	async function enterEscrow() {
    		if (!escrowEth) {
    			console.log("Please enter escrow amount");
    			$$invalidate(11, enterProgressMsg = "Please enter escrow amount");
    			return;
    		}

    		const amount = escrowEth / 4;
    		const amountInWei = Number(parseEther(amount.toString()));
    		$$invalidate(11, enterProgressMsg = "Depositing... " + escrowEth + " ETH + stake" + amount + "ETH");
    		await ethereum.request({ method: "eth_requestAccounts" });
    		const hash = await contract.write.deposit([BigInt(escrowID)], { value: BigInt(amountInWei * 5) });
    		$$invalidate(11, enterProgressMsg = "Deposit request signed and sent. Waiting for confirmation...");
    		const transaction = await publicClient.waitForTransactionReceipt({ hash });
    		$$invalidate(10, cancelProgressMsg = `Escrow entered in block ${transaction.blockNumber}`);
    		$$invalidate(11, enterProgressMsg = null);

    		// refresh the page
    		window.location.reload();
    	}

    	let completeProgressMsg = null;

    	async function completeEscrow() {
    		if (!escrowEth) {
    			$$invalidate(12, completeProgressMsg = "Could not find escrow amount");
    			return;
    		}

    		const amount = escrowEth / 4;
    		$$invalidate(12, completeProgressMsg = "Completing Trade, sending " + amount + " ETH to the merchant");
    		await ethereum.request({ method: "eth_requestAccounts" });
    		const hash = await contract.write.completeTrade([BigInt(escrowID)], {});
    		$$invalidate(12, completeProgressMsg = "Complete Escrow request signed and sent. Waiting for confirmation...");
    		const transaction = await publicClient.waitForTransactionReceipt({ hash });
    		$$invalidate(12, completeProgressMsg = `Escrow cancelled in block ${transaction.blockNumber}`);
    		window.location.reload();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (ethereum === undefined && !('ethereum' in $$props || $$self.$$.bound[$$self.$$.props['ethereum']])) {
    			console_1$2.warn("<ViewEscrowComp> was created without expected prop 'ethereum'");
    		}

    		if (account === undefined && !('account' in $$props || $$self.$$.bound[$$self.$$.props['account']])) {
    			console_1$2.warn("<ViewEscrowComp> was created without expected prop 'account'");
    		}

    		if (escrowID === undefined && !('escrowID' in $$props || $$self.$$.bound[$$self.$$.props['escrowID']])) {
    			console_1$2.warn("<ViewEscrowComp> was created without expected prop 'escrowID'");
    		}
    	});

    	const writable_props = ['ethereum', 'account', 'escrowID'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<ViewEscrowComp> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ethereum' in $$props) $$invalidate(16, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(17, account = $$props.account);
    		if ('escrowID' in $$props) $$invalidate(0, escrowID = $$props.escrowID);
    	};

    	$$self.$capture_state = () => ({
    		Container: Container$1,
    		Button: Button$1,
    		Alert: Alert$1,
    		Center: Center$1,
    		Badge: Badge$1,
    		Card,
    		Flex: Flex$1,
    		Divider: Divider$1,
    		NO_ONE,
    		contractAddress,
    		xrpEVMDevNet,
    		onMount,
    		Timeline,
    		Text: Text$1,
    		formatEther,
    		parseEther,
    		createPublicClient,
    		custom,
    		createWalletClient,
    		getContract,
    		abi,
    		ethereum,
    		account,
    		escrowID,
    		address,
    		publicClient,
    		walletClient,
    		contract,
    		detailsErrorMsg,
    		fetchedEscrow,
    		escrowEth,
    		isMerchant,
    		hasBuyer,
    		isBuyer,
    		progress,
    		buyItemData,
    		completeItemData,
    		getContractDetails,
    		cancelProgressMsg,
    		cancelEscrow,
    		enterProgressMsg,
    		enterEscrow,
    		completeProgressMsg,
    		completeEscrow
    	});

    	$$self.$inject_state = $$props => {
    		if ('ethereum' in $$props) $$invalidate(16, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(17, account = $$props.account);
    		if ('escrowID' in $$props) $$invalidate(0, escrowID = $$props.escrowID);
    		if ('detailsErrorMsg' in $$props) $$invalidate(1, detailsErrorMsg = $$props.detailsErrorMsg);
    		if ('fetchedEscrow' in $$props) $$invalidate(2, fetchedEscrow = $$props.fetchedEscrow);
    		if ('escrowEth' in $$props) $$invalidate(3, escrowEth = $$props.escrowEth);
    		if ('isMerchant' in $$props) $$invalidate(4, isMerchant = $$props.isMerchant);
    		if ('hasBuyer' in $$props) $$invalidate(5, hasBuyer = $$props.hasBuyer);
    		if ('isBuyer' in $$props) $$invalidate(6, isBuyer = $$props.isBuyer);
    		if ('progress' in $$props) $$invalidate(7, progress = $$props.progress);
    		if ('buyItemData' in $$props) $$invalidate(8, buyItemData = $$props.buyItemData);
    		if ('completeItemData' in $$props) $$invalidate(9, completeItemData = $$props.completeItemData);
    		if ('cancelProgressMsg' in $$props) $$invalidate(10, cancelProgressMsg = $$props.cancelProgressMsg);
    		if ('enterProgressMsg' in $$props) $$invalidate(11, enterProgressMsg = $$props.enterProgressMsg);
    		if ('completeProgressMsg' in $$props) $$invalidate(12, completeProgressMsg = $$props.completeProgressMsg);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		escrowID,
    		detailsErrorMsg,
    		fetchedEscrow,
    		escrowEth,
    		isMerchant,
    		hasBuyer,
    		isBuyer,
    		progress,
    		buyItemData,
    		completeItemData,
    		cancelProgressMsg,
    		enterProgressMsg,
    		completeProgressMsg,
    		cancelEscrow,
    		enterEscrow,
    		completeEscrow,
    		ethereum,
    		account
    	];
    }

    class ViewEscrowComp extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { ethereum: 16, account: 17, escrowID: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ViewEscrowComp",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get ethereum() {
    		throw new Error("<ViewEscrowComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ethereum(value) {
    		throw new Error("<ViewEscrowComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get account() {
    		throw new Error("<ViewEscrowComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<ViewEscrowComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get escrowID() {
    		throw new Error("<ViewEscrowComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set escrowID(value) {
    		throw new Error("<ViewEscrowComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/AllEscrowComp.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1, console: console_1$1 } = globals;
    const file$3 = "src/components/AllEscrowComp.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i].escrowId;
    	child_ctx[10] = list[i].amount;
    	child_ctx[11] = list[i].details;
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:6) <Badge variant="filled">
    function create_default_slot_3$1(ctx) {
    	let t_value = Number(/*amount*/ ctx[10]) / 10 ** 18 + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$allEscrowList*/ 1 && t_value !== (t_value = Number(/*amount*/ ctx[10]) / 10 ** 18 + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(69:6) <Badge variant=\\\"filled\\\">",
    		ctx
    	});

    	return block;
    }

    // (71:6) <Button         variant="light"         fullSize         href={`${window.location.href}?escrowID=${escrowId}`}>
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("View");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(71:6) <Button         variant=\\\"light\\\"         fullSize         href={`${window.location.href}?escrowID=${escrowId}`}>",
    		ctx
    	});

    	return block;
    }

    // (65:4) <Card shadow="sm" padding="lg">
    function create_default_slot_1$1(ctx) {
    	let h3;
    	let t0_value = /*details*/ ctx[11] + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2;
    	let strong;
    	let t3_value = /*escrowId*/ ctx[9] + "";
    	let t3;
    	let t4;
    	let br;
    	let t5;
    	let badge;
    	let t6;
    	let p1;
    	let t8;
    	let button;
    	let current;

    	badge = new Badge$1({
    			props: {
    				variant: "filled",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button$1({
    			props: {
    				variant: "light",
    				fullSize: true,
    				href: `${window.location.href}?escrowID=${/*escrowId*/ ctx[9]}`,
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text("Escrow #");
    			strong = element("strong");
    			t3 = text(t3_value);
    			t4 = space();
    			br = element("br");
    			t5 = space();
    			create_component(badge.$$.fragment);
    			t6 = space();
    			p1 = element("p");
    			p1.textContent = "Details of the transaction can go here.";
    			t8 = space();
    			create_component(button.$$.fragment);
    			set_style(h3, "margin-bottom", "0");
    			add_location(h3, file$3, 65, 6, 2062);
    			add_location(strong, file$3, 66, 43, 2150);
    			set_style(p0, "margin-bottom", "0");
    			add_location(p0, file$3, 66, 6, 2113);
    			add_location(br, file$3, 67, 6, 2188);
    			add_location(p1, file$3, 69, 6, 2267);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t2);
    			append_dev(p0, strong);
    			append_dev(strong, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(badge, target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$allEscrowList*/ 1) && t0_value !== (t0_value = /*details*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$allEscrowList*/ 1) && t3_value !== (t3_value = /*escrowId*/ ctx[9] + "")) set_data_dev(t3, t3_value);
    			const badge_changes = {};

    			if (dirty & /*$$scope, $allEscrowList*/ 16385) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    			const button_changes = {};
    			if (dirty & /*$allEscrowList*/ 1) button_changes.href = `${window.location.href}?escrowID=${/*escrowId*/ ctx[9]}`;

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t5);
    			destroy_component(badge, detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t8);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(65:4) <Card shadow=\\\"sm\\\" padding=\\\"lg\\\">",
    		ctx
    	});

    	return block;
    }

    // (64:2) {#each $allEscrowList as { escrowId, amount, details }
    function create_each_block(ctx) {
    	let card;
    	let t;
    	let br;
    	let current;

    	card = new Card({
    			props: {
    				shadow: "sm",
    				padding: "lg",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    			t = space();
    			br = element("br");
    			add_location(br, file$3, 76, 4, 2468);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, br, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, $allEscrowList*/ 16385) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(64:2) {#each $allEscrowList as { escrowId, amount, details }",
    		ctx
    	});

    	return block;
    }

    // (63:0) <Container size="xs" style="padding: 0px">
    function create_default_slot$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$allEscrowList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*window, $allEscrowList, Number*/ 1) {
    				each_value = /*$allEscrowList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(63:0) <Container size=\\\"xs\\\" style=\\\"padding: 0px\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let container;
    	let current;

    	container = new Container$1({
    			props: {
    				size: "xs",
    				style: "padding: 0px",
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope, $allEscrowList*/ 16385) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $allEscrowList;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AllEscrowComp', slots, []);
    	let { ethereum } = $$props;
    	let { account } = $$props;

    	const publicClient = createPublicClient({
    		chain: xrpEVMDevNet,
    		transport: custom(ethereum)
    	});

    	const walletClient = createWalletClient({
    		account,
    		chain: xrpEVMDevNet,
    		transport: custom(ethereum)
    	});

    	const contract = getContract({
    		address: contractAddress,
    		abi,
    		publicClient,
    		walletClient
    	});

    	let allEscrowList = writable([]);
    	validate_store(allEscrowList, 'allEscrowList');
    	component_subscribe($$self, allEscrowList, value => $$invalidate(0, $allEscrowList = value));

    	async function getEscrowInfo(escrowID) {
    		await ethereum.request({ method: "eth_requestAccounts" });
    		const res = await contract.read.escrows([BigInt(escrowID)]);

    		const escrow = {
    			buyer: res[0],
    			merchant: res[1],
    			amount: res[2],
    			details: res[3],
    			isDead: res[4],
    			complete: res[5]
    		};

    		return escrow;
    	}

    	onMount(() => {
    		let allEscrowListTemp = [];

    		getMerchantEscrows().then(escrowIDs => {
    			const escrowIDsList = [];

    			escrowIDs.forEach(escrowID => {
    				escrowIDsList.push(escrowID);
    			});

    			escrowIDsList.reverse().forEach(escrowID => {
    				console.log(escrowID);

    				getEscrowInfo(escrowID).then(escrow => {
    					allEscrowListTemp.push(Object.assign(Object.assign({}, escrow), { escrowId: Number(escrowID) }));
    					allEscrowList.set(allEscrowListTemp);
    				});
    			});
    		});
    	});

    	async function getMerchantEscrows() {
    		const escrowIDs = await contract.read.getMerchantEscrows([account]);
    		return escrowIDs;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (ethereum === undefined && !('ethereum' in $$props || $$self.$$.bound[$$self.$$.props['ethereum']])) {
    			console_1$1.warn("<AllEscrowComp> was created without expected prop 'ethereum'");
    		}

    		if (account === undefined && !('account' in $$props || $$self.$$.bound[$$self.$$.props['account']])) {
    			console_1$1.warn("<AllEscrowComp> was created without expected prop 'account'");
    		}
    	});

    	const writable_props = ['ethereum', 'account'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<AllEscrowComp> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ethereum' in $$props) $$invalidate(2, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(3, account = $$props.account);
    	};

    	$$self.$capture_state = () => ({
    		Badge: Badge$1,
    		Card,
    		Button: Button$1,
    		Container: Container$1,
    		onMount,
    		writable,
    		createPublicClient,
    		createWalletClient,
    		custom,
    		getContract,
    		abi,
    		contractAddress,
    		xrpEVMDevNet,
    		ethereum,
    		account,
    		publicClient,
    		walletClient,
    		contract,
    		allEscrowList,
    		getEscrowInfo,
    		getMerchantEscrows,
    		$allEscrowList
    	});

    	$$self.$inject_state = $$props => {
    		if ('ethereum' in $$props) $$invalidate(2, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(3, account = $$props.account);
    		if ('allEscrowList' in $$props) $$invalidate(1, allEscrowList = $$props.allEscrowList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$allEscrowList, allEscrowList, ethereum, account];
    }

    class AllEscrowComp extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { ethereum: 2, account: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AllEscrowComp",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get ethereum() {
    		throw new Error("<AllEscrowComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ethereum(value) {
    		throw new Error("<AllEscrowComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get account() {
    		throw new Error("<AllEscrowComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<AllEscrowComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Main.svelte generated by Svelte v3.59.2 */
    const file$2 = "src/Main.svelte";

    // (17:0) <Modal {opened} on:close={closeModal} withCloseButton={false}>
    function create_default_slot_6(ctx) {
    	let createescrowcomp;
    	let current;

    	createescrowcomp = new CreateEscrowComp({
    			props: {
    				ethereum: /*ethereum*/ ctx[0],
    				account: /*account*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(createescrowcomp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(createescrowcomp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const createescrowcomp_changes = {};
    			if (dirty & /*ethereum*/ 1) createescrowcomp_changes.ethereum = /*ethereum*/ ctx[0];
    			if (dirty & /*account*/ 2) createescrowcomp_changes.account = /*account*/ ctx[1];
    			createescrowcomp.$set(createescrowcomp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(createescrowcomp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(createescrowcomp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(createescrowcomp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(17:0) <Modal {opened} on:close={closeModal} withCloseButton={false}>",
    		ctx
    	});

    	return block;
    }

    // (23:4) <Flex justify="space-between">
    function create_default_slot_5(ctx) {
    	let div;
    	let image;
    	let t0;
    	let p;
    	let t2;
    	let accountinfo;
    	let current;

    	image = new Image$2({
    			props: {
    				width: "7 d0%",
    				radius: "md",
    				src: "https://raw.githubusercontent.com/KipCrossing/P2PTRADE/929a14876e06c61024352c515baa18691dcb2d47/public/logo.svg",
    				alt: "P2P Trade"
    			},
    			$$inline: true
    		});

    	accountinfo = new AccountInfo({
    			props: {
    				ethereum: /*ethereum*/ ctx[0],
    				account: /*account*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(image.$$.fragment);
    			t0 = space();
    			p = element("p");
    			p.textContent = "Peer to peer trustless trade.";
    			t2 = space();
    			create_component(accountinfo.$$.fragment);
    			set_style(p, "margin-top", "0");
    			add_location(p, file$2, 30, 8, 1142);
    			add_location(div, file$2, 23, 6, 900);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(image, div, null);
    			append_dev(div, t0);
    			append_dev(div, p);
    			insert_dev(target, t2, anchor);
    			mount_component(accountinfo, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const accountinfo_changes = {};
    			if (dirty & /*ethereum*/ 1) accountinfo_changes.ethereum = /*ethereum*/ ctx[0];
    			if (dirty & /*account*/ 2) accountinfo_changes.account = /*account*/ ctx[1];
    			accountinfo.$set(accountinfo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			transition_in(accountinfo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			transition_out(accountinfo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(image);
    			if (detaching) detach_dev(t2);
    			destroy_component(accountinfo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(23:4) <Flex justify=\\\"space-between\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:2) {:else}
    function create_else_block$2(ctx) {
    	let flex;
    	let t;
    	let allescrowcomp;
    	let current;

    	flex = new Flex$1({
    			props: {
    				justify: "space-between",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	allescrowcomp = new AllEscrowComp({
    			props: {
    				ethereum: /*ethereum*/ ctx[0],
    				account: /*account*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(flex.$$.fragment);
    			t = space();
    			create_component(allescrowcomp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(flex, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(allescrowcomp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const flex_changes = {};

    			if (dirty & /*$$scope, opened*/ 132) {
    				flex_changes.$$scope = { dirty, ctx };
    			}

    			flex.$set(flex_changes);
    			const allescrowcomp_changes = {};
    			if (dirty & /*ethereum*/ 1) allescrowcomp_changes.ethereum = /*ethereum*/ ctx[0];
    			if (dirty & /*account*/ 2) allescrowcomp_changes.account = /*account*/ ctx[1];
    			allescrowcomp.$set(allescrowcomp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flex.$$.fragment, local);
    			transition_in(allescrowcomp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flex.$$.fragment, local);
    			transition_out(allescrowcomp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(flex, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(allescrowcomp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(44:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:2) {#if escrowID}
    function create_if_block$2(ctx) {
    	let flex;
    	let t0;
    	let br;
    	let t1;
    	let viewescrowcomp;
    	let current;

    	flex = new Flex$1({
    			props: {
    				justify: "space-between",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	viewescrowcomp = new ViewEscrowComp({
    			props: {
    				ethereum: /*ethereum*/ ctx[0],
    				account: /*account*/ ctx[1],
    				escrowID: /*escrowID*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(flex.$$.fragment);
    			t0 = space();
    			br = element("br");
    			t1 = space();
    			create_component(viewescrowcomp.$$.fragment);
    			add_location(br, file$2, 41, 4, 1489);
    		},
    		m: function mount(target, anchor) {
    			mount_component(flex, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(viewescrowcomp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const flex_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				flex_changes.$$scope = { dirty, ctx };
    			}

    			flex.$set(flex_changes);
    			const viewescrowcomp_changes = {};
    			if (dirty & /*ethereum*/ 1) viewescrowcomp_changes.ethereum = /*ethereum*/ ctx[0];
    			if (dirty & /*account*/ 2) viewescrowcomp_changes.account = /*account*/ ctx[1];
    			viewescrowcomp.$set(viewescrowcomp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flex.$$.fragment, local);
    			transition_in(viewescrowcomp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flex.$$.fragment, local);
    			transition_out(viewescrowcomp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(flex, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			destroy_component(viewescrowcomp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(36:2) {#if escrowID}",
    		ctx
    	});

    	return block;
    }

    // (47:6) <Button variant="subtle" color="green" on:click={() => (opened = true)}         ><Plus slot="leftIcon" />
    function create_default_slot_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("New escrow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(47:6) <Button variant=\\\"subtle\\\" color=\\\"green\\\" on:click={() => (opened = true)}         ><Plus slot=\\\"leftIcon\\\" />",
    		ctx
    	});

    	return block;
    }

    // (48:9) 
    function create_leftIcon_slot_1(ctx) {
    	let plus;
    	let current;

    	plus = new Plus$1({
    			props: { slot: "leftIcon" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(plus.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(plus, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(plus.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(plus.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(plus, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_leftIcon_slot_1.name,
    		type: "slot",
    		source: "(48:9) ",
    		ctx
    	});

    	return block;
    }

    // (46:4) <Flex justify="space-between">
    function create_default_slot_3(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				variant: "subtle",
    				color: "green",
    				$$slots: {
    					leftIcon: [create_leftIcon_slot_1],
    					default: [create_default_slot_4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(46:4) <Flex justify=\\\"space-between\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:6) <Button variant="subtle" href={window.location.href.split("?")[0]}         ><CaretLeft slot="leftIcon" />
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Active Escrows");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(38:6) <Button variant=\\\"subtle\\\" href={window.location.href.split(\\\"?\\\")[0]}         ><CaretLeft slot=\\\"leftIcon\\\" />",
    		ctx
    	});

    	return block;
    }

    // (39:9) 
    function create_leftIcon_slot(ctx) {
    	let caretleft;
    	let current;

    	caretleft = new CaretLeft$1({
    			props: { slot: "leftIcon" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(caretleft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(caretleft, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(caretleft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(caretleft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(caretleft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_leftIcon_slot.name,
    		type: "slot",
    		source: "(39:9) ",
    		ctx
    	});

    	return block;
    }

    // (37:4) <Flex justify="space-between">
    function create_default_slot_1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				variant: "subtle",
    				href: window.location.href.split("?")[0],
    				$$slots: {
    					leftIcon: [create_leftIcon_slot],
    					default: [create_default_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(37:4) <Flex justify=\\\"space-between\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:0) <Container size="xs" override={{ px: "xs" }}>
    function create_default_slot$2(ctx) {
    	let div;
    	let flex;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	flex = new Flex$1({
    			props: {
    				justify: "space-between",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*escrowID*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(flex.$$.fragment);
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			set_style(div, "padding-top", "20px");
    			add_location(div, file$2, 21, 2, 827);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(flex, div, null);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const flex_changes = {};

    			if (dirty & /*$$scope, ethereum, account*/ 131) {
    				flex_changes.$$scope = { dirty, ctx };
    			}

    			flex.$set(flex_changes);
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flex.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flex.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(flex);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(21:0) <Container size=\\\"xs\\\" override={{ px: \\\"xs\\\" }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let modal;
    	let t;
    	let container;
    	let current;

    	modal = new Modal$1({
    			props: {
    				opened: /*opened*/ ctx[2],
    				withCloseButton: false,
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modal.$on("close", /*closeModal*/ ctx[4]);

    	container = new Container$1({
    			props: {
    				size: "xs",
    				override: { px: "xs" },
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    			t = space();
    			create_component(container.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modal_changes = {};
    			if (dirty & /*opened*/ 4) modal_changes.opened = /*opened*/ ctx[2];

    			if (dirty & /*$$scope, ethereum, account*/ 131) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    			const container_changes = {};

    			if (dirty & /*$$scope, ethereum, account, opened*/ 135) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Main', slots, []);
    	let { ethereum } = $$props;
    	let { account } = $$props;
    	const urlParams = new URLSearchParams(window.location.search);
    	const escrowID = urlParams.get("escrowID") || null;
    	let opened = false;

    	function closeModal() {
    		$$invalidate(2, opened = false);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (ethereum === undefined && !('ethereum' in $$props || $$self.$$.bound[$$self.$$.props['ethereum']])) {
    			console.warn("<Main> was created without expected prop 'ethereum'");
    		}

    		if (account === undefined && !('account' in $$props || $$self.$$.bound[$$self.$$.props['account']])) {
    			console.warn("<Main> was created without expected prop 'account'");
    		}
    	});

    	const writable_props = ['ethereum', 'account'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Main> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(2, opened = true);

    	$$self.$$set = $$props => {
    		if ('ethereum' in $$props) $$invalidate(0, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(1, account = $$props.account);
    	};

    	$$self.$capture_state = () => ({
    		Affix: Affix$1,
    		Container: Container$1,
    		SvelteUIProvider: SvelteUIProvider$1,
    		Button: Button$1,
    		Modal: Modal$1,
    		Flex: Flex$1,
    		Image: Image$2,
    		AccountInfo,
    		CreateEscrowComp,
    		ViewEscrowComp,
    		AllEscrowComp,
    		Plus: Plus$1,
    		CaretLeft: CaretLeft$1,
    		ethereum,
    		account,
    		urlParams,
    		escrowID,
    		opened,
    		closeModal
    	});

    	$$self.$inject_state = $$props => {
    		if ('ethereum' in $$props) $$invalidate(0, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(1, account = $$props.account);
    		if ('opened' in $$props) $$invalidate(2, opened = $$props.opened);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ethereum, account, opened, escrowID, closeModal, click_handler];
    }

    class Main extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { ethereum: 0, account: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Main",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get ethereum() {
    		throw new Error("<Main>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ethereum(value) {
    		throw new Error("<Main>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get account() {
    		throw new Error("<Main>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<Main>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Entry.svelte generated by Svelte v3.59.2 */

    const { console: console_1 } = globals;
    const file$1 = "src/Entry.svelte";

    // (72:2) {:else}
    function create_else_block$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No Account Selected";
    			add_location(div, file$1, 72, 4, 2203);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(72:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:2) {#if account}
    function create_if_block_1(ctx) {
    	let div;
    	let main;
    	let current;

    	main = new Main({
    			props: {
    				ethereum: /*ethereum*/ ctx[0],
    				account: /*account*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(main.$$.fragment);
    			add_location(div, file$1, 68, 4, 2136);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(main, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const main_changes = {};
    			if (dirty & /*ethereum*/ 1) main_changes.ethereum = /*ethereum*/ ctx[0];
    			if (dirty & /*account*/ 2) main_changes.account = /*account*/ ctx[1];
    			main.$set(main_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(main.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(main.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(68:2) {#if account}",
    		ctx
    	});

    	return block;
    }

    // (75:2) {#if message}
    function create_if_block$1(ctx) {
    	let div;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("message: ");
    			t1 = text(/*message*/ ctx[2]);
    			add_location(div, file$1, 75, 4, 2262);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 4) set_data_dev(t1, /*message*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(75:2) {#if message}",
    		ctx
    	});

    	return block;
    }

    // (67:0) <Container size="xs" style="padding: 0px">
    function create_default_slot$1(ctx) {
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*account*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*message*/ ctx[2] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(t.parentNode, t);
    			}

    			if (/*message*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(67:0) <Container size=\\\"xs\\\" style=\\\"padding: 0px\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let container;
    	let current;

    	container = new Container$1({
    			props: {
    				size: "xs",
    				style: "padding: 0px",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope, message, ethereum, account*/ 39) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Entry', slots, []);
    	let { ethereum } = $$props;
    	let account = null;
    	let message = null;

    	async function getAccount() {
    		$$invalidate(1, account = null);

    		const accounts = await ethereum.request({ method: "eth_requestAccounts" }).catch(err => {
    			if (err.code === 4001) {
    				// EIP-1193 userRejectedRequest error
    				// If this happens, the user rejected the connection request.
    				console.log("Please connect to MetaMask.");

    				$$invalidate(2, message = "Please connect to MetaMask.");
    			} else {
    				console.error(err);
    			}
    		});

    		if (!accounts) {
    			return null;
    		}

    		$$invalidate(1, account = accounts[0]);
    		return accounts[0];
    	}

    	async function requestChainChange() {
    		const chainId = await ethereum.request({ method: "eth_chainId" });

    		if (chainId === `0x${xrpEVMDevNet.id.toString(16)}`) {
    			return chainId;
    		}

    		const chainIdNew = await ethereum.request({
    			method: "wallet_switchEthereumChain",
    			params: [
    				{
    					chainId: `0x${xrpEVMDevNet.id.toString(16)}`
    				}
    			]
    		});

    		return chainIdNew;
    	}

    	onMount(() => {
    		getAccount().then(account => {
    			console.log("account", account);
    		});

    		requestChainChange().then(chainId => {
    			console.log("chainId", chainId);
    		});

    		ethereum.on("accountsChanged", accounts => {
    			console.log("accountsChanged", accounts);

    			getAccount().then(account => {
    				console.log("account", account);
    			});
    		});

    		ethereum.on("chainChanged", chainId => {
    			console.log("chainChanged", chainId);
    		});

    		ethereum.on("connect", connectInfo => {
    			console.log("connect", connectInfo);
    		});

    		ethereum.on("disconnect", error => {
    			console.log("disconnect", error);
    		});
    	});

    	$$self.$$.on_mount.push(function () {
    		if (ethereum === undefined && !('ethereum' in $$props || $$self.$$.bound[$$self.$$.props['ethereum']])) {
    			console_1.warn("<Entry> was created without expected prop 'ethereum'");
    		}
    	});

    	const writable_props = ['ethereum'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Entry> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ethereum' in $$props) $$invalidate(0, ethereum = $$props.ethereum);
    	};

    	$$self.$capture_state = () => ({
    		Container: Container$1,
    		http,
    		createWalletClient,
    		custom,
    		getContract,
    		contractAddress,
    		xrpEVMDevNet,
    		abi,
    		onMount,
    		Main,
    		ethereum,
    		account,
    		message,
    		getAccount,
    		requestChainChange
    	});

    	$$self.$inject_state = $$props => {
    		if ('ethereum' in $$props) $$invalidate(0, ethereum = $$props.ethereum);
    		if ('account' in $$props) $$invalidate(1, account = $$props.account);
    		if ('message' in $$props) $$invalidate(2, message = $$props.message);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ethereum, account, message];
    }

    class Entry extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { ethereum: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Entry",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get ethereum() {
    		throw new Error("<Entry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ethereum(value) {
    		throw new Error("<Entry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.59.2 */
    const file = "src/App.svelte";

    // (16:2) {:else}
    function create_else_block(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No Wallet in browser";
    			add_location(div, file, 16, 4, 407);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(16:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:2) {#if ethereum}
    function create_if_block(ctx) {
    	let entry;
    	let current;

    	entry = new Entry({
    			props: { ethereum: /*ethereum*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(entry.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(entry, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(entry.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(entry.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(entry, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(14:2) {#if ethereum}",
    		ctx
    	});

    	return block;
    }

    // (13:0) <SvelteUIProvider>
    function create_default_slot(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*ethereum*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(13:0) <SvelteUIProvider>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let title_value;
    	let meta;
    	let t;
    	let svelteuiprovider;
    	let current;
    	document.title = title_value = /*title*/ ctx[0];

    	svelteuiprovider = new SvelteUIProvider$1({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			meta = element("meta");
    			t = space();
    			create_component(svelteuiprovider.$$.fragment);
    			attr_dev(meta, "name", "description");
    			attr_dev(meta, "content", "P2PTRADE | Decentralised Trading App");
    			add_location(meta, file, 9, 2, 241);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, meta);
    			insert_dev(target, t, anchor);
    			mount_component(svelteuiprovider, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*title*/ 1) && title_value !== (title_value = /*title*/ ctx[0])) {
    				document.title = title_value;
    			}

    			const svelteuiprovider_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				svelteuiprovider_changes.$$scope = { dirty, ctx };
    			}

    			svelteuiprovider.$set(svelteuiprovider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svelteuiprovider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svelteuiprovider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(meta);
    			if (detaching) detach_dev(t);
    			destroy_component(svelteuiprovider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let { title } = $$props;
    	const ethereum = window.ethereum;

    	$$self.$$.on_mount.push(function () {
    		if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
    			console.warn("<App> was created without expected prop 'title'");
    		}
    	});

    	const writable_props = ['title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({ SvelteUIProvider: SvelteUIProvider$1, Entry, title, ethereum });

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, ethereum];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { title: 0, ethereum: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get title() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ethereum() {
    		return this.$$.ctx[1];
    	}

    	set ethereum(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const app = new App({
        target: document.body,
        props: {
            title: "Trading App",
        },
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map

    </script>
  </body>
</html>
