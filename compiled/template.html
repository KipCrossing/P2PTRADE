<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trading App</title>
  </head>
  <body>
    <div id="app"></div>
    <script>
      var app = (function () {
        "use strict";
        function t() {}
        function e(t, e) {
          for (const n in e) t[n] = e[n];
          return t;
        }
        function n(t) {
          return t();
        }
        function r() {
          return Object.create(null);
        }
        function s(t) {
          t.forEach(n);
        }
        function i(t) {
          return "function" == typeof t;
        }
        function o(t, e) {
          return t != t
            ? e == e
            : t !== e || (t && "object" == typeof t) || "function" == typeof t;
        }
        function a(e, n, r) {
          e.$$.on_destroy.push(
            (function (e, ...n) {
              if (null == e) return t;
              const r = e.subscribe(...n);
              return r.unsubscribe ? () => r.unsubscribe() : r;
            })(n, r)
          );
        }
        function c(t, e, n, r) {
          if (t) {
            const s = l(t, e, n, r);
            return t[0](s);
          }
        }
        function l(t, n, r, s) {
          return t[1] && s ? e(r.ctx.slice(), t[1](s(n))) : r.ctx;
        }
        function u(t, e, n, r) {
          if (t[2] && r) {
            const s = t[2](r(n));
            if (void 0 === e.dirty) return s;
            if ("object" == typeof s) {
              const t = [],
                n = Math.max(e.dirty.length, s.length);
              for (let r = 0; r < n; r += 1) t[r] = e.dirty[r] | s[r];
              return t;
            }
            return e.dirty | s;
          }
          return e.dirty;
        }
        function h(t, e, n, r, s, i) {
          if (s) {
            const o = l(e, n, r, i);
            t.p(o, s);
          }
        }
        function d(t) {
          if (t.ctx.length > 32) {
            const e = [],
              n = t.ctx.length / 32;
            for (let t = 0; t < n; t++) e[t] = -1;
            return e;
          }
          return -1;
        }
        function f(t) {
          const e = {};
          for (const n in t) "$" !== n[0] && (e[n] = t[n]);
          return e;
        }
        function p(t, e) {
          const n = {};
          e = new Set(e);
          for (const r in t) e.has(r) || "$" === r[0] || (n[r] = t[r]);
          return n;
        }
        function g(e) {
          return e && i(e.destroy) ? e.destroy : t;
        }
        function m(t, e) {
          t.appendChild(e);
        }
        function y(t, e, n) {
          const r = (function (t) {
            if (!t) return document;
            const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;
            if (e && e.host) return e;
            return t.ownerDocument;
          })(t);
          if (!r.getElementById(e)) {
            const t = A("style");
            (t.id = e),
              (t.textContent = n),
              (function (t, e) {
                m(t.head || t, e), e.sheet;
              })(r, t);
          }
        }
        function b(t, e, n) {
          t.insertBefore(e, n || null);
        }
        function w(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
        function A(t) {
          return document.createElement(t);
        }
        function v(t) {
          return document.createElementNS("http://www.w3.org/2000/svg", t);
        }
        function x(t) {
          return document.createTextNode(t);
        }
        function E() {
          return x(" ");
        }
        function k() {
          return x("");
        }
        function C(t, e, n, r) {
          return (
            t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r)
          );
        }
        function P(t, e, n) {
          null == n
            ? t.removeAttribute(e)
            : t.getAttribute(e) !== n && t.setAttribute(e, n);
        }
        const S = ["width", "height"];
        function I(t, e) {
          const n = Object.getOwnPropertyDescriptors(t.__proto__);
          for (const r in e)
            null == e[r]
              ? t.removeAttribute(r)
              : "style" === r
              ? (t.style.cssText = e[r])
              : "__value" === r
              ? (t.value = t[r] = e[r])
              : n[r] && n[r].set && -1 === S.indexOf(r)
              ? (t[r] = e[r])
              : P(t, r, e[r]);
        }
        function N(t, e) {
          (e = "" + e), t.data !== e && (t.data = e);
        }
        function B(t, e) {
          t.value = null == e ? "" : e;
        }
        function T(t, e, n) {
          t.classList[n ? "add" : "remove"](e);
        }
        class O {
          constructor(t = !1) {
            (this.is_svg = !1), (this.is_svg = t), (this.e = this.n = null);
          }
          c(t) {
            this.h(t);
          }
          m(t, e, n = null) {
            this.e ||
              (this.is_svg
                ? (this.e = v(e.nodeName))
                : (this.e = A(11 === e.nodeType ? "TEMPLATE" : e.nodeName)),
              (this.t = "TEMPLATE" !== e.tagName ? e : e.content),
              this.c(t)),
              this.i(n);
          }
          h(t) {
            (this.e.innerHTML = t),
              (this.n = Array.from(
                "TEMPLATE" === this.e.nodeName
                  ? this.e.content.childNodes
                  : this.e.childNodes
              ));
          }
          i(t) {
            for (let e = 0; e < this.n.length; e += 1) b(this.t, this.n[e], t);
          }
          p(t) {
            this.d(), this.h(t), this.i(this.a);
          }
          d() {
            this.n.forEach(w);
          }
        }
        function R(t, e) {
          return new t(e);
        }
        let L;
        function U(t) {
          L = t;
        }
        function F() {
          if (!L)
            throw new Error("Function called outside component initialization");
          return L;
        }
        function D(t) {
          F().$$.on_mount.push(t);
        }
        const M = [],
          z = [];
        let j = [];
        const $ = [],
          G = Promise.resolve();
        let H = !1;
        function Q() {
          H || ((H = !0), G.then(K));
        }
        function V(t) {
          j.push(t);
        }
        const J = new Set();
        let W = 0;
        function K() {
          if (0 !== W) return;
          const t = L;
          do {
            try {
              for (; W < M.length; ) {
                const t = M[W];
                W++, U(t), _(t.$$);
              }
            } catch (t) {
              throw ((M.length = 0), (W = 0), t);
            }
            for (U(null), M.length = 0, W = 0; z.length; ) z.pop()();
            for (let t = 0; t < j.length; t += 1) {
              const e = j[t];
              J.has(e) || (J.add(e), e());
            }
            j.length = 0;
          } while (M.length);
          for (; $.length; ) $.pop()();
          (H = !1), J.clear(), U(t);
        }
        function _(t) {
          if (null !== t.fragment) {
            t.update(), s(t.before_update);
            const e = t.dirty;
            (t.dirty = [-1]),
              t.fragment && t.fragment.p(t.ctx, e),
              t.after_update.forEach(V);
          }
        }
        const q = new Set();
        let Y;
        function Z() {
          Y = { r: 0, c: [], p: Y };
        }
        function X() {
          Y.r || s(Y.c), (Y = Y.p);
        }
        function tt(t, e) {
          t && t.i && (q.delete(t), t.i(e));
        }
        function et(t, e, n, r) {
          if (t && t.o) {
            if (q.has(t)) return;
            q.add(t),
              Y.c.push(() => {
                q.delete(t), r && (n && t.d(1), r());
              }),
              t.o(e);
          } else r && r();
        }
        function nt(t, e) {
          const n = {},
            r = {},
            s = { $$scope: 1 };
          let i = t.length;
          for (; i--; ) {
            const o = t[i],
              a = e[i];
            if (a) {
              for (const t in o) t in a || (r[t] = 1);
              for (const t in a) s[t] || ((n[t] = a[t]), (s[t] = 1));
              t[i] = a;
            } else for (const t in o) s[t] = 1;
          }
          for (const t in r) t in n || (n[t] = void 0);
          return n;
        }
        function rt(t) {
          t && t.c();
        }
        function st(t, e, r, o) {
          const { fragment: a, after_update: c } = t.$$;
          a && a.m(e, r),
            o ||
              V(() => {
                const e = t.$$.on_mount.map(n).filter(i);
                t.$$.on_destroy ? t.$$.on_destroy.push(...e) : s(e),
                  (t.$$.on_mount = []);
              }),
            c.forEach(V);
        }
        function it(t, e) {
          const n = t.$$;
          null !== n.fragment &&
            (!(function (t) {
              const e = [],
                n = [];
              j.forEach((r) => (-1 === t.indexOf(r) ? e.push(r) : n.push(r))),
                n.forEach((t) => t()),
                (j = e);
            })(n.after_update),
            s(n.on_destroy),
            n.fragment && n.fragment.d(e),
            (n.on_destroy = n.fragment = null),
            (n.ctx = []));
        }
        function ot(e, n, i, o, a, c, l, u = [-1]) {
          const h = L;
          U(e);
          const d = (e.$$ = {
            fragment: null,
            ctx: [],
            props: c,
            update: t,
            not_equal: a,
            bound: r(),
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(n.context || (h ? h.$$.context : [])),
            callbacks: r(),
            dirty: u,
            skip_bound: !1,
            root: n.target || h.$$.root,
          });
          l && l(d.root);
          let f = !1;
          if (
            ((d.ctx = i
              ? i(e, n.props || {}, (t, n, ...r) => {
                  const s = r.length ? r[0] : n;
                  return (
                    d.ctx &&
                      a(d.ctx[t], (d.ctx[t] = s)) &&
                      (!d.skip_bound && d.bound[t] && d.bound[t](s),
                      f &&
                        (function (t, e) {
                          -1 === t.$$.dirty[0] &&
                            (M.push(t), Q(), t.$$.dirty.fill(0)),
                            (t.$$.dirty[(e / 31) | 0] |= 1 << e % 31);
                        })(e, t)),
                    n
                  );
                })
              : []),
            d.update(),
            (f = !0),
            s(d.before_update),
            (d.fragment = !!o && o(d.ctx)),
            n.target)
          ) {
            if (n.hydrate) {
              const t = (function (t) {
                return Array.from(t.childNodes);
              })(n.target);
              d.fragment && d.fragment.l(t), t.forEach(w);
            } else d.fragment && d.fragment.c();
            n.intro && tt(e.$$.fragment),
              st(e, n.target, n.anchor, n.customElement),
              K();
          }
          U(h);
        }
        class at {
          $destroy() {
            it(this, 1), (this.$destroy = t);
          }
          $on(e, n) {
            if (!i(n)) return t;
            const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
            return (
              r.push(n),
              () => {
                const t = r.indexOf(n);
                -1 !== t && r.splice(t, 1);
              }
            );
          }
          $set(t) {
            var e;
            this.$$set &&
              ((e = t), 0 !== Object.keys(e).length) &&
              ((this.$$.skip_bound = !0),
              this.$$set(t),
              (this.$$.skip_bound = !1));
          }
        }
        function ct(t) {
          let e,
            n,
            r = gt(t[1], t[2]) + "";
          return {
            c() {
              (e = new O(!1)), (n = k()), (e.a = n);
            },
            m(t, s) {
              e.m(r, t, s), b(t, n, s);
            },
            p(t, n) {
              6 & n && r !== (r = gt(t[1], t[2]) + "") && e.p(r);
            },
            d(t) {
              t && w(n), t && e.d();
            },
          };
        }
        function lt(e) {
          let n,
            r = e[0] && ct(e);
          return {
            c() {
              r && r.c(), (n = k());
            },
            m(t, e) {
              r && r.m(t, e), b(t, n, e);
            },
            p(t, [e]) {
              t[0]
                ? r
                  ? r.p(t, e)
                  : ((r = ct(t)), r.c(), r.m(n.parentNode, n))
                : r && (r.d(1), (r = null));
            },
            i: t,
            o: t,
            d(t) {
              r && r.d(t), t && w(n);
            },
          };
        }
        function ut(t, e, n) {
          let { observable: r = !1 } = e,
            { component: s } = e,
            { code: i } = e;
          return (
            (t.$$set = (t) => {
              "observable" in t && n(0, (r = t.observable)),
                "component" in t && n(1, (s = t.component)),
                "code" in t && n(2, (i = t.code));
            }),
            [r, s, i]
          );
        }
        var ht = class extends at {
          constructor(t) {
            super(),
              ot(this, t, ut, lt, o, { observable: 0, component: 1, code: 2 });
          }
        };
        const dt = "undefined" != typeof window,
          ft = dt ? document.createElement("style") : void 0;
        if (dt) {
          const t = ft;
          (t.textContent =
            ".modal-header{padding: 2px 16px;background-color: #339af0;color: white;}.modal-body{padding: 2px 16px;}.modal-footer{padding: 2px 16px;background-color: #339af0;color: white;}.modal-content{position: relative;background-color: #fefefe;margin: auto;padding: 0;border: 1px solid #888;width: 80%;box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);animation-name: animateTop;animation-duration: 0.4s;}@keyframes animateTop {from {top: -300px; opacity: 0}to {top: 0; opacity: 1}}"),
            (t.id = "svelteui-inject");
        }
        function pt(t, e, n) {
          dt && document.head.appendChild(ft);
          return `\n    <div class="modal-content">\n        <div class="modal-header">\n            <h2>[${t} Component Error]:</h2>\n            <h3>${e}</h3>\n        </div>\n        <div class="modal-body">\n            <pre>\n                ${
            n || ""
          }\n            </pre>\n        </div>\n        <div class="modal-footer">\n            <h3>Fix the code to dismiss this error.</h3>\n        </div>\n    </div>        \n    `;
        }
        function gt(t, e) {
          const { message: n, solution: r } = e;
          return r ? pt(t, n, r) : pt(t, n);
        }
        function mt(t, e) {
          const n = [];
          if (e)
            for (let r = 0; r < e.length; r++) {
              const s = e[r],
                i = Array.isArray(s) ? s[0] : s;
              Array.isArray(s) && s.length > 1
                ? n.push(i(t, s[1]))
                : n.push(i(t));
            }
          return {
            update(t) {
              if (((t && t.length) || 0) != n.length)
                throw new Error(
                  "You must not change the length of an actions array."
                );
              if (t)
                for (let e = 0; e < t.length; e++) {
                  const r = n[e];
                  if (r && r.update) {
                    const n = t[e];
                    Array.isArray(n) && n.length > 1
                      ? r.update(n[1])
                      : r.update();
                  }
                }
            },
            destroy() {
              for (let t = 0; t < n.length; t++) {
                const e = n[t];
                e && e.destroy && e.destroy();
              }
            },
          };
        }
        const yt = "!",
          bt = new RegExp(
            `^[^${yt}]+(?:${yt}(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$`
          );
        function wt(t, e = []) {
          let n;
          const r = [];
          function s(e) {
            !(function (t, e) {
              const n = t.$$.callbacks[e.type];
              n && n.slice().forEach((t) => t.call(this, e));
            })(t, e);
          }
          return (
            (t.$on = (s, i) => {
              const o = s;
              let a = () => {};
              for (const n of e) {
                if ("string" == typeof n && n === o) {
                  const e = t.$$.callbacks[o] || (t.$$.callbacks[o] = []);
                  return (
                    e.push(i),
                    () => {
                      const t = e.indexOf(i);
                      -1 !== t && e.splice(t, 1);
                    }
                  );
                }
                if ("object" == typeof n && n.name === o) {
                  const t = i;
                  i = (...e) => {
                    ("object" == typeof n && n.shouldExclude()) || t(...e);
                  };
                }
              }
              return (
                n ? (a = n(o, i)) : r.push([o, i]),
                () => {
                  a();
                }
              );
            }),
            (t) => {
              const e = [],
                i = {};
              n = (n, r) => {
                let o = n,
                  a = r,
                  c = !1;
                if (o.match(bt)) {
                  const t = o.split(yt);
                  o = t[0];
                  const e = Object.fromEntries(t.slice(1).map((t) => [t, !0]));
                  e.passive && ((c = c || {}), (c.passive = !0)),
                    e.nonpassive && ((c = c || {}), (c.passive = !1)),
                    e.capture && ((c = c || {}), (c.capture = !0)),
                    e.once && ((c = c || {}), (c.once = !0)),
                    e.preventDefault &&
                      ((l = a),
                      (a = function (t) {
                        return t.preventDefault(), l.call(this, t);
                      })),
                    e.stopPropagation &&
                      (a = (function (t) {
                        return function (e) {
                          return e.stopPropagation(), t.call(this, e);
                        };
                      })(a));
                }
                var l;
                const u = C(t, o, a, c),
                  h = () => {
                    u();
                    const t = e.indexOf(h);
                    t > -1 && e.splice(t, 1);
                  };
                return e.push(h), o in i || (i[o] = C(t, o, s)), h;
              };
              for (let t = 0; t < r.length; t++) n(r[t][0], r[t][1]);
              return {
                destroy: () => {
                  for (let t = 0; t < e.length; t++) e[t]();
                  for (const t of Object.entries(i)) t[1]();
                },
              };
            }
          );
        }
        const At = {};
        function vt() {
          return (function (t) {
            return F().$$.context.get(t);
          })(At);
        }
        const xt = [];
        const Et = (function (e, n = t) {
          let r;
          const s = new Set();
          function i(t) {
            if (o(e, t) && ((e = t), r)) {
              const t = !xt.length;
              for (const t of s) t[1](), xt.push(t, e);
              if (t) {
                for (let t = 0; t < xt.length; t += 2) xt[t][0](xt[t + 1]);
                xt.length = 0;
              }
            }
          }
          return {
            set: i,
            update: function (t) {
              i(t(e));
            },
            subscribe: function (o, a = t) {
              const c = [o, a];
              return (
                s.add(c),
                1 === s.size && (r = n(i) || t),
                o(e),
                () => {
                  s.delete(c), 0 === s.size && r && (r(), (r = null));
                }
              );
            },
          };
        })("light");
        function kt() {
          let t;
          Et?.subscribe((e) => {
            t = e;
          });
          return {
            ...Qe,
            colorNames: zt,
            colorScheme: t,
            dark: Ke?.selector,
            fn: {
              cover: Dt.cover,
              themeColor: Dt.themeColor,
              size: Dt.size,
              radius: Dt.radius,
              rgba: Dt.rgba,
              variant: Dt.variant,
            },
          };
        }
        function Ct(t) {
          let n, r, o, a, l, f;
          const p = t[19].default,
            m = c(p, t, t[18], null);
          let y = [
              { id: "SVELTEUI_PROVIDER" },
              { class: (r = t[5](t[2], t[4].root, t[3])) },
              t[7],
            ],
            v = {};
          for (let t = 0; t < y.length; t += 1) v = e(v, y[t]);
          return {
            c() {
              (n = A("div")), m && m.c(), I(n, v);
            },
            m(e, r) {
              b(e, n, r),
                m && m.m(n, null),
                t[20](n),
                (a = !0),
                l ||
                  ((f = [
                    g((o = mt.call(null, n, t[1]))),
                    g(t[6].call(null, n)),
                  ]),
                  (l = !0));
            },
            p(t, [e]) {
              m &&
                m.p &&
                (!a || 262144 & e) &&
                h(m, p, t, t[18], a ? u(p, t[18], e, null) : d(t[18]), null),
                I(
                  n,
                  (v = nt(y, [
                    { id: "SVELTEUI_PROVIDER" },
                    (!a ||
                      (60 & e && r !== (r = t[5](t[2], t[4].root, t[3])))) && {
                      class: r,
                    },
                    128 & e && t[7],
                  ]))
                ),
                o && i(o.update) && 2 & e && o.update.call(null, t[1]);
            },
            i(t) {
              a || (tt(m, t), (a = !0));
            },
            o(t) {
              et(m, t), (a = !1);
            },
            d(e) {
              e && w(n), m && m.d(e), t[20](null), (l = !1), s(f);
            },
          };
        }
        function Pt(t, n, r) {
          let s, i, o, c;
          const l = [
            "use",
            "class",
            "element",
            "theme",
            "styles",
            "defaultProps",
            "themeObserver",
            "withNormalizeCSS",
            "withGlobalStyles",
            "override",
            "inherit",
          ];
          let u,
            h = p(n, l);
          a(t, Et, (t) => r(21, (u = t)));
          let { $$slots: d = {}, $$scope: g } = n,
            {
              use: m = [],
              class: y = "",
              element: b,
              theme: w = kt(),
              styles: A = {},
              defaultProps: v = {},
              themeObserver: x = "light",
              withNormalizeCSS: E = !1,
              withGlobalStyles: k = !1,
              override: C = {},
              inherit: P = !1,
            } = n;
          var S;
          (S = () => {
            const t = document.documentElement.classList;
            "dark" === u && t.add(Ke.className),
              "light" === u && t.remove(Ke.className);
          }),
            F().$$.before_update.push(S);
          const I = vt(),
            N = Jt(() => ({ root: {} })),
            B = wt(F()),
            T = kt();
          let O = null;
          return (
            (t.$$set = (t) => {
              (n = e(e({}, n), f(t))),
                r(7, (h = p(n, l))),
                "use" in t && r(1, (m = t.use)),
                "class" in t && r(2, (y = t.class)),
                "element" in t && r(0, (b = t.element)),
                "theme" in t && r(8, (w = t.theme)),
                "styles" in t && r(9, (A = t.styles)),
                "defaultProps" in t && r(10, (v = t.defaultProps)),
                "themeObserver" in t && r(11, (x = t.themeObserver)),
                "withNormalizeCSS" in t && r(12, (E = t.withNormalizeCSS)),
                "withGlobalStyles" in t && r(13, (k = t.withGlobalStyles)),
                "override" in t && r(14, (C = t.override)),
                "inherit" in t && r(15, (P = t.inherit)),
                "$$scope" in t && r(18, (g = t.$$scope));
            }),
            (t.$$.update = () => {
              34560 & t.$$.dirty &&
                r(
                  16,
                  (s = {
                    themeOverride: P ? { ...I.theme, ...w } : w,
                    styles: P ? { ...I.styles, ...A } : A,
                    defaultProps: P ? { ...I.styles, ...v } : v,
                  })
                ),
                65536 & t.$$.dirty &&
                  r(
                    17,
                    (i = (function (t, e) {
                      if (!e) return t;
                      return Object.keys(t).reduce(
                        (n, r) => (
                          (n[r] =
                            "object" == typeof e[r]
                              ? { ...t[r], ...e[r] }
                              : "number" == typeof e[r]
                              ? e[r]
                              : e[r] || t[r]),
                          n
                        ),
                        {}
                      );
                    })(T, s.themeOverride))
                  ),
                133120 & t.$$.dirty &&
                  null !== x &&
                  r(3, (O = "light" === x ? i : Ke)),
                8192 & t.$$.dirty && k && _e(),
                4096 & t.$$.dirty && E && qe(),
                65536 & t.$$.dirty &&
                  (function (t, e) {
                    F().$$.context.set(t, e);
                  })(At, {
                    theme: s.themeOverride,
                    styles: {},
                    defaultProps: {},
                  }),
                2048 & t.$$.dirty && Et.set(x),
                16384 & t.$$.dirty &&
                  r(
                    5,
                    ({ cx: o, classes: c } = N(null, { override: C })),
                    o,
                    (r(4, c), r(14, C))
                  );
            }),
            [
              b,
              m,
              y,
              O,
              c,
              o,
              B,
              h,
              w,
              A,
              v,
              x,
              E,
              k,
              C,
              P,
              s,
              i,
              g,
              d,
              function (t) {
                z[t ? "unshift" : "push"](() => {
                  (b = t), r(0, b);
                });
              },
            ]
          );
        }
        var St = class extends at {
          constructor(t) {
            super(),
              ot(this, t, Pt, Ct, o, {
                use: 1,
                class: 2,
                element: 0,
                theme: 8,
                styles: 9,
                defaultProps: 10,
                themeObserver: 11,
                withNormalizeCSS: 12,
                withGlobalStyles: 13,
                override: 14,
                inherit: 15,
              });
          }
        };
        function It(t, e = 0) {
          const n = vt()?.theme || kt();
          let r = "50";
          return (function (t) {
            let e = !1;
            switch (t) {
              case "dark":
              case "gray":
              case "red":
              case "pink":
              case "grape":
              case "violet":
              case "indigo":
              case "blue":
              case "cyan":
              case "teal":
              case "green":
              case "lime":
              case "yellow":
              case "orange":
                e = !0;
                break;
              default:
                e = !1;
            }
            return e;
          })(t)
            ? (e !== Number(0) && (r = `${e.toString()}00`),
              n.colors[`${t}${r}`]?.value)
            : t;
        }
        function Nt(t) {
          return (function (t) {
            const e = t.replace("#", "");
            return (
              "string" == typeof e &&
              6 === e.length &&
              !Number.isNaN(Number(`0x${e}`))
            );
          })(t)
            ? (function (t) {
                const e = t.replace("#", ""),
                  n = parseInt(e, 16);
                return {
                  r: (n >> 16) & 255,
                  g: (n >> 8) & 255,
                  b: 255 & n,
                  a: 1,
                };
              })(t)
            : t.startsWith("rgb")
            ? (function (t) {
                const [e, n, r, s] = t
                  .replace(/[^0-9,.]/g, "")
                  .split(",")
                  .map(Number);
                return { r: e, g: n, b: r, a: s || 1 };
              })(t)
            : { r: 0, g: 0, b: 0, a: 1 };
        }
        const Bt = (t, e) => {
          const { themeColor: n, rgba: r } = Dt,
            s = {
              filled: {
                [`${Ke.selector} &`]: { backgroundColor: n(t, 8) },
                border: "transparent",
                backgroundColor: n(t, 6),
                color: "White",
                "&:hover": { backgroundColor: n(t, 7) },
              },
              light: {
                [`${Ke.selector} &`]: {
                  backgroundColor: r(n(t, 8), 0.35),
                  color: "dark" === t ? n("dark", 0) : n(t, 2),
                  "&:hover": { backgroundColor: r(n(t, 7), 0.45) },
                },
                border: "transparent",
                backgroundColor: n(t, 0),
                color: "dark" === t ? n("dark", 9) : n(t, 6),
                "&:hover": { backgroundColor: n(t, 1) },
              },
              outline: {
                [`${Ke.selector} &`]: {
                  border: `1px solid ${n(t, 4)}`,
                  color: `${n(t, 4)}`,
                  "&:hover": { backgroundColor: r(n(t, 4), 0.05) },
                },
                border: `1px solid ${n(t, 7)}`,
                backgroundColor: "transparent",
                color: n(t, 7),
                "&:hover": { backgroundColor: r(n(t, 0), 0.35) },
              },
              subtle: {
                [`${Ke.selector} &`]: {
                  color: "dark" === t ? n("dark", 0) : n(t, 2),
                  "&:hover": { backgroundColor: r(n(t, 8), 0.35) },
                },
                border: "transparent",
                backgroundColor: "transparent",
                color: "dark" === t ? n("dark", 9) : n(t, 6),
                "&:hover": { backgroundColor: n(t, 0) },
              },
              default: {
                [`${Ke.selector} &`]: {
                  border: `1px solid ${n("dark", 5)}`,
                  backgroundColor: n("dark", 5),
                  color: "White",
                  "&:hover": { backgroundColor: n("dark", 4) },
                },
                border: `1px solid ${n("gray", 4)}`,
                backgroundColor: "White",
                color: "Black",
                "&:hover": { backgroundColor: n("gray", 0) },
              },
              white: {
                border: "transparent",
                backgroundColor: "White",
                color: n(t, 7),
                "&:hover": { backgroundColor: "White" },
              },
              gradient: {},
            };
          return (
            e &&
              (s.gradient = {
                border: "transparent",
                background: `linear-gradient(${e.deg}deg, $${e.from}600 0%, $${e.to}600 100%)`,
                color: "White",
              }),
            s
          );
        };
        const Tt =
          ((Ot = "rem"),
          (t) => {
            if ("number" == typeof t) return `${t / 16}${Ot}`;
            if ("string" == typeof t) {
              const e = t.replace("px", "");
              if (!Number.isNaN(Number(e))) return `${Number(e) / 16}${Ot}`;
            }
            return t;
          });
        var Ot;
        function Rt(t, e = 1) {
          if ("string" != typeof t || e > 1 || e < 0) return "rgba(0, 0, 0, 1)";
          const { r: n, g: r, b: s } = Nt(t);
          return `rgba(${n}, ${r}, ${s}, ${e})`;
        }
        const Lt = "indigo",
          Ut = "cyan",
          Ft = 45;
        const Dt = {
            cover: function (t = 0) {
              return {
                position: "absolute",
                top: Tt(t),
                right: Tt(t),
                left: Tt(t),
                bottom: Tt(t),
              };
            },
            size: function (t) {
              return "number" == typeof t.size
                ? t.size
                : "number" == typeof t.sizes[t.size]
                ? t.sizes[t.size]
                : +t.sizes[t.size]?.value || +t.sizes.md?.value;
            },
            radius: function (t) {
              const e = vt()?.theme || kt();
              return "number" == typeof t ? t : e.radii[t].value;
            },
            themeColor: It,
            variant: function ({ variant: t, color: e, gradient: n }) {
              const r = vt()?.theme || kt();
              if ("light" === t)
                return {
                  border: "transparent",
                  background: [Rt(It(e, 8), 0.35), Rt(It(e, 0), 1)],
                  color: [
                    "dark" === e ? It("dark", 0) : It(e, 2),
                    "dark" === e ? It("dark", 9) : It(e, 6),
                  ],
                  hover: [Rt(It(e, 7), 0.45), Rt(It(e, 1), 0.65)],
                };
              if ("default" === t)
                return {
                  border: [It("dark", 5), It("gray", 4)],
                  background: [It("dark", 5), r.colors.white.value],
                  color: [r.colors.white.value, r.colors.black.value],
                  hover: [It("dark", 4), It("gray", 0)],
                };
              if ("white" === t)
                return {
                  border: "transparent",
                  background: r.colors.white.value,
                  color: It(e, 6),
                  hover: null,
                };
              if ("outline" === t)
                return {
                  border: [It(e, 4), It(e, 6)],
                  background: "transparent",
                  color: [It(e, 4), It(e, 6)],
                  hover: [Rt(It(e, 4), 0.05), Rt(It(e, 0), 0.35)],
                };
              if ("gradient" === t) {
                const t = {
                  from: n?.from || Lt,
                  to: n?.to || Ut,
                  deg: n?.deg || Ft,
                };
                return {
                  background: `linear-gradient(${t.deg}deg, ${It(
                    t.from,
                    6
                  )} 0%, ${It(t.to, 6)} 100%)`,
                  color: r.colors.white.value,
                  border: "transparent",
                  hover: null,
                };
              }
              return "subtle" === t
                ? {
                    border: "transparent",
                    background: "transparent",
                    color: [
                      "dark" === e ? It("dark", 0) : It(e, 2),
                      "dark" === e ? It("dark", 9) : It(e, 6),
                    ],
                    hover: [Rt(It(e, 8), 0.35), Rt(It(e, 0), 1)],
                  }
                : {
                    border: "transparent",
                    background: [It(e, 8), It(e, 6)],
                    color: r.colors.white.value,
                    hover: It(e, 7),
                  };
            },
            rgba: Rt,
          },
          Mt = {
            primary: "#228be6",
            white: "#ffffff",
            black: "#000000",
            dark50: "#C1C2C5",
            dark100: "#A6A7AB",
            dark200: "#909296",
            dark300: "#5c5f66",
            dark400: "#373A40",
            dark500: "#2C2E33",
            dark600: "#25262b",
            dark700: "#1A1B1E",
            dark800: "#141517",
            dark900: "#101113",
            gray50: "#f8f9fa",
            gray100: "#f1f3f5",
            gray200: "#e9ecef",
            gray300: "#dee2e6",
            gray400: "#ced4da",
            gray500: "#adb5bd",
            gray600: "#868e96",
            gray700: "#495057",
            gray800: "#343a40",
            gray900: "#212529",
            red50: "#fff5f5",
            red100: "#ffe3e3",
            red200: "#ffc9c9",
            red300: "#ffa8a8",
            red400: "#ff8787",
            red500: "#ff6b6b",
            red600: "#fa5252",
            red700: "#f03e3e",
            red800: "#e03131",
            red900: "#c92a2a",
            pink50: "#fff0f6",
            pink100: "#ffdeeb",
            pink200: "#fcc2d7",
            pink300: "#faa2c1",
            pink400: "#f783ac",
            pink500: "#f06595",
            pink600: "#e64980",
            pink700: "#d6336c",
            pink800: "#c2255c",
            pink900: "#a61e4d",
            grape50: "#f8f0fc",
            grape100: "#f3d9fa",
            grape200: "#eebefa",
            grape300: "#e599f7",
            grape400: "#da77f2",
            grape500: "#cc5de8",
            grape600: "#be4bdb",
            grape700: "#ae3ec9",
            grape800: "#9c36b5",
            grape900: "#862e9c",
            violet50: "#f3f0ff",
            violet100: "#e5dbff",
            violet200: "#d0bfff",
            violet300: "#b197fc",
            violet400: "#9775fa",
            violet500: "#845ef7",
            violet600: "#7950f2",
            violet700: "#7048e8",
            violet800: "#6741d9",
            violet900: "#5f3dc4",
            indigo50: "#edf2ff",
            indigo100: "#dbe4ff",
            indigo200: "#bac8ff",
            indigo300: "#91a7ff",
            indigo400: "#748ffc",
            indigo500: "#5c7cfa",
            indigo600: "#4c6ef5",
            indigo700: "#4263eb",
            indigo800: "#3b5bdb",
            indigo900: "#364fc7",
            blue50: "#e7f5ff",
            blue100: "#d0ebff",
            blue200: "#a5d8ff",
            blue300: "#74c0fc",
            blue400: "#4dabf7",
            blue500: "#339af0",
            blue600: "#228be6",
            blue700: "#1c7ed6",
            blue800: "#1971c2",
            blue900: "#1864ab",
            cyan50: "#e3fafc",
            cyan100: "#c5f6fa",
            cyan200: "#99e9f2",
            cyan300: "#66d9e8",
            cyan400: "#3bc9db",
            cyan500: "#22b8cf",
            cyan600: "#15aabf",
            cyan700: "#1098ad",
            cyan800: "#0c8599",
            cyan900: "#0b7285",
            teal50: "#e6fcf5",
            teal100: "#c3fae8",
            teal200: "#96f2d7",
            teal300: "#63e6be",
            teal400: "#38d9a9",
            teal500: "#20c997",
            teal600: "#12b886",
            teal700: "#0ca678",
            teal800: "#099268",
            teal900: "#087f5b",
            green50: "#ebfbee",
            green100: "#d3f9d8",
            green200: "#b2f2bb",
            green300: "#8ce99a",
            green400: "#69db7c",
            green500: "#51cf66",
            green600: "#40c057",
            green700: "#37b24d",
            green800: "#2f9e44",
            green900: "#2b8a3e",
            lime50: "#f4fce3",
            lime100: "#e9fac8",
            lime200: "#d8f5a2",
            lime300: "#c0eb75",
            lime400: "#a9e34b",
            lime500: "#94d82d",
            lime600: "#82c91e",
            lime700: "#74b816",
            lime800: "#66a80f",
            lime900: "#5c940d",
            yellow50: "#fff9db",
            yellow100: "#fff3bf",
            yellow200: "#ffec99",
            yellow300: "#ffe066",
            yellow400: "#ffd43b",
            yellow500: "#fcc419",
            yellow600: "#fab005",
            yellow700: "#f59f00",
            yellow800: "#f08c00",
            yellow900: "#e67700",
            orange50: "#fff4e6",
            orange100: "#ffe8cc",
            orange200: "#ffd8a8",
            orange300: "#ffc078",
            orange400: "#ffa94d",
            orange500: "#ff922b",
            orange600: "#fd7e14",
            orange700: "#f76707",
            orange800: "#e8590c",
            orange900: "#d9480f",
          },
          zt = {
            blue: "blue",
            cyan: "cyan",
            dark: "dark",
            grape: "grape",
            gray: "gray",
            green: "green",
            indigo: "indigo",
            lime: "lime",
            orange: "orange",
            pink: "pink",
            red: "red",
            teal: "teal",
            violet: "violet",
            yellow: "yellow",
          },
          jt = {}.hasOwnProperty;
        function $t(...t) {
          const e = [];
          for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (!r) continue;
            const s = typeof r;
            if ("string" === s || "number" === s) e.push(r);
            else if (Array.isArray(r)) {
              if (r.length) {
                const t = { ...r };
                t && e.push(t);
              }
            } else if ("object" === s)
              if (r.toString === Object.prototype.toString)
                for (const t in r) jt.call(r, t) && r[t] && e.push(t);
              else e.push(r.toString());
          }
          return e.join(" ");
        }
        function Gt() {
          return { cx: $t };
        }
        const Ht = "svelteui";
        function Qt(t) {
          return `__svelteui-ref-${t || ""}`;
        }
        function Vt(t, e) {
          const n = [],
            r = {},
            s = (t) => {
              Object.keys(t).map((i) => {
                if ("variants" !== i) {
                  if (
                    ("ref" === i && n.push(t.ref),
                    "darkMode" === i && (t[`${e.dark} &`] = t.darkMode),
                    null !== t[i] && "object" == typeof t[i])
                  )
                    if ((s(t[i]), "darkMode" === i)) delete t[i];
                    else if (i.startsWith("@media"));
                    else if (!i.startsWith("&") && !i.startsWith(e.dark)) {
                      const e = je(t[i]);
                      (r[i] = e().toString()),
                        (t[`& .${e().toString()}`] = t[i]),
                        delete t[i];
                    }
                } else
                  ((t) => {
                    const e = Object.keys(t.variation);
                    for (const n of e) s(t.variation[n]);
                  })(t[i]);
              });
            };
          return (
            s(t),
            delete t["& .root"],
            { classMap: r, refs: Array.from(new Set(n)) }
          );
        }
        function Jt(t) {
          const e = "function" == typeof t ? t : () => t;
          return function (t = {}, n) {
            const r = vt()?.theme || kt(),
              { cx: s } = Gt(),
              { override: i, name: o } = n || {},
              a = e(r, t, Qt),
              c = Object.assign({}, a),
              { classMap: l, refs: u } = Vt(c, r),
              h = a.root ?? void 0,
              d = void 0 !== h ? { ...h, ...c } : a,
              f = je(d),
              p = (function (t) {
                const e = {};
                return (
                  Object.keys(t).forEach((n) => {
                    const [r, s] = t[n];
                    e[r] = s;
                  }),
                  e
                );
              })(
                Object.keys(a).map((t) => {
                  const e = u.find((e) => e.includes(t)) ?? "",
                    n = e?.split("-") ?? [],
                    r = e?.split("-")[n?.length - 1] === t,
                    s = t.toString();
                  let a = l[s] ?? s;
                  e && r && (a = `${a} ${e}`),
                    "root" === t && (a = f({ css: i }).toString());
                  let c = `${Ht}-${t.toString()}`;
                  return (
                    o &&
                      ((c = `${Ht}-${o}-${t.toString()}`), (a = `${a} ${c}`)),
                    [t, a]
                  );
                })
              );
            return { cx: s, theme: r, classes: p, getStyles: je(d) };
          };
        }
        var Wt = "colors",
          Kt = "sizes",
          _t = "space",
          qt = {
            gap: _t,
            gridGap: _t,
            columnGap: _t,
            gridColumnGap: _t,
            rowGap: _t,
            gridRowGap: _t,
            inset: _t,
            insetBlock: _t,
            insetBlockEnd: _t,
            insetBlockStart: _t,
            insetInline: _t,
            insetInlineEnd: _t,
            insetInlineStart: _t,
            margin: _t,
            marginTop: _t,
            marginRight: _t,
            marginBottom: _t,
            marginLeft: _t,
            marginBlock: _t,
            marginBlockEnd: _t,
            marginBlockStart: _t,
            marginInline: _t,
            marginInlineEnd: _t,
            marginInlineStart: _t,
            padding: _t,
            paddingTop: _t,
            paddingRight: _t,
            paddingBottom: _t,
            paddingLeft: _t,
            paddingBlock: _t,
            paddingBlockEnd: _t,
            paddingBlockStart: _t,
            paddingInline: _t,
            paddingInlineEnd: _t,
            paddingInlineStart: _t,
            top: _t,
            right: _t,
            bottom: _t,
            left: _t,
            scrollMargin: _t,
            scrollMarginTop: _t,
            scrollMarginRight: _t,
            scrollMarginBottom: _t,
            scrollMarginLeft: _t,
            scrollMarginX: _t,
            scrollMarginY: _t,
            scrollMarginBlock: _t,
            scrollMarginBlockEnd: _t,
            scrollMarginBlockStart: _t,
            scrollMarginInline: _t,
            scrollMarginInlineEnd: _t,
            scrollMarginInlineStart: _t,
            scrollPadding: _t,
            scrollPaddingTop: _t,
            scrollPaddingRight: _t,
            scrollPaddingBottom: _t,
            scrollPaddingLeft: _t,
            scrollPaddingX: _t,
            scrollPaddingY: _t,
            scrollPaddingBlock: _t,
            scrollPaddingBlockEnd: _t,
            scrollPaddingBlockStart: _t,
            scrollPaddingInline: _t,
            scrollPaddingInlineEnd: _t,
            scrollPaddingInlineStart: _t,
            fontSize: "fontSizes",
            background: Wt,
            backgroundColor: Wt,
            backgroundImage: Wt,
            borderImage: Wt,
            border: Wt,
            borderBlock: Wt,
            borderBlockEnd: Wt,
            borderBlockStart: Wt,
            borderBottom: Wt,
            borderBottomColor: Wt,
            borderColor: Wt,
            borderInline: Wt,
            borderInlineEnd: Wt,
            borderInlineStart: Wt,
            borderLeft: Wt,
            borderLeftColor: Wt,
            borderRight: Wt,
            borderRightColor: Wt,
            borderTop: Wt,
            borderTopColor: Wt,
            caretColor: Wt,
            color: Wt,
            columnRuleColor: Wt,
            fill: Wt,
            outline: Wt,
            outlineColor: Wt,
            stroke: Wt,
            textDecorationColor: Wt,
            fontFamily: "fonts",
            fontWeight: "fontWeights",
            lineHeight: "lineHeights",
            letterSpacing: "letterSpacings",
            blockSize: Kt,
            minBlockSize: Kt,
            maxBlockSize: Kt,
            inlineSize: Kt,
            minInlineSize: Kt,
            maxInlineSize: Kt,
            width: Kt,
            minWidth: Kt,
            maxWidth: Kt,
            height: Kt,
            minHeight: Kt,
            maxHeight: Kt,
            flexBasis: Kt,
            gridTemplateColumns: Kt,
            gridTemplateRows: Kt,
            borderWidth: "borderWidths",
            borderTopWidth: "borderWidths",
            borderRightWidth: "borderWidths",
            borderBottomWidth: "borderWidths",
            borderLeftWidth: "borderWidths",
            borderStyle: "borderStyles",
            borderTopStyle: "borderStyles",
            borderRightStyle: "borderStyles",
            borderBottomStyle: "borderStyles",
            borderLeftStyle: "borderStyles",
            borderRadius: "radii",
            borderTopLeftRadius: "radii",
            borderTopRightRadius: "radii",
            borderBottomRightRadius: "radii",
            borderBottomLeftRadius: "radii",
            boxShadow: "shadows",
            textShadow: "shadows",
            transition: "transitions",
            zIndex: "zIndices",
          },
          Yt = (t, e) =>
            "function" == typeof e
              ? { "()": Function.prototype.toString.call(e) }
              : e,
          Zt = () => {
            const t = Object.create(null);
            return (e, n, ...r) => {
              const s = ((t) => JSON.stringify(t, Yt))(e);
              return s in t ? t[s] : (t[s] = n(e, ...r));
            };
          },
          Xt = Symbol.for("sxs.internal"),
          te = (t, e) =>
            Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)),
          ee = (t) => {
            for (const e in t) return !0;
            return !1;
          },
          { hasOwnProperty: ne } = Object.prototype,
          re = (t) =>
            t.includes("-")
              ? t
              : t.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()),
          se = /\s+(?![^()]*\))/,
          ie = (t) => (e) =>
            t(...("string" == typeof e ? String(e).split(se) : [e])),
          oe = {
            appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
            backfaceVisibility: (t) => ({
              WebkitBackfaceVisibility: t,
              backfaceVisibility: t,
            }),
            backdropFilter: (t) => ({
              WebkitBackdropFilter: t,
              backdropFilter: t,
            }),
            backgroundClip: (t) => ({
              WebkitBackgroundClip: t,
              backgroundClip: t,
            }),
            boxDecorationBreak: (t) => ({
              WebkitBoxDecorationBreak: t,
              boxDecorationBreak: t,
            }),
            clipPath: (t) => ({ WebkitClipPath: t, clipPath: t }),
            content: (t) => ({
              content:
                t.includes('"') ||
                t.includes("'") ||
                /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(
                  t
                )
                  ? t
                  : `"${t}"`,
            }),
            hyphens: (t) => ({ WebkitHyphens: t, hyphens: t }),
            maskImage: (t) => ({ WebkitMaskImage: t, maskImage: t }),
            maskSize: (t) => ({ WebkitMaskSize: t, maskSize: t }),
            tabSize: (t) => ({ MozTabSize: t, tabSize: t }),
            textSizeAdjust: (t) => ({
              WebkitTextSizeAdjust: t,
              textSizeAdjust: t,
            }),
            userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
            marginBlock: ie((t, e) => ({
              marginBlockStart: t,
              marginBlockEnd: e || t,
            })),
            marginInline: ie((t, e) => ({
              marginInlineStart: t,
              marginInlineEnd: e || t,
            })),
            maxSize: ie((t, e) => ({ maxBlockSize: t, maxInlineSize: e || t })),
            minSize: ie((t, e) => ({ minBlockSize: t, minInlineSize: e || t })),
            paddingBlock: ie((t, e) => ({
              paddingBlockStart: t,
              paddingBlockEnd: e || t,
            })),
            paddingInline: ie((t, e) => ({
              paddingInlineStart: t,
              paddingInlineEnd: e || t,
            })),
          },
          ae = /([\d.]+)([^]*)/,
          ce = (t, e) =>
            t.length
              ? t.reduce(
                  (t, n) => (
                    t.push(
                      ...e.map((t) =>
                        t.includes("&")
                          ? t.replace(
                              /&/g,
                              /[ +>|~]/.test(n) && /&.*&/.test(t)
                                ? `:is(${n})`
                                : n
                            )
                          : n + " " + t
                      )
                    ),
                    t
                  ),
                  []
                )
              : e,
          le = (t, e) =>
            t in ue && "string" == typeof e
              ? e.replace(
                  /^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,
                  (e, n, r, s) =>
                    n +
                    ("stretch" === r
                      ? `-moz-available${s};${re(t)}:${n}-webkit-fill-available`
                      : `-moz-fit-content${s};${re(t)}:${n}fit-content`) +
                    s
                )
              : String(e),
          ue = {
            blockSize: 1,
            height: 1,
            inlineSize: 1,
            maxBlockSize: 1,
            maxHeight: 1,
            maxInlineSize: 1,
            maxWidth: 1,
            minBlockSize: 1,
            minHeight: 1,
            minInlineSize: 1,
            minWidth: 1,
            width: 1,
          },
          he = (t) => (t ? t + "-" : ""),
          de = (t, e, n) =>
            t.replace(
              /([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,
              (t, r, s, i, o) =>
                ("$" == i) == !!s
                  ? t
                  : (r || "--" == i ? "calc(" : "") +
                    "var(--" +
                    ("$" === i
                      ? he(e) +
                        (o.includes("$") ? "" : he(n)) +
                        o.replace(/\$/g, "-")
                      : o) +
                    ")" +
                    (r || "--" == i ? "*" + (r || "") + (s || "1") + ")" : "")
            ),
          fe = /\s*,\s*(?![^()]*\))/,
          pe = Object.prototype.toString,
          ge = (t, e, n, r, s) => {
            let i, o, a;
            const c = (t, e, n) => {
              let l, u;
              const h = (t) => {
                for (l in t) {
                  const p = 64 === l.charCodeAt(0),
                    g = p && Array.isArray(t[l]) ? t[l] : [t[l]];
                  for (u of g) {
                    const t = /[A-Z]/.test((f = l))
                        ? f
                        : f.replace(/-[^]/g, (t) => t[1].toUpperCase()),
                      g =
                        "object" == typeof u &&
                        u &&
                        u.toString === pe &&
                        (!r.utils[t] || !e.length);
                    if (t in r.utils && !g) {
                      const e = r.utils[t];
                      if (e !== o) {
                        (o = e), h(e(u)), (o = null);
                        continue;
                      }
                    } else if (t in oe) {
                      const e = oe[t];
                      if (e !== a) {
                        (a = e), h(e(u)), (a = null);
                        continue;
                      }
                    }
                    if (
                      (p &&
                        ((d =
                          l.slice(1) in r.media
                            ? "@media " + r.media[l.slice(1)]
                            : l),
                        (l = d.replace(
                          /\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,
                          (t, e, n, r, s, i) => {
                            const o = ae.test(e),
                              a = 0.0625 * (o ? -1 : 1),
                              [c, l] = o ? [r, e] : [e, r];
                            return (
                              "(" +
                              ("=" === n[0]
                                ? ""
                                : (">" === n[0]) === o
                                ? "max-"
                                : "min-") +
                              c +
                              ":" +
                              ("=" !== n[0] && 1 === n.length
                                ? l.replace(
                                    ae,
                                    (t, e, r) =>
                                      Number(e) + a * (">" === n ? 1 : -1) + r
                                  )
                                : l) +
                              (s
                                ? ") and (" +
                                  (">" === s[0] ? "min-" : "max-") +
                                  c +
                                  ":" +
                                  (1 === s.length
                                    ? i.replace(
                                        ae,
                                        (t, e, n) =>
                                          Number(e) +
                                          a * (">" === s ? -1 : 1) +
                                          n
                                      )
                                    : i)
                                : "") +
                              ")"
                            );
                          }
                        ))),
                      g)
                    ) {
                      const t = p ? n.concat(l) : [...n],
                        r = p ? [...e] : ce(e, l.split(fe));
                      void 0 !== i && s(me(...i)), (i = void 0), c(u, r, t);
                    } else
                      void 0 === i && (i = [[], e, n]),
                        (l =
                          p || 36 !== l.charCodeAt(0)
                            ? l
                            : `--${he(r.prefix)}${l
                                .slice(1)
                                .replace(/\$/g, "-")}`),
                        (u = g
                          ? u
                          : "number" == typeof u
                          ? u && t in ye
                            ? String(u) + "px"
                            : String(u)
                          : de(
                              le(t, null == u ? "" : u),
                              r.prefix,
                              r.themeMap[t]
                            )),
                        i[0].push(`${p ? `${l} ` : `${re(l)}:`}${u}`);
                  }
                }
                var d, f;
              };
              h(t), void 0 !== i && s(me(...i)), (i = void 0);
            };
            c(t, e, n);
          },
          me = (t, e, n) =>
            `${n.map((t) => `${t}{`).join("")}${
              e.length ? `${e.join(",")}{` : ""
            }${t.join(";")}${e.length ? "}" : ""}${Array(
              n.length ? n.length + 1 : 0
            ).join("}")}`,
          ye = {
            animationDelay: 1,
            animationDuration: 1,
            backgroundSize: 1,
            blockSize: 1,
            border: 1,
            borderBlock: 1,
            borderBlockEnd: 1,
            borderBlockEndWidth: 1,
            borderBlockStart: 1,
            borderBlockStartWidth: 1,
            borderBlockWidth: 1,
            borderBottom: 1,
            borderBottomLeftRadius: 1,
            borderBottomRightRadius: 1,
            borderBottomWidth: 1,
            borderEndEndRadius: 1,
            borderEndStartRadius: 1,
            borderInlineEnd: 1,
            borderInlineEndWidth: 1,
            borderInlineStart: 1,
            borderInlineStartWidth: 1,
            borderInlineWidth: 1,
            borderLeft: 1,
            borderLeftWidth: 1,
            borderRadius: 1,
            borderRight: 1,
            borderRightWidth: 1,
            borderSpacing: 1,
            borderStartEndRadius: 1,
            borderStartStartRadius: 1,
            borderTop: 1,
            borderTopLeftRadius: 1,
            borderTopRightRadius: 1,
            borderTopWidth: 1,
            borderWidth: 1,
            bottom: 1,
            columnGap: 1,
            columnRule: 1,
            columnRuleWidth: 1,
            columnWidth: 1,
            containIntrinsicSize: 1,
            flexBasis: 1,
            fontSize: 1,
            gap: 1,
            gridAutoColumns: 1,
            gridAutoRows: 1,
            gridTemplateColumns: 1,
            gridTemplateRows: 1,
            height: 1,
            inlineSize: 1,
            inset: 1,
            insetBlock: 1,
            insetBlockEnd: 1,
            insetBlockStart: 1,
            insetInline: 1,
            insetInlineEnd: 1,
            insetInlineStart: 1,
            left: 1,
            letterSpacing: 1,
            margin: 1,
            marginBlock: 1,
            marginBlockEnd: 1,
            marginBlockStart: 1,
            marginBottom: 1,
            marginInline: 1,
            marginInlineEnd: 1,
            marginInlineStart: 1,
            marginLeft: 1,
            marginRight: 1,
            marginTop: 1,
            maxBlockSize: 1,
            maxHeight: 1,
            maxInlineSize: 1,
            maxWidth: 1,
            minBlockSize: 1,
            minHeight: 1,
            minInlineSize: 1,
            minWidth: 1,
            offsetDistance: 1,
            offsetRotate: 1,
            outline: 1,
            outlineOffset: 1,
            outlineWidth: 1,
            overflowClipMargin: 1,
            padding: 1,
            paddingBlock: 1,
            paddingBlockEnd: 1,
            paddingBlockStart: 1,
            paddingBottom: 1,
            paddingInline: 1,
            paddingInlineEnd: 1,
            paddingInlineStart: 1,
            paddingLeft: 1,
            paddingRight: 1,
            paddingTop: 1,
            perspective: 1,
            right: 1,
            rowGap: 1,
            scrollMargin: 1,
            scrollMarginBlock: 1,
            scrollMarginBlockEnd: 1,
            scrollMarginBlockStart: 1,
            scrollMarginBottom: 1,
            scrollMarginInline: 1,
            scrollMarginInlineEnd: 1,
            scrollMarginInlineStart: 1,
            scrollMarginLeft: 1,
            scrollMarginRight: 1,
            scrollMarginTop: 1,
            scrollPadding: 1,
            scrollPaddingBlock: 1,
            scrollPaddingBlockEnd: 1,
            scrollPaddingBlockStart: 1,
            scrollPaddingBottom: 1,
            scrollPaddingInline: 1,
            scrollPaddingInlineEnd: 1,
            scrollPaddingInlineStart: 1,
            scrollPaddingLeft: 1,
            scrollPaddingRight: 1,
            scrollPaddingTop: 1,
            shapeMargin: 1,
            textDecoration: 1,
            textDecorationThickness: 1,
            textIndent: 1,
            textUnderlineOffset: 1,
            top: 1,
            transitionDelay: 1,
            transitionDuration: 1,
            verticalAlign: 1,
            width: 1,
            wordSpacing: 1,
          },
          be = (t) => String.fromCharCode(t + (t > 25 ? 39 : 97)),
          we = (t) =>
            ((t) => {
              let e,
                n = "";
              for (e = Math.abs(t); e > 52; e = (e / 52) | 0)
                n = be(e % 52) + n;
              return be(e % 52) + n;
            })(
              ((t, e) => {
                let n = e.length;
                for (; n; ) t = (33 * t) ^ e.charCodeAt(--n);
                return t;
              })(5381, JSON.stringify(t)) >>> 0
            ),
          Ae = [
            "themed",
            "global",
            "styled",
            "onevar",
            "resonevar",
            "allvar",
            "inline",
          ],
          ve = (t) => {
            if (t.href && !t.href.startsWith(location.origin)) return !1;
            try {
              return !!t.cssRules;
            } catch (t) {
              return !1;
            }
          },
          xe = (t) => {
            let e;
            const n = () => {
                const { cssRules: t } = e.sheet;
                return [].map
                  .call(t, (n, r) => {
                    const { cssText: s } = n;
                    let i = "";
                    if (s.startsWith("--sxs")) return "";
                    if (
                      t[r - 1] &&
                      (i = t[r - 1].cssText).startsWith("--sxs")
                    ) {
                      if (!n.cssRules.length) return "";
                      for (const t in e.rules)
                        if (e.rules[t].group === n)
                          return `--sxs{--sxs:${[...e.rules[t].cache].join(
                            " "
                          )}}${s}`;
                      return n.cssRules.length ? `${i}${s}` : "";
                    }
                    return s;
                  })
                  .join("");
              },
              r = () => {
                if (e) {
                  const { rules: t, sheet: n } = e;
                  if (!n.deleteRule) {
                    for (; 3 === Object(Object(n.cssRules)[0]).type; )
                      n.cssRules.splice(0, 1);
                    n.cssRules = [];
                  }
                  for (const e in t) delete t[e];
                }
                const s = Object(t).styleSheets || [];
                for (const t of s)
                  if (ve(t)) {
                    for (let s = 0, i = t.cssRules; i[s]; ++s) {
                      const o = Object(i[s]);
                      if (1 !== o.type) continue;
                      const a = Object(i[s + 1]);
                      if (4 !== a.type) continue;
                      ++s;
                      const { cssText: c } = o;
                      if (!c.startsWith("--sxs")) continue;
                      const l = c.slice(14, -3).trim().split(/\s+/),
                        u = Ae[l[0]];
                      u &&
                        (e ||
                          (e = { sheet: t, reset: r, rules: {}, toString: n }),
                        (e.rules[u] = {
                          group: a,
                          index: s,
                          cache: new Set(l),
                        }));
                    }
                    if (e) break;
                  }
                if (!e) {
                  const s = (t, e) => ({
                    type: e,
                    cssRules: [],
                    insertRule(t, e) {
                      this.cssRules.splice(
                        e,
                        0,
                        s(
                          t,
                          { import: 3, undefined: 1 }[
                            (t.toLowerCase().match(/^@([a-z]+)/) || [])[1]
                          ] || 4
                        )
                      );
                    },
                    get cssText() {
                      return "@media{}" === t
                        ? `@media{${[].map
                            .call(this.cssRules, (t) => t.cssText)
                            .join("")}}`
                        : t;
                    },
                  });
                  e = {
                    sheet: t
                      ? (t.head || t).appendChild(
                          document.createElement("style")
                        ).sheet
                      : s("", "text/css"),
                    rules: {},
                    reset: r,
                    toString: n,
                  };
                }
                const { sheet: i, rules: o } = e;
                for (let t = Ae.length - 1; t >= 0; --t) {
                  const e = Ae[t];
                  if (!o[e]) {
                    const n = Ae[t + 1],
                      r = o[n] ? o[n].index : i.cssRules.length;
                    i.insertRule("@media{}", r),
                      i.insertRule(`--sxs{--sxs:${t}}`, r),
                      (o[e] = {
                        group: i.cssRules[r + 1],
                        index: r,
                        cache: new Set([t]),
                      });
                  }
                  Ee(o[e]);
                }
              };
            return r(), e;
          },
          Ee = (t) => {
            const e = t.group;
            let n = e.cssRules.length;
            t.apply = (t) => {
              try {
                e.insertRule(t, n), ++n;
              } catch (t) {}
            };
          },
          ke = Symbol(),
          Ce = Zt(),
          Pe = (t, e) =>
            Ce(t, () => (...n) => {
              let r = { type: null, composers: new Set() };
              for (const e of n)
                if (null != e)
                  if (e[Xt]) {
                    null == r.type && (r.type = e[Xt].type);
                    for (const t of e[Xt].composers) r.composers.add(t);
                  } else
                    e.constructor !== Object || e.$$typeof
                      ? null == r.type && (r.type = e)
                      : r.composers.add(Se(e, t));
              return (
                null == r.type && (r.type = "span"),
                r.composers.size ||
                  r.composers.add(["PJLV", {}, [], [], {}, []]),
                Ie(t, r, e)
              );
            }),
          Se = (
            { variants: t, compoundVariants: e, defaultVariants: n, ...r },
            s
          ) => {
            const i = `${he(s.prefix)}c-${we(r)}`,
              o = [],
              a = [],
              c = Object.create(null),
              l = [];
            for (const t in n) c[t] = String(n[t]);
            if ("object" == typeof t && t)
              for (const e in t) {
                (u = c), (h = e), ne.call(u, h) || (c[e] = "undefined");
                const n = t[e];
                for (const t in n) {
                  const r = { [e]: String(t) };
                  "undefined" === String(t) && l.push(e);
                  const s = n[t],
                    i = [r, s, !ee(s)];
                  o.push(i);
                }
              }
            var u, h;
            if ("object" == typeof e && e)
              for (const t of e) {
                let { css: e, ...n } = t;
                e = ("object" == typeof e && e) || {};
                for (const t in n) n[t] = String(n[t]);
                const r = [n, e, !ee(e)];
                a.push(r);
              }
            return [i, r, o, a, c, l];
          },
          Ie = (t, e, n) => {
            const [r, s, i, o] = Ne(e.composers),
              a =
                "function" == typeof e.type || e.type.$$typeof
                  ? ((t) => {
                      function e() {
                        for (let n = 0; n < e[ke].length; n++) {
                          const [r, s] = e[ke][n];
                          t.rules[r].apply(s);
                        }
                        return (e[ke] = []), null;
                      }
                      return (
                        (e[ke] = []),
                        (e.rules = {}),
                        Ae.forEach(
                          (t) =>
                            (e.rules[t] = { apply: (n) => e[ke].push([t, n]) })
                        ),
                        e
                      );
                    })(n)
                  : null,
              c = (a || n).rules,
              l = `.${r}${
                s.length > 1 ? `:where(.${s.slice(1).join(".")})` : ""
              }`,
              u = (u) => {
                u = ("object" == typeof u && u) || Te;
                const { css: h, ...d } = u,
                  f = {};
                for (const t in i)
                  if ((delete d[t], t in u)) {
                    let e = u[t];
                    "object" == typeof e && e
                      ? (f[t] = { "@initial": i[t], ...e })
                      : ((e = String(e)),
                        (f[t] = "undefined" !== e || o.has(t) ? e : i[t]));
                  } else f[t] = i[t];
                const p = new Set([...s]);
                for (const [r, s, i, o] of e.composers) {
                  n.rules.styled.cache.has(r) ||
                    (n.rules.styled.cache.add(r),
                    ge(s, [`.${r}`], [], t, (t) => {
                      c.styled.apply(t);
                    }));
                  const e = Be(i, f, t.media),
                    a = Be(o, f, t.media, !0);
                  for (const s of e)
                    if (void 0 !== s)
                      for (const [e, i, o] of s) {
                        const s = `${r}-${we(i)}-${e}`;
                        p.add(s);
                        const a = (o ? n.rules.resonevar : n.rules.onevar)
                            .cache,
                          l = o ? c.resonevar : c.onevar;
                        a.has(s) ||
                          (a.add(s),
                          ge(i, [`.${s}`], [], t, (t) => {
                            l.apply(t);
                          }));
                      }
                  for (const e of a)
                    if (void 0 !== e)
                      for (const [s, i] of e) {
                        const e = `${r}-${we(i)}-${s}`;
                        p.add(e),
                          n.rules.allvar.cache.has(e) ||
                            (n.rules.allvar.cache.add(e),
                            ge(i, [`.${e}`], [], t, (t) => {
                              c.allvar.apply(t);
                            }));
                      }
                }
                if ("object" == typeof h && h) {
                  const e = `${r}-i${we(h)}-css`;
                  p.add(e),
                    n.rules.inline.cache.has(e) ||
                      (n.rules.inline.cache.add(e),
                      ge(h, [`.${e}`], [], t, (t) => {
                        c.inline.apply(t);
                      }));
                }
                for (const t of String(u.className || "")
                  .trim()
                  .split(/\s+/))
                  t && p.add(t);
                const g = (d.className = [...p].join(" "));
                return {
                  type: e.type,
                  className: g,
                  selector: l,
                  props: d,
                  toString: () => g,
                  deferredInjector: a,
                };
              };
            return te(u, {
              className: r,
              selector: l,
              [Xt]: e,
              toString: () => (n.rules.styled.cache.has(r) || u(), r),
            });
          },
          Ne = (t) => {
            let e = "";
            const n = [],
              r = {},
              s = [];
            for (const [i, , , , o, a] of t) {
              "" === e && (e = i), n.push(i), s.push(...a);
              for (const t in o) {
                const e = o[t];
                (void 0 === r[t] || "undefined" !== e || a.includes(e)) &&
                  (r[t] = e);
              }
            }
            return [e, n, r, new Set(s)];
          },
          Be = (t, e, n, r) => {
            const s = [];
            t: for (let [i, o, a] of t) {
              if (a) continue;
              let t,
                c = 0,
                l = !1;
              for (t in i) {
                const r = i[t];
                let s = e[t];
                if (s !== r) {
                  if ("object" != typeof s || !s) continue t;
                  {
                    let t,
                      e,
                      i = 0;
                    for (const o in s) {
                      if (r === String(s[o])) {
                        if ("@initial" !== o) {
                          const t = o.slice(1);
                          (e = e || []).push(
                            t in n ? n[t] : o.replace(/^@media ?/, "")
                          ),
                            (l = !0);
                        }
                        (c += i), (t = !0);
                      }
                      ++i;
                    }
                    if (
                      (e && e.length && (o = { ["@media " + e.join(", ")]: o }),
                      !t)
                    )
                      continue t;
                  }
                }
              }
              (s[c] = s[c] || []).push([r ? "cv" : `${t}-${i[t]}`, o, l]);
            }
            return s;
          },
          Te = {},
          Oe = Zt(),
          Re = (t, e) =>
            Oe(t, () => (...n) => {
              const r = () => {
                for (let r of n) {
                  r = ("object" == typeof r && r) || {};
                  let n = we(r);
                  if (!e.rules.global.cache.has(n)) {
                    if ((e.rules.global.cache.add(n), "@import" in r)) {
                      let t =
                        [].indexOf.call(
                          e.sheet.cssRules,
                          e.rules.themed.group
                        ) - 1;
                      for (let n of [].concat(r["@import"]))
                        (n = n.includes('"') || n.includes("'") ? n : `"${n}"`),
                          e.sheet.insertRule(`@import ${n};`, t++);
                      delete r["@import"];
                    }
                    ge(r, [], [], t, (t) => {
                      e.rules.global.apply(t);
                    });
                  }
                }
                return "";
              };
              return te(r, { toString: r });
            }),
          Le = Zt(),
          Ue = (t, e) =>
            Le(t, () => (n) => {
              const r = `${he(t.prefix)}k-${we(n)}`,
                s = () => {
                  if (!e.rules.global.cache.has(r)) {
                    e.rules.global.cache.add(r);
                    const s = [];
                    ge(n, [], [], t, (t) => s.push(t));
                    const i = `@keyframes ${r}{${s.join("")}}`;
                    e.rules.global.apply(i);
                  }
                  return r;
                };
              return te(s, {
                get name() {
                  return s();
                },
                toString: s,
              });
            }),
          Fe = class {
            constructor(t, e, n, r) {
              (this.token = null == t ? "" : String(t)),
                (this.value = null == e ? "" : String(e)),
                (this.scale = null == n ? "" : String(n)),
                (this.prefix = null == r ? "" : String(r));
            }
            get computedValue() {
              return "var(" + this.variable + ")";
            }
            get variable() {
              return "--" + he(this.prefix) + he(this.scale) + this.token;
            }
            toString() {
              return this.computedValue;
            }
          },
          De = Zt(),
          Me = (t, e) =>
            De(t, () => (n, r) => {
              r = ("object" == typeof n && n) || Object(r);
              const s = `.${(n =
                  (n = "string" == typeof n ? n : "") ||
                  `${he(t.prefix)}t-${we(r)}`)}`,
                i = {},
                o = [];
              for (const e in r) {
                i[e] = {};
                for (const n in r[e]) {
                  const s = `--${he(t.prefix)}${e}-${n}`,
                    a = de(String(r[e][n]), t.prefix, e);
                  (i[e][n] = new Fe(n, a, e, t.prefix)), o.push(`${s}:${a}`);
                }
              }
              const a = () => {
                if (o.length && !e.rules.themed.cache.has(n)) {
                  e.rules.themed.cache.add(n);
                  const s = `${r === t.theme ? ":root," : ""}.${n}{${o.join(
                    ";"
                  )}}`;
                  e.rules.themed.apply(s);
                }
                return n;
              };
              return {
                ...i,
                get className() {
                  return a();
                },
                selector: s,
                toString: a,
              };
            }),
          ze = Zt();
        const {
            css: je,
            globalCss: $e,
            keyframes: Ge,
            getCssText: He,
            theme: Qe,
            createTheme: Ve,
            config: Je,
            reset: We,
          } = ((t) => {
            let e = !1;
            const n = ze(t, (t) => {
              e = !0;
              const n =
                  "prefix" in (t = ("object" == typeof t && t) || {})
                    ? String(t.prefix)
                    : "",
                r = ("object" == typeof t.media && t.media) || {},
                s =
                  "object" == typeof t.root
                    ? t.root || null
                    : globalThis.document || null,
                i = ("object" == typeof t.theme && t.theme) || {},
                o = {
                  prefix: n,
                  media: r,
                  theme: i,
                  themeMap: ("object" == typeof t.themeMap && t.themeMap) || {
                    ...qt,
                  },
                  utils: ("object" == typeof t.utils && t.utils) || {},
                },
                a = xe(s),
                c = {
                  css: Pe(o, a),
                  globalCss: Re(o, a),
                  keyframes: Ue(o, a),
                  createTheme: Me(o, a),
                  reset() {
                    a.reset(), c.theme.toString();
                  },
                  theme: {},
                  sheet: a,
                  config: o,
                  prefix: n,
                  getCssText: a.toString,
                  toString: a.toString,
                };
              return String((c.theme = c.createTheme(i))), c;
            });
            return e || n.reset(), n;
          })({
            prefix: "svelteui",
            theme: {
              colors: Mt,
              space: {
                0: "0rem",
                xs: 10,
                sm: 12,
                md: 16,
                lg: 20,
                xl: 24,
                xsPX: "10px",
                smPX: "12px",
                mdPX: "16px",
                lgPX: "20px",
                xlPX: "24px",
                1: "0.125rem",
                2: "0.25rem",
                3: "0.375rem",
                4: "0.5rem",
                5: "0.625rem",
                6: "0.75rem",
                7: "0.875rem",
                8: "1rem",
                9: "1.25rem",
                10: "1.5rem",
                11: "1.75rem",
                12: "2rem",
                13: "2.25rem",
                14: "2.5rem",
                15: "2.75rem",
                16: "3rem",
                17: "3.5rem",
                18: "4rem",
                20: "5rem",
                24: "6rem",
                28: "7rem",
                32: "8rem",
                36: "9rem",
                40: "10rem",
                44: "11rem",
                48: "12rem",
                52: "13rem",
                56: "14rem",
                60: "15rem",
                64: "16rem",
                72: "18rem",
                80: "20rem",
                96: "24rem",
              },
              fontSizes: {
                xs: "12px",
                sm: "14px",
                md: "16px",
                lg: "18px",
                xl: "20px",
              },
              fonts: {
                standard:
                  "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
                mono: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
                fallback: "Segoe UI, system-ui, sans-serif",
              },
              fontWeights: {
                thin: 100,
                extralight: 200,
                light: 300,
                normal: 400,
                medium: 500,
                semibold: 600,
                bold: 700,
                extrabold: 800,
              },
              lineHeights: { xs: 1, sm: 1.25, md: 1.5, lg: 1.625, xl: 1.75 },
              letterSpacings: {
                tighter: "-0.05em",
                tight: "-0.025em",
                normal: "0",
                wide: "0.025em",
                wider: "0.05em",
                widest: "0.1em",
              },
              sizes: {},
              radii: {
                xs: "2px",
                sm: "4px",
                md: "8px",
                lg: "16px",
                xl: "32px",
                squared: "33%",
                rounded: "50%",
                pill: "9999px",
              },
              shadows: {
                xs: "0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)",
                sm: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 10px 15px -5px, rgba(0, 0, 0, 0.04) 0px 7px 7px -5px",
                md: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 20px 25px -5px, rgba(0, 0, 0, 0.04) 0px 10px 10px -5px",
                lg: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 28px 23px -7px, rgba(0, 0, 0, 0.04) 0px 12px 12px -7px",
                xl: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 36px 28px -7px, rgba(0, 0, 0, 0.04) 0px 17px 17px -7px",
              },
              zIndices: {
                1: "100",
                2: "200",
                3: "300",
                4: "400",
                5: "500",
                10: "1000",
                max: "9999",
              },
              borderWidths: {
                light: "1px",
                normal: "2px",
                bold: "3px",
                extrabold: "4px",
                black: "5px",
                xs: "1px",
                sm: "2px",
                md: "3px",
                lg: "4px",
                xl: "5px",
              },
              breakpoints: { xs: 576, sm: 768, md: 992, lg: 1200, xl: 1400 },
              borderStyles: {},
              transitions: {},
            },
            media: {
              xs: "(min-width: 576px)",
              sm: "(min-width: 768px)",
              md: "(min-width: 992px)",
              lg: "(min-width: 1200px)",
              xl: "(min-width: 1400px)",
            },
            utils: {
              focusRing: (t) => ({
                WebkitTapHighlightColor: "transparent",
                "&:focus": {
                  outlineOffset: 2,
                  outline:
                    "always" === t || "auto" === t
                      ? "2px solid $primary"
                      : "none",
                },
                "&:focus:not(:focus-visible)": {
                  outline: "auto" === t || "never" === t ? "none" : void 0,
                },
              }),
              p: (t) => ({ padding: t }),
              pt: (t) => ({ paddingTop: t }),
              pr: (t) => ({ paddingRight: t }),
              pb: (t) => ({ paddingBottom: t }),
              pl: (t) => ({ paddingLeft: t }),
              px: (t) => ({ paddingLeft: t, paddingRight: t }),
              py: (t) => ({ paddingTop: t, paddingBottom: t }),
              m: (t) => ({ margin: t }),
              mt: (t) => ({ marginTop: t }),
              mr: (t) => ({ marginRight: t }),
              mb: (t) => ({ marginBottom: t }),
              ml: (t) => ({ marginLeft: t }),
              mx: (t) => ({ marginLeft: t, marginRight: t }),
              my: (t) => ({ marginTop: t, marginBottom: t }),
              ta: (t) => ({ textAlign: t }),
              tt: (t) => ({ textTransform: t }),
              to: (t) => ({ textOverflow: t }),
              d: (t) => ({ display: t }),
              dflex: (t) => ({
                display: "flex",
                alignItems: t,
                justifyContent: t,
              }),
              fd: (t) => ({ flexDirection: t }),
              fw: (t) => ({ flexWrap: t }),
              ai: (t) => ({ alignItems: t }),
              ac: (t) => ({ alignContent: t }),
              jc: (t) => ({ justifyContent: t }),
              as: (t) => ({ alignSelf: t }),
              fg: (t) => ({ flexGrow: t }),
              fs: (t) => ({ fontSize: t }),
              fb: (t) => ({ flexBasis: t }),
              bc: (t) => ({ backgroundColor: t }),
              bf: (t) => ({ backdropFilter: t }),
              bg: (t) => ({ background: t }),
              bgBlur: (t) => ({ bf: "saturate(180%) blur(10px)", bg: t }),
              bgColor: (t) => ({ backgroundColor: t }),
              backgroundClip: (t) => ({
                WebkitBackgroundClip: t,
                backgroundClip: t,
              }),
              bgClip: (t) => ({ WebkitBackgroundClip: t, backgroundClip: t }),
              br: (t) => ({ borderRadius: t }),
              bw: (t) => ({ borderWidth: t }),
              btrr: (t) => ({ borderTopRightRadius: t }),
              bbrr: (t) => ({ borderBottomRightRadius: t }),
              bblr: (t) => ({ borderBottomLeftRadius: t }),
              btlr: (t) => ({ borderTopLeftRadius: t }),
              bs: (t) => ({ boxShadow: t }),
              normalShadow: (t) => ({ boxShadow: `0 4px 14px 0 $${t}` }),
              lh: (t) => ({ lineHeight: t }),
              ov: (t) => ({ overflow: t }),
              ox: (t) => ({ overflowX: t }),
              oy: (t) => ({ overflowY: t }),
              pe: (t) => ({ pointerEvents: t }),
              events: (t) => ({ pointerEvents: t }),
              us: (t) => ({ WebkitUserSelect: t, userSelect: t }),
              userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
              w: (t) => ({ width: t }),
              h: (t) => ({ height: t }),
              minW: (t) => ({ minWidth: t }),
              minH: (t) => ({ minWidth: t }),
              mw: (t) => ({ maxWidth: t }),
              maxW: (t) => ({ maxWidth: t }),
              mh: (t) => ({ maxHeight: t }),
              maxH: (t) => ({ maxHeight: t }),
              size: (t) => ({ width: t, height: t }),
              minSize: (t) => ({
                minWidth: t,
                minHeight: t,
                width: t,
                height: t,
              }),
              sizeMin: (t) => ({
                minWidth: t,
                minHeight: t,
                width: t,
                height: t,
              }),
              maxSize: (t) => ({ maxWidth: t, maxHeight: t }),
              sizeMax: (t) => ({ maxWidth: t, maxHeight: t }),
              appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
              scale: (t) => ({ transform: `scale(${t})` }),
              linearGradient: (t) => ({
                backgroundImage: `linear-gradient(${t})`,
              }),
              tdl: (t) => ({ textDecorationLine: t }),
              textGradient: (t) => ({
                backgroundImage: `linear-gradient(${t})`,
                WebkitBackgroundClip: "text",
                WebkitTextFillColor: "transparent",
              }),
            },
            themeMap: {
              ...qt,
              width: "space",
              height: "space",
              minWidth: "space",
              maxWidth: "space",
              minHeight: "space",
              maxHeight: "space",
              flexBasis: "space",
              gridTemplateColumns: "space",
              gridTemplateRows: "space",
              blockSize: "space",
              minBlockSize: "space",
              maxBlockSize: "space",
              inlineSize: "space",
              minInlineSize: "space",
              maxInlineSize: "space",
              borderWidth: "borderWeights",
            },
          }),
          Ke = Ve("dark-theme", {
            colors: Mt,
            shadows: {
              xs: "-4px 0 15px rgb(0 0 0 / 50%)",
              sm: "0 5px 20px -5px rgba(20, 20, 20, 0.1)",
              md: "0 8px 30px rgba(20, 20, 20, 0.15)",
              lg: "0 30px 60px rgba(20, 20, 20, 0.15)",
              xl: "0 40px 80px rgba(20, 20, 20, 0.25)",
            },
          }),
          _e = $e({
            a: { focusRing: "auto" },
            body: {
              [`${Ke.selector} &`]: {
                backgroundColor: "$dark700",
                color: "$dark50",
              },
              backgroundColor: "$white",
              color: "$black",
            },
          }),
          qe = $e({
            html: {
              fontFamily: "sans-serif",
              lineHeight: "1.15",
              textSizeAdjust: "100%",
              margin: 0,
            },
            body: { margin: 0 },
            "article, aside, footer, header, nav, section, figcaption, figure, main":
              { display: "block" },
            h1: { fontSize: "2em", margin: 0 },
            hr: { boxSizing: "content-box", height: 0, overflow: "visible" },
            pre: { fontFamily: "monospace, monospace", fontSize: "1em" },
            a: { background: "transparent", textDecorationSkip: "objects" },
            "a:active, a:hover": { outlineWidth: 0 },
            "abbr[title]": {
              borderBottom: "none",
              textDecoration: "underline",
            },
            "b, strong": { fontWeight: "bolder" },
            "code, kbp, samp": {
              fontFamily: "monospace, monospace",
              fontSize: "1em",
            },
            dfn: { fontStyle: "italic" },
            mark: { backgroundColor: "#ff0", color: "#000" },
            small: { fontSize: "80%" },
            "sub, sup": {
              fontSize: "75%",
              lineHeight: 0,
              position: "relative",
              verticalAlign: "baseline",
            },
            sup: { top: "-0.5em" },
            sub: { bottom: "-0.25em" },
            "audio, video": { display: "inline-block" },
            "audio:not([controls])": { display: "none", height: 0 },
            img: { borderStyle: "none", verticalAlign: "middle" },
            "svg:not(:root)": { overflow: "hidden" },
            "button, input, optgroup, select, textarea": {
              fontFamily: "sans-serif",
              fontSize: "100%",
              lineHeight: "1.15",
              margin: 0,
            },
            "button, input": { overflow: "visible" },
            "button, select": { textTransform: "none" },
            "button, [type=reset], [type=submit]": {
              WebkitAppearance: "button",
            },
            "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner":
              { borderStyle: "none", padding: 0 },
            "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring":
              { outline: "1px dotted ButtonText" },
            legend: {
              boxSizing: "border-box",
              color: "inherit",
              display: "table",
              maxWidth: "100%",
              padding: 0,
              whiteSpace: "normal",
            },
            progress: { display: "inline-block", verticalAlign: "baseline" },
            textarea: { overflow: "auto" },
            "[type=checkbox], [type=radio]": {
              boxSizing: "border-box",
              padding: 0,
            },
            "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button":
              { height: "auto" },
            "[type=search]": { appearance: "textfield", outlineOffset: "-2px" },
            "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration":
              { appearance: "none" },
            "::-webkit-file-upload-button": {
              appearance: "button",
              font: "inherit",
            },
            "details, menu": { display: "block" },
            summary: { display: "list-item" },
            canvas: { display: "inline-block" },
            template: { display: "none" },
            "[hidden]": { display: "none" },
          }),
          Ye = {
            xs: { height: 30, padding: "0px 14px" },
            sm: { height: 36, padding: "0px 18px" },
            md: { height: 42, padding: "0px 22px" },
            lg: { height: 50, padding: "0px 26px" },
            xl: { height: 60, padding: "0px 32px" },
            "compact-xs": { height: 22, padding: "0 7px" },
            "compact-sm": { height: 26, padding: "0 8px" },
            "compact-md": { height: 30, padding: "0 10px" },
            "compact-lg": { height: 34, padding: "0 12px" },
            "compact-xl": { height: 40, padding: "0 14px" },
          };
        var Ze = Jt(
          (
            t,
            {
              color: e,
              compact: n,
              fullSize: r,
              gradient: s,
              radius: i,
              size: o,
              variant: a,
            }
          ) => ({
            root: {
              focusRing: "auto",
              cursor: "pointer",
              position: "relative",
              boxSizing: "border-box",
              textDecoration: "none",
              outline: "none",
              userSelect: "none",
              appearance: "none",
              textAlign: "center",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              background: null,
              borderRadius: "number" == typeof i ? i : `$${i}`,
              height:
                "number" == typeof o
                  ? `${o}px`
                  : Ye[n ? `compact-${o}` : o].height,
              padding:
                "number" == typeof o
                  ? `0px ${o}px`
                  : Ye[n ? `compact-${o}` : o].padding,
              fontFamily: "$standard",
              fontWeight: "$semibold",
              fontSize: `$${o}`,
              lineHeight: 1,
              flexGrow: 0,
              width: r ? "100%" : "fit-content",
              "&:hover": {
                backgroundColor:
                  "gradient" === a ? null : t.fn.themeColor(e, 7),
                backgroundSize: "gradient" === a ? "200%" : null,
              },
              "&:active": { transform: "translateY(1px)" },
              "&:disabled": {
                pointerEvents: "none",
                borderColor: "transparent",
                background: t.fn.themeColor("gray", 2),
                backgroundColor: t.fn.themeColor("gray", 2),
                color: t.fn.themeColor("gray", 5),
                cursor: "not-allowed",
                darkMode: {
                  borderColor: "transparent",
                  backgroundColor: t.fn.themeColor("dark", 4),
                  color: t.fn.themeColor("dark", 6),
                },
              },
            },
            disabled: {
              pointerEvents: "none",
              borderColor: "transparent",
              background: t.fn.themeColor("gray", 2),
              backgroundColor: t.fn.themeColor("gray", 2),
              color: t.fn.themeColor("gray", 5),
              cursor: "not-allowed",
              darkMode: {
                backgroundColor: t.fn.themeColor("dark", 4),
                color: t.fn.themeColor("dark", 6),
              },
            },
            loading: {
              pointerEvents: "none",
              "&::before": {
                content: '""',
                position: "absolute",
                inset: -1,
                backgroundColor: "rgba(255, 255, 255, .5)",
                borderRadius: `$${i}`,
                cursor: "not-allowed",
              },
            },
            variants: {
              variation: Bt(e, s),
              disabled: {
                true: {
                  pointerEvents: "none",
                  borderColor: "transparent",
                  background: t.fn.themeColor("gray", 2),
                  backgroundColor: t.fn.themeColor("gray", 2),
                  color: t.fn.themeColor("gray", 5),
                  cursor: "not-allowed",
                  [`${Ke.selector} &`]: {
                    borderColor: "transparent",
                    backgroundColor: t.fn.themeColor("dark", 4),
                    color: t.fn.themeColor("dark", 6),
                  },
                },
              },
            },
          })
        );
        const Xe = Object.freeze([
          {
            error: !0,
            message:
              "If using the disabled prop, a loading cannot be set at the same time",
            solution:
              "\n                If your component looks like this:\n                \n                &lt;Button disabled loading ...&gt; Button Text &lt;/Button&gt;\n                         ^^^^^^^^ ^^^^^^^ - Try removing one of these\n                ",
          },
          {
            error: !0,
            message:
              "If using the external prop, a href prop must be associated with it. If you have an href prop there must be content inside.",
            solution:
              "\n                If your component looks like this:\n                \n                &lt;Button external ...&gt; Button Text &lt;/Button&gt;\n                         ^^^^^^^^ - Try adding the href prop too\n                ",
          },
        ]);
        function tn(e) {
          let n, r, s, o, a, c, l, u, h, d, f;
          return {
            c() {
              (n = v("svg")),
                (r = v("g")),
                (s = v("g")),
                (o = v("circle")),
                (a = v("path")),
                (c = v("animateTransform")),
                P(o, "stroke-opacity", ".5"),
                P(o, "cx", "16"),
                P(o, "cy", "16"),
                P(o, "r", "16"),
                P(c, "attributeName", "transform"),
                P(c, "type", "rotate"),
                P(c, "from", "0 16 16"),
                P(c, "to", "360 16 16"),
                P(c, "dur", "1s"),
                P(c, "repeatCount", "indefinite"),
                P(a, "d", "M32 16c0-9.94-8.06-16-16-16"),
                P(s, "transform", "translate(2.5 2.5)"),
                P(s, "stroke-width", "5"),
                P(r, "fill", "none"),
                P(r, "fill-rule", "evenodd"),
                P(n, "width", (l = `${e[1]}px`)),
                P(n, "height", (u = `${e[1]}px`)),
                P(n, "viewBox", "0 0 38 38"),
                P(n, "xmlns", "http://www.w3.org/2000/svg"),
                P(n, "stroke", e[2]),
                P(n, "class", e[3]);
            },
            m(t, i) {
              b(t, n, i),
                m(n, r),
                m(r, s),
                m(s, o),
                m(s, a),
                m(a, c),
                d || ((f = g((h = mt.call(null, n, e[0])))), (d = !0));
            },
            p(t, [e]) {
              2 & e && l !== (l = `${t[1]}px`) && P(n, "width", l),
                2 & e && u !== (u = `${t[1]}px`) && P(n, "height", u),
                4 & e && P(n, "stroke", t[2]),
                8 & e && P(n, "class", t[3]),
                h && i(h.update) && 1 & e && h.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && w(n), (d = !1), f();
            },
          };
        }
        function en(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var nn = class extends at {
          constructor(t) {
            super(),
              ot(this, t, en, tn, o, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        function rn(e) {
          let n, r, s, o, a, c, l, u, h, d, f, p, y, A, x, E, k, C, S, I;
          return {
            c() {
              (n = v("svg")),
                (r = v("rect")),
                (s = v("animate")),
                (o = v("animate")),
                (a = v("rect")),
                (c = v("animate")),
                (l = v("animate")),
                (u = v("rect")),
                (h = v("animate")),
                (d = v("animate")),
                (f = v("rect")),
                (p = v("animate")),
                (y = v("animate")),
                (A = v("rect")),
                (x = v("animate")),
                (E = v("animate")),
                P(s, "attributeName", "height"),
                P(s, "begin", "0.5s"),
                P(s, "dur", "1s"),
                P(s, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                P(s, "calcMode", "linear"),
                P(s, "repeatCount", "indefinite"),
                P(o, "attributeName", "y"),
                P(o, "begin", "0.5s"),
                P(o, "dur", "1s"),
                P(o, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                P(o, "calcMode", "linear"),
                P(o, "repeatCount", "indefinite"),
                P(r, "y", "10"),
                P(r, "width", "15"),
                P(r, "height", "120"),
                P(r, "rx", "6"),
                P(c, "attributeName", "height"),
                P(c, "begin", "0.25s"),
                P(c, "dur", "1s"),
                P(c, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                P(c, "calcMode", "linear"),
                P(c, "repeatCount", "indefinite"),
                P(l, "attributeName", "y"),
                P(l, "begin", "0.25s"),
                P(l, "dur", "1s"),
                P(l, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                P(l, "calcMode", "linear"),
                P(l, "repeatCount", "indefinite"),
                P(a, "x", "30"),
                P(a, "y", "10"),
                P(a, "width", "15"),
                P(a, "height", "120"),
                P(a, "rx", "6"),
                P(h, "attributeName", "height"),
                P(h, "begin", "0s"),
                P(h, "dur", "1s"),
                P(h, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                P(h, "calcMode", "linear"),
                P(h, "repeatCount", "indefinite"),
                P(d, "attributeName", "y"),
                P(d, "begin", "0s"),
                P(d, "dur", "1s"),
                P(d, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                P(d, "calcMode", "linear"),
                P(d, "repeatCount", "indefinite"),
                P(u, "x", "60"),
                P(u, "width", "15"),
                P(u, "height", "140"),
                P(u, "rx", "6"),
                P(p, "attributeName", "height"),
                P(p, "begin", "0.25s"),
                P(p, "dur", "1s"),
                P(p, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                P(p, "calcMode", "linear"),
                P(p, "repeatCount", "indefinite"),
                P(y, "attributeName", "y"),
                P(y, "begin", "0.25s"),
                P(y, "dur", "1s"),
                P(y, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                P(y, "calcMode", "linear"),
                P(y, "repeatCount", "indefinite"),
                P(f, "x", "90"),
                P(f, "y", "10"),
                P(f, "width", "15"),
                P(f, "height", "120"),
                P(f, "rx", "6"),
                P(x, "attributeName", "height"),
                P(x, "begin", "0.5s"),
                P(x, "dur", "1s"),
                P(x, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                P(x, "calcMode", "linear"),
                P(x, "repeatCount", "indefinite"),
                P(E, "attributeName", "y"),
                P(E, "begin", "0.5s"),
                P(E, "dur", "1s"),
                P(E, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                P(E, "calcMode", "linear"),
                P(E, "repeatCount", "indefinite"),
                P(A, "x", "120"),
                P(A, "y", "10"),
                P(A, "width", "15"),
                P(A, "height", "120"),
                P(A, "rx", "6"),
                P(n, "viewBox", "0 0 135 140"),
                P(n, "xmlns", "http://www.w3.org/2000/svg"),
                P(n, "fill", e[2]),
                P(n, "width", (k = `${e[1]}px`)),
                P(n, "class", e[3]);
            },
            m(t, i) {
              b(t, n, i),
                m(n, r),
                m(r, s),
                m(r, o),
                m(n, a),
                m(a, c),
                m(a, l),
                m(n, u),
                m(u, h),
                m(u, d),
                m(n, f),
                m(f, p),
                m(f, y),
                m(n, A),
                m(A, x),
                m(A, E),
                S || ((I = g((C = mt.call(null, n, e[0])))), (S = !0));
            },
            p(t, [e]) {
              4 & e && P(n, "fill", t[2]),
                2 & e && k !== (k = `${t[1]}px`) && P(n, "width", k),
                8 & e && P(n, "class", t[3]),
                C && i(C.update) && 1 & e && C.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && w(n), (S = !1), I();
            },
          };
        }
        function sn(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var on = class extends at {
          constructor(t) {
            super(),
              ot(this, t, sn, rn, o, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        function an(e) {
          let n, r, s, o, a, c, l, u, h, d, f, p, y, A, x;
          return {
            c() {
              (n = v("svg")),
                (r = v("circle")),
                (s = v("animate")),
                (o = v("animate")),
                (a = v("circle")),
                (c = v("animate")),
                (l = v("animate")),
                (u = v("circle")),
                (h = v("animate")),
                (d = v("animate")),
                P(s, "attributeName", "r"),
                P(s, "from", "15"),
                P(s, "to", "15"),
                P(s, "begin", "0s"),
                P(s, "dur", "0.8s"),
                P(s, "values", "15;9;15"),
                P(s, "calcMode", "linear"),
                P(s, "repeatCount", "indefinite"),
                P(o, "attributeName", "fill-opacity"),
                P(o, "from", "1"),
                P(o, "to", "1"),
                P(o, "begin", "0s"),
                P(o, "dur", "0.8s"),
                P(o, "values", "1;.5;1"),
                P(o, "calcMode", "linear"),
                P(o, "repeatCount", "indefinite"),
                P(r, "cx", "15"),
                P(r, "cy", "15"),
                P(r, "r", "15"),
                P(c, "attributeName", "r"),
                P(c, "from", "9"),
                P(c, "to", "9"),
                P(c, "begin", "0s"),
                P(c, "dur", "0.8s"),
                P(c, "values", "9;15;9"),
                P(c, "calcMode", "linear"),
                P(c, "repeatCount", "indefinite"),
                P(l, "attributeName", "fill-opacity"),
                P(l, "from", "0.5"),
                P(l, "to", "0.5"),
                P(l, "begin", "0s"),
                P(l, "dur", "0.8s"),
                P(l, "values", ".5;1;.5"),
                P(l, "calcMode", "linear"),
                P(l, "repeatCount", "indefinite"),
                P(a, "cx", "60"),
                P(a, "cy", "15"),
                P(a, "r", "9"),
                P(a, "fill-opacity", "0.3"),
                P(h, "attributeName", "r"),
                P(h, "from", "15"),
                P(h, "to", "15"),
                P(h, "begin", "0s"),
                P(h, "dur", "0.8s"),
                P(h, "values", "15;9;15"),
                P(h, "calcMode", "linear"),
                P(h, "repeatCount", "indefinite"),
                P(d, "attributeName", "fill-opacity"),
                P(d, "from", "1"),
                P(d, "to", "1"),
                P(d, "begin", "0s"),
                P(d, "dur", "0.8s"),
                P(d, "values", "1;.5;1"),
                P(d, "calcMode", "linear"),
                P(d, "repeatCount", "indefinite"),
                P(u, "cx", "105"),
                P(u, "cy", "15"),
                P(u, "r", "15"),
                P(n, "width", (f = `${e[1]}px`)),
                P(n, "height", (p = Number(e[1]) / 4 + "px")),
                P(n, "viewBox", "0 0 120 30"),
                P(n, "xmlns", "http://www.w3.org/2000/svg"),
                P(n, "fill", e[2]),
                P(n, "class", e[3]);
            },
            m(t, i) {
              b(t, n, i),
                m(n, r),
                m(r, s),
                m(r, o),
                m(n, a),
                m(a, c),
                m(a, l),
                m(n, u),
                m(u, h),
                m(u, d),
                A || ((x = g((y = mt.call(null, n, e[0])))), (A = !0));
            },
            p(t, [e]) {
              2 & e && f !== (f = `${t[1]}px`) && P(n, "width", f),
                2 & e &&
                  p !== (p = Number(t[1]) / 4 + "px") &&
                  P(n, "height", p),
                4 & e && P(n, "fill", t[2]),
                8 & e && P(n, "class", t[3]),
                y && i(y.update) && 1 & e && y.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && w(n), (A = !1), x();
            },
          };
        }
        function cn(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var ln = class extends at {
          constructor(t) {
            super(),
              ot(this, t, cn, an, o, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        const un = { xs: 18, sm: 22, md: 36, lg: 44, xl: 58 },
          hn = (t, e = !1) => Qe.colors[e ? `${t}400` : `${t}600`].value;
        function dn(t) {
          let n, r, s;
          const i = [
            { use: [t[5], [mt, t[1]]] },
            { color: "white" === t[4] ? "white" : hn(t[4]) },
            { size: un[t[3]] },
            { class: t[2] },
            t[8],
          ];
          var o = t[6][t[7]];
          function a(t) {
            let n = {};
            for (let t = 0; t < i.length; t += 1) n = e(n, i[t]);
            return { props: n };
          }
          return (
            o && ((n = R(o, a())), t[10](n)),
            {
              c() {
                n && rt(n.$$.fragment), (r = k());
              },
              m(t, e) {
                n && st(n, t, e), b(t, r, e), (s = !0);
              },
              p(t, [e]) {
                const s =
                  318 & e
                    ? nt(i, [
                        34 & e && { use: [t[5], [mt, t[1]]] },
                        16 & e && {
                          color: "white" === t[4] ? "white" : hn(t[4]),
                        },
                        8 & e && { size: un[t[3]] },
                        4 & e && { class: t[2] },
                        256 & e &&
                          ((c = t[8]),
                          "object" == typeof c && null !== c ? c : {}),
                      ])
                    : {};
                var c;
                if (o !== (o = t[6][t[7]])) {
                  if (n) {
                    Z();
                    const t = n;
                    et(t.$$.fragment, 1, 0, () => {
                      it(t, 1);
                    }),
                      X();
                  }
                  o
                    ? ((n = R(o, a())),
                      t[10](n),
                      rt(n.$$.fragment),
                      tt(n.$$.fragment, 1),
                      st(n, r.parentNode, r))
                    : (n = null);
                } else o && n.$set(s);
              },
              i(t) {
                s || (n && tt(n.$$.fragment, t), (s = !0));
              },
              o(t) {
                n && et(n.$$.fragment, t), (s = !1);
              },
              d(e) {
                t[10](null), e && w(r), n && it(n, e);
              },
            }
          );
        }
        function fn(t, n, r) {
          const s = ["use", "element", "class", "size", "color", "variant"];
          let i = p(n, s),
            {
              use: o = [],
              element: a,
              class: c = "",
              size: l = "md",
              color: u = "blue",
              variant: h = "circle",
            } = n;
          const d = wt(F()),
            g = { bars: on, circle: nn, dots: ln },
            m = h in g ? h : "circle";
          return (
            (t.$$set = (t) => {
              (n = e(e({}, n), f(t))),
                r(8, (i = p(n, s))),
                "use" in t && r(1, (o = t.use)),
                "element" in t && r(0, (a = t.element)),
                "class" in t && r(2, (c = t.class)),
                "size" in t && r(3, (l = t.size)),
                "color" in t && r(4, (u = t.color)),
                "variant" in t && r(9, (h = t.variant));
            }),
            [
              a,
              o,
              c,
              l,
              u,
              d,
              g,
              m,
              i,
              h,
              function (t) {
                z[t ? "unshift" : "push"](() => {
                  (a = t), r(0, a);
                });
              },
            ]
          );
        }
        var pn = class extends at {
          constructor(t) {
            super(),
              ot(this, t, fn, dn, o, {
                use: 1,
                element: 0,
                class: 2,
                size: 3,
                color: 4,
                variant: 9,
              });
          }
        };
        function gn(t) {
          y(
            t,
            "svelte-3pkhve",
            ".ripple.svelte-3pkhve{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-3pkhve .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-3pkhve .animation-enter{transition:none}.ripple.svelte-3pkhve .animation-in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-3pkhve .animation-out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}"
          );
        }
        function mn(e) {
          let n;
          return {
            c() {
              (n = A("div")), P(n, "class", "ripple svelte-3pkhve");
            },
            m(t, r) {
              b(t, n, r), e[4](n);
            },
            p: t,
            i: t,
            o: t,
            d(t) {
              t && w(n), e[4](null);
            },
          };
        }
        function yn(t, e) {
          (t.style.transform = e), (t.style.webkitTransform = e);
        }
        function bn(t, e) {
          t.style.opacity = e.toString();
        }
        const wn = function (t, e) {
            const n = ["touchcancel", "mouseleave", "dragstart"];
            let r = e.currentTarget || e.target;
            if (
              (r &&
                !r.classList.contains("ripple") &&
                (r = r.querySelector(".ripple")),
              !r)
            )
              return;
            const s = r.dataset.event;
            if (s && s !== t) return;
            r.dataset.event = t;
            const i = document.createElement("span"),
              {
                radius: o,
                scale: a,
                x: c,
                y: l,
                centerX: u,
                centerY: h,
              } = ((t, e) => {
                const n = e.getBoundingClientRect(),
                  r = (function (t) {
                    return "TouchEvent" === t.constructor.name;
                  })(t)
                    ? t.touches[t.touches.length - 1]
                    : t,
                  s = r.clientX - n.left,
                  i = r.clientY - n.top;
                let o = 0,
                  a = 0.3;
                const c = e.dataset.center;
                e.dataset.circle
                  ? ((a = 0.15),
                    (o = e.clientWidth / 2),
                    (o = c
                      ? o
                      : o + Math.sqrt((s - o) ** 2 + (i - o) ** 2) / 4))
                  : (o =
                      Math.sqrt(e.clientWidth ** 2 + e.clientHeight ** 2) / 2);
                const l = (e.clientWidth - 2 * o) / 2 + "px",
                  u = (e.clientHeight - 2 * o) / 2 + "px";
                return {
                  radius: o,
                  scale: a,
                  x: c ? l : s - o + "px",
                  y: c ? u : i - o + "px",
                  centerX: l,
                  centerY: u,
                };
              })(e, r),
              d = r.dataset.color,
              f = 2 * o + "px";
            (i.className = "animation"),
              (i.style.width = f),
              (i.style.height = f),
              (i.style.background = d),
              i.classList.add("animation-enter"),
              i.classList.add("animation--visible"),
              yn(i, `translate(${c}, ${l}) scale3d(${a},${a},${a})`),
              bn(i, 0),
              (i.dataset.activated = String(performance.now())),
              r.appendChild(i),
              setTimeout(() => {
                i.classList.remove("animation-enter"),
                  i.classList.add("animation-in"),
                  yn(i, `translate(${u}, ${h}) scale3d(1,1,1)`),
                  bn(i, 0.25);
              }, 0);
            const p = "mousedown" === t ? "mouseup" : "touchend",
              g = function () {
                document.removeEventListener(p, g),
                  n.forEach((t) => {
                    document.removeEventListener(t, g);
                  });
                const t = performance.now() - Number(i.dataset.activated),
                  e = Math.max(250 - t, 0);
                setTimeout(() => {
                  i.classList.remove("animation-in"),
                    i.classList.add("animation-out"),
                    bn(i, 0),
                    setTimeout(() => {
                      i && r.removeChild(i),
                        0 === r.children.length && delete r.dataset.event;
                    }, 300);
                }, e);
              };
            document.addEventListener(p, g),
              n.forEach((t) => {
                document.addEventListener(t, g, { passive: !0 });
              });
          },
          An = function (t) {
            0 === t.button && wn(t.type, t);
          },
          vn = function (t) {
            if (t.changedTouches)
              for (let e = 0; e < t.changedTouches.length; ++e)
                wn(t.type, t.changedTouches[e]);
          };
        function xn(t, e, n) {
          let r,
            s,
            { center: i = !1 } = e,
            { circle: o = !1 } = e,
            { color: a = "currentColor" } = e;
          var c;
          return (
            D(async () => {
              await (Q(), G);
              try {
                i && n(0, (r.dataset.center = "true"), r),
                  o && n(0, (r.dataset.circle = "true"), r),
                  n(0, (r.dataset.color = a), r),
                  (s = r.parentElement);
              } catch (t) {}
              if (!s)
                return void console.error("Ripple: Trigger element not found.");
              let t = window.getComputedStyle(s);
              (0 !== t.position.length && "static" !== t.position) ||
                (s.style.position = "relative"),
                s.addEventListener("touchstart", vn, { passive: !0 }),
                s.addEventListener("mousedown", An, { passive: !0 });
            }),
            (c = () => {
              s &&
                (s.removeEventListener("mousedown", An),
                s.removeEventListener("touchstart", vn));
            }),
            F().$$.on_destroy.push(c),
            (t.$$set = (t) => {
              "center" in t && n(1, (i = t.center)),
                "circle" in t && n(2, (o = t.circle)),
                "color" in t && n(3, (a = t.color));
            }),
            [
              r,
              i,
              o,
              a,
              function (t) {
                z[t ? "unshift" : "push"](() => {
                  (r = t), n(0, r);
                });
              },
            ]
          );
        }
        var En = class extends at {
          constructor(t) {
            super(),
              ot(this, t, xn, mn, o, { center: 1, circle: 2, color: 3 }, gn);
          }
        };
        function kn(t) {
          y(
            t,
            "svelte-5xpm5q",
            ".uppercase.svelte-5xpm5q{text-transform:uppercase}.left-section.svelte-5xpm5q{margin-right:10px;display:flex;align-items:center;justify-content:center}.right-section.svelte-5xpm5q{margin-left:10px;display:flex;align-items:center;justify-content:center}"
          );
        }
        const Cn = (t) => ({}),
          Pn = (t) => ({}),
          Sn = (t) => ({}),
          In = (t) => ({}),
          Nn = (t) => ({}),
          Bn = (t) => ({}),
          Tn = (t) => ({}),
          On = (t) => ({});
        function Rn(t) {
          let n, r, o, a, l, f, p, y, v, k, C, P, S;
          const N = [Fn, Un],
            B = [];
          function O(t, e) {
            return t[11] && "left" === t[5] ? 0 : t[21].leftIcon ? 1 : -1;
          }
          ~(r = O(t)) && (o = B[r] = N[r](t));
          const R = t[28].default,
            L = c(R, t, t[27], null),
            U =
              L ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = x("Button");
                  },
                  m(t, n) {
                    b(t, e, n);
                  },
                  d(t) {
                    t && w(e);
                  },
                };
              })();
          let F = t[13] && Dn();
          const D = [zn, Mn],
            M = [];
          function z(t, e) {
            return t[11] && "right" === t[5] ? 0 : t[21].rightIcon ? 1 : -1;
          }
          ~(p = z(t)) && (y = M[p] = D[p](t));
          let j = [
              {
                class: (v = t[18](
                  t[3],
                  t[17].root,
                  t[16]({ css: t[1], variation: t[4] }),
                  { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                )),
              },
              { disabled: t[9] },
              t[20],
              { tabindex: "0" },
            ],
            $ = {};
          for (let t = 0; t < j.length; t += 1) $ = e($, j[t]);
          return {
            c() {
              (n = A("button")),
                o && o.c(),
                (a = E()),
                U && U.c(),
                (l = E()),
                F && F.c(),
                (f = E()),
                y && y.c(),
                I(n, $),
                T(n, "compact", t[10]),
                T(n, "uppercase", t[12]),
                T(n, "svelte-5xpm5q", !0);
            },
            m(e, s) {
              b(e, n, s),
                ~r && B[r].m(n, null),
                m(n, a),
                U && U.m(n, null),
                m(n, l),
                F && F.m(n, null),
                m(n, f),
                ~p && M[p].m(n, null),
                n.autofocus && n.focus(),
                t[30](n),
                (C = !0),
                P ||
                  ((S = [
                    g((k = mt.call(null, n, t[2]))),
                    g(t[19].call(null, n)),
                  ]),
                  (P = !0));
            },
            p(t, e) {
              let s = r;
              (r = O(t)),
                r === s
                  ? ~r && B[r].p(t, e)
                  : (o &&
                      (Z(),
                      et(B[s], 1, 1, () => {
                        B[s] = null;
                      }),
                      X()),
                    ~r
                      ? ((o = B[r]),
                        o ? o.p(t, e) : ((o = B[r] = N[r](t)), o.c()),
                        tt(o, 1),
                        o.m(n, a))
                      : (o = null)),
                L &&
                  L.p &&
                  (!C || 134217728 & e) &&
                  h(L, R, t, t[27], C ? u(R, t[27], e, null) : d(t[27]), null),
                t[13]
                  ? F
                    ? 8192 & e && tt(F, 1)
                    : ((F = Dn()), F.c(), tt(F, 1), F.m(n, f))
                  : F &&
                    (Z(),
                    et(F, 1, 1, () => {
                      F = null;
                    }),
                    X());
              let c = p;
              (p = z(t)),
                p === c
                  ? ~p && M[p].p(t, e)
                  : (y &&
                      (Z(),
                      et(M[c], 1, 1, () => {
                        M[c] = null;
                      }),
                      X()),
                    ~p
                      ? ((y = M[p]),
                        y ? y.p(t, e) : ((y = M[p] = D[p](t)), y.c()),
                        tt(y, 1),
                        y.m(n, null))
                      : (y = null)),
                I(
                  n,
                  ($ = nt(j, [
                    (!C ||
                      (461338 & e &&
                        v !==
                          (v = t[18](
                            t[3],
                            t[17].root,
                            t[16]({ css: t[1], variation: t[4] }),
                            { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                          )))) && { class: v },
                    (!C || 512 & e) && { disabled: t[9] },
                    1048576 & e && t[20],
                    { tabindex: "0" },
                  ]))
                ),
                k && i(k.update) && 4 & e && k.update.call(null, t[2]),
                T(n, "compact", t[10]),
                T(n, "uppercase", t[12]),
                T(n, "svelte-5xpm5q", !0);
            },
            i(t) {
              C || (tt(o), tt(U, t), tt(F), tt(y), (C = !0));
            },
            o(t) {
              et(o), et(U, t), et(F), et(y), (C = !1);
            },
            d(e) {
              e && w(n),
                ~r && B[r].d(),
                U && U.d(e),
                F && F.d(),
                ~p && M[p].d(),
                t[30](null),
                (P = !1),
                s(S);
            },
          };
        }
        function Ln(t) {
          let n, r, o, a, l, f, p, y, v, k, C, P, S, N;
          const B = [$n, jn],
            O = [];
          function R(t, e) {
            return t[11] && "left" === t[5] ? 0 : t[21].leftIcon ? 1 : -1;
          }
          ~(r = R(t)) && (o = O[r] = B[r](t));
          const L = t[28].default,
            U = c(L, t, t[27], null),
            F =
              U ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = x("Button");
                  },
                  m(t, n) {
                    b(t, e, n);
                  },
                  d(t) {
                    t && w(e);
                  },
                };
              })();
          let D = t[13] && Gn();
          const M = [Qn, Hn],
            z = [];
          function j(t, e) {
            return t[11] && "right" === t[5] ? 0 : t[21].rightIcon ? 1 : -1;
          }
          ~(p = j(t)) && (y = z[p] = M[p](t));
          let $ = [
              { href: t[7] },
              {
                class: (v = t[18](
                  t[3],
                  t[17].root,
                  t[16]({ css: t[1], variation: t[4], disabled: t[9] }),
                  { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                )),
              },
              { role: "button" },
              { rel: "noreferrer noopener" },
              { target: (k = t[8] ? "_blank" : "_self") },
              t[20],
              { tabindex: "0" },
            ],
            G = {};
          for (let t = 0; t < $.length; t += 1) G = e(G, $[t]);
          return {
            c() {
              (n = A("a")),
                o && o.c(),
                (a = E()),
                F && F.c(),
                (l = E()),
                D && D.c(),
                (f = E()),
                y && y.c(),
                I(n, G),
                T(n, "compact", t[10]),
                T(n, "uppercase", t[12]),
                T(n, "svelte-5xpm5q", !0);
            },
            m(e, s) {
              b(e, n, s),
                ~r && O[r].m(n, null),
                m(n, a),
                F && F.m(n, null),
                m(n, l),
                D && D.m(n, null),
                m(n, f),
                ~p && z[p].m(n, null),
                t[29](n),
                (P = !0),
                S ||
                  ((N = [
                    g((C = mt.call(null, n, t[2]))),
                    g(t[19].call(null, n)),
                  ]),
                  (S = !0));
            },
            p(t, e) {
              let s = r;
              (r = R(t)),
                r === s
                  ? ~r && O[r].p(t, e)
                  : (o &&
                      (Z(),
                      et(O[s], 1, 1, () => {
                        O[s] = null;
                      }),
                      X()),
                    ~r
                      ? ((o = O[r]),
                        o ? o.p(t, e) : ((o = O[r] = B[r](t)), o.c()),
                        tt(o, 1),
                        o.m(n, a))
                      : (o = null)),
                U &&
                  U.p &&
                  (!P || 134217728 & e) &&
                  h(U, L, t, t[27], P ? u(L, t[27], e, null) : d(t[27]), null),
                t[13]
                  ? D
                    ? 8192 & e && tt(D, 1)
                    : ((D = Gn()), D.c(), tt(D, 1), D.m(n, f))
                  : D &&
                    (Z(),
                    et(D, 1, 1, () => {
                      D = null;
                    }),
                    X());
              let c = p;
              (p = j(t)),
                p === c
                  ? ~p && z[p].p(t, e)
                  : (y &&
                      (Z(),
                      et(z[c], 1, 1, () => {
                        z[c] = null;
                      }),
                      X()),
                    ~p
                      ? ((y = z[p]),
                        y ? y.p(t, e) : ((y = z[p] = M[p](t)), y.c()),
                        tt(y, 1),
                        y.m(n, null))
                      : (y = null)),
                I(
                  n,
                  (G = nt($, [
                    (!P || 128 & e) && { href: t[7] },
                    (!P ||
                      (461338 & e &&
                        v !==
                          (v = t[18](
                            t[3],
                            t[17].root,
                            t[16]({
                              css: t[1],
                              variation: t[4],
                              disabled: t[9],
                            }),
                            { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                          )))) && { class: v },
                    { role: "button" },
                    { rel: "noreferrer noopener" },
                    (!P ||
                      (256 & e && k !== (k = t[8] ? "_blank" : "_self"))) && {
                      target: k,
                    },
                    1048576 & e && t[20],
                    { tabindex: "0" },
                  ]))
                ),
                C && i(C.update) && 4 & e && C.update.call(null, t[2]),
                T(n, "compact", t[10]),
                T(n, "uppercase", t[12]),
                T(n, "svelte-5xpm5q", !0);
            },
            i(t) {
              P || (tt(o), tt(F, t), tt(D), tt(y), (P = !0));
            },
            o(t) {
              et(o), et(F, t), et(D), et(y), (P = !1);
            },
            d(e) {
              e && w(n),
                ~r && O[r].d(),
                F && F.d(e),
                D && D.d(),
                ~p && z[p].d(),
                t[29](null),
                (S = !1),
                s(N);
            },
          };
        }
        function Un(t) {
          let e, n;
          const r = t[28].leftIcon,
            s = c(r, t, t[27], In),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = x("X");
                  },
                  m(t, n) {
                    b(t, e, n);
                  },
                  d(t) {
                    t && w(e);
                  },
                };
              })();
          return {
            c() {
              (e = A("span")),
                i && i.c(),
                P(e, "class", "left-section svelte-5xpm5q");
            },
            m(t, r) {
              b(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? u(r, t[27], e, Sn) : d(t[27]), In);
            },
            i(t) {
              n || (tt(i, t), (n = !0));
            },
            o(t) {
              et(i, t), (n = !1);
            },
            d(t) {
              t && w(e), i && i.d(t);
            },
          };
        }
        function Fn(t) {
          let e, n, r;
          return (
            (n = new pn({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = A("span")),
                  rt(n.$$.fragment),
                  P(e, "class", "left-section svelte-5xpm5q");
              },
              m(t, s) {
                b(t, e, s), st(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (tt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && w(e), it(n);
              },
            }
          );
        }
        function Dn(t) {
          let e, n;
          return (
            (e = new En({ props: { center: !1, circle: !1 } })),
            {
              c() {
                rt(e.$$.fragment);
              },
              m(t, r) {
                st(e, t, r), (n = !0);
              },
              i(t) {
                n || (tt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                it(e, t);
              },
            }
          );
        }
        function Mn(t) {
          let e, n;
          const r = t[28].rightIcon,
            s = c(r, t, t[27], Pn),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = x("X");
                  },
                  m(t, n) {
                    b(t, e, n);
                  },
                  d(t) {
                    t && w(e);
                  },
                };
              })();
          return {
            c() {
              (e = A("span")),
                i && i.c(),
                P(e, "class", "right-section svelte-5xpm5q");
            },
            m(t, r) {
              b(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? u(r, t[27], e, Cn) : d(t[27]), Pn);
            },
            i(t) {
              n || (tt(i, t), (n = !0));
            },
            o(t) {
              et(i, t), (n = !1);
            },
            d(t) {
              t && w(e), i && i.d(t);
            },
          };
        }
        function zn(t) {
          let e, n, r;
          return (
            (n = new pn({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = A("span")),
                  rt(n.$$.fragment),
                  P(e, "class", "right-section svelte-5xpm5q");
              },
              m(t, s) {
                b(t, e, s), st(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (tt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && w(e), it(n);
              },
            }
          );
        }
        function jn(t) {
          let e, n;
          const r = t[28].leftIcon,
            s = c(r, t, t[27], On),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = x("X");
                  },
                  m(t, n) {
                    b(t, e, n);
                  },
                  d(t) {
                    t && w(e);
                  },
                };
              })();
          return {
            c() {
              (e = A("span")),
                i && i.c(),
                P(e, "class", "left-section svelte-5xpm5q");
            },
            m(t, r) {
              b(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? u(r, t[27], e, Tn) : d(t[27]), On);
            },
            i(t) {
              n || (tt(i, t), (n = !0));
            },
            o(t) {
              et(i, t), (n = !1);
            },
            d(t) {
              t && w(e), i && i.d(t);
            },
          };
        }
        function $n(t) {
          let e, n, r;
          return (
            (n = new pn({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = A("span")),
                  rt(n.$$.fragment),
                  P(e, "class", "left-section svelte-5xpm5q");
              },
              m(t, s) {
                b(t, e, s), st(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (tt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && w(e), it(n);
              },
            }
          );
        }
        function Gn(t) {
          let e, n;
          return (
            (e = new En({ props: { center: !1, circle: !1 } })),
            {
              c() {
                rt(e.$$.fragment);
              },
              m(t, r) {
                st(e, t, r), (n = !0);
              },
              i(t) {
                n || (tt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                it(e, t);
              },
            }
          );
        }
        function Hn(t) {
          let e, n;
          const r = t[28].rightIcon,
            s = c(r, t, t[27], Bn),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = x("X");
                  },
                  m(t, n) {
                    b(t, e, n);
                  },
                  d(t) {
                    t && w(e);
                  },
                };
              })();
          return {
            c() {
              (e = A("span")),
                i && i.c(),
                P(e, "class", "right-section svelte-5xpm5q");
            },
            m(t, r) {
              b(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? u(r, t[27], e, Nn) : d(t[27]), Bn);
            },
            i(t) {
              n || (tt(i, t), (n = !0));
            },
            o(t) {
              et(i, t), (n = !1);
            },
            d(t) {
              t && w(e), i && i.d(t);
            },
          };
        }
        function Qn(t) {
          let e, n, r;
          return (
            (n = new pn({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = A("span")),
                  rt(n.$$.fragment),
                  P(e, "class", "right-section svelte-5xpm5q");
              },
              m(t, s) {
                b(t, e, s), st(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (tt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && w(e), it(n);
              },
            }
          );
        }
        function Vn(t) {
          let e, n, r, s, i, o;
          e = new ht({
            props: { observable: t[14], component: "Button", code: t[15] },
          });
          const a = [Ln, Rn],
            c = [];
          function l(t, e) {
            return t[7] ? 0 : 1;
          }
          return (
            (r = l(t)),
            (s = c[r] = a[r](t)),
            {
              c() {
                rt(e.$$.fragment), (n = E()), s.c(), (i = k());
              },
              m(t, s) {
                st(e, t, s), b(t, n, s), c[r].m(t, s), b(t, i, s), (o = !0);
              },
              p(t, [n]) {
                const o = {};
                16384 & n && (o.observable = t[14]),
                  32768 & n && (o.code = t[15]),
                  e.$set(o);
                let u = r;
                (r = l(t)),
                  r === u
                    ? c[r].p(t, n)
                    : (Z(),
                      et(c[u], 1, 1, () => {
                        c[u] = null;
                      }),
                      X(),
                      (s = c[r]),
                      s ? s.p(t, n) : ((s = c[r] = a[r](t)), s.c()),
                      tt(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (tt(e.$$.fragment, t), tt(s), (o = !0));
              },
              o(t) {
                et(e.$$.fragment, t), et(s), (o = !1);
              },
              d(t) {
                it(e, t), t && w(n), c[r].d(t), t && w(i);
              },
            }
          );
        }
        function Jn(t, n, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "variant",
            "color",
            "size",
            "radius",
            "gradient",
            "loaderPosition",
            "loaderProps",
            "href",
            "external",
            "disabled",
            "compact",
            "loading",
            "uppercase",
            "fullSize",
            "ripple",
          ];
          let c = p(n, a),
            { $$slots: l = {}, $$scope: u } = n;
          const h = (function (t) {
            const e = {};
            for (const n in t) e[n] = !0;
            return e;
          })(l);
          let {
            use: d = [],
            element: g,
            class: m = "",
            override: y = {},
            variant: b = "filled",
            color: w = "blue",
            size: A = "sm",
            radius: v = "sm",
            gradient: x = { from: "indigo", to: "cyan", deg: 45 },
            loaderPosition: E = "left",
            loaderProps: k = { size: "xs", color: "white", variant: "circle" },
            href: C = null,
            external: P = !1,
            disabled: S = !1,
            compact: I = !1,
            loading: N = !1,
            uppercase: B = !1,
            fullSize: T = !1,
            ripple: O = !1,
          } = n;
          const R = wt(F());
          let L,
            U = !1;
          return (
            S && N && ((U = !0), (L = Xe[0])),
            ((P && "string" != typeof C) || C?.length < 1) &&
              ((U = !0), (L = Xe[1])),
            (t.$$set = (t) => {
              (n = e(e({}, n), f(t))),
                r(20, (c = p(n, a))),
                "use" in t && r(2, (d = t.use)),
                "element" in t && r(0, (g = t.element)),
                "class" in t && r(3, (m = t.class)),
                "override" in t && r(1, (y = t.override)),
                "variant" in t && r(4, (b = t.variant)),
                "color" in t && r(22, (w = t.color)),
                "size" in t && r(23, (A = t.size)),
                "radius" in t && r(24, (v = t.radius)),
                "gradient" in t && r(25, (x = t.gradient)),
                "loaderPosition" in t && r(5, (E = t.loaderPosition)),
                "loaderProps" in t && r(6, (k = t.loaderProps)),
                "href" in t && r(7, (C = t.href)),
                "external" in t && r(8, (P = t.external)),
                "disabled" in t && r(9, (S = t.disabled)),
                "compact" in t && r(10, (I = t.compact)),
                "loading" in t && r(11, (N = t.loading)),
                "uppercase" in t && r(12, (B = t.uppercase)),
                "fullSize" in t && r(26, (T = t.fullSize)),
                "ripple" in t && r(13, (O = t.ripple)),
                "$$scope" in t && r(27, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              16384 & t.$$.dirty && U && r(1, (y = { display: "none" })),
                130024464 & t.$$.dirty &&
                  r(
                    18,
                    ({
                      cx: s,
                      classes: i,
                      getStyles: o,
                    } = Ze(
                      {
                        color: w,
                        compact: I,
                        fullSize: T,
                        gradient: x,
                        radius: v,
                        size: A,
                        variant: b,
                      },
                      { name: "Button" }
                    )),
                    s,
                    (r(17, i),
                    r(22, w),
                    r(10, I),
                    r(26, T),
                    r(25, x),
                    r(24, v),
                    r(23, A),
                    r(4, b)),
                    (r(16, o),
                    r(22, w),
                    r(10, I),
                    r(26, T),
                    r(25, x),
                    r(24, v),
                    r(23, A),
                    r(4, b))
                  );
            }),
            [
              g,
              y,
              d,
              m,
              b,
              E,
              k,
              C,
              P,
              S,
              I,
              N,
              B,
              O,
              U,
              L,
              o,
              i,
              s,
              R,
              c,
              h,
              w,
              A,
              v,
              x,
              T,
              u,
              l,
              function (t) {
                z[t ? "unshift" : "push"](() => {
                  (g = t), r(0, g);
                });
              },
              function (t) {
                z[t ? "unshift" : "push"](() => {
                  (g = t), r(0, g);
                });
              },
            ]
          );
        }
        var Wn = class extends at {
          constructor(t) {
            super(),
              ot(
                this,
                t,
                Jn,
                Vn,
                o,
                {
                  use: 2,
                  element: 0,
                  class: 3,
                  override: 1,
                  variant: 4,
                  color: 22,
                  size: 23,
                  radius: 24,
                  gradient: 25,
                  loaderPosition: 5,
                  loaderProps: 6,
                  href: 7,
                  external: 8,
                  disabled: 9,
                  compact: 10,
                  loading: 11,
                  uppercase: 12,
                  fullSize: 26,
                  ripple: 13,
                },
                kn
              );
          }
        };
        const Kn = [
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "Deposit",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
              ],
              name: "EscrowCancelled",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_merchant",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "EscrowCreated",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
              ],
              name: "TradeCompleted",
              type: "event",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "cancelEscrow",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "completeTrade",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "string", name: "_details", type: "string" },
              ],
              name: "createEscrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "deposit",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "escrows",
              outputs: [
                { internalType: "address", name: "buyer", type: "address" },
                { internalType: "address", name: "merchant", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
                { internalType: "string", name: "details", type: "string" },
                { internalType: "bool", name: "isDead", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "nextEscrowId",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          ],
          _n = "6.6.4";
        function qn(t, e, n) {
          const r = e.split("|").map((t) => t.trim());
          for (let n = 0; n < r.length; n++)
            switch (e) {
              case "any":
                return;
              case "bigint":
              case "boolean":
              case "number":
              case "string":
                if (typeof t === e) return;
            }
          const s = new Error(`invalid value for type ${e}`);
          throw (
            ((s.code = "INVALID_ARGUMENT"),
            (s.argument = `value.${n}`),
            (s.value = t),
            s)
          );
        }
        async function Yn(t) {
          const e = Object.keys(t),
            n = await Promise.all(e.map((e) => Promise.resolve(t[e])));
          return n.reduce((t, n, r) => ((t[e[r]] = n), t), {});
        }
        function Zn(t, e, n) {
          for (let r in e) {
            let s = e[r];
            const i = n ? n[r] : null;
            i && qn(s, i, r),
              Object.defineProperty(t, r, {
                enumerable: !0,
                value: s,
                writable: !1,
              });
          }
        }
        function Xn(t) {
          if (null == t) return "null";
          if (Array.isArray(t)) return "[ " + t.map(Xn).join(", ") + " ]";
          if (t instanceof Uint8Array) {
            const e = "0123456789abcdef";
            let n = "0x";
            for (let r = 0; r < t.length; r++)
              (n += e[t[r] >> 4]), (n += e[15 & t[r]]);
            return n;
          }
          if ("object" == typeof t && "function" == typeof t.toJSON)
            return Xn(t.toJSON());
          switch (typeof t) {
            case "boolean":
            case "symbol":
            case "number":
              return t.toString();
            case "bigint":
              return BigInt(t).toString();
            case "string":
              return JSON.stringify(t);
            case "object": {
              const e = Object.keys(t);
              return (
                e.sort(),
                "{ " + e.map((e) => `${Xn(e)}: ${Xn(t[e])}`).join(", ") + " }"
              );
            }
          }
          return "[ COULD NOT SERIALIZE ]";
        }
        function tr(t, e) {
          return t && t.code === e;
        }
        function er(t) {
          return tr(t, "CALL_EXCEPTION");
        }
        function nr(t, e, n) {
          {
            const r = [];
            if (n) {
              if ("message" in n || "code" in n || "name" in n)
                throw new Error(
                  `value will overwrite populated values: ${Xn(n)}`
                );
              for (const t in n) {
                const e = n[t];
                r.push(t + "=" + Xn(e));
              }
            }
            r.push(`code=${e}`),
              r.push(`version=${_n}`),
              r.length && (t += " (" + r.join(", ") + ")");
          }
          let r;
          switch (e) {
            case "INVALID_ARGUMENT":
              r = new TypeError(t);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              r = new RangeError(t);
              break;
            default:
              r = new Error(t);
          }
          return Zn(r, { code: e }), n && Object.assign(r, n), r;
        }
        function rr(t, e, n, r) {
          if (!t) throw nr(e, n, r);
        }
        function sr(t, e, n, r) {
          rr(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
        }
        function ir(t, e, n) {
          null == n && (n = ""),
            n && (n = ": " + n),
            rr(t >= e, "missing arguemnt" + n, "MISSING_ARGUMENT", {
              count: t,
              expectedCount: e,
            }),
            rr(t <= e, "too many arguemnts" + n, "UNEXPECTED_ARGUMENT", {
              count: t,
              expectedCount: e,
            });
        }
        const or = ["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
          try {
            if ("test" !== "test".normalize(e)) throw new Error("bad");
            if ("NFD" === e) {
              const t = String.fromCharCode(233).normalize("NFD");
              if (t !== String.fromCharCode(101, 769))
                throw new Error("broken");
            }
            t.push(e);
          } catch (t) {}
          return t;
        }, []);
        function ar(t, e, n) {
          if ((null == n && (n = ""), t !== e)) {
            let t = n,
              e = "new";
            n && ((t += "."), (e += " " + n)),
              rr(
                !1,
                `private constructor; use ${t}from* methods`,
                "UNSUPPORTED_OPERATION",
                { operation: e }
              );
          }
        }
        function cr(t, e, n) {
          if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
          if ("string" == typeof t && t.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
            const e = new Uint8Array((t.length - 2) / 2);
            let n = 2;
            for (let r = 0; r < e.length; r++)
              (e[r] = parseInt(t.substring(n, n + 2), 16)), (n += 2);
            return e;
          }
          sr(!1, "invalid BytesLike value", e || "value", t);
        }
        function lr(t, e) {
          return cr(t, e, !1);
        }
        function ur(t, e) {
          return cr(t, e, !0);
        }
        function hr(t, e) {
          return (
            !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/)) &&
            ("number" != typeof e || t.length === 2 + 2 * e) &&
            (!0 !== e || t.length % 2 == 0)
          );
        }
        const dr = "0123456789abcdef";
        function fr(t) {
          const e = lr(t);
          let n = "0x";
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            n += dr[(240 & r) >> 4] + dr[15 & r];
          }
          return n;
        }
        function pr(t) {
          return "0x" + t.map((t) => fr(t).substring(2)).join("");
        }
        function gr(t) {
          return hr(t, !0) ? (t.length - 2) / 2 : lr(t).length;
        }
        function mr(t, e, n) {
          const r = lr(t);
          return (
            null != n &&
              n > r.length &&
              rr(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
                buffer: r,
                length: r.length,
                offset: n,
              }),
            fr(r.slice(null == e ? 0 : e, null == n ? r.length : n))
          );
        }
        function yr(t, e) {
          return (function (t, e, n) {
            const r = lr(t);
            rr(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
              buffer: new Uint8Array(r),
              length: e,
              offset: e + 1,
            });
            const s = new Uint8Array(e);
            return s.fill(0), n ? s.set(r, e - r.length) : s.set(r, 0), fr(s);
          })(t, e, !0);
        }
        const br = BigInt(0),
          wr = BigInt(1),
          Ar = 9007199254740991;
        function vr(t, e) {
          const n = Cr(t, "value"),
            r = BigInt(Ir(e, "width"));
          if (
            (rr(n >> r === br, "overflow", "NUMERIC_FAULT", {
              operation: "fromTwos",
              fault: "overflow",
              value: t,
            }),
            n >> (r - wr))
          ) {
            return -((~n & ((wr << r) - wr)) + wr);
          }
          return n;
        }
        function xr(t, e) {
          let n = kr(t, "value");
          const r = BigInt(Ir(e, "width")),
            s = wr << (r - wr);
          if (n < br) {
            (n = -n),
              rr(n <= s, "too low", "NUMERIC_FAULT", {
                operation: "toTwos",
                fault: "overflow",
                value: t,
              });
            return (~n & ((wr << r) - wr)) + wr;
          }
          return (
            rr(n < s, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: t,
            }),
            n
          );
        }
        function Er(t, e) {
          const n = Cr(t, "value"),
            r = BigInt(Ir(e, "bits"));
          return n & ((wr << r) - wr);
        }
        function kr(t, e) {
          switch (typeof t) {
            case "bigint":
              return t;
            case "number":
              return (
                sr(Number.isInteger(t), "underflow", e || "value", t),
                sr(t >= -Ar && t <= Ar, "overflow", e || "value", t),
                BigInt(t)
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return "-" === t[0] && "-" !== t[1]
                  ? -BigInt(t.substring(1))
                  : BigInt(t);
              } catch (n) {
                sr(
                  !1,
                  `invalid BigNumberish string: ${n.message}`,
                  e || "value",
                  t
                );
              }
          }
          sr(!1, "invalid BigNumberish value", e || "value", t);
        }
        function Cr(t, e) {
          const n = kr(t, e);
          return (
            rr(n >= br, "unsigned value cannot be negative", "NUMERIC_FAULT", {
              fault: "overflow",
              operation: "getUint",
              value: t,
            }),
            n
          );
        }
        const Pr = "0123456789abcdef";
        function Sr(t) {
          if (t instanceof Uint8Array) {
            let e = "0x0";
            for (const n of t) (e += Pr[n >> 4]), (e += Pr[15 & n]);
            return BigInt(e);
          }
          return kr(t);
        }
        function Ir(t, e) {
          switch (typeof t) {
            case "bigint":
              return (
                sr(t >= -Ar && t <= Ar, "overflow", e || "value", t), Number(t)
              );
            case "number":
              return (
                sr(Number.isInteger(t), "underflow", e || "value", t),
                sr(t >= -Ar && t <= Ar, "overflow", e || "value", t),
                t
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return Ir(BigInt(t), e);
              } catch (n) {
                sr(!1, `invalid numeric string: ${n.message}`, e || "value", t);
              }
          }
          sr(!1, "invalid numeric value", e || "value", t);
        }
        function Nr(t, e) {
          let n = Cr(t, "value").toString(16);
          if (null == e) n.length % 2 && (n = "0" + n);
          else {
            const r = Ir(e, "width");
            for (
              rr(
                2 * r >= n.length,
                `value exceeds width (${r} bits)`,
                "NUMERIC_FAULT",
                { operation: "toBeHex", fault: "overflow", value: t }
              );
              n.length < 2 * r;

            )
              n = "0" + n;
          }
          return "0x" + n;
        }
        function Br(t) {
          const e = Cr(t, "value");
          if (e === br) return new Uint8Array([]);
          let n = e.toString(16);
          n.length % 2 && (n = "0" + n);
          const r = new Uint8Array(n.length / 2);
          for (let t = 0; t < r.length; t++) {
            const e = 2 * t;
            r[t] = parseInt(n.substring(e, e + 2), 16);
          }
          return r;
        }
        function Tr(t) {
          let e = fr(
            (function (t) {
              return hr(t, !0) || t instanceof Uint8Array;
            })(t)
              ? t
              : Br(t)
          ).substring(2);
          for (; e.startsWith("0"); ) e = e.substring(1);
          return "" === e && (e = "0"), "0x" + e;
        }
        BigInt(0);
        const Or = BigInt(58);
        class Rr {
          filter;
          emitter;
          #t;
          constructor(t, e, n) {
            (this.#t = e), Zn(this, { emitter: t, filter: n });
          }
          async removeListener() {
            null != this.#t && (await this.emitter.off(this.filter, this.#t));
          }
        }
        function Lr(t, e, n, r, s) {
          if ("BAD_PREFIX" === t || "UNEXPECTED_CONTINUE" === t) {
            let t = 0;
            for (let r = e + 1; r < n.length && n[r] >> 6 == 2; r++) t++;
            return t;
          }
          return "OVERRUN" === t ? n.length - e - 1 : 0;
        }
        const Ur = Object.freeze({
          error: function (t, e, n, r, s) {
            sr(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
          },
          ignore: Lr,
          replace: function (t, e, n, r, s) {
            return "OVERLONG" === t
              ? (sr(
                  "number" == typeof s,
                  "invalid bad code point for replacement",
                  "badCodepoint",
                  s
                ),
                r.push(s),
                0)
              : (r.push(65533), Lr(t, e, n));
          },
        });
        function Fr(t, e) {
          null != e &&
            (!(function (t) {
              rr(
                or.indexOf(t) >= 0,
                "platform missing String.prototype.normalize",
                "UNSUPPORTED_OPERATION",
                { operation: "String.prototype.normalize", info: { form: t } }
              );
            })(e),
            (t = t.normalize(e)));
          let n = [];
          for (let e = 0; e < t.length; e++) {
            const r = t.charCodeAt(e);
            if (r < 128) n.push(r);
            else if (r < 2048) n.push((r >> 6) | 192), n.push((63 & r) | 128);
            else if (55296 == (64512 & r)) {
              e++;
              const s = t.charCodeAt(e);
              sr(
                e < t.length && 56320 == (64512 & s),
                "invalid surrogate pair",
                "str",
                t
              );
              const i = 65536 + ((1023 & r) << 10) + (1023 & s);
              n.push((i >> 18) | 240),
                n.push(((i >> 12) & 63) | 128),
                n.push(((i >> 6) & 63) | 128),
                n.push((63 & i) | 128);
            } else
              n.push((r >> 12) | 224),
                n.push(((r >> 6) & 63) | 128),
                n.push((63 & r) | 128);
          }
          return new Uint8Array(n);
        }
        function Dr(t, e) {
          return (
            (n = (function (t, e) {
              null == e && (e = Ur.error);
              const n = lr(t, "bytes"),
                r = [];
              let s = 0;
              for (; s < n.length; ) {
                const t = n[s++];
                if (t >> 7 == 0) {
                  r.push(t);
                  continue;
                }
                let i = null,
                  o = null;
                if (192 == (224 & t)) (i = 1), (o = 127);
                else if (224 == (240 & t)) (i = 2), (o = 2047);
                else {
                  if (240 != (248 & t)) {
                    s += e(
                      128 == (192 & t) ? "UNEXPECTED_CONTINUE" : "BAD_PREFIX",
                      s - 1,
                      n,
                      r
                    );
                    continue;
                  }
                  (i = 3), (o = 65535);
                }
                if (s - 1 + i >= n.length) {
                  s += e("OVERRUN", s - 1, n, r);
                  continue;
                }
                let a = t & ((1 << (8 - i - 1)) - 1);
                for (let t = 0; t < i; t++) {
                  let t = n[s];
                  if (128 != (192 & t)) {
                    (s += e("MISSING_CONTINUE", s, n, r)), (a = null);
                    break;
                  }
                  (a = (a << 6) | (63 & t)), s++;
                }
                null !== a &&
                  (a > 1114111
                    ? (s += e("OUT_OF_RANGE", s - 1 - i, n, r, a))
                    : a >= 55296 && a <= 57343
                    ? (s += e("UTF16_SURROGATE", s - 1 - i, n, r, a))
                    : a <= o
                    ? (s += e("OVERLONG", s - 1 - i, n, r, a))
                    : r.push(a));
              }
              return r;
            })(t, e)),
            n
              .map((t) =>
                t <= 65535
                  ? String.fromCharCode(t)
                  : ((t -= 65536),
                    String.fromCharCode(
                      55296 + ((t >> 10) & 1023),
                      56320 + (1023 & t)
                    ))
              )
              .join("")
          );
          var n;
        }
        let Mr = async function (t, e) {
          const n = t.url.split(":")[0].toLowerCase();
          let r;
          if (
            (rr(
              "http" === n || "https" === n,
              `unsupported protocol ${n}`,
              "UNSUPPORTED_OPERATION",
              { info: { protocol: n }, operation: "request" }
            ),
            rr(
              "https" === n || !t.credentials || t.allowInsecureAuthentication,
              "insecure authorized connections unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "request" }
            ),
            e)
          ) {
            const t = new AbortController();
            (r = t.signal),
              e.addListener(() => {
                t.abort();
              });
          }
          const s = {
              method: t.method,
              headers: new Headers(Array.from(t)),
              body: t.body || void 0,
              signal: r,
            },
            i = await fetch(t.url, s),
            o = {};
          i.headers.forEach((t, e) => {
            o[e.toLowerCase()] = t;
          });
          const a = await i.arrayBuffer(),
            c = null == a ? null : new Uint8Array(a);
          return {
            statusCode: i.status,
            statusMessage: i.statusText,
            headers: o,
            body: c,
          };
        };
        const zr = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
          jr = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
        let $r = !1;
        async function Gr(t, e) {
          try {
            const e = t.match(zr);
            if (!e) throw new Error("invalid data");
            return new _r(
              200,
              "OK",
              { "content-type": e[1] || "text/plain" },
              e[2]
                ? (function (t) {
                    t = atob(t);
                    const e = new Uint8Array(t.length);
                    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
                    return lr(e);
                  })(e[3])
                : Fr(
                    e[3].replace(/%([0-9a-f][0-9a-f])/gi, (t, e) =>
                      String.fromCharCode(parseInt(e, 16))
                    )
                  )
            );
          } catch (e) {
            return new _r(
              599,
              "BAD REQUEST (invalid data: URI)",
              {},
              null,
              new Kr(t)
            );
          }
        }
        function Hr(t) {
          return async function (e, n) {
            try {
              const n = e.match(jr);
              if (!n) throw new Error("invalid link");
              return new Kr(`${t}${n[2]}`);
            } catch (t) {
              return new _r(
                599,
                "BAD REQUEST (invalid IPFS URI)",
                {},
                null,
                new Kr(e)
              );
            }
          };
        }
        const Qr = { data: Gr, ipfs: Hr("https://gateway.ipfs.io/ipfs/") },
          Vr = new WeakMap();
        class Jr {
          #e;
          #n;
          constructor(t) {
            (this.#e = []),
              (this.#n = !1),
              Vr.set(t, () => {
                if (!this.#n) {
                  this.#n = !0;
                  for (const t of this.#e)
                    setTimeout(() => {
                      t();
                    }, 0);
                  this.#e = [];
                }
              });
          }
          addListener(t) {
            rr(!this.#n, "singal already cancelled", "UNSUPPORTED_OPERATION", {
              operation: "fetchCancelSignal.addCancelListener",
            }),
              this.#e.push(t);
          }
          get cancelled() {
            return this.#n;
          }
          checkSignal() {
            rr(!this.cancelled, "cancelled", "CANCELLED", {});
          }
        }
        function Wr(t) {
          if (null == t) throw new Error("missing signal; should not happen");
          return t.checkSignal(), t;
        }
        class Kr {
          #r;
          #s;
          #i;
          #o;
          #a;
          #c;
          #l;
          #u;
          #h;
          #d;
          #f;
          #p;
          #g;
          #m;
          get url() {
            return this.#c;
          }
          set url(t) {
            this.#c = String(t);
          }
          get body() {
            return null == this.#l ? null : new Uint8Array(this.#l);
          }
          set body(t) {
            if (null == t) (this.#l = void 0), (this.#u = void 0);
            else if ("string" == typeof t)
              (this.#l = Fr(t)), (this.#u = "text/plain");
            else if (t instanceof Uint8Array)
              (this.#l = t), (this.#u = "application/octet-stream");
            else {
              if ("object" != typeof t) throw new Error("invalid body");
              (this.#l = Fr(JSON.stringify(t))), (this.#u = "application/json");
            }
          }
          hasBody() {
            return null != this.#l;
          }
          get method() {
            return this.#o ? this.#o : this.hasBody() ? "POST" : "GET";
          }
          set method(t) {
            null == t && (t = ""), (this.#o = String(t).toUpperCase());
          }
          get headers() {
            const t = Object.assign({}, this.#i);
            return (
              this.#h &&
                (t.authorization = `Basic ${(function (t) {
                  const e = lr(t);
                  let n = "";
                  for (let t = 0; t < e.length; t++)
                    n += String.fromCharCode(e[t]);
                  return btoa(n);
                })(Fr(this.#h))}`),
              this.allowGzip && (t["accept-encoding"] = "gzip"),
              null == t["content-type"] &&
                this.#u &&
                (t["content-type"] = this.#u),
              this.body && (t["content-length"] = String(this.body.length)),
              t
            );
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          setHeader(t, e) {
            this.#i[String(t).toLowerCase()] = String(e);
          }
          clearHeaders() {
            this.#i = {};
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          get credentials() {
            return this.#h || null;
          }
          setCredentials(t, e) {
            sr(
              !t.match(/:/),
              "invalid basic authentication username",
              "username",
              "[REDACTED]"
            ),
              (this.#h = `${t}:${e}`);
          }
          get allowGzip() {
            return this.#s;
          }
          set allowGzip(t) {
            this.#s = !!t;
          }
          get allowInsecureAuthentication() {
            return !!this.#r;
          }
          set allowInsecureAuthentication(t) {
            this.#r = !!t;
          }
          get timeout() {
            return this.#a;
          }
          set timeout(t) {
            sr(t >= 0, "timeout must be non-zero", "timeout", t), (this.#a = t);
          }
          get preflightFunc() {
            return this.#d || null;
          }
          set preflightFunc(t) {
            this.#d = t;
          }
          get processFunc() {
            return this.#f || null;
          }
          set processFunc(t) {
            this.#f = t;
          }
          get retryFunc() {
            return this.#p || null;
          }
          set retryFunc(t) {
            this.#p = t;
          }
          constructor(t) {
            (this.#c = String(t)),
              (this.#r = !1),
              (this.#s = !0),
              (this.#i = {}),
              (this.#o = ""),
              (this.#a = 3e5),
              (this.#m = { slotInterval: 250, maxAttempts: 12 });
          }
          toString() {
            return `<FetchRequest method=${JSON.stringify(
              this.method
            )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
              this.headers
            )} body=${this.#l ? fr(this.#l) : "null"}>`;
          }
          setThrottleParams(t) {
            null != t.slotInterval && (this.#m.slotInterval = t.slotInterval),
              null != t.maxAttempts && (this.#m.maxAttempts = t.maxAttempts);
          }
          async #y(t, e, n, r, s) {
            if (t >= this.#m.maxAttempts)
              return s.makeServerError("exceeded maximum retry limit");
            rr(qr() <= e, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: r,
            }),
              n > 0 &&
                (await (function (t) {
                  return new Promise((e) => setTimeout(e, t));
                })(n));
            let i = this.clone();
            const o = (i.url.split(":")[0] || "").toLowerCase();
            if (o in Qr) {
              const t = await Qr[o](i.url, Wr(r.#g));
              if (t instanceof _r) {
                let e = t;
                if (this.processFunc) {
                  Wr(r.#g);
                  try {
                    e = await this.processFunc(i, e);
                  } catch (t) {
                    (null != t.throttle && "number" == typeof t.stall) ||
                      e
                        .makeServerError("error in post-processing function", t)
                        .assertOk();
                  }
                }
                return e;
              }
              i = t;
            }
            this.preflightFunc && (i = await this.preflightFunc(i));
            const a = await Mr(i, Wr(r.#g));
            let c = new _r(a.statusCode, a.statusMessage, a.headers, a.body, r);
            if (301 === c.statusCode || 302 === c.statusCode) {
              try {
                const n = c.headers.location || "";
                return i.redirect(n).#y(t + 1, e, 0, r, c);
              } catch (t) {}
              return c;
            }
            if (
              429 === c.statusCode &&
              (null == this.retryFunc || (await this.retryFunc(i, c, t)))
            ) {
              const n = c.headers["retry-after"];
              let s =
                this.#m.slotInterval *
                Math.trunc(Math.random() * Math.pow(2, t));
              return (
                "string" == typeof n &&
                  n.match(/^[1-9][0-9]*$/) &&
                  (s = parseInt(n)),
                i.clone().#y(t + 1, e, s, r, c)
              );
            }
            if (this.processFunc) {
              Wr(r.#g);
              try {
                c = await this.processFunc(i, c);
              } catch (n) {
                (null != n.throttle && "number" == typeof n.stall) ||
                  c
                    .makeServerError("error in post-processing function", n)
                    .assertOk();
                let s =
                  this.#m.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, t));
                return (
                  n.stall >= 0 && (s = n.stall), i.clone().#y(t + 1, e, s, r, c)
                );
              }
            }
            return c;
          }
          send() {
            return (
              rr(
                null == this.#g,
                "request already sent",
                "UNSUPPORTED_OPERATION",
                { operation: "fetchRequest.send" }
              ),
              (this.#g = new Jr(this)),
              this.#y(
                0,
                qr() + this.timeout,
                0,
                this,
                new _r(0, "", {}, null, this)
              )
            );
          }
          cancel() {
            rr(
              null != this.#g,
              "request has not been sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.cancel" }
            );
            const t = Vr.get(this);
            if (!t) throw new Error("missing signal; should not happen");
            t();
          }
          redirect(t) {
            const e = this.url.split(":")[0].toLowerCase(),
              n = t.split(":")[0].toLowerCase();
            rr(
              "GET" === this.method &&
                ("https" !== e || "http" !== n) &&
                t.match(/^https?:/),
              "unsupported redirect",
              "UNSUPPORTED_OPERATION",
              {
                operation: `redirect(${this.method} ${JSON.stringify(
                  this.url
                )} => ${JSON.stringify(t)})`,
              }
            );
            const r = new Kr(t);
            return (
              (r.method = "GET"),
              (r.allowGzip = this.allowGzip),
              (r.timeout = this.timeout),
              (r.#i = Object.assign({}, this.#i)),
              this.#l && (r.#l = new Uint8Array(this.#l)),
              (r.#u = this.#u),
              r
            );
          }
          clone() {
            const t = new Kr(this.url);
            return (
              (t.#o = this.#o),
              this.#l && (t.#l = this.#l),
              (t.#u = this.#u),
              (t.#i = Object.assign({}, this.#i)),
              (t.#h = this.#h),
              this.allowGzip && (t.allowGzip = !0),
              (t.timeout = this.timeout),
              this.allowInsecureAuthentication &&
                (t.allowInsecureAuthentication = !0),
              (t.#d = this.#d),
              (t.#f = this.#f),
              (t.#p = this.#p),
              t
            );
          }
          static lockConfig() {
            $r = !0;
          }
          static getGateway(t) {
            return Qr[t.toLowerCase()] || null;
          }
          static registerGateway(t, e) {
            if ("http" === (t = t.toLowerCase()) || "https" === t)
              throw new Error(`cannot intercept ${t}; use registerGetUrl`);
            if ($r) throw new Error("gateways locked");
            Qr[t] = e;
          }
          static registerGetUrl(t) {
            if ($r) throw new Error("gateways locked");
            Mr = t;
          }
          static createDataGateway() {
            return Gr;
          }
          static createIpfsGatewayFunc(t) {
            return Hr(t);
          }
        }
        class _r {
          #b;
          #w;
          #i;
          #l;
          #A;
          #v;
          toString() {
            return `<FetchResponse status=${this.statusCode} body=${
              this.#l ? fr(this.#l) : "null"
            }>`;
          }
          get statusCode() {
            return this.#b;
          }
          get statusMessage() {
            return this.#w;
          }
          get headers() {
            return Object.assign({}, this.#i);
          }
          get body() {
            return null == this.#l ? null : new Uint8Array(this.#l);
          }
          get bodyText() {
            try {
              return null == this.#l ? "" : Dr(this.#l);
            } catch (t) {
              rr(
                !1,
                "response body is not valid UTF-8 data",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyText", info: { response: this } }
              );
            }
          }
          get bodyJson() {
            try {
              return JSON.parse(this.bodyText);
            } catch (t) {
              rr(
                !1,
                "response body is not valid JSON",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyJson", info: { response: this } }
              );
            }
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          constructor(t, e, n, r, s) {
            (this.#b = t),
              (this.#w = e),
              (this.#i = Object.keys(n).reduce(
                (t, e) => ((t[e.toLowerCase()] = String(n[e])), t),
                {}
              )),
              (this.#l = null == r ? null : new Uint8Array(r)),
              (this.#A = s || null),
              (this.#v = { message: "" });
          }
          makeServerError(t, e) {
            let n;
            n = t
              ? `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})`
              : `CLIENT ESCALATED SERVER ERROR (${(t = `${this.statusCode} ${this.statusMessage}`)})`;
            const r = new _r(
              599,
              n,
              this.headers,
              this.body,
              this.#A || void 0
            );
            return (r.#v = { message: t, error: e }), r;
          }
          throwThrottleError(t, e) {
            null == e
              ? (e = -1)
              : sr(
                  Number.isInteger(e) && e >= 0,
                  "invalid stall timeout",
                  "stall",
                  e
                );
            const n = new Error(t || "throttling requests");
            throw (Zn(n, { stall: e, throttle: !0 }), n);
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          hasBody() {
            return null != this.#l;
          }
          get request() {
            return this.#A;
          }
          ok() {
            return (
              "" === this.#v.message &&
              this.statusCode >= 200 &&
              this.statusCode < 300
            );
          }
          assertOk() {
            if (this.ok()) return;
            let { message: t, error: e } = this.#v;
            "" === t &&
              (t = `server response ${this.statusCode} ${this.statusMessage}`),
              rr(!1, t, "SERVER_ERROR", {
                request: this.request || "unknown request",
                response: this,
                error: e,
              });
          }
        }
        function qr() {
          return new Date().getTime();
        }
        const Yr = BigInt(-1),
          Zr = BigInt(0),
          Xr = BigInt(1),
          ts = BigInt(5),
          es = {};
        let ns = "0000";
        for (; ns.length < 80; ) ns += ns;
        function rs(t) {
          let e = ns;
          for (; e.length < t; ) e += e;
          return BigInt("1" + e.substring(0, t));
        }
        function ss(t, e, n) {
          const r = BigInt(e.width);
          if (e.signed) {
            const e = Xr << (r - Xr);
            rr(null == n || (t >= -e && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = t > Zr ? vr(Er(t, r), r) : -vr(Er(-t, r), r));
          } else {
            const e = Xr << r;
            rr(null == n || (t >= 0 && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = ((t % e) + e) % e & (e - Xr));
          }
          return t;
        }
        function is(t) {
          "number" == typeof t && (t = `fixed128x${t}`);
          let e = !0,
            n = 128,
            r = 18;
          if ("string" == typeof t)
            if ("fixed" === t);
            else if ("ufixed" === t) e = !1;
            else {
              const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              sr(s, "invalid fixed format", "format", t),
                (e = "u" !== s[1]),
                (n = parseInt(s[2])),
                (r = parseInt(s[3]));
            }
          else if (t) {
            const s = t,
              i = (t, e, n) =>
                null == s[t]
                  ? n
                  : (sr(
                      typeof s[t] === e,
                      "invalid fixed format (" + t + " not " + e + ")",
                      "format." + t,
                      s[t]
                    ),
                    s[t]);
            (e = i("signed", "boolean", e)),
              (n = i("width", "number", n)),
              (r = i("decimals", "number", r));
          }
          sr(
            n % 8 == 0,
            "invalid FixedNumber width (not byte aligned)",
            "format.width",
            n
          ),
            sr(
              r <= 80,
              "invalid FixedNumber decimals (too large)",
              "format.decimals",
              r
            );
          return {
            signed: e,
            width: n,
            decimals: r,
            name: (e ? "" : "u") + "fixed" + String(n) + "x" + String(r),
          };
        }
        class os {
          format;
          #x;
          #E;
          #k;
          _value;
          constructor(t, e, n) {
            ar(t, es, "FixedNumber"), (this.#E = e), (this.#x = n);
            const r = (function (t, e) {
              let n = "";
              t < Zr && ((n = "-"), (t *= Yr));
              let r = t.toString();
              if (0 === e) return n + r;
              for (; r.length <= e; ) r = ns + r;
              const s = r.length - e;
              for (
                r = r.substring(0, s) + "." + r.substring(s);
                "0" === r[0] && "." !== r[1];

              )
                r = r.substring(1);
              for (; "0" === r[r.length - 1] && "." !== r[r.length - 2]; )
                r = r.substring(0, r.length - 1);
              return n + r;
            })(e, n.decimals);
            Zn(this, { format: n.name, _value: r }), (this.#k = rs(n.decimals));
          }
          get signed() {
            return this.#x.signed;
          }
          get width() {
            return this.#x.width;
          }
          get decimals() {
            return this.#x.decimals;
          }
          get value() {
            return this.#E;
          }
          #C(t) {
            sr(
              this.format === t.format,
              "incompatible format; use fixedNumber.toFormat",
              "other",
              t
            );
          }
          #P(t, e) {
            return (t = ss(t, this.#x, e)), new os(es, t, this.#x);
          }
          #S(t, e) {
            return this.#C(t), this.#P(this.#E + t.#E, e);
          }
          addUnsafe(t) {
            return this.#S(t);
          }
          add(t) {
            return this.#S(t, "add");
          }
          #I(t, e) {
            return this.#C(t), this.#P(this.#E - t.#E, e);
          }
          subUnsafe(t) {
            return this.#I(t);
          }
          sub(t) {
            return this.#I(t, "sub");
          }
          #N(t, e) {
            return this.#C(t), this.#P((this.#E * t.#E) / this.#k, e);
          }
          mulUnsafe(t) {
            return this.#N(t);
          }
          mul(t) {
            return this.#N(t, "mul");
          }
          mulSignal(t) {
            this.#C(t);
            const e = this.#E * t.#E;
            return (
              rr(
                e % this.#k === Zr,
                "precision lost during signalling mul",
                "NUMERIC_FAULT",
                { operation: "mulSignal", fault: "underflow", value: this }
              ),
              this.#P(e / this.#k, "mulSignal")
            );
          }
          #B(t, e) {
            return (
              rr(t.#E !== Zr, "division by zero", "NUMERIC_FAULT", {
                operation: "div",
                fault: "divide-by-zero",
                value: this,
              }),
              this.#C(t),
              this.#P((this.#E * this.#k) / t.#E, e)
            );
          }
          divUnsafe(t) {
            return this.#B(t);
          }
          div(t) {
            return this.#B(t, "div");
          }
          divSignal(t) {
            rr(t.#E !== Zr, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            }),
              this.#C(t);
            const e = this.#E * this.#k;
            return (
              rr(
                e % t.#E === Zr,
                "precision lost during signalling div",
                "NUMERIC_FAULT",
                { operation: "divSignal", fault: "underflow", value: this }
              ),
              this.#P(e / t.#E, "divSignal")
            );
          }
          cmp(t) {
            let e = this.value,
              n = t.value;
            const r = this.decimals - t.decimals;
            return (
              r > 0 ? (n *= rs(r)) : r < 0 && (e *= rs(-r)),
              e < n ? -1 : e > n ? 1 : 0
            );
          }
          eq(t) {
            return 0 === this.cmp(t);
          }
          lt(t) {
            return this.cmp(t) < 0;
          }
          lte(t) {
            return this.cmp(t) <= 0;
          }
          gt(t) {
            return this.cmp(t) > 0;
          }
          gte(t) {
            return this.cmp(t) >= 0;
          }
          floor() {
            let t = this.#E;
            return (
              this.#E < Zr && (t -= this.#k - Xr),
              (t = (this.#E / this.#k) * this.#k),
              this.#P(t, "floor")
            );
          }
          ceiling() {
            let t = this.#E;
            return (
              this.#E > Zr && (t += this.#k - Xr),
              (t = (this.#E / this.#k) * this.#k),
              this.#P(t, "ceiling")
            );
          }
          round(t) {
            if ((null == t && (t = 0), t >= this.decimals)) return this;
            const e = this.decimals - t,
              n = ts * rs(e - 1);
            let r = this.value + n;
            const s = rs(e);
            return (
              (r = (r / s) * s), ss(r, this.#x, "round"), new os(es, r, this.#x)
            );
          }
          isZero() {
            return this.#E === Zr;
          }
          isNegative() {
            return this.#E < Zr;
          }
          toString() {
            return this._value;
          }
          toUnsafeFloat() {
            return parseFloat(this.toString());
          }
          toFormat(t) {
            return os.fromString(this.toString(), t);
          }
          static fromValue(t, e, n) {
            const r = null == e ? 0 : Ir(e),
              s = is(n);
            let i = kr(t, "value");
            const o = r - s.decimals;
            if (o > 0) {
              const e = rs(o);
              rr(
                i % e === Zr,
                "value loses precision for format",
                "NUMERIC_FAULT",
                { operation: "fromValue", fault: "underflow", value: t }
              ),
                (i /= e);
            } else o < 0 && (i *= rs(-o));
            return ss(i, s, "fromValue"), new os(es, i, s);
          }
          static fromString(t, e) {
            const n = t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            sr(
              n && n[2].length + n[3].length > 0,
              "invalid FixedNumber string value",
              "value",
              t
            );
            const r = is(e);
            let s = n[2] || "0",
              i = n[3] || "";
            for (; i.length < r.decimals; ) i += ns;
            rr(
              i.substring(r.decimals).match(/^0*$/),
              "too many decimals for format",
              "NUMERIC_FAULT",
              { operation: "fromString", fault: "underflow", value: t }
            ),
              (i = i.substring(0, r.decimals));
            const o = BigInt(n[1] + s + i);
            return ss(o, r, "fromString"), new os(es, o, r);
          }
          static fromBytes(t, e) {
            let n = Sr(lr(t, "value"));
            const r = is(e);
            return (
              r.signed && (n = vr(n, r.width)),
              ss(n, r, "fromBytes"),
              new os(es, n, r)
            );
          }
        }
        function as(t) {
          let e = t.toString(16);
          for (; e.length < 2; ) e = "0" + e;
          return "0x" + e;
        }
        function cs(t, e, n) {
          let r = 0;
          for (let s = 0; s < n; s++) r = 256 * r + t[e + s];
          return r;
        }
        function ls(t, e, n, r) {
          const s = [];
          for (; n < e + 1 + r; ) {
            const i = us(t, n);
            s.push(i.result),
              rr(
                (n += i.consumed) <= e + 1 + r,
                "child data too short",
                "BUFFER_OVERRUN",
                { buffer: t, length: r, offset: e }
              );
          }
          return { consumed: 1 + r, result: s };
        }
        function us(t, e) {
          rr(0 !== t.length, "data too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: 0,
            offset: 1,
          });
          const n = (e) => {
            rr(
              e <= t.length,
              "data short segment too short",
              "BUFFER_OVERRUN",
              { buffer: t, length: t.length, offset: e }
            );
          };
          if (t[e] >= 248) {
            const r = t[e] - 247;
            n(e + 1 + r);
            const s = cs(t, e + 1, r);
            return n(e + 1 + r + s), ls(t, e, e + 1 + r, r + s);
          }
          if (t[e] >= 192) {
            const r = t[e] - 192;
            return n(e + 1 + r), ls(t, e, e + 1, r);
          }
          if (t[e] >= 184) {
            const r = t[e] - 183;
            n(e + 1 + r);
            const s = cs(t, e + 1, r);
            n(e + 1 + r + s);
            return {
              consumed: 1 + r + s,
              result: fr(t.slice(e + 1 + r, e + 1 + r + s)),
            };
          }
          if (t[e] >= 128) {
            const r = t[e] - 128;
            n(e + 1 + r);
            return { consumed: 1 + r, result: fr(t.slice(e + 1, e + 1 + r)) };
          }
          return { consumed: 1, result: as(t[e]) };
        }
        function hs(t) {
          const e = lr(t, "data"),
            n = us(e, 0);
          return (
            sr(
              n.consumed === e.length,
              "unexpected junk after rlp payload",
              "data",
              t
            ),
            n.result
          );
        }
        function ds(t) {
          const e = [];
          for (; t; ) e.unshift(255 & t), (t >>= 8);
          return e;
        }
        function fs(t) {
          if (Array.isArray(t)) {
            let e = [];
            if (
              (t.forEach(function (t) {
                e = e.concat(fs(t));
              }),
              e.length <= 55)
            )
              return e.unshift(192 + e.length), e;
            const n = ds(e.length);
            return n.unshift(247 + n.length), n.concat(e);
          }
          const e = Array.prototype.slice.call(lr(t, "object"));
          if (1 === e.length && e[0] <= 127) return e;
          if (e.length <= 55) return e.unshift(128 + e.length), e;
          const n = ds(e.length);
          return n.unshift(183 + n.length), n.concat(e);
        }
        const ps = "0123456789abcdef";
        function gs(t) {
          let e = "0x";
          for (const n of fs(t)) (e += ps[n >> 4]), (e += ps[15 & n]);
          return e;
        }
        const ms = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
        function ys(t) {
          return (function (t, e) {
            sr("string" == typeof t, "value must be a string", "value", t);
            let n = 18;
            if ("string" == typeof e) {
              const t = ms.indexOf(e);
              sr(t >= 0, "invalid unit", "unit", e), (n = 3 * t);
            } else null != e && (n = Ir(e, "unit"));
            return os.fromString(t, { decimals: n, width: 512 }).value;
          })(t, 18);
        }
        const bs = 32,
          ws = new Uint8Array(bs),
          As = ["then"],
          vs = {};
        function xs(t, e) {
          const n = new Error(
            `deferred error during ABI decoding triggered accessing ${t}`
          );
          throw ((n.error = e), n);
        }
        class Es extends Array {
          #T;
          constructor(...t) {
            const e = t[0];
            let n = t[1],
              r = (t[2] || []).slice(),
              s = !0;
            e !== vs && ((n = t), (r = []), (s = !1)),
              super(n.length),
              n.forEach((t, e) => {
                this[e] = t;
              });
            const i = r.reduce(
              (t, e) => (
                "string" == typeof e && t.set(e, (t.get(e) || 0) + 1), t
              ),
              new Map()
            );
            if (
              ((this.#T = Object.freeze(
                n.map((t, e) => {
                  const n = r[e];
                  return null != n && 1 === i.get(n) ? n : null;
                })
              )),
              s)
            )
              return (
                Object.freeze(this),
                new Proxy(this, {
                  get: (t, e, n) => {
                    if ("string" == typeof e) {
                      if (e.match(/^[0-9]+$/)) {
                        const n = Ir(e, "%index");
                        if (n < 0 || n >= this.length)
                          throw new RangeError("out of result range");
                        const r = t[n];
                        return r instanceof Error && xs(`index ${n}`, r), r;
                      }
                      if (As.indexOf(e) >= 0) return Reflect.get(t, e, n);
                      const r = t[e];
                      if (r instanceof Function)
                        return function (...e) {
                          return r.apply(this === n ? t : this, e);
                        };
                      if (!(e in t))
                        return t.getValue.apply(this === n ? t : this, [e]);
                    }
                    return Reflect.get(t, e, n);
                  },
                })
              );
          }
          toArray() {
            const t = [];
            return (
              this.forEach((e, n) => {
                e instanceof Error && xs(`index ${n}`, e), t.push(e);
              }),
              t
            );
          }
          toObject() {
            return this.#T.reduce(
              (t, e, n) => (
                rr(
                  null != e,
                  "value at index ${ index } unnamed",
                  "UNSUPPORTED_OPERATION",
                  { operation: "toObject()" }
                ),
                e in t || (t[e] = this.getValue(e)),
                t
              ),
              {}
            );
          }
          slice(t, e) {
            null == t && (t = 0),
              t < 0 && (t += this.length) < 0 && (t = 0),
              null == e && (e = this.length),
              e < 0 && (e += this.length) < 0 && (e = 0),
              e > this.length && (e = this.length);
            const n = [],
              r = [];
            for (let s = t; s < e; s++) n.push(this[s]), r.push(this.#T[s]);
            return new Es(vs, n, r);
          }
          filter(t, e) {
            const n = [],
              r = [];
            for (let s = 0; s < this.length; s++) {
              const i = this[s];
              i instanceof Error && xs(`index ${s}`, i),
                t.call(e, i, s, this) && (n.push(i), r.push(this.#T[s]));
            }
            return new Es(vs, n, r);
          }
          map(t, e) {
            const n = [];
            for (let r = 0; r < this.length; r++) {
              const s = this[r];
              s instanceof Error && xs(`index ${r}`, s),
                n.push(t.call(e, s, r, this));
            }
            return n;
          }
          getValue(t) {
            const e = this.#T.indexOf(t);
            if (-1 === e) return;
            const n = this[e];
            return (
              n instanceof Error &&
                xs(`property ${JSON.stringify(t)}`, n.error),
              n
            );
          }
          static fromItems(t, e) {
            return new Es(vs, t, e);
          }
        }
        function ks(t) {
          let e = Br(t);
          return (
            rr(e.length <= bs, "value out-of-bounds", "BUFFER_OVERRUN", {
              buffer: e,
              length: bs,
              offset: e.length,
            }),
            e.length !== bs && (e = ur(pr([ws.slice(e.length % bs), e]))),
            e
          );
        }
        class Cs {
          name;
          type;
          localName;
          dynamic;
          constructor(t, e, n, r) {
            Zn(
              this,
              { name: t, type: e, localName: n, dynamic: r },
              {
                name: "string",
                type: "string",
                localName: "string",
                dynamic: "boolean",
              }
            );
          }
          _throwError(t, e) {
            sr(!1, t, this.localName, e);
          }
        }
        class Ps {
          #O;
          #R;
          constructor() {
            (this.#O = []), (this.#R = 0);
          }
          get data() {
            return pr(this.#O);
          }
          get length() {
            return this.#R;
          }
          #L(t) {
            return this.#O.push(t), (this.#R += t.length), t.length;
          }
          appendWriter(t) {
            return this.#L(ur(t.data));
          }
          writeBytes(t) {
            let e = ur(t);
            const n = e.length % bs;
            return n && (e = ur(pr([e, ws.slice(n)]))), this.#L(e);
          }
          writeValue(t) {
            return this.#L(ks(t));
          }
          writeUpdatableValue() {
            const t = this.#O.length;
            return (
              this.#O.push(ws),
              (this.#R += bs),
              (e) => {
                this.#O[t] = ks(e);
              }
            );
          }
        }
        class Ss {
          allowLoose;
          #O;
          #U;
          constructor(t, e) {
            Zn(this, { allowLoose: !!e }), (this.#O = ur(t)), (this.#U = 0);
          }
          get data() {
            return fr(this.#O);
          }
          get dataLength() {
            return this.#O.length;
          }
          get consumed() {
            return this.#U;
          }
          get bytes() {
            return new Uint8Array(this.#O);
          }
          #F(t, e, n) {
            let r = Math.ceil(e / bs) * bs;
            return (
              this.#U + r > this.#O.length &&
                (this.allowLoose && n && this.#U + e <= this.#O.length
                  ? (r = e)
                  : rr(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                      buffer: ur(this.#O),
                      length: this.#O.length,
                      offset: this.#U + r,
                    })),
              this.#O.slice(this.#U, this.#U + r)
            );
          }
          subReader(t) {
            return new Ss(this.#O.slice(this.#U + t), this.allowLoose);
          }
          readBytes(t, e) {
            let n = this.#F(0, t, !!e);
            return (this.#U += n.length), n.slice(0, t);
          }
          readValue() {
            return Sr(this.readBytes(bs));
          }
          readIndex() {
            return Ir(Sr(this.readBytes(bs)));
          }
        }
        function Is(t) {
          if (!Number.isSafeInteger(t) || t < 0)
            throw new Error(`Wrong positive integer: ${t}`);
        }
        function Ns(t, ...e) {
          if (!(t instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          if (e.length > 0 && !e.includes(t.length))
            throw new TypeError(
              `Expected Uint8Array of length ${e}, not of length=${t.length}`
            );
        }
        const Bs = {
            number: Is,
            bool: function (t) {
              if ("boolean" != typeof t)
                throw new Error(`Expected boolean, not ${t}`);
            },
            bytes: Ns,
            hash: function (t) {
              if ("function" != typeof t || "function" != typeof t.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              Is(t.outputLen), Is(t.blockLen);
            },
            exists: function (t, e = !0) {
              if (t.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (e && t.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (t, e) {
              Ns(t);
              const n = e.outputLen;
              if (t.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          Ts = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
          Os = (t, e) => (t << (32 - e)) | (t >>> e);
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ if (
          !(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])
        )
          throw new Error("Non little-endian hardware is not supported");
        function Rs(t) {
          if (
            ("string" == typeof t &&
              (t = (function (t) {
                if ("string" != typeof t)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof t
                  );
                return new TextEncoder().encode(t);
              })(t)),
            !(t instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof t})`
            );
          return t;
        }
        Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
        class Ls {
          clone() {
            return this._cloneInto();
          }
        }
        function Us(t) {
          const e = (e) => t().update(Rs(e)).digest(),
            n = t();
          return (
            (e.outputLen = n.outputLen),
            (e.blockLen = n.blockLen),
            (e.create = () => t()),
            e
          );
        }
        class Fs extends Ls {
          constructor(t, e) {
            super(), (this.finished = !1), (this.destroyed = !1), Bs.hash(t);
            const n = Rs(e);
            if (((this.iHash = t.create()), !(this.iHash instanceof Ls)))
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            const r = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const s = new Uint8Array(r);
            s.set(
              n.length > this.iHash.blockLen ? t.create().update(n).digest() : n
            );
            for (let t = 0; t < s.length; t++) s[t] ^= 54;
            this.iHash.update(s), (this.oHash = t.create());
            for (let t = 0; t < s.length; t++) s[t] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(t) {
            return Bs.exists(this), this.iHash.update(t), this;
          }
          digestInto(t) {
            Bs.exists(this),
              Bs.bytes(t, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(t),
              this.oHash.update(t),
              this.oHash.digestInto(t),
              this.destroy();
          }
          digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t), t;
          }
          _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: e,
              iHash: n,
              finished: r,
              destroyed: s,
              blockLen: i,
              outputLen: o,
            } = this;
            return (
              (t.finished = r),
              (t.destroyed = s),
              (t.blockLen = i),
              (t.outputLen = o),
              (t.oHash = e._cloneInto(t.oHash)),
              (t.iHash = n._cloneInto(t.iHash)),
              t
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const Ds = (t, e, n) => new Fs(t, e).update(n).digest();
        Ds.create = (t, e) => new Fs(t, e);
        class Ms extends Ls {
          constructor(t, e, n, r) {
            super(),
              (this.blockLen = t),
              (this.outputLen = e),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(t)),
              (this.view = Ts(this.buffer));
          }
          update(t) {
            Bs.exists(this);
            const { view: e, buffer: n, blockLen: r } = this,
              s = (t = Rs(t)).length;
            for (let i = 0; i < s; ) {
              const o = Math.min(r - this.pos, s - i);
              if (o !== r)
                n.set(t.subarray(i, i + o), this.pos),
                  (this.pos += o),
                  (i += o),
                  this.pos === r && (this.process(e, 0), (this.pos = 0));
              else {
                const e = Ts(t);
                for (; r <= s - i; i += r) this.process(e, i);
              }
            }
            return (this.length += t.length), this.roundClean(), this;
          }
          digestInto(t) {
            Bs.exists(this), Bs.output(t, this), (this.finished = !0);
            const { buffer: e, view: n, blockLen: r, isLE: s } = this;
            let { pos: i } = this;
            (e[i++] = 128),
              this.buffer.subarray(i).fill(0),
              this.padOffset > r - i && (this.process(n, 0), (i = 0));
            for (let t = i; t < r; t++) e[t] = 0;
            !(function (t, e, n, r) {
              if ("function" == typeof t.setBigUint64)
                return t.setBigUint64(e, n, r);
              const s = BigInt(32),
                i = BigInt(4294967295),
                o = Number((n >> s) & i),
                a = Number(n & i),
                c = r ? 4 : 0,
                l = r ? 0 : 4;
              t.setUint32(e + c, o, r), t.setUint32(e + l, a, r);
            })(n, r - 8, BigInt(8 * this.length), s),
              this.process(n, 0);
            const o = Ts(t);
            this.get().forEach((t, e) => o.setUint32(4 * e, t, s));
          }
          digest() {
            const { buffer: t, outputLen: e } = this;
            this.digestInto(t);
            const n = t.slice(0, e);
            return this.destroy(), n;
          }
          _cloneInto(t) {
            t || (t = new this.constructor()), t.set(...this.get());
            const {
              blockLen: e,
              buffer: n,
              length: r,
              finished: s,
              destroyed: i,
              pos: o,
            } = this;
            return (
              (t.length = r),
              (t.pos = o),
              (t.finished = s),
              (t.destroyed = i),
              r % e && t.buffer.set(n),
              t
            );
          }
        }
        const zs = (t, e, n) => (t & e) ^ (~t & n),
          js = (t, e, n) => (t & e) ^ (t & n) ^ (e & n),
          $s = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          Gs = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          Hs = new Uint32Array(64);
        class Qs extends Ms {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | Gs[0]),
              (this.B = 0 | Gs[1]),
              (this.C = 0 | Gs[2]),
              (this.D = 0 | Gs[3]),
              (this.E = 0 | Gs[4]),
              (this.F = 0 | Gs[5]),
              (this.G = 0 | Gs[6]),
              (this.H = 0 | Gs[7]);
          }
          get() {
            const { A: t, B: e, C: n, D: r, E: s, F: i, G: o, H: a } = this;
            return [t, e, n, r, s, i, o, a];
          }
          set(t, e, n, r, s, i, o, a) {
            (this.A = 0 | t),
              (this.B = 0 | e),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | s),
              (this.F = 0 | i),
              (this.G = 0 | o),
              (this.H = 0 | a);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4) Hs[n] = t.getUint32(e, !1);
            for (let t = 16; t < 64; t++) {
              const e = Hs[t - 15],
                n = Hs[t - 2],
                r = Os(e, 7) ^ Os(e, 18) ^ (e >>> 3),
                s = Os(n, 17) ^ Os(n, 19) ^ (n >>> 10);
              Hs[t] = (s + Hs[t - 7] + r + Hs[t - 16]) | 0;
            }
            let { A: n, B: r, C: s, D: i, E: o, F: a, G: c, H: l } = this;
            for (let t = 0; t < 64; t++) {
              const e =
                  (l +
                    (Os(o, 6) ^ Os(o, 11) ^ Os(o, 25)) +
                    zs(o, a, c) +
                    $s[t] +
                    Hs[t]) |
                  0,
                u = ((Os(n, 2) ^ Os(n, 13) ^ Os(n, 22)) + js(n, r, s)) | 0;
              (l = c),
                (c = a),
                (a = o),
                (o = (i + e) | 0),
                (i = s),
                (s = r),
                (r = n),
                (n = (e + u) | 0);
            }
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (s = (s + this.C) | 0),
              (i = (i + this.D) | 0),
              (o = (o + this.E) | 0),
              (a = (a + this.F) | 0),
              (c = (c + this.G) | 0),
              (l = (l + this.H) | 0),
              this.set(n, r, s, i, o, a, c, l);
          }
          roundClean() {
            Hs.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        const Vs = Us(() => new Qs()),
          Js = BigInt(2 ** 32 - 1),
          Ws = BigInt(32);
        function Ks(t, e = !1) {
          return e
            ? { h: Number(t & Js), l: Number((t >> Ws) & Js) }
            : { h: 0 | Number((t >> Ws) & Js), l: 0 | Number(t & Js) };
        }
        const _s = {
            fromBig: Ks,
            split: function (t, e = !1) {
              let n = new Uint32Array(t.length),
                r = new Uint32Array(t.length);
              for (let s = 0; s < t.length; s++) {
                const { h: i, l: o } = Ks(t[s], e);
                [n[s], r[s]] = [i, o];
              }
              return [n, r];
            },
            toBig: (t, e) => (BigInt(t >>> 0) << Ws) | BigInt(e >>> 0),
            shrSH: (t, e, n) => t >>> n,
            shrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrSH: (t, e, n) => (t >>> n) | (e << (32 - n)),
            rotrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrBH: (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
            rotrBL: (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
            rotr32H: (t, e) => e,
            rotr32L: (t, e) => t,
            rotlSH: (t, e, n) => (t << n) | (e >>> (32 - n)),
            rotlSL: (t, e, n) => (e << n) | (t >>> (32 - n)),
            rotlBH: (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
            rotlBL: (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
            add: function (t, e, n, r) {
              const s = (e >>> 0) + (r >>> 0);
              return { h: (t + n + ((s / 2 ** 32) | 0)) | 0, l: 0 | s };
            },
            add3L: (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
            add3H: (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
            add4L: (t, e, n, r) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
            add4H: (t, e, n, r, s) => (e + n + r + s + ((t / 2 ** 32) | 0)) | 0,
            add5H: (t, e, n, r, s, i) =>
              (e + n + r + s + i + ((t / 2 ** 32) | 0)) | 0,
            add5L: (t, e, n, r, s) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0),
          },
          [qs, Ys] = _s.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((t) => BigInt(t))
          ),
          Zs = new Uint32Array(80),
          Xs = new Uint32Array(80);
        class ti extends Ms {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: t,
              Al: e,
              Bh: n,
              Bl: r,
              Ch: s,
              Cl: i,
              Dh: o,
              Dl: a,
              Eh: c,
              El: l,
              Fh: u,
              Fl: h,
              Gh: d,
              Gl: f,
              Hh: p,
              Hl: g,
            } = this;
            return [t, e, n, r, s, i, o, a, c, l, u, h, d, f, p, g];
          }
          set(t, e, n, r, s, i, o, a, c, l, u, h, d, f, p, g) {
            (this.Ah = 0 | t),
              (this.Al = 0 | e),
              (this.Bh = 0 | n),
              (this.Bl = 0 | r),
              (this.Ch = 0 | s),
              (this.Cl = 0 | i),
              (this.Dh = 0 | o),
              (this.Dl = 0 | a),
              (this.Eh = 0 | c),
              (this.El = 0 | l),
              (this.Fh = 0 | u),
              (this.Fl = 0 | h),
              (this.Gh = 0 | d),
              (this.Gl = 0 | f),
              (this.Hh = 0 | p),
              (this.Hl = 0 | g);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4)
              (Zs[n] = t.getUint32(e)), (Xs[n] = t.getUint32((e += 4)));
            for (let t = 16; t < 80; t++) {
              const e = 0 | Zs[t - 15],
                n = 0 | Xs[t - 15],
                r = _s.rotrSH(e, n, 1) ^ _s.rotrSH(e, n, 8) ^ _s.shrSH(e, n, 7),
                s = _s.rotrSL(e, n, 1) ^ _s.rotrSL(e, n, 8) ^ _s.shrSL(e, n, 7),
                i = 0 | Zs[t - 2],
                o = 0 | Xs[t - 2],
                a =
                  _s.rotrSH(i, o, 19) ^ _s.rotrBH(i, o, 61) ^ _s.shrSH(i, o, 6),
                c =
                  _s.rotrSL(i, o, 19) ^ _s.rotrBL(i, o, 61) ^ _s.shrSL(i, o, 6),
                l = _s.add4L(s, c, Xs[t - 7], Xs[t - 16]),
                u = _s.add4H(l, r, a, Zs[t - 7], Zs[t - 16]);
              (Zs[t] = 0 | u), (Xs[t] = 0 | l);
            }
            let {
              Ah: n,
              Al: r,
              Bh: s,
              Bl: i,
              Ch: o,
              Cl: a,
              Dh: c,
              Dl: l,
              Eh: u,
              El: h,
              Fh: d,
              Fl: f,
              Gh: p,
              Gl: g,
              Hh: m,
              Hl: y,
            } = this;
            for (let t = 0; t < 80; t++) {
              const e =
                  _s.rotrSH(u, h, 14) ^
                  _s.rotrSH(u, h, 18) ^
                  _s.rotrBH(u, h, 41),
                b =
                  _s.rotrSL(u, h, 14) ^
                  _s.rotrSL(u, h, 18) ^
                  _s.rotrBL(u, h, 41),
                w = (u & d) ^ (~u & p),
                A = (h & f) ^ (~h & g),
                v = _s.add5L(y, b, A, Ys[t], Xs[t]),
                x = _s.add5H(v, m, e, w, qs[t], Zs[t]),
                E = 0 | v,
                k =
                  _s.rotrSH(n, r, 28) ^
                  _s.rotrBH(n, r, 34) ^
                  _s.rotrBH(n, r, 39),
                C =
                  _s.rotrSL(n, r, 28) ^
                  _s.rotrBL(n, r, 34) ^
                  _s.rotrBL(n, r, 39),
                P = (n & s) ^ (n & o) ^ (s & o),
                S = (r & i) ^ (r & a) ^ (i & a);
              (m = 0 | p),
                (y = 0 | g),
                (p = 0 | d),
                (g = 0 | f),
                (d = 0 | u),
                (f = 0 | h),
                ({ h: u, l: h } = _s.add(0 | c, 0 | l, 0 | x, 0 | E)),
                (c = 0 | o),
                (l = 0 | a),
                (o = 0 | s),
                (a = 0 | i),
                (s = 0 | n),
                (i = 0 | r);
              const I = _s.add3L(E, C, S);
              (n = _s.add3H(I, x, k, P)), (r = 0 | I);
            }
            ({ h: n, l: r } = _s.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
              ({ h: s, l: i } = _s.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | i)),
              ({ h: o, l: a } = _s.add(0 | this.Ch, 0 | this.Cl, 0 | o, 0 | a)),
              ({ h: c, l: l } = _s.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
              ({ h: u, l: h } = _s.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | h)),
              ({ h: d, l: f } = _s.add(0 | this.Fh, 0 | this.Fl, 0 | d, 0 | f)),
              ({ h: p, l: g } = _s.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
              ({ h: m, l: y } = _s.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
              this.set(n, r, s, i, o, a, c, l, u, h, d, f, p, g, m, y);
          }
          roundClean() {
            Zs.fill(0), Xs.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class ei extends ti {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class ni extends ti {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        const ri = Us(() => new ti());
        Us(() => new ei()), Us(() => new ni());
        const si = (function () {
          if ("undefined" != typeof self) return self;
          if ("undefined" != typeof window) return window;
          if ("undefined" != typeof global) return global;
          throw new Error("unable to locate global object");
        })();
        si.crypto || si.msCrypto;
        let ii = !1;
        const oi = function (t, e, n) {
          return (function (t, e) {
            const n = { sha256: Vs, sha512: ri }[t];
            return (
              sr(null != n, "invalid hmac algorithm", "algorithm", t),
              Ds.create(n, e)
            );
          })(t, e)
            .update(n)
            .digest();
        };
        let ai = oi;
        function ci(t, e, n) {
          const r = lr(e, "key"),
            s = lr(n, "data");
          return fr(ai(t, r, s));
        }
        (ci._ = oi),
          (ci.lock = function () {
            ii = !0;
          }),
          (ci.register = function (t) {
            if (ii) throw new Error("computeHmac is locked");
            ai = t;
          }),
          Object.freeze(ci);
        const [li, ui, hi] = [[], [], []],
          di = BigInt(0),
          fi = BigInt(1),
          pi = BigInt(2),
          gi = BigInt(7),
          mi = BigInt(256),
          yi = BigInt(113);
        for (let t = 0, e = fi, n = 1, r = 0; t < 24; t++) {
          ([n, r] = [r, (2 * n + 3 * r) % 5]),
            li.push(2 * (5 * r + n)),
            ui.push((((t + 1) * (t + 2)) / 2) % 64);
          let s = di;
          for (let t = 0; t < 7; t++)
            (e = ((e << fi) ^ ((e >> gi) * yi)) % mi),
              e & pi && (s ^= fi << ((fi << BigInt(t)) - fi));
          hi.push(s);
        }
        const [bi, wi] = _s.split(hi, !0),
          Ai = (t, e, n) => (n > 32 ? _s.rotlBH(t, e, n) : _s.rotlSH(t, e, n)),
          vi = (t, e, n) => (n > 32 ? _s.rotlBL(t, e, n) : _s.rotlSL(t, e, n));
        class xi extends Ls {
          constructor(t, e, n, r = !1, s = 24) {
            if (
              (super(),
              (this.blockLen = t),
              (this.suffix = e),
              (this.outputLen = n),
              (this.enableXOF = r),
              (this.rounds = s),
              (this.pos = 0),
              (this.posOut = 0),
              (this.finished = !1),
              (this.destroyed = !1),
              Bs.number(n),
              0 >= this.blockLen || this.blockLen >= 200)
            )
              throw new Error("Sha3 supports only keccak-f1600 function");
            var i;
            (this.state = new Uint8Array(200)),
              (this.state32 =
                ((i = this.state),
                new Uint32Array(
                  i.buffer,
                  i.byteOffset,
                  Math.floor(i.byteLength / 4)
                )));
          }
          keccak() {
            !(function (t, e = 24) {
              const n = new Uint32Array(10);
              for (let r = 24 - e; r < 24; r++) {
                for (let e = 0; e < 10; e++)
                  n[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
                for (let e = 0; e < 10; e += 2) {
                  const r = (e + 8) % 10,
                    s = (e + 2) % 10,
                    i = n[s],
                    o = n[s + 1],
                    a = Ai(i, o, 1) ^ n[r],
                    c = vi(i, o, 1) ^ n[r + 1];
                  for (let n = 0; n < 50; n += 10)
                    (t[e + n] ^= a), (t[e + n + 1] ^= c);
                }
                let e = t[2],
                  s = t[3];
                for (let n = 0; n < 24; n++) {
                  const r = ui[n],
                    i = Ai(e, s, r),
                    o = vi(e, s, r),
                    a = li[n];
                  (e = t[a]), (s = t[a + 1]), (t[a] = i), (t[a + 1] = o);
                }
                for (let e = 0; e < 50; e += 10) {
                  for (let r = 0; r < 10; r++) n[r] = t[e + r];
                  for (let r = 0; r < 10; r++)
                    t[e + r] ^= ~n[(r + 2) % 10] & n[(r + 4) % 10];
                }
                (t[0] ^= bi[r]), (t[1] ^= wi[r]);
              }
              n.fill(0);
            })(this.state32, this.rounds),
              (this.posOut = 0),
              (this.pos = 0);
          }
          update(t) {
            Bs.exists(this);
            const { blockLen: e, state: n } = this,
              r = (t = Rs(t)).length;
            for (let s = 0; s < r; ) {
              const i = Math.min(e - this.pos, r - s);
              for (let e = 0; e < i; e++) n[this.pos++] ^= t[s++];
              this.pos === e && this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            const { state: t, suffix: e, pos: n, blockLen: r } = this;
            (t[n] ^= e),
              0 != (128 & e) && n === r - 1 && this.keccak(),
              (t[r - 1] ^= 128),
              this.keccak();
          }
          writeInto(t) {
            Bs.exists(this, !1), Bs.bytes(t), this.finish();
            const e = this.state,
              { blockLen: n } = this;
            for (let r = 0, s = t.length; r < s; ) {
              this.posOut >= n && this.keccak();
              const i = Math.min(n - this.posOut, s - r);
              t.set(e.subarray(this.posOut, this.posOut + i), r),
                (this.posOut += i),
                (r += i);
            }
            return t;
          }
          xofInto(t) {
            if (!this.enableXOF)
              throw new Error("XOF is not possible for this instance");
            return this.writeInto(t);
          }
          xof(t) {
            return Bs.number(t), this.xofInto(new Uint8Array(t));
          }
          digestInto(t) {
            if ((Bs.output(t, this), this.finished))
              throw new Error("digest() was already called");
            return this.writeInto(t), this.destroy(), t;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            (this.destroyed = !0), this.state.fill(0);
          }
          _cloneInto(t) {
            const {
              blockLen: e,
              suffix: n,
              outputLen: r,
              rounds: s,
              enableXOF: i,
            } = this;
            return (
              t || (t = new xi(e, n, r, i, s)),
              t.state32.set(this.state32),
              (t.pos = this.pos),
              (t.posOut = this.posOut),
              (t.finished = this.finished),
              (t.rounds = s),
              (t.suffix = n),
              (t.outputLen = r),
              (t.enableXOF = i),
              (t.destroyed = this.destroyed),
              t
            );
          }
        }
        const Ei = (t, e, n) => Us(() => new xi(e, t, n));
        Ei(6, 144, 28),
          Ei(6, 136, 32),
          Ei(6, 104, 48),
          Ei(6, 72, 64),
          Ei(1, 144, 28);
        const ki = Ei(1, 136, 32);
        Ei(1, 104, 48), Ei(1, 72, 64);
        const Ci = (t, e, n) =>
          (function (t) {
            const e = (e, n) => t(n).update(Rs(e)).digest(),
              n = t({});
            return (
              (e.outputLen = n.outputLen),
              (e.blockLen = n.blockLen),
              (e.create = (e) => t(e)),
              e
            );
          })((r = {}) => new xi(e, t, void 0 === r.dkLen ? n : r.dkLen, !0));
        Ci(31, 168, 16), Ci(31, 136, 32);
        let Pi = !1;
        const Si = function (t) {
          return ki(t);
        };
        let Ii = Si;
        function Ni(t) {
          const e = lr(t, "data");
          return fr(Ii(e));
        }
        (Ni._ = Si),
          (Ni.lock = function () {
            Pi = !0;
          }),
          (Ni.register = function (t) {
            if (Pi) throw new TypeError("keccak256 is locked");
            Ii = t;
          }),
          Object.freeze(Ni);
        var Bi = Object.freeze({ __proto__: null, default: {} });
        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
        const Ti = BigInt(0),
          Oi = BigInt(1),
          Ri = BigInt(2),
          Li = BigInt(3),
          Ui = BigInt(8),
          Fi = Object.freeze({
            a: Ti,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
            ),
            h: Oi,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          }),
          Di = (t, e) => (t + e / Ri) / e,
          Mi = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar(t) {
              const { n: e } = Fi,
                n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -Oi * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                i = n,
                o = BigInt("0x100000000000000000000000000000000"),
                a = Di(i * t, e),
                c = Di(-r * t, e);
              let l = fo(t - a * n - c * s, e),
                u = fo(-a * r - c * i, e);
              const h = l > o,
                d = u > o;
              if ((h && (l = e - l), d && (u = e - u), l > o || u > o))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
              return { k1neg: h, k1: l, k2neg: d, k2: u };
            },
          },
          zi = 32,
          ji = 32,
          $i = zi + 1,
          Gi = 2 * zi + 1;
        function Hi(t) {
          const { a: e, b: n } = Fi,
            r = fo(t * t),
            s = fo(r * t);
          return fo(s + e * t + n);
        }
        const Qi = Fi.a === Ti;
        class Vi extends Error {
          constructor(t) {
            super(t);
          }
        }
        function Ji(t) {
          if (!(t instanceof Wi)) throw new TypeError("JacobianPoint expected");
        }
        class Wi {
          constructor(t, e, n) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          static fromAffine(t) {
            if (!(t instanceof qi))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(qi.ZERO) ? Wi.ZERO : new Wi(t.x, t.y, Oi);
          }
          static toAffineBatch(t) {
            const e = (function (t, e = Fi.P) {
              const n = new Array(t.length),
                r = t.reduce(
                  (t, r, s) => (r === Ti ? t : ((n[s] = t), fo(t * r, e))),
                  Oi
                ),
                s = go(r, e);
              return (
                t.reduceRight(
                  (t, r, s) =>
                    r === Ti ? t : ((n[s] = fo(t * n[s], e)), fo(t * r, e)),
                  s
                ),
                n
              );
            })(t.map((t) => t.z));
            return t.map((t, n) => t.toAffine(e[n]));
          }
          static normalizeZ(t) {
            return Wi.toAffineBatch(t).map(Wi.fromAffine);
          }
          equals(t) {
            Ji(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: o } = t,
              a = fo(r * r),
              c = fo(o * o),
              l = fo(e * c),
              u = fo(s * a),
              h = fo(fo(n * o) * c),
              d = fo(fo(i * r) * a);
            return l === u && h === d;
          }
          negate() {
            return new Wi(this.x, fo(-this.y), this.z);
          }
          double() {
            const { x: t, y: e, z: n } = this,
              r = fo(t * t),
              s = fo(e * e),
              i = fo(s * s),
              o = t + s,
              a = fo(Ri * (fo(o * o) - r - i)),
              c = fo(Li * r),
              l = fo(c * c),
              u = fo(l - Ri * a),
              h = fo(c * (a - u) - Ui * i),
              d = fo(Ri * e * n);
            return new Wi(u, h, d);
          }
          add(t) {
            Ji(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: o } = t;
            if (s === Ti || i === Ti) return this;
            if (e === Ti || n === Ti) return t;
            const a = fo(r * r),
              c = fo(o * o),
              l = fo(e * c),
              u = fo(s * a),
              h = fo(fo(n * o) * c),
              d = fo(fo(i * r) * a),
              f = fo(u - l),
              p = fo(d - h);
            if (f === Ti) return p === Ti ? this.double() : Wi.ZERO;
            const g = fo(f * f),
              m = fo(f * g),
              y = fo(l * g),
              b = fo(p * p - m - Ri * y),
              w = fo(p * (y - b) - h * m),
              A = fo(r * o * f);
            return new Wi(b, w, A);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiplyUnsafe(t) {
            const e = Wi.ZERO;
            if ("bigint" == typeof t && t === Ti) return e;
            let n = ho(t);
            if (n === Oi) return this;
            if (!Qi) {
              let t = e,
                r = this;
              for (; n > Ti; )
                n & Oi && (t = t.add(r)), (r = r.double()), (n >>= Oi);
              return t;
            }
            let { k1neg: r, k1: s, k2neg: i, k2: o } = Mi.splitScalar(n),
              a = e,
              c = e,
              l = this;
            for (; s > Ti || o > Ti; )
              s & Oi && (a = a.add(l)),
                o & Oi && (c = c.add(l)),
                (l = l.double()),
                (s >>= Oi),
                (o >>= Oi);
            return (
              r && (a = a.negate()),
              i && (c = c.negate()),
              (c = new Wi(fo(c.x * Mi.beta), c.y, c.z)),
              a.add(c)
            );
          }
          precomputeWindow(t) {
            const e = Qi ? 128 / t + 1 : 256 / t + 1,
              n = [];
            let r = this,
              s = r;
            for (let i = 0; i < e; i++) {
              (s = r), n.push(s);
              for (let e = 1; e < 2 ** (t - 1); e++) (s = s.add(r)), n.push(s);
              r = s.double();
            }
            return n;
          }
          wNAF(t, e) {
            !e && this.equals(Wi.BASE) && (e = qi.BASE);
            const n = (e && e._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = e && _i.get(e);
            r ||
              ((r = this.precomputeWindow(n)),
              e && 1 !== n && ((r = Wi.normalizeZ(r)), _i.set(e, r)));
            let s = Wi.ZERO,
              i = Wi.BASE;
            const o = 1 + (Qi ? 128 / n : 256 / n),
              a = 2 ** (n - 1),
              c = BigInt(2 ** n - 1),
              l = 2 ** n,
              u = BigInt(n);
            for (let e = 0; e < o; e++) {
              const n = e * a;
              let o = Number(t & c);
              (t >>= u), o > a && ((o -= l), (t += Oi));
              const h = n,
                d = n + Math.abs(o) - 1,
                f = e % 2 != 0,
                p = o < 0;
              0 === o ? (i = i.add(Ki(f, r[h]))) : (s = s.add(Ki(p, r[d])));
            }
            return { p: s, f: i };
          }
          multiply(t, e) {
            let n,
              r,
              s = ho(t);
            if (Qi) {
              const { k1neg: t, k1: i, k2neg: o, k2: a } = Mi.splitScalar(s);
              let { p: c, f: l } = this.wNAF(i, e),
                { p: u, f: h } = this.wNAF(a, e);
              (c = Ki(t, c)),
                (u = Ki(o, u)),
                (u = new Wi(fo(u.x * Mi.beta), u.y, u.z)),
                (n = c.add(u)),
                (r = l.add(h));
            } else {
              const { p: t, f: i } = this.wNAF(s, e);
              (n = t), (r = i);
            }
            return Wi.normalizeZ([n, r])[0];
          }
          toAffine(t) {
            const { x: e, y: n, z: r } = this,
              s = this.equals(Wi.ZERO);
            null == t && (t = s ? Ui : go(r));
            const i = t,
              o = fo(i * i),
              a = fo(o * i),
              c = fo(e * o),
              l = fo(n * a),
              u = fo(r * i);
            if (s) return qi.ZERO;
            if (u !== Oi) throw new Error("invZ was invalid");
            return new qi(c, l);
          }
        }
        function Ki(t, e) {
          const n = e.negate();
          return t ? n : e;
        }
        (Wi.BASE = new Wi(Fi.Gx, Fi.Gy, Oi)), (Wi.ZERO = new Wi(Ti, Oi, Ti));
        const _i = new WeakMap();
        class qi {
          constructor(t, e) {
            (this.x = t), (this.y = e);
          }
          _setWindowSize(t) {
            (this._WINDOW_SIZE = t), _i.delete(this);
          }
          hasEvenY() {
            return this.y % Ri === Ti;
          }
          static fromCompressedHex(t) {
            const e = 32 === t.length,
              n = lo(e ? t : t.subarray(1));
            if (!vo(n)) throw new Error("Point is not on curve");
            let r = (function (t) {
              const { P: e } = Fi,
                n = BigInt(6),
                r = BigInt(11),
                s = BigInt(22),
                i = BigInt(23),
                o = BigInt(44),
                a = BigInt(88),
                c = (t * t * t) % e,
                l = (c * c * t) % e,
                u = (po(l, Li) * l) % e,
                h = (po(u, Li) * l) % e,
                d = (po(h, Ri) * c) % e,
                f = (po(d, r) * d) % e,
                p = (po(f, s) * f) % e,
                g = (po(p, o) * p) % e,
                m = (po(g, a) * g) % e,
                y = (po(m, o) * p) % e,
                b = (po(y, Li) * l) % e,
                w = (po(b, i) * f) % e,
                A = (po(w, n) * c) % e,
                v = po(A, Ri),
                x = (v * v) % e;
              if (x !== t) throw new Error("Cannot find square root");
              return v;
            })(Hi(n));
            const s = (r & Oi) === Oi;
            if (e) s && (r = fo(-r));
            else {
              (1 == (1 & t[0])) !== s && (r = fo(-r));
            }
            const i = new qi(n, r);
            return i.assertValidity(), i;
          }
          static fromUncompressedHex(t) {
            const e = lo(t.subarray(1, zi + 1)),
              n = lo(t.subarray(zi + 1, 2 * zi + 1)),
              r = new qi(e, n);
            return r.assertValidity(), r;
          }
          static fromHex(t) {
            const e = uo(t),
              n = e.length,
              r = e[0];
            if (n === zi) return this.fromCompressedHex(e);
            if (n === $i && (2 === r || 3 === r))
              return this.fromCompressedHex(e);
            if (n === Gi && 4 === r) return this.fromUncompressedHex(e);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${$i} compressed bytes or ${Gi} uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(t) {
            return qi.BASE.multiply(Eo(t));
          }
          static fromSignature(t, e, n) {
            const { r: r, s: s } = (function (t) {
              if (t instanceof Xi) return t.assertValidity(), t;
              try {
                return Xi.fromDER(t);
              } catch (e) {
                return Xi.fromCompact(t);
              }
            })(e);
            if (![0, 1, 2, 3].includes(n))
              throw new Error("Cannot recover: invalid recovery bit");
            const i = mo(uo(t)),
              { n: o } = Fi,
              a = 2 === n || 3 === n ? r + o : r,
              c = go(a, o),
              l = fo(-i * c, o),
              u = fo(s * c, o),
              h = 1 & n ? "03" : "02",
              d = qi.fromHex(h + so(a)),
              f = qi.BASE.multiplyAndAddUnsafe(d, l, u);
            if (!f)
              throw new Error("Cannot recover signature: point at infinify");
            return f.assertValidity(), f;
          }
          toRawBytes(t = !1) {
            return co(this.toHex(t));
          }
          toHex(t = !1) {
            const e = so(this.x);
            if (t) {
              return `${this.hasEvenY() ? "02" : "03"}${e}`;
            }
            return `04${e}${so(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const t = "Point is not on elliptic curve",
              { x: e, y: n } = this;
            if (!vo(e) || !vo(n)) throw new Error(t);
            const r = fo(n * n);
            if (fo(r - Hi(e)) !== Ti) throw new Error(t);
          }
          equals(t) {
            return this.x === t.x && this.y === t.y;
          }
          negate() {
            return new qi(this.x, fo(-this.y));
          }
          double() {
            return Wi.fromAffine(this).double().toAffine();
          }
          add(t) {
            return Wi.fromAffine(this).add(Wi.fromAffine(t)).toAffine();
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            return Wi.fromAffine(this).multiply(t, this).toAffine();
          }
          multiplyAndAddUnsafe(t, e, n) {
            const r = Wi.fromAffine(this),
              s =
                e === Ti || e === Oi || this !== qi.BASE
                  ? r.multiplyUnsafe(e)
                  : r.multiply(e),
              i = Wi.fromAffine(t).multiplyUnsafe(n),
              o = s.add(i);
            return o.equals(Wi.ZERO) ? void 0 : o.toAffine();
          }
        }
        function Yi(t) {
          return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t;
        }
        function Zi(t) {
          if (t.length < 2 || 2 !== t[0])
            throw new Error(`Invalid signature integer tag: ${no(t)}`);
          const e = t[1],
            n = t.subarray(2, e + 2);
          if (!e || n.length !== e)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: lo(n), left: t.subarray(e + 2) };
        }
        (qi.BASE = new qi(Fi.Gx, Fi.Gy)), (qi.ZERO = new qi(Ti, Ti));
        let Xi = class t {
          constructor(t, e) {
            (this.r = t), (this.s = e), this.assertValidity();
          }
          static fromCompact(e) {
            const n = e instanceof Uint8Array,
              r = "Signature.fromCompact";
            if ("string" != typeof e && !n)
              throw new TypeError(`${r}: Expected string or Uint8Array`);
            const s = n ? no(e) : e;
            if (128 !== s.length) throw new Error(`${r}: Expected 64-byte hex`);
            return new t(ao(s.slice(0, 64)), ao(s.slice(64, 128)));
          }
          static fromDER(e) {
            const n = e instanceof Uint8Array;
            if ("string" != typeof e && !n)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: r, s: s } = (function (t) {
              if (t.length < 2 || 48 != t[0])
                throw new Error(`Invalid signature tag: ${no(t)}`);
              if (t[1] !== t.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: e, left: n } = Zi(t.subarray(2)),
                { data: r, left: s } = Zi(n);
              if (s.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${no(s)}`
                );
              return { r: e, s: r };
            })(n ? e : co(e));
            return new t(r, s);
          }
          static fromHex(t) {
            return this.fromDER(t);
          }
          assertValidity() {
            const { r: t, s: e } = this;
            if (!Ao(t))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!Ao(e))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const t = Fi.n >> Oi;
            return this.s > t;
          }
          normalizeS() {
            return this.hasHighS() ? new t(this.r, fo(-this.s, Fi.n)) : this;
          }
          toDERRawBytes() {
            return co(this.toDERHex());
          }
          toDERHex() {
            const t = Yi(oo(this.s)),
              e = Yi(oo(this.r)),
              n = t.length / 2,
              r = e.length / 2,
              s = oo(n),
              i = oo(r);
            return `30${oo(r + n + 4)}02${i}${e}02${s}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return co(this.toCompactHex());
          }
          toCompactHex() {
            return so(this.r) + so(this.s);
          }
        };
        function to(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            n = new Uint8Array(e);
          for (let e = 0, r = 0; e < t.length; e++) {
            const s = t[e];
            n.set(s, r), (r += s.length);
          }
          return n;
        }
        const eo = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0")
        );
        function no(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let e = "";
          for (let n = 0; n < t.length; n++) e += eo[t[n]];
          return e;
        }
        const ro = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000"
        );
        function so(t) {
          if ("bigint" != typeof t) throw new Error("Expected bigint");
          if (!(Ti <= t && t < ro))
            throw new Error("Expected number 0 <= n < 2^256");
          return t.toString(16).padStart(64, "0");
        }
        function io(t) {
          const e = co(so(t));
          if (32 !== e.length) throw new Error("Error: expected 32 bytes");
          return e;
        }
        function oo(t) {
          const e = t.toString(16);
          return 1 & e.length ? `0${e}` : e;
        }
        function ao(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof t
            );
          return BigInt(`0x${t}`);
        }
        function co(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + t.length
            );
          const e = new Uint8Array(t.length / 2);
          for (let n = 0; n < e.length; n++) {
            const r = 2 * n,
              s = t.slice(r, r + 2),
              i = Number.parseInt(s, 16);
            if (Number.isNaN(i) || i < 0)
              throw new Error("Invalid byte sequence");
            e[n] = i;
          }
          return e;
        }
        function lo(t) {
          return ao(no(t));
        }
        function uo(t) {
          return t instanceof Uint8Array ? Uint8Array.from(t) : co(t);
        }
        function ho(t) {
          if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
          if ("bigint" == typeof t && Ao(t)) return t;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function fo(t, e = Fi.P) {
          const n = t % e;
          return n >= Ti ? n : e + n;
        }
        function po(t, e) {
          const { P: n } = Fi;
          let r = t;
          for (; e-- > Ti; ) (r *= r), (r %= n);
          return r;
        }
        function go(t, e = Fi.P) {
          if (t === Ti || e <= Ti)
            throw new Error(
              `invert: expected positive integers, got n=${t} mod=${e}`
            );
          let n = fo(t, e),
            r = e,
            s = Ti,
            i = Oi;
          for (; n !== Ti; ) {
            const t = r % n,
              e = s - i * (r / n);
            (r = n), (n = t), (s = i), (i = e);
          }
          if (r !== Oi) throw new Error("invert: does not exist");
          return fo(s, e);
        }
        function mo(t, e = !1) {
          const n = (function (t) {
            const e = 8 * t.length - 8 * ji,
              n = lo(t);
            return e > 0 ? n >> BigInt(e) : n;
          })(t);
          if (e) return n;
          const { n: r } = Fi;
          return n >= r ? n - r : n;
        }
        let yo, bo;
        class wo {
          constructor(t, e) {
            if (
              ((this.hashLen = t),
              (this.qByteLen = e),
              "number" != typeof t || t < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(t).fill(1)),
              (this.k = new Uint8Array(t).fill(0)),
              (this.counter = 0);
          }
          hmac(...t) {
            return Oo.hmacSha256(this.k, ...t);
          }
          hmacSync(...t) {
            return bo(this.k, ...t);
          }
          checkSync() {
            if ("function" != typeof bo)
              throw new Vi("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed(t = new Uint8Array()) {
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), t)),
              (this.v = await this.hmac(this.v)),
              0 !== t.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), t)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync(t = new Uint8Array()) {
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), t)),
              (this.v = this.hmacSync(this.v)),
              0 !== t.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), t)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return to(...e);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return to(...e);
          }
        }
        function Ao(t) {
          return Ti < t && t < Fi.n;
        }
        function vo(t) {
          return Ti < t && t < Fi.P;
        }
        function xo(t, e, n, r = !0) {
          const { n: s } = Fi,
            i = mo(t, !0);
          if (!Ao(i)) return;
          const o = go(i, s),
            a = qi.BASE.multiply(i),
            c = fo(a.x, s);
          if (c === Ti) return;
          const l = fo(o * fo(e + n * c, s), s);
          if (l === Ti) return;
          let u = new Xi(c, l),
            h = (a.x === u.r ? 0 : 2) | Number(a.y & Oi);
          return (
            r && u.hasHighS() && ((u = u.normalizeS()), (h ^= 1)),
            { sig: u, recovery: h }
          );
        }
        function Eo(t) {
          let e;
          if ("bigint" == typeof t) e = t;
          else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
          else if ("string" == typeof t) {
            if (t.length !== 2 * ji)
              throw new Error("Expected 32 bytes of private key");
            e = ao(t);
          } else {
            if (!(t instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (t.length !== ji)
              throw new Error("Expected 32 bytes of private key");
            e = lo(t);
          }
          if (!Ao(e)) throw new Error("Expected private key: 0 < key < n");
          return e;
        }
        function ko(t) {
          const e = t instanceof Uint8Array,
            n = "string" == typeof t,
            r = (e || n) && t.length;
          return e
            ? r === $i || r === Gi
            : n
            ? r === 2 * $i || r === 2 * Gi
            : t instanceof qi;
        }
        function Co(t, e, n = !1) {
          if (ko(t))
            throw new TypeError(
              "getSharedSecret: first arg must be private key"
            );
          if (!ko(e))
            throw new TypeError(
              "getSharedSecret: second arg must be public key"
            );
          const r =
            (s = e) instanceof qi ? (s.assertValidity(), s) : qi.fromHex(s);
          var s;
          return r.assertValidity(), r.multiply(Eo(t)).toRawBytes(n);
        }
        function Po(t) {
          return lo(t.length > zi ? t.slice(0, zi) : t);
        }
        function So(t) {
          const e = Po(t),
            n = fo(e, Fi.n);
          return Io(n < Ti ? e : n);
        }
        function Io(t) {
          return io(t);
        }
        function No(t, e, n = {}) {
          const {
              seed: r,
              m: s,
              d: i,
            } = (function (t, e, n) {
              if (null == t)
                throw new Error(
                  `sign: expected valid message hash, not "${t}"`
                );
              const r = uo(t),
                s = Eo(e),
                i = [Io(s), So(r)];
              if (null != n) {
                !0 === n && (n = Oo.randomBytes(zi));
                const t = uo(n);
                if (t.length !== zi)
                  throw new Error(`sign: Expected ${zi} bytes of extra data`);
                i.push(t);
              }
              return { seed: to(...i), m: Po(r), d: s };
            })(t, e, n.extraEntropy),
            o = new wo(32, ji);
          let a;
          for (
            o.reseedSync(r);
            !(a = xo(o.generateSync(), s, i, n.canonical));

          )
            o.reseedSync();
          return (function (t, e) {
            const { sig: n, recovery: r } = t,
              { der: s, recovered: i } = Object.assign(
                { canonical: !0, der: !0 },
                e
              ),
              o = s ? n.toDERRawBytes() : n.toCompactRawBytes();
            return i ? [o, r] : o;
          })(a, n);
        }
        qi.BASE._setWindowSize(8);
        const Bo = {
            node: Bi,
            web:
              "object" == typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          To = {},
          Oo = {
            bytesToHex: no,
            hexToBytes: co,
            concatBytes: to,
            mod: fo,
            invert: go,
            isValidPrivateKey(t) {
              try {
                return Eo(t), !0;
              } catch (t) {
                return !1;
              }
            },
            _bigintTo32Bytes: io,
            _normalizePrivateKey: Eo,
            hashToPrivateKey: (t) => {
              t = uo(t);
              const e = ji + 8;
              if (t.length < e || t.length > 1024)
                throw new Error(
                  "Expected valid bytes of private key as per FIPS 186"
                );
              return io(fo(lo(t), Fi.n - Oi) + Oi);
            },
            randomBytes: (t = 32) => {
              if (Bo.web) return Bo.web.getRandomValues(new Uint8Array(t));
              if (Bo.node) {
                const { randomBytes: e } = Bo.node;
                return Uint8Array.from(e(t));
              }
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            },
            randomPrivateKey: () => Oo.hashToPrivateKey(Oo.randomBytes(ji + 8)),
            precompute(t = 8, e = qi.BASE) {
              const n = e === qi.BASE ? e : new qi(e.x, e.y);
              return n._setWindowSize(t), n.multiply(Li), n;
            },
            sha256: async (...t) => {
              if (Bo.web) {
                const e = await Bo.web.subtle.digest("SHA-256", to(...t));
                return new Uint8Array(e);
              }
              if (Bo.node) {
                const { createHash: e } = Bo.node,
                  n = e("sha256");
                return (
                  t.forEach((t) => n.update(t)), Uint8Array.from(n.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async (t, ...e) => {
              if (Bo.web) {
                const n = await Bo.web.subtle.importKey(
                    "raw",
                    t,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"]
                  ),
                  r = to(...e),
                  s = await Bo.web.subtle.sign("HMAC", n, r);
                return new Uint8Array(s);
              }
              if (Bo.node) {
                const { createHmac: n } = Bo.node,
                  r = n("sha256", t);
                return (
                  e.forEach((t) => r.update(t)), Uint8Array.from(r.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async (t, ...e) => {
              let n = To[t];
              if (void 0 === n) {
                const e = await Oo.sha256(
                  Uint8Array.from(t, (t) => t.charCodeAt(0))
                );
                (n = to(e, e)), (To[t] = n);
              }
              return Oo.sha256(n, ...e);
            },
            taggedHashSync: (t, ...e) => {
              if ("function" != typeof yo)
                throw new Vi("sha256Sync is undefined, you need to set it");
              let n = To[t];
              if (void 0 === n) {
                const e = yo(Uint8Array.from(t, (t) => t.charCodeAt(0)));
                (n = to(e, e)), (To[t] = n);
              }
              return yo(n, ...e);
            },
            _JacobianPoint: Wi,
          };
        Object.defineProperties(Oo, {
          sha256Sync: {
            configurable: !1,
            get: () => yo,
            set(t) {
              yo || (yo = t);
            },
          },
          hmacSha256Sync: {
            configurable: !1,
            get: () => bo,
            set(t) {
              bo || (bo = t);
            },
          },
        });
        const Ro = "0x0000000000000000000000000000000000000000",
          Lo =
            "0x0000000000000000000000000000000000000000000000000000000000000000",
          Uo = BigInt(0),
          Fo = BigInt(1),
          Do = BigInt(2),
          Mo = BigInt(27),
          zo = BigInt(28),
          jo = BigInt(35),
          $o = {};
        function Go(t) {
          return yr(Br(t), 32);
        }
        class Ho {
          #D;
          #M;
          #z;
          #j;
          get r() {
            return this.#D;
          }
          set r(t) {
            sr(32 === gr(t), "invalid r", "value", t), (this.#D = fr(t));
          }
          get s() {
            return this.#M;
          }
          set s(t) {
            sr(32 === gr(t), "invalid s", "value", t);
            const e = fr(t);
            sr(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e),
              (this.#M = e);
          }
          get v() {
            return this.#z;
          }
          set v(t) {
            const e = Ir(t, "value");
            sr(27 === e || 28 === e, "invalid v", "v", t), (this.#z = e);
          }
          get networkV() {
            return this.#j;
          }
          get legacyChainId() {
            const t = this.networkV;
            return null == t ? null : Ho.getChainId(t);
          }
          get yParity() {
            return 27 === this.v ? 0 : 1;
          }
          get yParityAndS() {
            const t = lr(this.s);
            return this.yParity && (t[0] |= 128), fr(t);
          }
          get compactSerialized() {
            return pr([this.r, this.yParityAndS]);
          }
          get serialized() {
            return pr([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
          }
          constructor(t, e, n, r) {
            ar(t, $o, "Signature"),
              (this.#D = e),
              (this.#M = n),
              (this.#z = r),
              (this.#j = null);
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
          }
          clone() {
            const t = new Ho($o, this.r, this.s, this.v);
            return this.networkV && (t.#j = this.networkV), t;
          }
          toJSON() {
            const t = this.networkV;
            return {
              _type: "signature",
              networkV: null != t ? t.toString() : null,
              r: this.r,
              s: this.s,
              v: this.v,
            };
          }
          static getChainId(t) {
            const e = kr(t, "v");
            return e == Mo || e == zo
              ? Uo
              : (sr(e >= jo, "invalid EIP-155 v", "v", t), (e - jo) / Do);
          }
          static getChainIdV(t, e) {
            return kr(t) * Do + BigInt(35 + e - 27);
          }
          static getNormalizedV(t) {
            const e = kr(t);
            return e === Uo || e === Mo
              ? 27
              : e === Fo || e === zo
              ? 28
              : (sr(e >= jo, "invalid v", "v", t), e & Fo ? 27 : 28);
          }
          static from(t) {
            function e(e, n) {
              sr(e, n, "signature", t);
            }
            if (null == t) return new Ho($o, Lo, Lo, 27);
            if ("string" == typeof t) {
              const n = lr(t, "signature");
              if (64 === n.length) {
                const t = fr(n.slice(0, 32)),
                  e = n.slice(32, 64),
                  r = 128 & e[0] ? 28 : 27;
                return (e[0] &= 127), new Ho($o, t, fr(e), r);
              }
              if (65 === n.length) {
                const t = fr(n.slice(0, 32)),
                  r = n.slice(32, 64);
                e(0 == (128 & r[0]), "non-canonical s");
                const s = Ho.getNormalizedV(n[64]);
                return new Ho($o, t, fr(r), s);
              }
              e(!1, "invalid raw signature length");
            }
            if (t instanceof Ho) return t.clone();
            const n = t.r;
            e(null != n, "missing r");
            const r = Go(n),
              s = (function (t, n) {
                if (null != t) return Go(t);
                if (null != n) {
                  e(hr(n, 32), "invalid yParityAndS");
                  const t = lr(n);
                  return (t[0] &= 127), fr(t);
                }
                e(!1, "missing s");
              })(t.s, t.yParityAndS);
            e(0 == (128 & lr(s)[0]), "non-canonical s");
            const { networkV: i, v: o } = (function (t, n, r) {
                if (null != t) {
                  const e = kr(t);
                  return {
                    networkV: e >= jo ? e : void 0,
                    v: Ho.getNormalizedV(e),
                  };
                }
                if (null != n)
                  return (
                    e(hr(n, 32), "invalid yParityAndS"),
                    { v: 128 & lr(n)[0] ? 28 : 27 }
                  );
                if (null != r) {
                  switch (Ir(r, "sig.yParity")) {
                    case 0:
                      return { v: 27 };
                    case 1:
                      return { v: 28 };
                  }
                  e(!1, "invalid yParity");
                }
                e(!1, "missing v");
              })(t.v, t.yParityAndS, t.yParity),
              a = new Ho($o, r, s, o);
            return (
              i && (a.#j = i),
              e(
                null == t.yParity || Ir(t.yParity, "sig.yParity") === a.yParity,
                "yParity mismatch"
              ),
              e(
                null == t.yParityAndS || t.yParityAndS === a.yParityAndS,
                "yParityAndS mismatch"
              ),
              a
            );
          }
        }
        Oo.hmacSha256Sync = function (t, ...e) {
          return lr(ci("sha256", t, pr(e)));
        };
        class Qo {
          #$;
          constructor(t) {
            sr(32 === gr(t), "invalid private key", "privateKey", "[REDACTED]"),
              (this.#$ = fr(t));
          }
          get privateKey() {
            return this.#$;
          }
          get publicKey() {
            return Qo.computePublicKey(this.#$);
          }
          get compressedPublicKey() {
            return Qo.computePublicKey(this.#$, !0);
          }
          sign(t) {
            sr(32 === gr(t), "invalid digest length", "digest", t);
            const [e, n] = No(ur(t), ur(this.#$), {
                recovered: !0,
                canonical: !0,
              }),
              r = Xi.fromHex(e);
            return Ho.from({
              r: Nr("0x" + r.r.toString(16), 32),
              s: Nr("0x" + r.s.toString(16), 32),
              v: n ? 28 : 27,
            });
          }
          computeSharedSecret(t) {
            const e = Qo.computePublicKey(t);
            return fr(Co(ur(this.#$), lr(e)));
          }
          static computePublicKey(t, e) {
            let n = lr(t, "key");
            if (32 === n.length) {
              return fr(
                (function (t, e = !1) {
                  return qi.fromPrivateKey(t).toRawBytes(e);
                })(n, !!e)
              );
            }
            if (64 === n.length) {
              const t = new Uint8Array(65);
              (t[0] = 4), t.set(n, 1), (n = t);
            }
            return fr(qi.fromHex(n).toRawBytes(e));
          }
          static recoverPublicKey(t, e) {
            sr(32 === gr(t), "invalid digest length", "digest", t);
            const n = Ho.from(e),
              r = Xi.fromCompact(ur(pr([n.r, n.s]))).toDERRawBytes(),
              s = (function (t, e, n, r = !1) {
                return qi.fromSignature(t, e, n).toRawBytes(r);
              })(ur(t), r, n.yParity);
            return (
              sr(null != s, "invalid signautre for digest", "signature", e),
              fr(s)
            );
          }
          static addPoints(t, e, n) {
            const r = qi.fromHex(Qo.computePublicKey(t).substring(2)),
              s = qi.fromHex(Qo.computePublicKey(e).substring(2));
            return "0x" + r.add(s).toHex(!!n);
          }
        }
        const Vo = BigInt(0),
          Jo = BigInt(36);
        function Wo(t) {
          const e = (t = t.toLowerCase()).substring(2).split(""),
            n = new Uint8Array(40);
          for (let t = 0; t < 40; t++) n[t] = e[t].charCodeAt(0);
          const r = lr(Ni(n));
          for (let t = 0; t < 40; t += 2)
            r[t >> 1] >> 4 >= 8 && (e[t] = e[t].toUpperCase()),
              (15 & r[t >> 1]) >= 8 && (e[t + 1] = e[t + 1].toUpperCase());
          return "0x" + e.join("");
        }
        const Ko = {};
        for (let t = 0; t < 10; t++) Ko[String(t)] = String(t);
        for (let t = 0; t < 26; t++)
          Ko[String.fromCharCode(65 + t)] = String(10 + t);
        const _o = 15;
        const qo = (function () {
          const t = {};
          for (let e = 0; e < 36; e++) {
            t["0123456789abcdefghijklmnopqrstuvwxyz"[e]] = BigInt(e);
          }
          return t;
        })();
        function Yo(t) {
          if (
            (sr("string" == typeof t, "invalid address", "address", t),
            t.match(/^(0x)?[0-9a-fA-F]{40}$/))
          ) {
            t.startsWith("0x") || (t = "0x" + t);
            const e = Wo(t);
            return (
              sr(
                !t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t,
                "bad address checksum",
                "address",
                t
              ),
              e
            );
          }
          if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            sr(
              t.substring(2, 4) ===
                (function (t) {
                  let e = (t =
                    (t = t.toUpperCase()).substring(4) +
                    t.substring(0, 2) +
                    "00")
                    .split("")
                    .map((t) => Ko[t])
                    .join("");
                  for (; e.length >= _o; ) {
                    let t = e.substring(0, _o);
                    e = (parseInt(t, 10) % 97) + e.substring(t.length);
                  }
                  let n = String(98 - (parseInt(e, 10) % 97));
                  for (; n.length < 2; ) n = "0" + n;
                  return n;
                })(t),
              "bad icap checksum",
              "address",
              t
            );
            let e = (function (t) {
              t = t.toLowerCase();
              let e = Vo;
              for (let n = 0; n < t.length; n++) e = e * Jo + qo[t[n]];
              return e;
            })(t.substring(4)).toString(16);
            for (; e.length < 40; ) e = "0" + e;
            return Wo("0x" + e);
          }
          sr(!1, "invalid address", "address", t);
        }
        function Zo(t) {
          return t && "function" == typeof t.getAddress;
        }
        async function Xo(t, e) {
          const n = await e;
          return (
            (null != n && "0x0000000000000000000000000000000000000000" !== n) ||
              (rr(
                "string" != typeof t,
                "unconfigured name",
                "UNCONFIGURED_NAME",
                { value: t }
              ),
              sr(
                !1,
                "invalid AddressLike value; did not resolve to a value address",
                "target",
                t
              )),
            Yo(n)
          );
        }
        function ta(t, e) {
          return "string" == typeof t
            ? t.match(/^0x[0-9a-f]{40}$/i)
              ? Yo(t)
              : (rr(
                  null != e,
                  "ENS resolution requires a provider",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName" }
                ),
                Xo(t, e.resolveName(t)))
            : Zo(t)
            ? Xo(t, t.getAddress())
            : t && "function" == typeof t.then
            ? Xo(t, t)
            : void sr(!1, "unsupported addressable value", "target", t);
        }
        const ea = {};
        function na(t, e) {
          let n = !1;
          return (
            e < 0 && ((n = !0), (e *= -1)),
            new ia(ea, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e })
          );
        }
        function ra(t, e) {
          return new ia(ea, `bytes${e || ""}`, t, { size: e });
        }
        const sa = Symbol.for("_ethers_typed");
        class ia {
          type;
          value;
          #G;
          _typedSymbol;
          constructor(t, e, n, r) {
            null == r && (r = null),
              ar(ea, t, "Typed"),
              Zn(this, { _typedSymbol: sa, type: e, value: n }),
              (this.#G = r),
              this.format();
          }
          format() {
            if ("array" === this.type) throw new Error("");
            if ("dynamicArray" === this.type) throw new Error("");
            return "tuple" === this.type
              ? `tuple(${this.value.map((t) => t.format()).join(",")})`
              : this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return "string" === this.type;
          }
          get tupleName() {
            if ("tuple" !== this.type) throw TypeError("not a tuple");
            return this.#G;
          }
          get arrayLength() {
            if ("array" !== this.type) throw TypeError("not an array");
            return !0 === this.#G
              ? -1
              : !1 === this.#G
              ? this.value.length
              : null;
          }
          static from(t, e) {
            return new ia(ea, t, e);
          }
          static uint8(t) {
            return na(t, 8);
          }
          static uint16(t) {
            return na(t, 16);
          }
          static uint24(t) {
            return na(t, 24);
          }
          static uint32(t) {
            return na(t, 32);
          }
          static uint40(t) {
            return na(t, 40);
          }
          static uint48(t) {
            return na(t, 48);
          }
          static uint56(t) {
            return na(t, 56);
          }
          static uint64(t) {
            return na(t, 64);
          }
          static uint72(t) {
            return na(t, 72);
          }
          static uint80(t) {
            return na(t, 80);
          }
          static uint88(t) {
            return na(t, 88);
          }
          static uint96(t) {
            return na(t, 96);
          }
          static uint104(t) {
            return na(t, 104);
          }
          static uint112(t) {
            return na(t, 112);
          }
          static uint120(t) {
            return na(t, 120);
          }
          static uint128(t) {
            return na(t, 128);
          }
          static uint136(t) {
            return na(t, 136);
          }
          static uint144(t) {
            return na(t, 144);
          }
          static uint152(t) {
            return na(t, 152);
          }
          static uint160(t) {
            return na(t, 160);
          }
          static uint168(t) {
            return na(t, 168);
          }
          static uint176(t) {
            return na(t, 176);
          }
          static uint184(t) {
            return na(t, 184);
          }
          static uint192(t) {
            return na(t, 192);
          }
          static uint200(t) {
            return na(t, 200);
          }
          static uint208(t) {
            return na(t, 208);
          }
          static uint216(t) {
            return na(t, 216);
          }
          static uint224(t) {
            return na(t, 224);
          }
          static uint232(t) {
            return na(t, 232);
          }
          static uint240(t) {
            return na(t, 240);
          }
          static uint248(t) {
            return na(t, 248);
          }
          static uint256(t) {
            return na(t, 256);
          }
          static uint(t) {
            return na(t, 256);
          }
          static int8(t) {
            return na(t, -8);
          }
          static int16(t) {
            return na(t, -16);
          }
          static int24(t) {
            return na(t, -24);
          }
          static int32(t) {
            return na(t, -32);
          }
          static int40(t) {
            return na(t, -40);
          }
          static int48(t) {
            return na(t, -48);
          }
          static int56(t) {
            return na(t, -56);
          }
          static int64(t) {
            return na(t, -64);
          }
          static int72(t) {
            return na(t, -72);
          }
          static int80(t) {
            return na(t, -80);
          }
          static int88(t) {
            return na(t, -88);
          }
          static int96(t) {
            return na(t, -96);
          }
          static int104(t) {
            return na(t, -104);
          }
          static int112(t) {
            return na(t, -112);
          }
          static int120(t) {
            return na(t, -120);
          }
          static int128(t) {
            return na(t, -128);
          }
          static int136(t) {
            return na(t, -136);
          }
          static int144(t) {
            return na(t, -144);
          }
          static int152(t) {
            return na(t, -152);
          }
          static int160(t) {
            return na(t, -160);
          }
          static int168(t) {
            return na(t, -168);
          }
          static int176(t) {
            return na(t, -176);
          }
          static int184(t) {
            return na(t, -184);
          }
          static int192(t) {
            return na(t, -192);
          }
          static int200(t) {
            return na(t, -200);
          }
          static int208(t) {
            return na(t, -208);
          }
          static int216(t) {
            return na(t, -216);
          }
          static int224(t) {
            return na(t, -224);
          }
          static int232(t) {
            return na(t, -232);
          }
          static int240(t) {
            return na(t, -240);
          }
          static int248(t) {
            return na(t, -248);
          }
          static int256(t) {
            return na(t, -256);
          }
          static int(t) {
            return na(t, -256);
          }
          static bytes1(t) {
            return ra(t, 1);
          }
          static bytes2(t) {
            return ra(t, 2);
          }
          static bytes3(t) {
            return ra(t, 3);
          }
          static bytes4(t) {
            return ra(t, 4);
          }
          static bytes5(t) {
            return ra(t, 5);
          }
          static bytes6(t) {
            return ra(t, 6);
          }
          static bytes7(t) {
            return ra(t, 7);
          }
          static bytes8(t) {
            return ra(t, 8);
          }
          static bytes9(t) {
            return ra(t, 9);
          }
          static bytes10(t) {
            return ra(t, 10);
          }
          static bytes11(t) {
            return ra(t, 11);
          }
          static bytes12(t) {
            return ra(t, 12);
          }
          static bytes13(t) {
            return ra(t, 13);
          }
          static bytes14(t) {
            return ra(t, 14);
          }
          static bytes15(t) {
            return ra(t, 15);
          }
          static bytes16(t) {
            return ra(t, 16);
          }
          static bytes17(t) {
            return ra(t, 17);
          }
          static bytes18(t) {
            return ra(t, 18);
          }
          static bytes19(t) {
            return ra(t, 19);
          }
          static bytes20(t) {
            return ra(t, 20);
          }
          static bytes21(t) {
            return ra(t, 21);
          }
          static bytes22(t) {
            return ra(t, 22);
          }
          static bytes23(t) {
            return ra(t, 23);
          }
          static bytes24(t) {
            return ra(t, 24);
          }
          static bytes25(t) {
            return ra(t, 25);
          }
          static bytes26(t) {
            return ra(t, 26);
          }
          static bytes27(t) {
            return ra(t, 27);
          }
          static bytes28(t) {
            return ra(t, 28);
          }
          static bytes29(t) {
            return ra(t, 29);
          }
          static bytes30(t) {
            return ra(t, 30);
          }
          static bytes31(t) {
            return ra(t, 31);
          }
          static bytes32(t) {
            return ra(t, 32);
          }
          static address(t) {
            return new ia(ea, "address", t);
          }
          static bool(t) {
            return new ia(ea, "bool", !!t);
          }
          static bytes(t) {
            return new ia(ea, "bytes", t);
          }
          static string(t) {
            return new ia(ea, "string", t);
          }
          static array(t, e) {
            throw new Error("not implemented yet");
          }
          static tuple(t, e) {
            throw new Error("not implemented yet");
          }
          static overrides(t) {
            return new ia(ea, "overrides", Object.assign({}, t));
          }
          static isTyped(t) {
            return (
              t &&
              "object" == typeof t &&
              "_typedSymbol" in t &&
              t._typedSymbol === sa
            );
          }
          static dereference(t, e) {
            if (ia.isTyped(t)) {
              if (t.type !== e)
                throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
              return t.value;
            }
            return t;
          }
        }
        class oa extends Cs {
          constructor(t) {
            super("address", "address", t, !1);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(t, e) {
            let n = ia.dereference(e, "string");
            try {
              n = Yo(n);
            } catch (t) {
              return this._throwError(t.message, e);
            }
            return t.writeValue(n);
          }
          decode(t) {
            return Yo(Nr(t.readValue(), 20));
          }
        }
        class aa extends Cs {
          coder;
          constructor(t) {
            super(t.name, t.type, "_", t.dynamic), (this.coder = t);
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(t, e) {
            return this.coder.encode(t, e);
          }
          decode(t) {
            return this.coder.decode(t);
          }
        }
        function ca(t, e, n) {
          let r = [];
          if (Array.isArray(n)) r = n;
          else if (n && "object" == typeof n) {
            let t = {};
            r = e.map((e) => {
              const r = e.localName;
              return (
                rr(
                  r,
                  "cannot encode object for signature with missing names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                rr(
                  !t[r],
                  "cannot encode object for signature with duplicate names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                (t[r] = !0),
                n[r]
              );
            });
          } else sr(!1, "invalid tuple value", "tuple", n);
          sr(e.length === r.length, "types/value length mismatch", "tuple", n);
          let s = new Ps(),
            i = new Ps(),
            o = [];
          e.forEach((t, e) => {
            let n = r[e];
            if (t.dynamic) {
              let e = i.length;
              t.encode(i, n);
              let r = s.writeUpdatableValue();
              o.push((t) => {
                r(t + e);
              });
            } else t.encode(s, n);
          }),
            o.forEach((t) => {
              t(s.length);
            });
          let a = t.appendWriter(s);
          return (a += t.appendWriter(i)), a;
        }
        function la(t, e) {
          let n = [],
            r = [],
            s = t.subReader(0);
          return (
            e.forEach((e) => {
              let i = null;
              if (e.dynamic) {
                let n = t.readIndex(),
                  r = s.subReader(n);
                try {
                  i = e.decode(r);
                } catch (t) {
                  if (tr(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              } else
                try {
                  i = e.decode(t);
                } catch (t) {
                  if (tr(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              if (null == i) throw new Error("investigate");
              n.push(i), r.push(e.localName || null);
            }),
            Es.fromItems(n, r)
          );
        }
        class ua extends Cs {
          coder;
          length;
          constructor(t, e, n) {
            super(
              "array",
              t.type + "[" + (e >= 0 ? e : "") + "]",
              n,
              -1 === e || t.dynamic
            ),
              Zn(this, { coder: t, length: e });
          }
          defaultValue() {
            const t = this.coder.defaultValue(),
              e = [];
            for (let n = 0; n < this.length; n++) e.push(t);
            return e;
          }
          encode(t, e) {
            const n = ia.dereference(e, "array");
            Array.isArray(n) || this._throwError("expected array value", n);
            let r = this.length;
            -1 === r && ((r = n.length), t.writeValue(n.length)),
              ir(
                n.length,
                r,
                "coder array" + (this.localName ? " " + this.localName : "")
              );
            let s = [];
            for (let t = 0; t < n.length; t++) s.push(this.coder);
            return ca(t, s, n);
          }
          decode(t) {
            let e = this.length;
            -1 === e &&
              ((e = t.readIndex()),
              rr(
                e * bs <= t.dataLength,
                "insufficient data length",
                "BUFFER_OVERRUN",
                { buffer: t.bytes, offset: e * bs, length: t.dataLength }
              ));
            let n = [];
            for (let t = 0; t < e; t++) n.push(new aa(this.coder));
            return la(t, n);
          }
        }
        class ha extends Cs {
          constructor(t) {
            super("bool", "bool", t, !1);
          }
          defaultValue() {
            return !1;
          }
          encode(t, e) {
            const n = ia.dereference(e, "bool");
            return t.writeValue(n ? 1 : 0);
          }
          decode(t) {
            return !!t.readValue();
          }
        }
        class da extends Cs {
          constructor(t, e) {
            super(t, t, e, !0);
          }
          defaultValue() {
            return "0x";
          }
          encode(t, e) {
            e = ur(e);
            let n = t.writeValue(e.length);
            return (n += t.writeBytes(e)), n;
          }
          decode(t) {
            return t.readBytes(t.readIndex(), !0);
          }
        }
        class fa extends da {
          constructor(t) {
            super("bytes", t);
          }
          decode(t) {
            return fr(super.decode(t));
          }
        }
        class pa extends Cs {
          size;
          constructor(t, e) {
            let n = "bytes" + String(t);
            super(n, n, e, !1), Zn(this, { size: t }, { size: "number" });
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + 2 * this.size
            );
          }
          encode(t, e) {
            let n = ur(ia.dereference(e, this.type));
            return (
              n.length !== this.size &&
                this._throwError("incorrect data length", e),
              t.writeBytes(n)
            );
          }
          decode(t) {
            return fr(t.readBytes(this.size));
          }
        }
        const ga = new Uint8Array([]);
        class ma extends Cs {
          constructor(t) {
            super("null", "", t, !1);
          }
          defaultValue() {
            return null;
          }
          encode(t, e) {
            return (
              null != e && this._throwError("not null", e), t.writeBytes(ga)
            );
          }
          decode(t) {
            return t.readBytes(0), null;
          }
        }
        const ya = BigInt(0),
          ba = BigInt(1),
          wa = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        class Aa extends Cs {
          size;
          signed;
          constructor(t, e, n) {
            const r = (e ? "int" : "uint") + 8 * t;
            super(r, r, n, !1),
              Zn(
                this,
                { size: t, signed: e },
                { size: "number", signed: "boolean" }
              );
          }
          defaultValue() {
            return 0;
          }
          encode(t, e) {
            let n = kr(ia.dereference(e, this.type)),
              r = Er(wa, 256);
            if (this.signed) {
              let t = Er(r, 8 * this.size - 1);
              (n > t || n < -(t + ba)) &&
                this._throwError("value out-of-bounds", e),
                (n = xr(n, 256));
            } else
              (n < ya || n > Er(r, 8 * this.size)) &&
                this._throwError("value out-of-bounds", e);
            return t.writeValue(n);
          }
          decode(t) {
            let e = Er(t.readValue(), 8 * this.size);
            return this.signed && (e = vr(e, 8 * this.size)), e;
          }
        }
        class va extends da {
          constructor(t) {
            super("string", t);
          }
          defaultValue() {
            return "";
          }
          encode(t, e) {
            return super.encode(t, Fr(ia.dereference(e, "string")));
          }
          decode(t) {
            return Dr(super.decode(t));
          }
        }
        class xa extends Cs {
          coders;
          constructor(t, e) {
            let n = !1;
            const r = [];
            t.forEach((t) => {
              t.dynamic && (n = !0), r.push(t.type);
            });
            super("tuple", "tuple(" + r.join(",") + ")", e, n),
              Zn(this, { coders: Object.freeze(t.slice()) });
          }
          defaultValue() {
            const t = [];
            this.coders.forEach((e) => {
              t.push(e.defaultValue());
            });
            const e = this.coders.reduce((t, e) => {
              const n = e.localName;
              return n && (t[n] || (t[n] = 0), t[n]++), t;
            }, {});
            return (
              this.coders.forEach((n, r) => {
                let s = n.localName;
                s &&
                  1 === e[s] &&
                  ("length" === s && (s = "_length"),
                  null == t[s] && (t[s] = t[r]));
              }),
              Object.freeze(t)
            );
          }
          encode(t, e) {
            const n = ia.dereference(e, "tuple");
            return ca(t, this.coders, n);
          }
          decode(t) {
            return la(t, this.coders);
          }
        }
        function Ea(t) {
          return Ni(Fr(t));
        }
        function ka(t) {
          return (function (t) {
            let e = 0;
            return () => t[e++];
          })(
            (function (t) {
              let e = 0;
              function n() {
                return (t[e++] << 8) | t[e++];
              }
              let r = n(),
                s = 1,
                i = [0, 1];
              for (let t = 1; t < r; t++) i.push((s += n()));
              let o = n(),
                a = e;
              e += o;
              let c = 0,
                l = 0;
              function u() {
                return (
                  0 == c && ((l = (l << 8) | t[e++]), (c = 8)), (l >> --c) & 1
                );
              }
              const h = 2 ** 31,
                d = h >>> 1,
                f = h - 1;
              let p = 0;
              for (let t = 0; t < 31; t++) p = (p << 1) | u();
              let g = [],
                m = 0,
                y = h;
              for (;;) {
                let t = Math.floor(((p - m + 1) * s - 1) / y),
                  e = 0,
                  n = r;
                for (; n - e > 1; ) {
                  let r = (e + n) >>> 1;
                  t < i[r] ? (n = r) : (e = r);
                }
                if (0 == e) break;
                g.push(e);
                let o = m + Math.floor((y * i[e]) / s),
                  a = m + Math.floor((y * i[e + 1]) / s) - 1;
                for (; 0 == ((o ^ a) & d); )
                  (p = ((p << 1) & f) | u()),
                    (o = (o << 1) & f),
                    (a = ((a << 1) & f) | 1);
                for (; o & ~a & 536870912; )
                  (p = (p & d) | ((p << 1) & (f >>> 1)) | u()),
                    (o = (o << 1) ^ d),
                    (a = ((a ^ d) << 1) | d | 1);
                (m = o), (y = 1 + a - o);
              }
              let b = r - 4;
              return g.map((e) => {
                switch (e - b) {
                  case 3:
                    return (
                      b + 65792 + ((t[a++] << 16) | (t[a++] << 8) | t[a++])
                    );
                  case 2:
                    return b + 256 + ((t[a++] << 8) | t[a++]);
                  case 1:
                    return b + t[a++];
                  default:
                    return e - 1;
                }
              });
            })(
              (function (t) {
                let e = [];
                [
                  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                ].forEach((t, n) => (e[t.charCodeAt(0)] = n));
                let n = t.length,
                  r = new Uint8Array((6 * n) >> 3);
                for (let s = 0, i = 0, o = 0, a = 0; s < n; s++)
                  (a = (a << 6) | e[t.charCodeAt(s)]),
                    (o += 6),
                    o >= 8 && (r[i++] = a >> (o -= 8));
                return r;
              })(t)
            )
          );
        }
        function Ca(t) {
          return 1 & t ? ~t >> 1 : t >> 1;
        }
        function Pa(t, e) {
          let n = Array(t);
          for (let r = 0, s = 0; r < t; r++) n[r] = s += Ca(e());
          return n;
        }
        function Sa(t, e = 0) {
          let n = [];
          for (;;) {
            let r = t(),
              s = t();
            if (!s) break;
            e += r;
            for (let t = 0; t < s; t++) n.push(e + t);
            e += s + 1;
          }
          return n;
        }
        function Ia(t) {
          return Ba(() => {
            let e = Sa(t);
            if (e.length) return e;
          });
        }
        function Na(t) {
          let e = [];
          for (;;) {
            let n = t();
            if (0 == n) break;
            e.push(Oa(n, t));
          }
          for (;;) {
            let n = t() - 1;
            if (n < 0) break;
            e.push(Ra(n, t));
          }
          return e.flat();
        }
        function Ba(t) {
          let e = [];
          for (;;) {
            let n = t(e.length);
            if (!n) break;
            e.push(n);
          }
          return e;
        }
        function Ta(t, e, n) {
          let r = Array(t)
            .fill()
            .map(() => []);
          for (let s = 0; s < e; s++) Pa(t, n).forEach((t, e) => r[e].push(t));
          return r;
        }
        function Oa(t, e) {
          let n = 1 + e(),
            r = e(),
            s = Ba(e);
          return Ta(s.length, 1 + t, e).flatMap((t, e) => {
            let [i, ...o] = t;
            return Array(s[e])
              .fill()
              .map((t, e) => {
                let s = e * r;
                return [i + e * n, o.map((t) => t + s)];
              });
          });
        }
        function Ra(t, e) {
          return Ta(1 + e(), 1 + t, e).map((t) => [t[0], t.slice(1)]);
        }
        var La = ka(
          "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"
        );
        const Ua = new Map([
            [8217, "apostrophe"],
            [8260, "fraction slash"],
            [12539, "middle dot"],
          ]),
          Fa = 4;
        function Da(t) {
          return `{${(function (t) {
            return t.toString(16).toUpperCase().padStart(2, "0");
          })(t)}}`;
        }
        function Ma(t) {
          let e = t.length;
          if (e < 4096) return String.fromCodePoint(...t);
          let n = [];
          for (let r = 0; r < e; )
            n.push(String.fromCodePoint(...t.slice(r, (r += 4096))));
          return n.join("");
        }
        var za = ka(
          "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"
        );
        function ja(t) {
          return (t >> 24) & 255;
        }
        function $a(t) {
          return 16777215 & t;
        }
        const Ga = new Map(
            Ia(za).flatMap((t, e) => t.map((t) => [t, (e + 1) << 24]))
          ),
          Ha = new Set(Sa(za)),
          Qa = new Map(),
          Va = new Map();
        for (let [t, e] of Na(za)) {
          if (!Ha.has(t) && 2 == e.length) {
            let [n, r] = e,
              s = Va.get(n);
            s || ((s = new Map()), Va.set(n, s)), s.set(r, t);
          }
          Qa.set(t, e.reverse());
        }
        const Ja = 44032,
          Wa = 4352,
          Ka = 4449,
          _a = 4519,
          qa = 28,
          Ya = 21 * qa,
          Za = Ja + 19 * Ya,
          Xa = Wa + 19,
          tc = Ka + 21,
          ec = _a + qa;
        function nc(t) {
          return t >= Ja && t < Za;
        }
        function rc(t, e) {
          if (t >= Wa && t < Xa && e >= Ka && e < tc)
            return Ja + (t - Wa) * Ya + (e - Ka) * qa;
          if (nc(t) && e > _a && e < ec && (t - Ja) % qa == 0)
            return t + (e - _a);
          {
            let n = Va.get(t);
            return n && ((n = n.get(e)), n) ? n : -1;
          }
        }
        function sc(t) {
          let e = [],
            n = [],
            r = !1;
          function s(t) {
            let n = Ga.get(t);
            n && ((r = !0), (t |= n)), e.push(t);
          }
          for (let r of t)
            for (;;) {
              if (r < 128) e.push(r);
              else if (nc(r)) {
                let t = r - Ja,
                  e = ((t % Ya) / qa) | 0,
                  n = t % qa;
                s(Wa + ((t / Ya) | 0)), s(Ka + e), n > 0 && s(_a + n);
              } else {
                let t = Qa.get(r);
                t ? n.push(...t) : s(r);
              }
              if (!n.length) break;
              r = n.pop();
            }
          if (r && e.length > 1) {
            let t = ja(e[0]);
            for (let n = 1; n < e.length; n++) {
              let r = ja(e[n]);
              if (0 == r || t <= r) {
                t = r;
                continue;
              }
              let s = n - 1;
              for (;;) {
                let n = e[s + 1];
                if (((e[s + 1] = e[s]), (e[s] = n), !s)) break;
                if (((t = ja(e[--s])), t <= r)) break;
              }
              t = ja(e[n]);
            }
          }
          return e;
        }
        function ic(t) {
          return sc(t).map($a);
        }
        function oc(t) {
          return (function (t) {
            let e = [],
              n = [],
              r = -1,
              s = 0;
            for (let i of t) {
              let t = ja(i),
                o = $a(i);
              if (-1 == r) 0 == t ? (r = o) : e.push(o);
              else if (s > 0 && s >= t)
                0 == t ? (e.push(r, ...n), (n.length = 0), (r = o)) : n.push(o),
                  (s = t);
              else {
                let i = rc(r, o);
                i >= 0
                  ? (r = i)
                  : 0 == s && 0 == t
                  ? (e.push(r), (r = o))
                  : (n.push(o), (s = t));
              }
            }
            return r >= 0 && e.push(r, ...n), e;
          })(sc(t));
        }
        const ac = 65039,
          cc = ".",
          lc = 1,
          uc = 45;
        function hc() {
          return new Set(Sa(La));
        }
        const dc = new Map(Na(La)),
          fc = hc(),
          pc = hc(),
          gc = new Set(
            Sa(La).map(
              function (t) {
                return this[t];
              },
              [...pc]
            )
          ),
          mc = hc();
        hc();
        const yc = Ia(La);
        function bc() {
          return new Set([Sa(La).map((t) => yc[t]), Sa(La)].flat(2));
        }
        const wc = La(),
          Ac = Ba((t) => {
            let e = Ba(La).map((t) => t + 96);
            if (e.length) {
              let n = t >= wc;
              (e[0] -= 32), (e = Ma(e)), n && (e = `Restricted[${e}]`);
              let r = bc(),
                s = bc(),
                i = [...r, ...s].sort((t, e) => t - e);
              return { N: e, P: r, M: !La(), R: n, V: new Set(i) };
            }
          }),
          vc = hc(),
          xc = new Map();
        [...vc, ...hc()]
          .sort((t, e) => t - e)
          .map((t, e, n) => {
            let r = La(),
              s = (n[e] = r ? n[e - r] : { V: [], M: new Map() });
            s.V.push(t), vc.has(t) || xc.set(t, s);
          });
        for (let { V: t, M: e } of new Set(xc.values())) {
          let n = [];
          for (let e of t) {
            let t = Ac.filter((t) => t.V.has(e)),
              r = n.find(({ G: e }) => t.some((t) => e.has(t)));
            r || ((r = { G: new Set(), V: [] }), n.push(r)),
              r.V.push(e),
              t.forEach((t) => r.G.add(t));
          }
          let r = n.flatMap(({ G: t }) => [...t]);
          for (let { G: t, V: s } of n) {
            let n = new Set(r.filter((e) => !t.has(e)));
            for (let t of s) e.set(t, n);
          }
        }
        let Ec = new Set(),
          kc = new Set();
        for (let t of Ac) for (let e of t.V) (Ec.has(e) ? kc : Ec).add(e);
        for (let t of Ec) xc.has(t) || kc.has(t) || xc.set(t, lc);
        const Cc = new Set([...Ec, ...ic(Ec)]),
          Pc = Sa(La),
          Sc = (function t(e) {
            let n = Ba(() => {
                let e = Sa(La).map((t) => Pc[t]);
                if (e.length) return t(e);
              }).sort((t, e) => e.Q.size - t.Q.size),
              r = La(),
              s = r % 3;
            r = (r / 3) | 0;
            let i = 1 & r;
            r >>= 1;
            let o = 1 & r,
              a = 2 & r;
            return { B: n, V: s, F: i, S: o, C: a, Q: new Set(e) };
          })([]);
        class Ic extends Array {
          get is_emoji() {
            return !0;
          }
        }
        function Nc(t, e = Da) {
          let n = [];
          var r;
          (r = t[0]), pc.has(r) && n.push("");
          let s = 0,
            i = t.length;
          for (let r = 0; r < i; r++) {
            let i = t[r];
            Rc(i) && (n.push(Ma(t.slice(s, r))), n.push(e(i)), (s = r + 1));
          }
          return n.push(Ma(t.slice(s, i))), n.join("");
        }
        function Bc(t) {
          return (Rc(t) ? "" : `${Tc(Nc([t]))} `) + Da(t);
        }
        function Tc(t) {
          return `"${t}"`;
        }
        function Oc(t) {
          for (let e = t.lastIndexOf(95); e > 0; )
            if (95 !== t[--e])
              throw new Error("underscore allowed only at start");
        }
        function Rc(t) {
          return mc.has(t);
        }
        function Lc(t) {
          return (function (t) {
            return t
              .map(({ input: e, error: n, output: r }) => {
                if (n) {
                  let r = n.message;
                  throw new Error(
                    1 == t.length ? r : `Invalid label ${Tc(Nc(e))}: ${r}`
                  );
                }
                return Ma(r);
              })
              .join(cc);
          })(
            (function (t, e) {
              let n = 0;
              return t.split(cc).map((t) => {
                let r,
                  s = (function (t) {
                    let e = [];
                    for (let n = 0, r = t.length; n < r; ) {
                      let r = t.codePointAt(n);
                      (n += r < 65536 ? 1 : 2), e.push(r);
                    }
                    return e;
                  })(t),
                  i = { input: s, offset: n };
                n += s.length + 1;
                try {
                  let t,
                    n = (i.tokens = (function (t, e) {
                      let n = [],
                        r = [];
                      t = t.slice().reverse();
                      for (; t.length; ) {
                        let s = Mc(t);
                        if (s) r.length && (n.push(e(r)), (r = [])), n.push(s);
                        else {
                          let e = t.pop();
                          if (Cc.has(e)) r.push(e);
                          else {
                            let t = dc.get(e);
                            if (t) r.push(...t);
                            else if (!fc.has(e)) throw Uc(e);
                          }
                        }
                      }
                      r.length && n.push(e(r));
                      return n;
                    })(s, oc)),
                    o = n.length;
                  if (!o) throw new Error("empty label");
                  {
                    let s = n[0],
                      a = o > 1 || s.is_emoji;
                    if (!a && s.every((t) => t < 128))
                      (r = s),
                        Oc(r),
                        (function (t) {
                          if (t.length >= 4 && t[2] == uc && t[3] == uc)
                            throw new Error("invalid label extension");
                        })(r),
                        (t = "ASCII");
                    else if (
                      (a &&
                        ((i.emoji = !0),
                        (s = n.flatMap((t) => (t.is_emoji ? [] : t)))),
                      (r = n.flatMap((t) =>
                        !e && t.is_emoji ? t.filter((t) => t != ac) : t
                      )),
                      Oc(r),
                      s.length)
                    ) {
                      if (pc.has(r[0])) throw Dc("leading combining mark");
                      for (let t = 1; t < o; t++) {
                        let e = n[t];
                        if (!e.is_emoji && pc.has(e[0]))
                          throw Dc(
                            `emoji + combining mark: "${Ma(n[t - 1])} + ${Nc([
                              e[0],
                            ])}"`
                          );
                      }
                      !(function (t) {
                        let e = t[0],
                          n = Ua.get(e);
                        if (n) throw Dc(`leading ${n}`);
                        let r = t.length,
                          s = -1;
                        for (let i = 1; i < r; i++) {
                          e = t[i];
                          let r = Ua.get(e);
                          if (r) {
                            if (s == i) throw Dc(`${n} + ${r}`);
                            (s = i + 1), (n = r);
                          }
                        }
                        if (s == r) throw Dc(`trailing ${n}`);
                      })(r);
                      let e = [...new Set(s)],
                        [i] = (function (t) {
                          let e = Ac;
                          for (let n of t) {
                            let t = e.filter((t) => t.V.has(n));
                            if (!t.length) throw e === Ac ? Uc(n) : Fc(e[0], n);
                            if (((e = t), 1 == t.length)) break;
                          }
                          return e;
                        })(e);
                      !(function (t, e) {
                        let { V: n, M: r } = t;
                        for (let r of e) if (!n.has(r)) throw Fc(t, r);
                        if (r) {
                          let t = ic(e);
                          for (let e = 1, n = t.length; e < n; e++)
                            if (gc.has(t[e])) {
                              let r = e + 1;
                              for (let s; r < n && gc.has((s = t[r])); r++)
                                for (let n = e; n < r; n++)
                                  if (t[n] == s)
                                    throw new Error(
                                      `non-spacing marks: repeated ${Bc(s)}`
                                    );
                              if (r - e > Fa)
                                throw new Error(
                                  `non-spacing marks: too many ${Tc(
                                    Nc(t.slice(e - 1, r))
                                  )} (${r - e}/${Fa})`
                                );
                              e = r;
                            }
                        }
                      })(i, s),
                        (function (t, e) {
                          let n,
                            r = [];
                          for (let t of e) {
                            let e = xc.get(t);
                            if (e === lc) return;
                            if (e) {
                              let r = e.M.get(t);
                              if (
                                ((n = n ? n.filter((t) => r.has(t)) : [...r]),
                                !n.length)
                              )
                                return;
                            } else r.push(t);
                          }
                          if (n)
                            for (let e of n)
                              if (r.every((t) => e.V.has(t)))
                                throw new Error(
                                  `whole-script confusable: ${t.N}/${e.N}`
                                );
                        })(i, e),
                        (t = i.N);
                    } else t = "Emoji";
                  }
                  i.type = t;
                } catch (t) {
                  i.error = t;
                }
                return (i.output = r), i;
              });
            })(t)
          );
        }
        function Uc(t) {
          return new Error(`disallowed character: ${Bc(t)}`);
        }
        function Fc(t, e) {
          let n = Bc(e),
            r = Ac.find((t) => t.P.has(e));
          return (
            r && (n = `${r.N} ${n}`),
            new Error(`illegal mixture: ${t.N} + ${n}`)
          );
        }
        function Dc(t) {
          return new Error(`illegal placement: ${t}`);
        }
        function Mc(t, e) {
          let n,
            r,
            s = Sc,
            i = [],
            o = t.length;
          for (e && (e.length = 0); o; ) {
            let a = t[--o];
            if (((s = s.B.find((t) => t.Q.has(a))), !s)) break;
            if (s.S) r = a;
            else if (s.C && a === r) break;
            i.push(a),
              s.F && (i.push(ac), o > 0 && t[o - 1] == ac && o--),
              s.V &&
                ((n = zc(i, s)),
                e && e.push(...t.slice(o).reverse()),
                (t.length = o));
          }
          return n;
        }
        function zc(t, e) {
          let n = Ic.from(t);
          return 2 == e.V && n.splice(1, 1), n;
        }
        const jc = new Uint8Array(32);
        function $c(t) {
          return (
            sr(0 !== t.length, "invalid ENS name; empty component", "comp", t),
            t
          );
        }
        function Gc(t) {
          const e = Fr(
              (function (t) {
                try {
                  return Lc(t);
                } catch (e) {
                  sr(!1, `invalid ENS name (${e.message})`, "name", t);
                }
              })(t)
            ),
            n = [];
          if (0 === t.length) return n;
          let r = 0;
          for (let t = 0; t < e.length; t++) {
            46 === e[t] && (n.push($c(e.slice(r, t))), (r = t + 1));
          }
          return (
            sr(r < e.length, "invalid ENS name; empty component", "name", t),
            n.push($c(e.slice(r))),
            n
          );
        }
        function Hc(t) {
          sr("string" == typeof t, "invalid ENS name; not a string", "name", t);
          let e = jc;
          const n = Gc(t);
          for (; n.length; ) e = Ni(pr([e, Ni(n.pop())]));
          return fr(e);
        }
        function Qc(t, e) {
          return {
            address: Yo(t),
            storageKeys: e.map(
              (t, e) => (
                sr(hr(t, 32), "invalid slot", `storageKeys[${e}]`, t),
                t.toLowerCase()
              )
            ),
          };
        }
        function Vc(t) {
          if (Array.isArray(t))
            return t.map((e, n) =>
              Array.isArray(e)
                ? (sr(2 === e.length, "invalid slot set", `value[${n}]`, e),
                  Qc(e[0], e[1]))
                : (sr(
                    null != e && "object" == typeof e,
                    "invalid address-slot set",
                    "value",
                    t
                  ),
                  Qc(e.address, e.storageKeys))
            );
          sr(
            null != t && "object" == typeof t,
            "invalid access list",
            "value",
            t
          );
          const e = Object.keys(t).map((e) => {
            const n = t[e].reduce((t, e) => ((t[e] = !0), t), {});
            return Qc(e, Object.keys(n).sort());
          });
          return e.sort((t, e) => t.address.localeCompare(e.address)), e;
        }
        function Jc(t, e) {
          return (function (t) {
            let e;
            return (
              (e =
                "string" == typeof t
                  ? Qo.computePublicKey(t, !1)
                  : t.publicKey),
              Yo(Ni("0x" + e.substring(4)).substring(26))
            );
          })(Qo.recoverPublicKey(t, e));
        }
        jc.fill(0);
        const Wc = BigInt(0),
          Kc = BigInt(2),
          _c = BigInt(27),
          qc = BigInt(28),
          Yc = BigInt(35),
          Zc = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        function Xc(t) {
          return "0x" === t ? null : Yo(t);
        }
        function tl(t, e) {
          try {
            return Vc(t);
          } catch (n) {
            sr(!1, n.message, e, t);
          }
        }
        function el(t, e) {
          return "0x" === t ? 0 : Ir(t, e);
        }
        function nl(t, e) {
          if ("0x" === t) return Wc;
          const n = kr(t, e);
          return sr(n <= Zc, "value exceeds uint size", e, n), n;
        }
        function rl(t, e) {
          const n = kr(t, "value"),
            r = Br(n);
          return sr(r.length <= 32, "value too large", `tx.${e}`, n), r;
        }
        function sl(t) {
          return Vc(t).map((t) => [t.address, t.storageKeys]);
        }
        function il(t, e) {
          const n = [
            rl(t.nonce || 0, "nonce"),
            rl(t.gasPrice || 0, "gasPrice"),
            rl(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Yo(t.to) : "0x",
            rl(t.value || 0, "value"),
            t.data || "0x",
          ];
          let r = Wc;
          if (t.chainId != Wc)
            (r = kr(t.chainId, "tx.chainId")),
              sr(
                !e || null == e.networkV || e.legacyChainId === r,
                "tx.chainId/sig.v mismatch",
                "sig",
                e
              );
          else if (t.signature) {
            const e = t.signature.legacyChainId;
            null != e && (r = e);
          }
          if (!e)
            return (
              r !== Wc && (n.push(Br(r)), n.push("0x"), n.push("0x")), gs(n)
            );
          let s = BigInt(27 + e.yParity);
          return (
            r !== Wc
              ? (s = Ho.getChainIdV(r, e.v))
              : BigInt(e.v) !== s &&
                sr(!1, "tx.chainId/sig.v mismatch", "sig", e),
            n.push(Br(s)),
            n.push(Br(e.r)),
            n.push(Br(e.s)),
            gs(n)
          );
        }
        function ol(t, e) {
          let n;
          try {
            if (((n = el(e[0], "yParity")), 0 !== n && 1 !== n))
              throw new Error("bad yParity");
          } catch (t) {
            sr(!1, "invalid yParity", "yParity", e[0]);
          }
          const r = yr(e[1], 32),
            s = yr(e[2], 32),
            i = Ho.from({ r: r, s: s, yParity: n });
          t.signature = i;
        }
        function al(t, e) {
          const n = [
            rl(t.chainId || 0, "chainId"),
            rl(t.nonce || 0, "nonce"),
            rl(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
            rl(t.maxFeePerGas || 0, "maxFeePerGas"),
            rl(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Yo(t.to) : "0x",
            rl(t.value || 0, "value"),
            t.data || "0x",
            sl(t.accessList || []),
          ];
          return (
            e &&
              (n.push(rl(e.yParity, "yParity")),
              n.push(Br(e.r)),
              n.push(Br(e.s))),
            pr(["0x02", gs(n)])
          );
        }
        function cl(t, e) {
          const n = [
            rl(t.chainId || 0, "chainId"),
            rl(t.nonce || 0, "nonce"),
            rl(t.gasPrice || 0, "gasPrice"),
            rl(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Yo(t.to) : "0x",
            rl(t.value || 0, "value"),
            t.data || "0x",
            sl(t.accessList || []),
          ];
          return (
            e &&
              (n.push(rl(e.yParity, "recoveryParam")),
              n.push(Br(e.r)),
              n.push(Br(e.s))),
            pr(["0x01", gs(n)])
          );
        }
        class ll {
          #H;
          #Q;
          #O;
          #V;
          #J;
          #W;
          #K;
          #_;
          #q;
          #Y;
          #Z;
          #X;
          get type() {
            return this.#H;
          }
          set type(t) {
            switch (t) {
              case null:
                this.#H = null;
                break;
              case 0:
              case "legacy":
                this.#H = 0;
                break;
              case 1:
              case "berlin":
              case "eip-2930":
                this.#H = 1;
                break;
              case 2:
              case "london":
              case "eip-1559":
                this.#H = 2;
                break;
              default:
                sr(!1, "unsupported transaction type", "type", t);
            }
          }
          get typeName() {
            switch (this.type) {
              case 0:
                return "legacy";
              case 1:
                return "eip-2930";
              case 2:
                return "eip-1559";
            }
            return null;
          }
          get to() {
            return this.#Q;
          }
          set to(t) {
            this.#Q = null == t ? null : Yo(t);
          }
          get nonce() {
            return this.#V;
          }
          set nonce(t) {
            this.#V = Ir(t, "value");
          }
          get gasLimit() {
            return this.#J;
          }
          set gasLimit(t) {
            this.#J = kr(t);
          }
          get gasPrice() {
            const t = this.#W;
            return null != t || (0 !== this.type && 1 !== this.type) ? t : Wc;
          }
          set gasPrice(t) {
            this.#W = null == t ? null : kr(t, "gasPrice");
          }
          get maxPriorityFeePerGas() {
            const t = this.#K;
            return null == t ? (2 === this.type ? Wc : null) : t;
          }
          set maxPriorityFeePerGas(t) {
            this.#K = null == t ? null : kr(t, "maxPriorityFeePerGas");
          }
          get maxFeePerGas() {
            const t = this.#_;
            return null == t ? (2 === this.type ? Wc : null) : t;
          }
          set maxFeePerGas(t) {
            this.#_ = null == t ? null : kr(t, "maxFeePerGas");
          }
          get data() {
            return this.#O;
          }
          set data(t) {
            this.#O = fr(t);
          }
          get value() {
            return this.#q;
          }
          set value(t) {
            this.#q = kr(t, "value");
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = kr(t);
          }
          get signature() {
            return this.#Z || null;
          }
          set signature(t) {
            this.#Z = null == t ? null : Ho.from(t);
          }
          get accessList() {
            const t = this.#X || null;
            return null == t
              ? 1 === this.type || 2 === this.type
                ? []
                : null
              : t;
          }
          set accessList(t) {
            this.#X = null == t ? null : Vc(t);
          }
          constructor() {
            (this.#H = null),
              (this.#Q = null),
              (this.#V = 0),
              (this.#J = BigInt(0)),
              (this.#W = null),
              (this.#K = null),
              (this.#_ = null),
              (this.#O = "0x"),
              (this.#q = BigInt(0)),
              (this.#Y = BigInt(0)),
              (this.#Z = null),
              (this.#X = null);
          }
          get hash() {
            return null == this.signature ? null : Ni(this.serialized);
          }
          get unsignedHash() {
            return Ni(this.unsignedSerialized);
          }
          get from() {
            return null == this.signature
              ? null
              : Jc(this.unsignedHash, this.signature);
          }
          get fromPublicKey() {
            return null == this.signature
              ? null
              : Qo.recoverPublicKey(this.unsignedHash, this.signature);
          }
          isSigned() {
            return null != this.signature;
          }
          get serialized() {
            switch (
              (rr(
                null != this.signature,
                "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
                "UNSUPPORTED_OPERATION",
                { operation: ".serialized" }
              ),
              this.inferType())
            ) {
              case 0:
                return il(this, this.signature);
              case 1:
                return cl(this, this.signature);
              case 2:
                return al(this, this.signature);
            }
            rr(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".serialized",
            });
          }
          get unsignedSerialized() {
            switch (this.inferType()) {
              case 0:
                return il(this);
              case 1:
                return cl(this);
              case 2:
                return al(this);
            }
            rr(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".unsignedSerialized",
            });
          }
          inferType() {
            return this.inferTypes().pop();
          }
          inferTypes() {
            const t = null != this.gasPrice,
              e =
                null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
              n = null != this.accessList;
            null != this.maxFeePerGas &&
              null != this.maxPriorityFeePerGas &&
              rr(
                this.maxFeePerGas >= this.maxPriorityFeePerGas,
                "priorityFee cannot be more than maxFee",
                "BAD_DATA",
                { value: this }
              ),
              rr(
                !e || (0 !== this.type && 1 !== this.type),
                "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
                "BAD_DATA",
                { value: this }
              ),
              rr(
                0 !== this.type || !n,
                "legacy transaction cannot have accessList",
                "BAD_DATA",
                { value: this }
              );
            const r = [];
            return (
              null != this.type
                ? r.push(this.type)
                : e
                ? r.push(2)
                : t
                ? (r.push(1), n || r.push(0))
                : n
                ? (r.push(1), r.push(2))
                : (r.push(0), r.push(1), r.push(2)),
              r.sort(),
              r
            );
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          clone() {
            return ll.from(this);
          }
          toJSON() {
            const t = (t) => (null == t ? null : t.toString());
            return {
              type: this.type,
              to: this.to,
              data: this.data,
              nonce: this.nonce,
              gasLimit: t(this.gasLimit),
              gasPrice: t(this.gasPrice),
              maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
              maxFeePerGas: t(this.maxFeePerGas),
              value: t(this.value),
              chainId: t(this.chainId),
              sig: this.signature ? this.signature.toJSON() : null,
              accessList: this.accessList,
            };
          }
          static from(t) {
            if (null == t) return new ll();
            if ("string" == typeof t) {
              const e = lr(t);
              if (e[0] >= 127)
                return ll.from(
                  (function (t) {
                    const e = hs(t);
                    sr(
                      Array.isArray(e) && (9 === e.length || 6 === e.length),
                      "invalid field count for legacy transaction",
                      "data",
                      t
                    );
                    const n = {
                      type: 0,
                      nonce: el(e[0], "nonce"),
                      gasPrice: nl(e[1], "gasPrice"),
                      gasLimit: nl(e[2], "gasLimit"),
                      to: Xc(e[3]),
                      value: nl(e[4], "value"),
                      data: fr(e[5]),
                      chainId: Wc,
                    };
                    if (6 === e.length) return n;
                    const r = nl(e[6], "v"),
                      s = nl(e[7], "r"),
                      i = nl(e[8], "s");
                    if (s === Wc && i === Wc) n.chainId = r;
                    else {
                      let s = (r - Yc) / Kc;
                      s < Wc && (s = Wc),
                        (n.chainId = s),
                        sr(
                          s !== Wc || r === _c || r === qc,
                          "non-canonical legacy v",
                          "v",
                          e[6]
                        ),
                        (n.signature = Ho.from({
                          r: yr(e[7], 32),
                          s: yr(e[8], 32),
                          v: r,
                        })),
                        (n.hash = Ni(t));
                    }
                    return n;
                  })(e)
                );
              switch (e[0]) {
                case 1:
                  return ll.from(
                    (function (t) {
                      const e = hs(lr(t).slice(1));
                      sr(
                        Array.isArray(e) && (8 === e.length || 11 === e.length),
                        "invalid field count for transaction type: 1",
                        "data",
                        fr(t)
                      );
                      const n = {
                        type: 1,
                        chainId: nl(e[0], "chainId"),
                        nonce: el(e[1], "nonce"),
                        gasPrice: nl(e[2], "gasPrice"),
                        gasLimit: nl(e[3], "gasLimit"),
                        to: Xc(e[4]),
                        value: nl(e[5], "value"),
                        data: fr(e[6]),
                        accessList: tl(e[7], "accessList"),
                      };
                      return (
                        8 === e.length || ((n.hash = Ni(t)), ol(n, e.slice(8))),
                        n
                      );
                    })(e)
                  );
                case 2:
                  return ll.from(
                    (function (t) {
                      const e = hs(lr(t).slice(1));
                      sr(
                        Array.isArray(e) && (9 === e.length || 12 === e.length),
                        "invalid field count for transaction type: 2",
                        "data",
                        fr(t)
                      );
                      const n = nl(e[2], "maxPriorityFeePerGas"),
                        r = nl(e[3], "maxFeePerGas"),
                        s = {
                          type: 2,
                          chainId: nl(e[0], "chainId"),
                          nonce: el(e[1], "nonce"),
                          maxPriorityFeePerGas: n,
                          maxFeePerGas: r,
                          gasPrice: null,
                          gasLimit: nl(e[4], "gasLimit"),
                          to: Xc(e[5]),
                          value: nl(e[6], "value"),
                          data: fr(e[7]),
                          accessList: tl(e[8], "accessList"),
                        };
                      return (
                        9 === e.length || ((s.hash = Ni(t)), ol(s, e.slice(9))),
                        s
                      );
                    })(e)
                  );
              }
              rr(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from",
              });
            }
            const e = new ll();
            return (
              null != t.type && (e.type = t.type),
              null != t.to && (e.to = t.to),
              null != t.nonce && (e.nonce = t.nonce),
              null != t.gasLimit && (e.gasLimit = t.gasLimit),
              null != t.gasPrice && (e.gasPrice = t.gasPrice),
              null != t.maxPriorityFeePerGas &&
                (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas),
              null != t.maxFeePerGas && (e.maxFeePerGas = t.maxFeePerGas),
              null != t.data && (e.data = t.data),
              null != t.value && (e.value = t.value),
              null != t.chainId && (e.chainId = t.chainId),
              null != t.signature && (e.signature = Ho.from(t.signature)),
              null != t.accessList && (e.accessList = t.accessList),
              null != t.hash &&
                (sr(
                  e.isSigned(),
                  "unsigned transaction cannot define hash",
                  "tx",
                  t
                ),
                sr(e.hash === t.hash, "hash mismatch", "tx", t)),
              null != t.from &&
                (sr(
                  e.isSigned(),
                  "unsigned transaction cannot define from",
                  "tx",
                  t
                ),
                sr(
                  e.from.toLowerCase() === (t.from || "").toLowerCase(),
                  "from mismatch",
                  "tx",
                  t
                )),
              e
            );
          }
        }
        const ul = new Uint8Array(32);
        ul.fill(0);
        const hl = BigInt(-1),
          dl = BigInt(0),
          fl = BigInt(1),
          pl = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        const gl = Nr(fl, 32),
          ml = Nr(dl, 32),
          yl = {
            name: "string",
            version: "string",
            chainId: "uint256",
            verifyingContract: "address",
            salt: "bytes32",
          },
          bl = ["name", "version", "chainId", "verifyingContract", "salt"];
        function wl(t) {
          return function (e) {
            return (
              sr(
                "string" == typeof e,
                `invalid domain value for ${JSON.stringify(t)}`,
                `domain.${t}`,
                e
              ),
              e
            );
          };
        }
        const Al = {
          name: wl("name"),
          version: wl("version"),
          chainId: function (t) {
            const e = kr(t, "domain.chainId");
            return (
              sr(e >= 0, "invalid chain ID", "domain.chainId", t),
              Number.isSafeInteger(e) ? Number(e) : Tr(e)
            );
          },
          verifyingContract: function (t) {
            try {
              return Yo(t).toLowerCase();
            } catch (t) {}
            sr(
              !1,
              'invalid domain value "verifyingContract"',
              "domain.verifyingContract",
              t
            );
          },
          salt: function (t) {
            const e = lr(t, "domain.salt");
            return (
              sr(
                32 === e.length,
                'invalid domain value "salt"',
                "domain.salt",
                t
              ),
              fr(e)
            );
          },
        };
        function vl(t) {
          {
            const e = t.match(/^(u?)int(\d*)$/);
            if (e) {
              const n = "" === e[1],
                r = parseInt(e[2] || "256");
              sr(
                r % 8 == 0 &&
                  0 !== r &&
                  r <= 256 &&
                  (null == e[2] || e[2] === String(r)),
                "invalid numeric width",
                "type",
                t
              );
              const s = Er(pl, n ? r - 1 : r),
                i = n ? (s + fl) * hl : dl;
              return function (e) {
                const r = kr(e, "value");
                return (
                  sr(
                    r >= i && r <= s,
                    `value out-of-bounds for ${t}`,
                    "value",
                    r
                  ),
                  Nr(n ? xr(r, 256) : r, 32)
                );
              };
            }
          }
          {
            const e = t.match(/^bytes(\d+)$/);
            if (e) {
              const n = parseInt(e[1]);
              return (
                sr(
                  0 !== n && n <= 32 && e[1] === String(n),
                  "invalid bytes width",
                  "type",
                  t
                ),
                function (e) {
                  return (
                    sr(
                      lr(e).length === n,
                      `invalid length for ${t}`,
                      "value",
                      e
                    ),
                    (function (t) {
                      const e = lr(t),
                        n = e.length % 32;
                      return n ? pr([e, ul.slice(n)]) : fr(e);
                    })(e)
                  );
                }
              );
            }
          }
          switch (t) {
            case "address":
              return function (t) {
                return yr(Yo(t), 32);
              };
            case "bool":
              return function (t) {
                return t ? gl : ml;
              };
            case "bytes":
              return function (t) {
                return Ni(t);
              };
            case "string":
              return function (t) {
                return Ea(t);
              };
          }
          return null;
        }
        function xl(t, e) {
          return `${t}(${e
            .map(({ name: t, type: e }) => e + " " + t)
            .join(",")})`;
        }
        class El {
          primaryType;
          #tt;
          get types() {
            return JSON.parse(this.#tt);
          }
          #et;
          #nt;
          constructor(t) {
            (this.#tt = JSON.stringify(t)),
              (this.#et = new Map()),
              (this.#nt = new Map());
            const e = new Map(),
              n = new Map(),
              r = new Map();
            Object.keys(t).forEach((t) => {
              e.set(t, new Set()), n.set(t, []), r.set(t, new Set());
            });
            for (const r in t) {
              const s = new Set();
              for (const i of t[r]) {
                sr(
                  !s.has(i.name),
                  `duplicate variable name ${JSON.stringify(
                    i.name
                  )} in ${JSON.stringify(r)}`,
                  "types",
                  t
                ),
                  s.add(i.name);
                const o = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                sr(
                  o !== r,
                  `circular type reference to ${JSON.stringify(o)}`,
                  "types",
                  t
                );
                vl(o) ||
                  (sr(
                    n.has(o),
                    `unknown type ${JSON.stringify(o)}`,
                    "types",
                    t
                  ),
                  n.get(o).push(r),
                  e.get(r).add(o));
              }
            }
            const s = Array.from(n.keys()).filter((t) => 0 === n.get(t).length);
            sr(0 !== s.length, "missing primary type", "types", t),
              sr(
                1 === s.length,
                `ambiguous primary types or unused types: ${s
                  .map((t) => JSON.stringify(t))
                  .join(", ")}`,
                "types",
                t
              ),
              Zn(this, { primaryType: s[0] }),
              (function s(i, o) {
                sr(
                  !o.has(i),
                  `circular type reference to ${JSON.stringify(i)}`,
                  "types",
                  t
                ),
                  o.add(i);
                for (const t of e.get(i))
                  if (n.has(t)) {
                    s(t, o);
                    for (const e of o) r.get(e).add(t);
                  }
                o.delete(i);
              })(this.primaryType, new Set());
            for (const [e, n] of r) {
              const r = Array.from(n);
              r.sort(),
                this.#et.set(
                  e,
                  xl(e, t[e]) + r.map((e) => xl(e, t[e])).join("")
                );
            }
          }
          getEncoder(t) {
            let e = this.#nt.get(t);
            return e || ((e = this.#rt(t)), this.#nt.set(t, e)), e;
          }
          #rt(t) {
            {
              const e = vl(t);
              if (e) return e;
            }
            const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (e) {
              const t = e[1],
                n = this.getEncoder(t);
              return (r) => {
                sr(
                  !e[3] || parseInt(e[3]) === r.length,
                  `array length mismatch; expected length ${parseInt(e[3])}`,
                  "value",
                  r
                );
                let s = r.map(n);
                return this.#et.has(t) && (s = s.map(Ni)), Ni(pr(s));
              };
            }
            const n = this.types[t];
            if (n) {
              const e = Ea(this.#et.get(t));
              return (t) => {
                const r = n.map(({ name: e, type: n }) => {
                  const r = this.getEncoder(n)(t[e]);
                  return this.#et.has(n) ? Ni(r) : r;
                });
                return r.unshift(e), pr(r);
              };
            }
            sr(!1, `unknown type: ${t}`, "type", t);
          }
          encodeType(t) {
            const e = this.#et.get(t);
            return sr(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
          }
          encodeData(t, e) {
            return this.getEncoder(t)(e);
          }
          hashStruct(t, e) {
            return Ni(this.encodeData(t, e));
          }
          encode(t) {
            return this.encodeData(this.primaryType, t);
          }
          hash(t) {
            return this.hashStruct(this.primaryType, t);
          }
          _visit(t, e, n) {
            if (vl(t)) return n(t, e);
            const r = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (r)
              return (
                sr(
                  !r[3] || parseInt(r[3]) === e.length,
                  `array length mismatch; expected length ${parseInt(r[3])}`,
                  "value",
                  e
                ),
                e.map((t) => this._visit(r[1], t, n))
              );
            const s = this.types[t];
            if (s)
              return s.reduce(
                (t, { name: r, type: s }) => (
                  (t[r] = this._visit(s, e[r], n)), t
                ),
                {}
              );
            sr(!1, `unknown type: ${t}`, "type", t);
          }
          visit(t, e) {
            return this._visit(this.primaryType, t, e);
          }
          static from(t) {
            return new El(t);
          }
          static getPrimaryType(t) {
            return El.from(t).primaryType;
          }
          static hashStruct(t, e, n) {
            return El.from(e).hashStruct(t, n);
          }
          static hashDomain(t) {
            const e = [];
            for (const n in t) {
              if (null == t[n]) continue;
              const r = yl[n];
              sr(
                r,
                `invalid typed-data domain key: ${JSON.stringify(n)}`,
                "domain",
                t
              ),
                e.push({ name: n, type: r });
            }
            return (
              e.sort((t, e) => bl.indexOf(t.name) - bl.indexOf(e.name)),
              El.hashStruct("EIP712Domain", { EIP712Domain: e }, t)
            );
          }
          static encode(t, e, n) {
            return pr(["0x1901", El.hashDomain(t), El.from(e).hash(n)]);
          }
          static hash(t, e, n) {
            return Ni(El.encode(t, e, n));
          }
          static async resolveNames(t, e, n, r) {
            t = Object.assign({}, t);
            for (const e in t) null == t[e] && delete t[e];
            const s = {};
            t.verifyingContract &&
              !hr(t.verifyingContract, 20) &&
              (s[t.verifyingContract] = "0x");
            const i = El.from(e);
            i.visit(
              n,
              (t, e) => ("address" !== t || hr(e, 20) || (s[e] = "0x"), e)
            );
            for (const t in s) s[t] = await r(t);
            return (
              t.verifyingContract &&
                s[t.verifyingContract] &&
                (t.verifyingContract = s[t.verifyingContract]),
              {
                domain: t,
                value: (n = i.visit(n, (t, e) =>
                  "address" === t && s[e] ? s[e] : e
                )),
              }
            );
          }
          static getPayload(t, e, n) {
            El.hashDomain(t);
            const r = {},
              s = [];
            bl.forEach((e) => {
              const n = t[e];
              null != n &&
                ((r[e] = Al[e](n)), s.push({ name: e, type: yl[e] }));
            });
            const i = El.from(e),
              o = Object.assign({}, e);
            return (
              sr(
                null == o.EIP712Domain,
                "types must not contain EIP712Domain type",
                "types.EIP712Domain",
                e
              ),
              (o.EIP712Domain = s),
              i.encode(n),
              {
                types: o,
                domain: r,
                primaryType: i.primaryType,
                message: i.visit(n, (t, e) => {
                  if (t.match(/^bytes(\d*)/)) return fr(lr(e));
                  if (t.match(/^u?int/)) return kr(e).toString();
                  switch (t) {
                    case "address":
                      return e.toLowerCase();
                    case "bool":
                      return !!e;
                    case "string":
                      return (
                        sr("string" == typeof e, "invalid string", "value", e),
                        e
                      );
                  }
                  sr(!1, "unsupported type", "type", t);
                }),
              }
            );
          }
        }
        function kl(t) {
          const e = new Set();
          return t.forEach((t) => e.add(t)), Object.freeze(e);
        }
        const Cl =
            "constant external internal payable private public pure view",
          Pl = kl(Cl.split(" ")),
          Sl = "constructor error event fallback function receive struct",
          Il = kl(Sl.split(" ")),
          Nl = "calldata memory storage payable indexed",
          Bl = kl(Nl.split(" ")),
          Tl = kl([Sl, Nl, "tuple returns", Cl].join(" ").split(" ")),
          Ol = {
            "(": "OPEN_PAREN",
            ")": "CLOSE_PAREN",
            "[": "OPEN_BRACKET",
            "]": "CLOSE_BRACKET",
            ",": "COMMA",
            "@": "AT",
          },
          Rl = new RegExp("^(\\s*)"),
          Ll = new RegExp("^([0-9]+)"),
          Ul = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
          Fl = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
          Dl = new RegExp(
            "^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"
          );
        class Ml {
          #U;
          #st;
          get offset() {
            return this.#U;
          }
          get length() {
            return this.#st.length - this.#U;
          }
          constructor(t) {
            (this.#U = 0), (this.#st = t.slice());
          }
          clone() {
            return new Ml(this.#st);
          }
          reset() {
            this.#U = 0;
          }
          #it(t = 0, e = 0) {
            return new Ml(
              this.#st.slice(t, e).map((e) =>
                Object.freeze(
                  Object.assign({}, e, {
                    match: e.match - t,
                    linkBack: e.linkBack - t,
                    linkNext: e.linkNext - t,
                  })
                )
              )
            );
          }
          popKeyword(t) {
            const e = this.peek();
            if ("KEYWORD" !== e.type || !t.has(e.text))
              throw new Error(`expected keyword ${e.text}`);
            return this.pop().text;
          }
          popType(t) {
            if (this.peek().type !== t)
              throw new Error(
                `expected ${t}; got ${JSON.stringify(this.peek())}`
              );
            return this.pop().text;
          }
          popParen() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = this.#it(this.#U + 1, t.match + 1);
            return (this.#U = t.match + 1), e;
          }
          popParams() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = [];
            for (; this.#U < t.match - 1; ) {
              const t = this.peek().linkNext;
              e.push(this.#it(this.#U + 1, t)), (this.#U = t);
            }
            return (this.#U = t.match + 1), e;
          }
          peek() {
            if (this.#U >= this.#st.length) throw new Error("out-of-bounds");
            return this.#st[this.#U];
          }
          peekKeyword(t) {
            const e = this.peekType("KEYWORD");
            return null != e && t.has(e) ? e : null;
          }
          peekType(t) {
            if (0 === this.length) return null;
            const e = this.peek();
            return e.type === t ? e.text : null;
          }
          pop() {
            const t = this.peek();
            return this.#U++, t;
          }
          toString() {
            const t = [];
            for (let e = this.#U; e < this.#st.length; e++) {
              const n = this.#st[e];
              t.push(`${n.type}:${n.text}`);
            }
            return `<TokenString ${t.join(" ")}>`;
          }
        }
        function zl(t) {
          const e = [],
            n = (e) => {
              const n = i < t.length ? JSON.stringify(t[i]) : "$EOI";
              throw new Error(`invalid token ${n} at ${i}: ${e}`);
            };
          let r = [],
            s = [],
            i = 0;
          for (; i < t.length; ) {
            let o = t.substring(i),
              a = o.match(Rl);
            a && ((i += a[1].length), (o = t.substring(i)));
            const c = {
              depth: r.length,
              linkBack: -1,
              linkNext: -1,
              match: -1,
              type: "",
              text: "",
              offset: i,
              value: -1,
            };
            e.push(c);
            let l = Ol[o[0]] || "";
            if (l) {
              if (((c.type = l), (c.text = o[0]), i++, "OPEN_PAREN" === l))
                r.push(e.length - 1), s.push(e.length - 1);
              else if ("CLOSE_PAREN" == l)
                0 === r.length && n("no matching open bracket"),
                  (c.match = r.pop()),
                  (e[c.match].match = e.length - 1),
                  c.depth--,
                  (c.linkBack = s.pop()),
                  (e[c.linkBack].linkNext = e.length - 1);
              else if ("COMMA" === l)
                (c.linkBack = s.pop()),
                  (e[c.linkBack].linkNext = e.length - 1),
                  s.push(e.length - 1);
              else if ("OPEN_BRACKET" === l) c.type = "BRACKET";
              else if ("CLOSE_BRACKET" === l) {
                let t = e.pop().text;
                if (e.length > 0 && "NUMBER" === e[e.length - 1].type) {
                  const n = e.pop().text;
                  (t = n + t), (e[e.length - 1].value = Ir(n));
                }
                if (0 === e.length || "BRACKET" !== e[e.length - 1].type)
                  throw new Error("missing opening bracket");
                e[e.length - 1].text += t;
              }
            } else if (((a = o.match(Ul)), a)) {
              if (((c.text = a[1]), (i += c.text.length), Tl.has(c.text))) {
                c.type = "KEYWORD";
                continue;
              }
              if (c.text.match(Dl)) {
                c.type = "TYPE";
                continue;
              }
              c.type = "ID";
            } else {
              if (((a = o.match(Ll)), !a))
                throw new Error(
                  `unexpected token ${JSON.stringify(o[0])} at position ${i}`
                );
              (c.text = a[1]), (c.type = "NUMBER"), (i += c.text.length);
            }
          }
          return new Ml(e.map((t) => Object.freeze(t)));
        }
        function jl(t, e) {
          let n = [];
          for (const r in e.keys()) t.has(r) && n.push(r);
          if (n.length > 1)
            throw new Error(`conflicting types: ${n.join(", ")}`);
        }
        function $l(t, e) {
          if (e.peekKeyword(Il)) {
            const n = e.pop().text;
            if (n !== t) throw new Error(`expected ${t}, got ${n}`);
          }
          return e.popType("ID");
        }
        function Gl(t, e) {
          const n = new Set();
          for (;;) {
            const r = t.peekType("KEYWORD");
            if (null == r || (e && !e.has(r))) break;
            if ((t.pop(), n.has(r)))
              throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
            n.add(r);
          }
          return Object.freeze(n);
        }
        function Hl(t) {
          let e = Gl(t, Pl);
          return (
            jl(e, kl("constant payable nonpayable".split(" "))),
            jl(e, kl("pure view payable nonpayable".split(" "))),
            e.has("view")
              ? "view"
              : e.has("pure")
              ? "pure"
              : e.has("payable")
              ? "payable"
              : e.has("nonpayable")
              ? "nonpayable"
              : e.has("constant")
              ? "view"
              : "nonpayable"
          );
        }
        function Ql(t, e) {
          return t.popParams().map((t) => su.from(t, e));
        }
        function Vl(t) {
          if (t.peekType("AT")) {
            if ((t.pop(), t.peekType("NUMBER"))) return kr(t.pop().text);
            throw new Error("invalid gas");
          }
          return null;
        }
        function Jl(t) {
          if (t.length) throw new Error(`unexpected tokens: ${t.toString()}`);
        }
        const Wl = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function Kl(t) {
          const e = t.match(Dl);
          if ((sr(e, "invalid type", "type", t), "uint" === t))
            return "uint256";
          if ("int" === t) return "int256";
          if (e[2]) {
            const n = parseInt(e[2]);
            sr(0 !== n && n <= 32, "invalid bytes length", "type", t);
          } else if (e[3]) {
            const n = parseInt(e[3]);
            sr(
              0 !== n && n <= 256 && n % 8 == 0,
              "invalid numeric width",
              "type",
              t
            );
          }
          return t;
        }
        const _l = {},
          ql = Symbol.for("_ethers_internal"),
          Yl = "_ParamTypeInternal",
          Zl = "_ErrorInternal",
          Xl = "_EventInternal",
          tu = "_ConstructorInternal",
          eu = "_FallbackInternal",
          nu = "_FunctionInternal",
          ru = "_StructInternal";
        class su {
          name;
          type;
          baseType;
          indexed;
          components;
          arrayLength;
          arrayChildren;
          constructor(t, e, n, r, s, i, o, a) {
            if (
              (ar(t, _l, "ParamType"),
              Object.defineProperty(this, ql, { value: Yl }),
              i && (i = Object.freeze(i.slice())),
              "array" === r)
            ) {
              if (null == o || null == a) throw new Error("");
            } else if (null != o || null != a) throw new Error("");
            if ("tuple" === r) {
              if (null == i) throw new Error("");
            } else if (null != i) throw new Error("");
            Zn(this, {
              name: e,
              type: n,
              baseType: r,
              indexed: s,
              components: i,
              arrayLength: o,
              arrayChildren: a,
            });
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t)) {
              let e = {
                type: "tuple" === this.baseType ? "tuple" : this.type,
                name: this.name || void 0,
              };
              return (
                "boolean" == typeof this.indexed && (e.indexed = this.indexed),
                this.isTuple() &&
                  (e.components = this.components.map((e) =>
                    JSON.parse(e.format(t))
                  )),
                JSON.stringify(e)
              );
            }
            let e = "";
            return (
              this.isArray()
                ? ((e += this.arrayChildren.format(t)),
                  (e += `[${
                    this.arrayLength < 0 ? "" : String(this.arrayLength)
                  }]`))
                : this.isTuple()
                ? ("sighash" !== t && (e += this.type),
                  (e +=
                    "(" +
                    this.components
                      .map((e) => e.format(t))
                      .join("full" === t ? ", " : ",") +
                    ")"))
                : (e += this.type),
              "sighash" !== t &&
                (!0 === this.indexed && (e += " indexed"),
                "full" === t && this.name && (e += " " + this.name)),
              e
            );
          }
          isArray() {
            return "array" === this.baseType;
          }
          isTuple() {
            return "tuple" === this.baseType;
          }
          isIndexable() {
            return null != this.indexed;
          }
          walk(t, e) {
            if (this.isArray()) {
              if (!Array.isArray(t)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && t.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t) => n.arrayChildren.walk(t, e));
            }
            if (this.isTuple()) {
              if (!Array.isArray(t)) throw new Error("invalid tuple value");
              if (t.length !== this.components.length)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t, r) => n.components[r].walk(t, e));
            }
            return e(this.type, t);
          }
          #ot(t, e, n, r) {
            if (this.isArray()) {
              if (!Array.isArray(e)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && e.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const s = this.arrayChildren,
                i = e.slice();
              return (
                i.forEach((e, r) => {
                  s.#ot(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            if (this.isTuple()) {
              const s = this.components;
              let i;
              if (Array.isArray(e)) i = e.slice();
              else {
                if (null == e || "object" != typeof e)
                  throw new Error("invalid tuple value");
                i = s.map((t) => {
                  if (!t.name)
                    throw new Error(
                      "cannot use object value with unnamed components"
                    );
                  if (!(t.name in e))
                    throw new Error(`missing value for component ${t.name}`);
                  return e[t.name];
                });
              }
              if (i.length !== this.components.length)
                throw new Error("array is wrong length");
              return (
                i.forEach((e, r) => {
                  s[r].#ot(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            const s = n(this.type, e);
            s.then
              ? t.push(
                  (async function () {
                    r(await s);
                  })()
                )
              : r(s);
          }
          async walkAsync(t, e) {
            const n = [],
              r = [t];
            return (
              this.#ot(n, t, e, (t) => {
                r[0] = t;
              }),
              n.length && (await Promise.all(n)),
              r[0]
            );
          }
          static from(t, e) {
            if (su.isParamType(t)) return t;
            if ("string" == typeof t) return su.from(zl(t), e);
            if (t instanceof Ml) {
              let n = "",
                r = "",
                s = null;
              Gl(t, kl(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN")
                ? ((r = "tuple"),
                  (s = t.popParams().map((t) => su.from(t))),
                  (n = `tuple(${s.map((t) => t.format()).join(",")})`))
                : ((n = Kl(t.popType("TYPE"))), (r = n));
              let i = null,
                o = null;
              for (; t.length && t.peekType("BRACKET"); ) {
                const e = t.pop();
                (i = new su(_l, "", n, r, null, s, o, i)),
                  (o = e.value),
                  (n += e.text),
                  (r = "array"),
                  (s = null);
              }
              let a = null;
              if (Gl(t, Bl).has("indexed")) {
                if (!e) throw new Error("");
                a = !0;
              }
              const c = t.peekType("ID") ? t.pop().text : "";
              if (t.length) throw new Error("leftover tokens");
              return new su(_l, c, n, r, a, s, o, i);
            }
            const n = t.name;
            sr(
              !n || ("string" == typeof n && n.match(Fl)),
              "invalid name",
              "obj.name",
              n
            );
            let r = t.indexed;
            null != r &&
              (sr(e, "parameter cannot be indexed", "obj.indexed", t.indexed),
              (r = !!r));
            let s = t.type,
              i = s.match(Wl);
            if (i) {
              const e = parseInt(i[2] || "-1"),
                o = su.from({ type: i[1], components: t.components });
              return new su(_l, n || "", s, "array", r, null, e, o);
            }
            if ("tuple" === s || s.startsWith("tuple(") || s.startsWith("(")) {
              const e =
                null != t.components
                  ? t.components.map((t) => su.from(t))
                  : null;
              return new su(_l, n || "", s, "tuple", r, e, null, null);
            }
            return (
              (s = Kl(t.type)), new su(_l, n || "", s, s, r, null, null, null)
            );
          }
          static isParamType(t) {
            return t && t[ql] === Yl;
          }
        }
        class iu {
          type;
          inputs;
          constructor(t, e, n) {
            ar(t, _l, "Fragment"),
              Zn(this, { type: e, inputs: (n = Object.freeze(n.slice())) });
          }
          static from(t) {
            if ("string" == typeof t) {
              try {
                iu.from(JSON.parse(t));
              } catch (t) {}
              return iu.from(zl(t));
            }
            if (t instanceof Ml) {
              switch (t.peekKeyword(Il)) {
                case "constructor":
                  return uu.from(t);
                case "error":
                  return cu.from(t);
                case "event":
                  return lu.from(t);
                case "fallback":
                case "receive":
                  return hu.from(t);
                case "function":
                  return du.from(t);
                case "struct":
                  return fu.from(t);
              }
            } else if ("object" == typeof t) {
              switch (t.type) {
                case "constructor":
                  return uu.from(t);
                case "error":
                  return cu.from(t);
                case "event":
                  return lu.from(t);
                case "fallback":
                case "receive":
                  return hu.from(t);
                case "function":
                  return du.from(t);
                case "struct":
                  return fu.from(t);
              }
              rr(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from",
              });
            }
            sr(!1, "unsupported frgament object", "obj", t);
          }
          static isConstructor(t) {
            return uu.isFragment(t);
          }
          static isError(t) {
            return cu.isFragment(t);
          }
          static isEvent(t) {
            return lu.isFragment(t);
          }
          static isFunction(t) {
            return du.isFragment(t);
          }
          static isStruct(t) {
            return fu.isFragment(t);
          }
        }
        class ou extends iu {
          name;
          constructor(t, e, n, r) {
            super(t, e, r),
              sr(
                "string" == typeof n && n.match(Fl),
                "invalid identifier",
                "name",
                n
              ),
              (r = Object.freeze(r.slice())),
              Zn(this, { name: n });
          }
        }
        function au(t, e) {
          return (
            "(" +
            e.map((e) => e.format(t)).join("full" === t ? ", " : ",") +
            ")"
          );
        }
        class cu extends ou {
          constructor(t, e, n) {
            super(t, "error", e, n),
              Object.defineProperty(this, ql, { value: Zl });
          }
          get selector() {
            return Ea(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("error"),
              e.push(this.name + au(t, this.inputs)),
              e.join(" ")
            );
          }
          static from(t) {
            if (cu.isFragment(t)) return t;
            if ("string" == typeof t) return cu.from(zl(t));
            if (t instanceof Ml) {
              const e = $l("error", t),
                n = Ql(t);
              return Jl(t), new cu(_l, e, n);
            }
            return new cu(_l, t.name, t.inputs ? t.inputs.map(su.from) : []);
          }
          static isFragment(t) {
            return t && t[ql] === Zl;
          }
        }
        class lu extends ou {
          anonymous;
          constructor(t, e, n, r) {
            super(t, "event", e, n),
              Object.defineProperty(this, ql, { value: Xl }),
              Zn(this, { anonymous: r });
          }
          get topicHash() {
            return Ea(this.format("sighash"));
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("event"),
              e.push(this.name + au(t, this.inputs)),
              "sighash" !== t && this.anonymous && e.push("anonymous"),
              e.join(" ")
            );
          }
          static getTopicHash(t, e) {
            e = (e || []).map((t) => su.from(t));
            return new lu(_l, t, e, !1).topicHash;
          }
          static from(t) {
            if (lu.isFragment(t)) return t;
            if ("string" == typeof t) return lu.from(zl(t));
            if (t instanceof Ml) {
              const e = $l("event", t),
                n = Ql(t, !0),
                r = !!Gl(t, kl(["anonymous"])).has("anonymous");
              return Jl(t), new lu(_l, e, n, r);
            }
            return new lu(
              _l,
              t.name,
              t.inputs ? t.inputs.map((t) => su.from(t, !0)) : [],
              !!t.anonymous
            );
          }
          static isFragment(t) {
            return t && t[ql] === Xl;
          }
        }
        class uu extends iu {
          payable;
          gas;
          constructor(t, e, n, r, s) {
            super(t, e, n),
              Object.defineProperty(this, ql, { value: tu }),
              Zn(this, { payable: r, gas: s });
          }
          format(t) {
            if (
              (rr(
                null != t && "sighash" !== t,
                "cannot format a constructor for sighash",
                "UNSUPPORTED_OPERATION",
                { operation: "format(sighash)" }
              ),
              "json" === t)
            )
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [`constructor${au(t, this.inputs)}`];
            return (
              e.push(this.payable ? "payable" : "nonpayable"),
              null != this.gas && e.push(`@${this.gas.toString()}`),
              e.join(" ")
            );
          }
          static from(t) {
            if (uu.isFragment(t)) return t;
            if ("string" == typeof t) return uu.from(zl(t));
            if (t instanceof Ml) {
              Gl(t, kl(["constructor"]));
              const e = Ql(t),
                n = !!Gl(t, kl(["payable"])).has("payable"),
                r = Vl(t);
              return Jl(t), new uu(_l, "constructor", e, n, r);
            }
            return new uu(
              _l,
              "constructor",
              t.inputs ? t.inputs.map(su.from) : [],
              !!t.payable,
              null != t.gas ? t.gas : null
            );
          }
          static isFragment(t) {
            return t && t[ql] === tu;
          }
        }
        class hu extends iu {
          payable;
          constructor(t, e, n) {
            super(t, "fallback", e),
              Object.defineProperty(this, ql, { value: eu }),
              Zn(this, { payable: n });
          }
          format(t) {
            const e = 0 === this.inputs.length ? "receive" : "fallback";
            if ("json" === t) {
              const t = this.payable ? "payable" : "nonpayable";
              return JSON.stringify({ type: e, stateMutability: t });
            }
            return `${e}()${this.payable ? " payable" : ""}`;
          }
          static from(t) {
            if (hu.isFragment(t)) return t;
            if ("string" == typeof t) return hu.from(zl(t));
            if (t instanceof Ml) {
              const e = t.toString();
              sr(
                t.peekKeyword(kl(["fallback", "receive"])),
                "type must be fallback or receive",
                "obj",
                e
              );
              if ("receive" === t.popKeyword(kl(["fallback", "receive"]))) {
                const e = Ql(t);
                return (
                  sr(
                    0 === e.length,
                    "receive cannot have arguments",
                    "obj.inputs",
                    e
                  ),
                  Gl(t, kl(["payable"])),
                  Jl(t),
                  new hu(_l, [], !0)
                );
              }
              let n = Ql(t);
              n.length
                ? sr(
                    1 === n.length && "bytes" === n[0].type,
                    "invalid fallback inputs",
                    "obj.inputs",
                    n.map((t) => t.format("minimal")).join(", ")
                  )
                : (n = [su.from("bytes")]);
              const r = Hl(t);
              if (
                (sr(
                  "nonpayable" === r || "payable" === r,
                  "fallback cannot be constants",
                  "obj.stateMutability",
                  r
                ),
                Gl(t, kl(["returns"])).has("returns"))
              ) {
                const e = Ql(t);
                sr(
                  1 === e.length && "bytes" === e[0].type,
                  "invalid fallback outputs",
                  "obj.outputs",
                  e.map((t) => t.format("minimal")).join(", ")
                );
              }
              return Jl(t), new hu(_l, n, "payable" === r);
            }
            if ("receive" === t.type) return new hu(_l, [], !0);
            if ("fallback" === t.type) {
              const e = [su.from("bytes")],
                n = "payable" === t.stateMutability;
              return new hu(_l, e, n);
            }
            sr(!1, "invalid fallback description", "obj", t);
          }
          static isFragment(t) {
            return t && t[ql] === eu;
          }
        }
        class du extends ou {
          constant;
          outputs;
          stateMutability;
          payable;
          gas;
          constructor(t, e, n, r, s, i) {
            super(t, "function", e, r),
              Object.defineProperty(this, ql, { value: nu });
            Zn(this, {
              constant: "view" === n || "pure" === n,
              gas: i,
              outputs: (s = Object.freeze(s.slice())),
              payable: "payable" === n,
              stateMutability: n,
            });
          }
          get selector() {
            return Ea(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  "nonpayable" !== this.stateMutability
                    ? this.stateMutability
                    : void 0,
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
                outputs: this.outputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("function"),
              e.push(this.name + au(t, this.inputs)),
              "sighash" !== t &&
                ("nonpayable" !== this.stateMutability &&
                  e.push(this.stateMutability),
                this.outputs &&
                  this.outputs.length &&
                  (e.push("returns"), e.push(au(t, this.outputs))),
                null != this.gas && e.push(`@${this.gas.toString()}`)),
              e.join(" ")
            );
          }
          static getSelector(t, e) {
            e = (e || []).map((t) => su.from(t));
            return new du(_l, t, "view", e, [], null).selector;
          }
          static from(t) {
            if (du.isFragment(t)) return t;
            if ("string" == typeof t) return du.from(zl(t));
            if (t instanceof Ml) {
              const e = $l("function", t),
                n = Ql(t),
                r = Hl(t);
              let s = [];
              Gl(t, kl(["returns"])).has("returns") && (s = Ql(t));
              const i = Vl(t);
              return Jl(t), new du(_l, e, r, n, s, i);
            }
            let e = t.stateMutability;
            return (
              null == e &&
                ((e = "payable"),
                "boolean" == typeof t.constant
                  ? ((e = "view"),
                    t.constant ||
                      ((e = "payable"),
                      "boolean" != typeof t.payable ||
                        t.payable ||
                        (e = "nonpayable")))
                  : "boolean" != typeof t.payable ||
                    t.payable ||
                    (e = "nonpayable")),
              new du(
                _l,
                t.name,
                e,
                t.inputs ? t.inputs.map(su.from) : [],
                t.outputs ? t.outputs.map(su.from) : [],
                null != t.gas ? t.gas : null
              )
            );
          }
          static isFragment(t) {
            return t && t[ql] === nu;
          }
        }
        class fu extends ou {
          constructor(t, e, n) {
            super(t, "struct", e, n),
              Object.defineProperty(this, ql, { value: ru });
          }
          format() {
            throw new Error("@TODO");
          }
          static from(t) {
            if ("string" == typeof t) return fu.from(zl(t));
            if (t instanceof Ml) {
              const e = $l("struct", t),
                n = Ql(t);
              return Jl(t), new fu(_l, e, n);
            }
            return new fu(_l, t.name, t.inputs ? t.inputs.map(su.from) : []);
          }
          static isFragment(t) {
            return t && t[ql] === ru;
          }
        }
        const pu = new Map();
        pu.set(0, "GENERIC_PANIC"),
          pu.set(1, "ASSERT_FALSE"),
          pu.set(17, "OVERFLOW"),
          pu.set(18, "DIVIDE_BY_ZERO"),
          pu.set(33, "ENUM_RANGE_ERROR"),
          pu.set(34, "BAD_STORAGE_DATA"),
          pu.set(49, "STACK_UNDERFLOW"),
          pu.set(50, "ARRAY_RANGE_ERROR"),
          pu.set(65, "OUT_OF_MEMORY"),
          pu.set(81, "UNINITIALIZED_FUNCTION_CALL");
        const gu = new RegExp(/^bytes([0-9]*)$/),
          mu = new RegExp(/^(u?int)([0-9]*)$/);
        let yu = null;
        class bu {
          #at(t) {
            if (t.isArray())
              return new ua(this.#at(t.arrayChildren), t.arrayLength, t.name);
            if (t.isTuple())
              return new xa(
                t.components.map((t) => this.#at(t)),
                t.name
              );
            switch (t.baseType) {
              case "address":
                return new oa(t.name);
              case "bool":
                return new ha(t.name);
              case "string":
                return new va(t.name);
              case "bytes":
                return new fa(t.name);
              case "":
                return new ma(t.name);
            }
            let e = t.type.match(mu);
            if (e) {
              let n = parseInt(e[2] || "256");
              return (
                sr(
                  0 !== n && n <= 256 && n % 8 == 0,
                  "invalid " + e[1] + " bit length",
                  "param",
                  t
                ),
                new Aa(n / 8, "int" === e[1], t.name)
              );
            }
            if (((e = t.type.match(gu)), e)) {
              let n = parseInt(e[1]);
              return (
                sr(0 !== n && n <= 32, "invalid bytes length", "param", t),
                new pa(n, t.name)
              );
            }
            sr(!1, "invalid type", "type", t.type);
          }
          getDefaultValue(t) {
            const e = t.map((t) => this.#at(su.from(t)));
            return new xa(e, "_").defaultValue();
          }
          encode(t, e) {
            ir(e.length, t.length, "types/values length mismatch");
            const n = t.map((t) => this.#at(su.from(t))),
              r = new xa(n, "_"),
              s = new Ps();
            return r.encode(s, e), s.data;
          }
          decode(t, e, n) {
            const r = t.map((t) => this.#at(su.from(t)));
            return new xa(r, "_").decode(new Ss(e, n));
          }
          static defaultAbiCoder() {
            return null == yu && (yu = new bu()), yu;
          }
          static getBuiltinCallException(t, e, n) {
            return (function (t, e, n, r) {
              let s = "missing revert data",
                i = null,
                o = null;
              if (n) {
                s = "execution reverted";
                const t = lr(n);
                if (((n = fr(n)), 0 === t.length))
                  (s += " (no data present; likely require(false) occurred"),
                    (i = "require(false)");
                else if (t.length % 32 != 4)
                  s += " (could not decode reason; invalid data length)";
                else if ("0x08c379a0" === fr(t.slice(0, 4)))
                  try {
                    (i = r.decode(["string"], t.slice(4))[0]),
                      (o = {
                        signature: "Error(string)",
                        name: "Error",
                        args: [i],
                      }),
                      (s += `: ${JSON.stringify(i)}`);
                  } catch (t) {
                    s += " (could not decode reason; invalid string data)";
                  }
                else if ("0x4e487b71" === fr(t.slice(0, 4)))
                  try {
                    const e = Number(r.decode(["uint256"], t.slice(4))[0]);
                    (o = {
                      signature: "Panic(uint256)",
                      name: "Panic",
                      args: [e],
                    }),
                      (i = `Panic due to ${pu.get(e) || "UNKNOWN"}(${e})`),
                      (s += `: ${i}`);
                  } catch (t) {
                    s += " (could not decode panic code)";
                  }
                else s += " (unknown custom error)";
              }
              const a = { to: e.to ? Yo(e.to) : null, data: e.data || "0x" };
              return (
                e.from && (a.from = Yo(e.from)),
                nr(s, "CALL_EXCEPTION", {
                  action: t,
                  data: n,
                  reason: i,
                  transaction: a,
                  invocation: null,
                  revert: o,
                })
              );
            })(t, e, n, bu.defaultAbiCoder());
          }
        }
        class wu {
          fragment;
          name;
          signature;
          topic;
          args;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            Zn(this, { fragment: t, name: r, signature: s, topic: e, args: n });
          }
        }
        class Au {
          fragment;
          name;
          args;
          signature;
          selector;
          value;
          constructor(t, e, n, r) {
            const s = t.name,
              i = t.format();
            Zn(this, {
              fragment: t,
              name: s,
              args: n,
              signature: i,
              selector: e,
              value: r,
            });
          }
        }
        class vu {
          fragment;
          name;
          args;
          signature;
          selector;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            Zn(this, {
              fragment: t,
              name: r,
              args: n,
              signature: s,
              selector: e,
            });
          }
        }
        class xu {
          hash;
          _isIndexed;
          static isIndexed(t) {
            return !(!t || !t._isIndexed);
          }
          constructor(t) {
            Zn(this, { hash: t, _isIndexed: !0 });
          }
        }
        const Eu = {
            0: "generic panic",
            1: "assert(false)",
            17: "arithmetic overflow",
            18: "division or modulo by zero",
            33: "enum overflow",
            34: "invalid encoded storage byte array accessed",
            49: "out-of-bounds array access; popping on an empty array",
            50: "out-of-bounds access of an array or bytesN",
            65: "out of memory",
            81: "uninitialized function",
          },
          ku = {
            "0x08c379a0": {
              signature: "Error(string)",
              name: "Error",
              inputs: ["string"],
              reason: (t) => `reverted with reason string ${JSON.stringify(t)}`,
            },
            "0x4e487b71": {
              signature: "Panic(uint256)",
              name: "Panic",
              inputs: ["uint256"],
              reason: (t) => {
                let e = "unknown panic code";
                return (
                  t >= 0 &&
                    t <= 255 &&
                    Eu[t.toString()] &&
                    (e = Eu[t.toString()]),
                  `reverted with panic code 0x${t.toString(16)} (${e})`
                );
              },
            },
          };
        class Cu {
          fragments;
          deploy;
          fallback;
          receive;
          #ct;
          #lt;
          #ut;
          #ht;
          constructor(t) {
            let e = [];
            (e = "string" == typeof t ? JSON.parse(t) : t),
              (this.#ut = new Map()),
              (this.#ct = new Map()),
              (this.#lt = new Map());
            const n = [];
            for (const t of e)
              try {
                n.push(iu.from(t));
              } catch (t) {
                console.log("EE", t);
              }
            Zn(this, { fragments: Object.freeze(n) });
            let r = null,
              s = !1;
            (this.#ht = this.getAbiCoder()),
              this.fragments.forEach((t, e) => {
                let n;
                switch (t.type) {
                  case "constructor":
                    return this.deploy
                      ? void console.log("duplicate definition - constructor")
                      : void Zn(this, { deploy: t });
                  case "fallback":
                    return void (0 === t.inputs.length
                      ? (s = !0)
                      : (sr(
                          !r || t.payable !== r.payable,
                          "conflicting fallback fragments",
                          `fragments[${e}]`,
                          t
                        ),
                        (r = t),
                        (s = r.payable)));
                  case "function":
                    n = this.#ut;
                    break;
                  case "event":
                    n = this.#lt;
                    break;
                  case "error":
                    n = this.#ct;
                    break;
                  default:
                    return;
                }
                const i = t.format();
                n.has(i) || n.set(i, t);
              }),
              this.deploy || Zn(this, { deploy: uu.from("constructor()") }),
              Zn(this, { fallback: r, receive: s });
          }
          format(t) {
            const e = t ? "minimal" : "full",
              n = this.fragments.map((t) => t.format(e));
            return n;
          }
          formatJson() {
            const t = this.fragments.map((t) => t.format("json"));
            return JSON.stringify(t.map((t) => JSON.parse(t)));
          }
          getAbiCoder() {
            return bu.defaultAbiCoder();
          }
          #dt(t, e, n) {
            if (hr(t)) {
              const e = t.toLowerCase();
              for (const t of this.#ut.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#ut) e.split("(")[0] === t && r.push(n);
              if (e) {
                const t = e.length > 0 ? e[e.length - 1] : null;
                let n = e.length,
                  s = !0;
                ia.isTyped(t) && "overrides" === t.type && ((s = !1), n--);
                for (let t = r.length - 1; t >= 0; t--) {
                  const e = r[t].inputs.length;
                  e === n || (s && e === n - 1) || r.splice(t, 1);
                }
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if (ia.isTyped(e[s])) {
                      if (s >= n.length) {
                        if ("overrides" === e[s].type) continue;
                        r.splice(t, 1);
                        break;
                      }
                      if (e[s].type !== n[s].baseType) {
                        r.splice(t, 1);
                        break;
                      }
                    }
                }
              }
              if (1 === r.length && e && e.length !== r[0].inputs.length) {
                const t = e[e.length - 1];
                (null == t || Array.isArray(t) || "object" != typeof t) &&
                  r.splice(0, 1);
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                const e = r.map((t) => JSON.stringify(t.format())).join(", ");
                sr(
                  !1,
                  `ambiguous function description (i.e. matches ${e})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#ut.get(du.from(t).format());
            return r || null;
          }
          getFunctionName(t) {
            const e = this.#dt(t, null, !1);
            return sr(e, "no matching function", "key", t), e.name;
          }
          hasFunction(t) {
            return !!this.#dt(t, null, !1);
          }
          getFunction(t, e) {
            return this.#dt(t, e || null, !0);
          }
          forEachFunction(t) {
            const e = Array.from(this.#ut.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ut.get(r), n);
            }
          }
          #ft(t, e, n) {
            if (hr(t)) {
              const e = t.toLowerCase();
              for (const t of this.#lt.values())
                if (e === t.topicHash) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#lt) e.split("(")[0] === t && r.push(n);
              if (e) {
                for (let t = r.length - 1; t >= 0; t--)
                  r[t].inputs.length < e.length && r.splice(t, 1);
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if (ia.isTyped(e[s]) && e[s].type !== n[s].baseType) {
                      r.splice(t, 1);
                      break;
                    }
                }
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                const e = r.map((t) => JSON.stringify(t.format())).join(", ");
                sr(
                  !1,
                  `ambiguous event description (i.e. matches ${e})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#lt.get(lu.from(t).format());
            return r || null;
          }
          getEventName(t) {
            const e = this.#ft(t, null, !1);
            return sr(e, "no matching event", "key", t), e.name;
          }
          hasEvent(t) {
            return !!this.#ft(t, null, !1);
          }
          getEvent(t, e) {
            return this.#ft(t, e || null, !0);
          }
          forEachEvent(t) {
            const e = Array.from(this.#lt.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#lt.get(r), n);
            }
          }
          getError(t, e) {
            if (hr(t)) {
              const e = t.toLowerCase();
              if (ku[e]) return cu.from(ku[e].signature);
              for (const t of this.#ct.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const e = [];
              for (const [n, r] of this.#ct) n.split("(")[0] === t && e.push(r);
              if (0 === e.length)
                return "Error" === t
                  ? cu.from("error Error(string)")
                  : "Panic" === t
                  ? cu.from("error Panic(uint256)")
                  : null;
              if (e.length > 1) {
                const n = e.map((t) => JSON.stringify(t.format())).join(", ");
                sr(!1, `ambiguous error description (i.e. ${n})`, "name", t);
              }
              return e[0];
            }
            if ("Error(string)" === (t = cu.from(t).format()))
              return cu.from("error Error(string)");
            if ("Panic(uint256)" === t) return cu.from("error Panic(uint256)");
            const n = this.#ct.get(t);
            return n || null;
          }
          forEachError(t) {
            const e = Array.from(this.#ct.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ct.get(r), n);
            }
          }
          _decodeParams(t, e) {
            return this.#ht.decode(t, e);
          }
          _encodeParams(t, e) {
            return this.#ht.encode(t, e);
          }
          encodeDeploy(t) {
            return this._encodeParams(this.deploy.inputs, t || []);
          }
          decodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              sr(e, "unknown error", "fragment", t), (t = e);
            }
            return (
              sr(
                mr(e, 0, 4) === t.selector,
                `data signature does not match error ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, mr(e, 4))
            );
          }
          encodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              sr(e, "unknown error", "fragment", t), (t = e);
            }
            return pr([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              sr(e, "unknown function", "fragment", t), (t = e);
            }
            return (
              sr(
                mr(e, 0, 4) === t.selector,
                `data signature does not match function ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, mr(e, 4))
            );
          }
          encodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              sr(e, "unknown function", "fragment", t), (t = e);
            }
            return pr([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              sr(e, "unknown function", "fragment", t), (t = e);
            }
            let n = "invalid length for result data";
            const r = ur(e);
            if (r.length % 32 == 0)
              try {
                return this.#ht.decode(t.outputs, r);
              } catch (t) {
                n = "could not decode result data";
              }
            rr(!1, n, "BAD_DATA", {
              value: fr(r),
              info: { method: t.name, signature: t.format() },
            });
          }
          makeError(t, e) {
            const n = lr(t, "data"),
              r = bu.getBuiltinCallException("call", e, n);
            if (
              r.message.startsWith("execution reverted (unknown custom error)")
            ) {
              const t = fr(n.slice(0, 4)),
                e = this.getError(t);
              if (e)
                try {
                  const t = this.#ht.decode(e.inputs, n.slice(4));
                  (r.revert = { name: e.name, signature: e.format(), args: t }),
                    (r.reason = r.revert.signature),
                    (r.message = `execution reverted: ${r.reason}`);
                } catch (t) {
                  r.message =
                    "execution reverted (coult not decode custom error)";
                }
            }
            const s = this.parseTransaction(e);
            return (
              s &&
                (r.invocation = {
                  method: s.name,
                  signature: s.signature,
                  args: s.args,
                }),
              r
            );
          }
          encodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              sr(e, "unknown function", "fragment", t), (t = e);
            }
            return fr(this.#ht.encode(t.outputs, e || []));
          }
          encodeFilterTopics(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              sr(e, "unknown event", "eventFragment", t), (t = e);
            }
            rr(
              e.length <= t.inputs.length,
              `too many arguments for ${t.format()}`,
              "UNEXPECTED_ARGUMENT",
              { count: e.length, expectedCount: t.inputs.length }
            );
            const n = [];
            t.anonymous || n.push(t.topicHash);
            const r = (t, e) =>
              "string" === t.type
                ? Ea(e)
                : "bytes" === t.type
                ? Ni(fr(e))
                : ("bool" === t.type &&
                    "boolean" == typeof e &&
                    (e = e ? "0x01" : "0x00"),
                  t.type.match(/^u?int/) && (e = Nr(e)),
                  "address" === t.type && this.#ht.encode(["address"], [e]),
                  yr(fr(e), 32));
            for (
              e.forEach((e, s) => {
                const i = t.inputs[s];
                i.indexed
                  ? null == e
                    ? n.push(null)
                    : "array" === i.baseType || "tuple" === i.baseType
                    ? sr(
                        !1,
                        "filtering with tuples or arrays not supported",
                        "contract." + i.name,
                        e
                      )
                    : Array.isArray(e)
                    ? n.push(e.map((t) => r(i, t)))
                    : n.push(r(i, e))
                  : sr(
                      null == e,
                      "cannot filter non-indexed parameters; must be null",
                      "contract." + i.name,
                      e
                    );
              });
              n.length && null === n[n.length - 1];

            )
              n.pop();
            return n;
          }
          encodeEventLog(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              sr(e, "unknown event", "eventFragment", t), (t = e);
            }
            const n = [],
              r = [],
              s = [];
            return (
              t.anonymous || n.push(t.topicHash),
              sr(
                e.length === t.inputs.length,
                "event arguments/values mismatch",
                "values",
                e
              ),
              t.inputs.forEach((t, i) => {
                const o = e[i];
                if (t.indexed)
                  if ("string" === t.type) n.push(Ea(o));
                  else if ("bytes" === t.type) n.push(Ni(o));
                  else {
                    if ("tuple" === t.baseType || "array" === t.baseType)
                      throw new Error("not implemented");
                    n.push(this.#ht.encode([t.type], [o]));
                  }
                else r.push(t), s.push(o);
              }),
              { data: this.#ht.encode(r, s), topics: n }
            );
          }
          decodeEventLog(t, e, n) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              sr(e, "unknown event", "eventFragment", t), (t = e);
            }
            if (null != n && !t.anonymous) {
              const e = t.topicHash;
              sr(
                hr(n[0], 32) && n[0].toLowerCase() === e,
                "fragment/topic mismatch",
                "topics[0]",
                n[0]
              ),
                (n = n.slice(1));
            }
            const r = [],
              s = [],
              i = [];
            t.inputs.forEach((t, e) => {
              t.indexed
                ? "string" === t.type ||
                  "bytes" === t.type ||
                  "tuple" === t.baseType ||
                  "array" === t.baseType
                  ? (r.push(su.from({ type: "bytes32", name: t.name })),
                    i.push(!0))
                  : (r.push(t), i.push(!1))
                : (s.push(t), i.push(!1));
            });
            const o = null != n ? this.#ht.decode(r, pr(n)) : null,
              a = this.#ht.decode(s, e, !0),
              c = [],
              l = [];
            let u = 0,
              h = 0;
            return (
              t.inputs.forEach((t, e) => {
                let n = null;
                if (t.indexed)
                  if (null == o) n = new xu(null);
                  else if (i[e]) n = new xu(o[h++]);
                  else
                    try {
                      n = o[h++];
                    } catch (t) {
                      n = t;
                    }
                else
                  try {
                    n = a[u++];
                  } catch (t) {
                    n = t;
                  }
                c.push(n), l.push(t.name || null);
              }),
              Es.fromItems(c, l)
            );
          }
          parseTransaction(t) {
            const e = lr(t.data, "tx.data"),
              n = kr(null != t.value ? t.value : 0, "tx.value"),
              r = this.getFunction(fr(e.slice(0, 4)));
            if (!r) return null;
            const s = this.#ht.decode(r.inputs, e.slice(4));
            return new Au(r, r.selector, s, n);
          }
          parseCallResult(t) {
            throw new Error("@TODO");
          }
          parseLog(t) {
            const e = this.getEvent(t.topics[0]);
            return !e || e.anonymous
              ? null
              : new wu(
                  e,
                  e.topicHash,
                  this.decodeEventLog(e, t.data, t.topics)
                );
          }
          parseError(t) {
            const e = fr(t),
              n = this.getError(mr(e, 0, 4));
            if (!n) return null;
            const r = this.#ht.decode(n.inputs, mr(e, 4));
            return new vu(n, n.selector, r);
          }
          static from(t) {
            return t instanceof Cu
              ? t
              : "string" == typeof t
              ? new Cu(JSON.parse(t))
              : "function" == typeof t.format
              ? new Cu(t.format("json"))
              : new Cu(t);
          }
        }
        const Pu = BigInt(0);
        function Su(t) {
          return null == t ? null : t;
        }
        function Iu(t) {
          return null == t ? null : t.toString();
        }
        class Nu {
          gasPrice;
          maxFeePerGas;
          maxPriorityFeePerGas;
          constructor(t, e, n) {
            Zn(this, {
              gasPrice: Su(t),
              maxFeePerGas: Su(e),
              maxPriorityFeePerGas: Su(n),
            });
          }
          toJSON() {
            const {
              gasPrice: t,
              maxFeePerGas: e,
              maxPriorityFeePerGas: n,
            } = this;
            return {
              _type: "FeeData",
              gasPrice: Iu(t),
              maxFeePerGas: Iu(e),
              maxPriorityFeePerGas: Iu(n),
            };
          }
        }
        function Bu(t) {
          const e = {};
          t.to && (e.to = t.to),
            t.from && (e.from = t.from),
            t.data && (e.data = fr(t.data));
          const n =
            "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
              /,/
            );
          for (const r of n)
            r in t && null != t[r] && (e[r] = kr(t[r], `request.${r}`));
          const r = "type,nonce".split(/,/);
          for (const n of r)
            n in t && null != t[n] && (e[n] = Ir(t[n], `request.${n}`));
          return (
            t.accessList && (e.accessList = Vc(t.accessList)),
            "blockTag" in t && (e.blockTag = t.blockTag),
            "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead),
            "customData" in t && (e.customData = t.customData),
            e
          );
        }
        class Tu {
          provider;
          number;
          hash;
          timestamp;
          parentHash;
          nonce;
          difficulty;
          gasLimit;
          gasUsed;
          miner;
          extraData;
          baseFeePerGas;
          #pt;
          constructor(t, e) {
            (this.#pt = t.transactions.map((t) =>
              "string" != typeof t ? new Lu(t, e) : t
            )),
              Zn(this, {
                provider: e,
                hash: Su(t.hash),
                number: t.number,
                timestamp: t.timestamp,
                parentHash: t.parentHash,
                nonce: t.nonce,
                difficulty: t.difficulty,
                gasLimit: t.gasLimit,
                gasUsed: t.gasUsed,
                miner: t.miner,
                extraData: t.extraData,
                baseFeePerGas: Su(t.baseFeePerGas),
              });
          }
          get transactions() {
            return this.#pt.map((t) => ("string" == typeof t ? t : t.hash));
          }
          get prefetchedTransactions() {
            const t = this.#pt.slice();
            return 0 === t.length
              ? []
              : (rr(
                  "object" == typeof t[0],
                  "transactions were not prefetched with block request",
                  "UNSUPPORTED_OPERATION",
                  { operation: "transactionResponses()" }
                ),
                t);
          }
          toJSON() {
            const {
              baseFeePerGas: t,
              difficulty: e,
              extraData: n,
              gasLimit: r,
              gasUsed: s,
              hash: i,
              miner: o,
              nonce: a,
              number: c,
              parentHash: l,
              timestamp: u,
              transactions: h,
            } = this;
            return {
              _type: "Block",
              baseFeePerGas: Iu(t),
              difficulty: Iu(e),
              extraData: n,
              gasLimit: Iu(r),
              gasUsed: Iu(s),
              hash: i,
              miner: o,
              nonce: a,
              number: c,
              parentHash: l,
              timestamp: u,
              transactions: h,
            };
          }
          [Symbol.iterator]() {
            let t = 0;
            const e = this.transactions;
            return {
              next: () =>
                t < this.length
                  ? { value: e[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get length() {
            return this.#pt.length;
          }
          get date() {
            return null == this.timestamp
              ? null
              : new Date(1e3 * this.timestamp);
          }
          async getTransaction(t) {
            let e;
            if ("number" == typeof t) e = this.#pt[t];
            else {
              const n = t.toLowerCase();
              for (const t of this.#pt) {
                if ("string" == typeof t) {
                  if (t !== n) continue;
                  e = t;
                  break;
                }
                if (t.hash !== n) {
                  e = t;
                  break;
                }
              }
            }
            if (null == e) throw new Error("no such tx");
            return "string" == typeof e
              ? await this.provider.getTransaction(e)
              : e;
          }
          getPrefetchedTransaction(t) {
            const e = this.prefetchedTransactions;
            if ("number" == typeof t) return e[t];
            t = t.toLowerCase();
            for (const n of e) if (n.hash === t) return n;
            sr(!1, "no matching transaction", "indexOrHash", t);
          }
          isMined() {
            return !!this.hash;
          }
          isLondon() {
            return !!this.baseFeePerGas;
          }
          orphanedEvent() {
            if (!this.isMined()) throw new Error("");
            return {
              orphan: "drop-block",
              hash: (t = this).hash,
              number: t.number,
            };
            var t;
          }
        }
        class Ou {
          provider;
          transactionHash;
          blockHash;
          blockNumber;
          removed;
          address;
          data;
          topics;
          index;
          transactionIndex;
          constructor(t, e) {
            this.provider = e;
            const n = Object.freeze(t.topics.slice());
            Zn(this, {
              transactionHash: t.transactionHash,
              blockHash: t.blockHash,
              blockNumber: t.blockNumber,
              removed: t.removed,
              address: t.address,
              data: t.data,
              topics: n,
              index: t.index,
              transactionIndex: t.transactionIndex,
            });
          }
          toJSON() {
            const {
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: o,
              transactionHash: a,
              transactionIndex: c,
            } = this;
            return {
              _type: "log",
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: o,
              transactionHash: a,
              transactionIndex: c,
            };
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            return (
              rr(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t
            );
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.transactionHash);
            return (
              rr(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t
            );
          }
          async getTransactionReceipt() {
            const t = await this.provider.getTransactionReceipt(
              this.transactionHash
            );
            return (
              rr(
                !!t,
                "failed to find transaction receipt",
                "UNKNOWN_ERROR",
                {}
              ),
              t
            );
          }
          removedEvent() {
            return {
              orphan: "drop-log",
              log: {
                transactionHash: (t = this).transactionHash,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                address: t.address,
                data: t.data,
                topics: Object.freeze(t.topics.slice()),
                index: t.index,
              },
            };
            var t;
          }
        }
        class Ru {
          provider;
          to;
          from;
          contractAddress;
          hash;
          index;
          blockHash;
          blockNumber;
          logsBloom;
          gasUsed;
          cumulativeGasUsed;
          gasPrice;
          type;
          status;
          root;
          #gt;
          constructor(t, e) {
            this.#gt = Object.freeze(t.logs.map((t) => new Ou(t, e)));
            let n = Pu;
            null != t.effectiveGasPrice
              ? (n = t.effectiveGasPrice)
              : null != t.gasPrice && (n = t.gasPrice),
              Zn(this, {
                provider: e,
                to: t.to,
                from: t.from,
                contractAddress: t.contractAddress,
                hash: t.hash,
                index: t.index,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                logsBloom: t.logsBloom,
                gasUsed: t.gasUsed,
                cumulativeGasUsed: t.cumulativeGasUsed,
                gasPrice: n,
                type: t.type,
                status: t.status,
                root: t.root,
              });
          }
          get logs() {
            return this.#gt;
          }
          toJSON() {
            const {
              to: t,
              from: e,
              contractAddress: n,
              hash: r,
              index: s,
              blockHash: i,
              blockNumber: o,
              logsBloom: a,
              logs: c,
              status: l,
              root: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              blockHash: i,
              blockNumber: o,
              contractAddress: n,
              cumulativeGasUsed: Iu(this.cumulativeGasUsed),
              from: e,
              gasPrice: Iu(this.gasPrice),
              gasUsed: Iu(this.gasUsed),
              hash: r,
              index: s,
              logs: c,
              logsBloom: a,
              root: u,
              status: l,
              to: t,
            };
          }
          get length() {
            return this.logs.length;
          }
          [Symbol.iterator]() {
            let t = 0;
            return {
              next: () =>
                t < this.length
                  ? { value: this.logs[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get fee() {
            return this.gasUsed * this.gasPrice;
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.hash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getResult() {
            return await this.provider.getTransactionResult(this.hash);
          }
          async confirmations() {
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          removedEvent() {
            return Fu(this);
          }
          reorderedEvent(t) {
            return (
              rr(
                !t || t.isMined(),
                "unmined 'other' transction cannot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "reorderedEvent(other)" }
              ),
              Uu(this, t)
            );
          }
        }
        class Lu {
          provider;
          blockNumber;
          blockHash;
          index;
          hash;
          type;
          to;
          from;
          nonce;
          gasLimit;
          gasPrice;
          maxPriorityFeePerGas;
          maxFeePerGas;
          data;
          value;
          chainId;
          signature;
          accessList;
          #mt;
          constructor(t, e) {
            (this.provider = e),
              (this.blockNumber = null != t.blockNumber ? t.blockNumber : null),
              (this.blockHash = null != t.blockHash ? t.blockHash : null),
              (this.hash = t.hash),
              (this.index = t.index),
              (this.type = t.type),
              (this.from = t.from),
              (this.to = t.to || null),
              (this.gasLimit = t.gasLimit),
              (this.nonce = t.nonce),
              (this.data = t.data),
              (this.value = t.value),
              (this.gasPrice = t.gasPrice),
              (this.maxPriorityFeePerGas =
                null != t.maxPriorityFeePerGas ? t.maxPriorityFeePerGas : null),
              (this.maxFeePerGas =
                null != t.maxFeePerGas ? t.maxFeePerGas : null),
              (this.chainId = t.chainId),
              (this.signature = t.signature),
              (this.accessList = null != t.accessList ? t.accessList : null),
              (this.#mt = -1);
          }
          toJSON() {
            const {
              blockNumber: t,
              blockHash: e,
              index: n,
              hash: r,
              type: s,
              to: i,
              from: o,
              nonce: a,
              data: c,
              signature: l,
              accessList: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              accessList: u,
              blockNumber: t,
              blockHash: e,
              chainId: Iu(this.chainId),
              data: c,
              from: o,
              gasLimit: Iu(this.gasLimit),
              gasPrice: Iu(this.gasPrice),
              hash: r,
              maxFeePerGas: Iu(this.maxFeePerGas),
              maxPriorityFeePerGas: Iu(this.maxPriorityFeePerGas),
              nonce: a,
              signature: l,
              to: i,
              index: n,
              type: s,
              value: Iu(this.value),
            };
          }
          async getBlock() {
            let t = this.blockNumber;
            if (null == t) {
              const e = await this.getTransaction();
              e && (t = e.blockNumber);
            }
            if (null == t) return null;
            const e = this.provider.getBlock(t);
            if (null == e) throw new Error("TODO");
            return e;
          }
          async getTransaction() {
            return this.provider.getTransaction(this.hash);
          }
          async confirmations() {
            if (null == this.blockNumber) {
              const { tx: t, blockNumber: e } = await Yn({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(),
              });
              return null == t || null == t.blockNumber
                ? 0
                : e - t.blockNumber + 1;
            }
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          async wait(t, e) {
            const n = null == t ? 1 : t,
              r = null == e ? 0 : e;
            let s = this.#mt,
              i = -1,
              o = -1 === s;
            const a = async () => {
                if (o) return null;
                const { blockNumber: t, nonce: e } = await Yn({
                  blockNumber: this.provider.getBlockNumber(),
                  nonce: this.provider.getTransactionCount(this.from),
                });
                if (e < this.nonce) return void (s = t);
                if (o) return null;
                const r = await this.getTransaction();
                if (!r || null == r.blockNumber)
                  for (
                    -1 === i && ((i = s - 3), i < this.#mt && (i = this.#mt));
                    i <= t;

                  ) {
                    if (o) return null;
                    const e = await this.provider.getBlock(i, !0);
                    if (null == e) return;
                    for (const t of e) if (t === this.hash) return;
                    for (let r = 0; r < e.length; r++) {
                      const i = await e.getTransaction(r);
                      if (i.from === this.from && i.nonce === this.nonce) {
                        if (o) return null;
                        const e = await this.provider.getTransactionReceipt(
                          i.hash
                        );
                        if (null == e) return;
                        if (t - e.blockNumber + 1 < n) return;
                        let r = "replaced";
                        i.data === this.data &&
                        i.to === this.to &&
                        i.value === this.value
                          ? (r = "repriced")
                          : "0x" === i.data &&
                            i.from === i.to &&
                            i.value === Pu &&
                            (r = "cancelled"),
                          rr(
                            !1,
                            "transaction was replaced",
                            "TRANSACTION_REPLACED",
                            {
                              cancelled: "replaced" === r || "cancelled" === r,
                              reason: r,
                              replacement: i.replaceableTransaction(s),
                              hash: i.hash,
                              receipt: e,
                            }
                          );
                      }
                    }
                    i++;
                  }
              },
              c = await this.provider.getTransactionReceipt(this.hash);
            if (0 === n) return c;
            if (c) {
              if ((await c.confirmations()) >= n) return c;
            } else if ((await a(), 0 === n)) return null;
            const l = new Promise((t, e) => {
              const i = [],
                c = () => {
                  i.forEach((t) => t());
                };
              if (
                (i.push(() => {
                  o = !0;
                }),
                r > 0)
              ) {
                const t = setTimeout(() => {
                  c(), e(nr("wait for transaction timeout", "TIMEOUT"));
                }, r);
                i.push(() => {
                  clearTimeout(t);
                });
              }
              const l = async (e) => {
                (await e.confirmations()) >= n && (c(), t(e));
              };
              if (
                (i.push(() => {
                  this.provider.off(this.hash, l);
                }),
                this.provider.on(this.hash, l),
                s >= 0)
              ) {
                const t = async () => {
                  try {
                    await a();
                  } catch (t) {
                    if (tr(t, "TRANSACTION_REPLACED")) return c(), void e(t);
                  }
                  o || this.provider.once("block", t);
                };
                i.push(() => {
                  this.provider.off("block", t);
                }),
                  this.provider.once("block", t);
              }
            });
            return await l;
          }
          isMined() {
            return null != this.blockHash;
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          removedEvent() {
            return (
              rr(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              Fu(this)
            );
          }
          reorderedEvent(t) {
            return (
              rr(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              rr(
                !t || t.isMined(),
                "unmined 'other' transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              Uu(this, t)
            );
          }
          replaceableTransaction(t) {
            sr(
              Number.isInteger(t) && t >= 0,
              "invalid startBlock",
              "startBlock",
              t
            );
            const e = new Lu(this, this.provider);
            return (e.#mt = t), e;
          }
        }
        function Uu(t, e) {
          return { orphan: "reorder-transaction", tx: t, other: e };
        }
        function Fu(t) {
          return { orphan: "drop-transaction", tx: t };
        }
        class Du extends Ou {
          interface;
          fragment;
          args;
          constructor(t, e, n) {
            super(t, t.provider);
            Zn(this, {
              args: e.decodeEventLog(n, t.data, t.topics),
              fragment: n,
              interface: e,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        class Mu extends Ru {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          get logs() {
            return super.logs.map((t) => {
              const e = t.topics.length ? this.#yt.getEvent(t.topics[0]) : null;
              return e ? new Du(t, this.#yt, e) : t;
            });
          }
        }
        class zu extends Lu {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          async wait(t) {
            const e = await super.wait(t);
            return null == e ? null : new Mu(this.#yt, this.provider, e);
          }
        }
        class ju extends Rr {
          log;
          constructor(t, e, n, r) {
            super(t, e, n), Zn(this, { log: r });
          }
          async getBlock() {
            return await this.log.getBlock();
          }
          async getTransaction() {
            return await this.log.getTransaction();
          }
          async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
          }
        }
        class $u extends ju {
          constructor(t, e, n, r, s) {
            super(t, e, n, new Du(s, t.interface, r));
            Zn(this, {
              args: t.interface.decodeEventLog(
                r,
                this.log.data,
                this.log.topics
              ),
              fragment: r,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        const Gu = BigInt(0);
        function Hu(t) {
          return t && "function" == typeof t.call;
        }
        function Qu(t) {
          return t && "function" == typeof t.estimateGas;
        }
        function Vu(t) {
          return t && "function" == typeof t.resolveName;
        }
        function Ju(t) {
          return t && "function" == typeof t.sendTransaction;
        }
        class Wu {
          #bt;
          fragment;
          constructor(t, e, n) {
            if ((Zn(this, { fragment: e }), e.inputs.length < n.length))
              throw new Error("too many arguments");
            const r = Ku(t.runner, "resolveName"),
              s = Vu(r) ? r : null;
            this.#bt = (async function () {
              const r = await Promise.all(
                e.inputs.map((t, e) =>
                  null == n[e]
                    ? null
                    : t.walkAsync(n[e], (t, e) =>
                        "address" === t ? ta(e, s) : e
                      )
                )
              );
              return t.interface.encodeFilterTopics(e, r);
            })();
          }
          getTopicFilter() {
            return this.#bt;
          }
        }
        function Ku(t, e) {
          return null == t
            ? null
            : "function" == typeof t[e]
            ? t
            : t.provider && "function" == typeof t.provider[e]
            ? t.provider
            : null;
        }
        function _u(t) {
          return null == t ? null : t.provider || null;
        }
        async function qu(t, e) {
          const n = Bu(ia.dereference(t, "overrides"));
          return (
            sr(
              null == n.to || (e || []).indexOf("to") >= 0,
              "cannot override to",
              "overrides.to",
              n.to
            ),
            sr(
              null == n.data || (e || []).indexOf("data") >= 0,
              "cannot override data",
              "overrides.data",
              n.data
            ),
            n.from && (n.from = await ta(n.from)),
            n
          );
        }
        function Yu(t) {
          const e = async function (e) {
              const n = await qu(e, ["data"]);
              n.to = await t.getAddress();
              const r = t.interface,
                s = kr(n.value || Gu, "overrides.value") === Gu,
                i = "0x" === (n.data || "0x");
              !r.fallback ||
                r.fallback.payable ||
                !r.receive ||
                i ||
                s ||
                sr(
                  !1,
                  "cannot send data to receive or send value to non-payable fallback",
                  "overrides",
                  e
                ),
                sr(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                );
              return (
                sr(
                  r.receive || (r.fallback && r.fallback.payable) || s,
                  "cannot send value to non-payable fallback",
                  "overrides.value",
                  n.value
                ),
                sr(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                ),
                n
              );
            },
            n = async function (n) {
              const r = t.runner;
              rr(
                Ju(r),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await r.sendTransaction(await e(n)),
                i = _u(t.runner);
              return new zu(t.interface, i, s);
            },
            r = async (t) => await n(t);
          return (
            Zn(r, {
              _contract: t,
              estimateGas: async function (n) {
                const r = Ku(t.runner, "estimateGas");
                return (
                  rr(
                    Qu(r),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await r.estimateGas(await e(n))
                );
              },
              populateTransaction: e,
              send: n,
              staticCall: async function (n) {
                const r = Ku(t.runner, "call");
                rr(
                  Hu(r),
                  "contract runner does not support calling",
                  "UNSUPPORTED_OPERATION",
                  { operation: "call" }
                );
                const s = await e(n);
                try {
                  return await r.call(s);
                } catch (e) {
                  if (er(e) && e.data) throw t.interface.makeError(e.data, s);
                  throw e;
                }
              },
            }),
            r
          );
        }
        function Zu(t, e) {
          const n = function (...n) {
              const r = t.interface.getFunction(e, n);
              return (
                rr(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                  operation: "fragment",
                }),
                r
              );
            },
            r = async function (...e) {
              const r = n(...e);
              let s = {};
              if (
                (r.inputs.length + 1 === e.length && (s = await qu(e.pop())),
                r.inputs.length !== e.length)
              )
                throw new Error(
                  "internal error: fragment inputs doesn't match arguments; should not happen"
                );
              const i = await (async function (t, e, n) {
                const r = Ku(t, "resolveName"),
                  s = Vu(r) ? r : null;
                return await Promise.all(
                  e.map((t, e) =>
                    t.walkAsync(
                      n[e],
                      (t, e) => (
                        (e = ia.dereference(e, t)),
                        "address" === t ? ta(e, s) : e
                      )
                    )
                  )
                );
              })(t.runner, r.inputs, e);
              return Object.assign(
                {},
                s,
                await Yn({
                  to: t.getAddress(),
                  data: t.interface.encodeFunctionData(r, i),
                })
              );
            },
            s = async function (...t) {
              const e = await o(...t);
              return 1 === e.length ? e[0] : e;
            },
            i = async function (...e) {
              const n = t.runner;
              rr(
                Ju(n),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await n.sendTransaction(await r(...e)),
                i = _u(t.runner);
              return new zu(t.interface, i, s);
            },
            o = async function (...e) {
              const s = Ku(t.runner, "call");
              rr(
                Hu(s),
                "contract runner does not support calling",
                "UNSUPPORTED_OPERATION",
                { operation: "call" }
              );
              const i = await r(...e);
              let o = "0x";
              try {
                o = await s.call(i);
              } catch (e) {
                if (er(e) && e.data) throw t.interface.makeError(e.data, i);
                throw e;
              }
              const a = n(...e);
              return t.interface.decodeFunctionResult(a, o);
            },
            a = async (...t) =>
              n(...t).constant ? await s(...t) : await i(...t);
          return (
            Zn(a, {
              name: t.interface.getFunctionName(e),
              _contract: t,
              _key: e,
              getFragment: n,
              estimateGas: async function (...e) {
                const n = Ku(t.runner, "estimateGas");
                return (
                  rr(
                    Qu(n),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await n.estimateGas(await r(...e))
                );
              },
              populateTransaction: r,
              send: i,
              staticCall: s,
              staticCallResult: o,
            }),
            Object.defineProperty(a, "fragment", {
              configurable: !1,
              enumerable: !0,
              get: () => {
                const n = t.interface.getFunction(e);
                return (
                  rr(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                    operation: "fragment",
                  }),
                  n
                );
              },
            }),
            a
          );
        }
        const Xu = Symbol.for("_ethersInternal_contract"),
          th = new WeakMap();
        function eh(t) {
          return th.get(t[Xu]);
        }
        async function nh(t, e) {
          let n,
            r = null;
          if (Array.isArray(e)) {
            const r = function (e) {
              if (hr(e, 32)) return e;
              const n = t.interface.getEvent(e);
              return sr(n, "unknown fragment", "name", e), n.topicHash;
            };
            n = e.map((t) =>
              null == t ? null : Array.isArray(t) ? t.map(r) : r(t)
            );
          } else
            "*" === e
              ? (n = [null])
              : "string" == typeof e
              ? hr(e, 32)
                ? (n = [e])
                : ((r = t.interface.getEvent(e)),
                  sr(r, "unknown fragment", "event", e),
                  (n = [r.topicHash]))
              : (s = e) &&
                "object" == typeof s &&
                "getTopicFilter" in s &&
                "function" == typeof s.getTopicFilter &&
                s.fragment
              ? (n = await e.getTopicFilter())
              : "fragment" in e
              ? ((r = e.fragment), (n = [r.topicHash]))
              : sr(!1, "unknown event name", "event", e);
          var s;
          n = n.map((t) => {
            if (null == t) return null;
            if (Array.isArray(t)) {
              const e = Array.from(
                new Set(t.map((t) => t.toLowerCase())).values()
              );
              return 1 === e.length ? e[0] : (e.sort(), e);
            }
            return t.toLowerCase();
          });
          const i = n
            .map((t) =>
              null == t ? "null" : Array.isArray(t) ? t.join("|") : t
            )
            .join("&");
          return { fragment: r, tag: i, topics: n };
        }
        async function rh(t, e) {
          const { subs: n } = eh(t);
          return n.get((await nh(t, e)).tag) || null;
        }
        async function sh(t, e, n) {
          const r = _u(t.runner);
          rr(
            r,
            "contract runner does not support subscribing",
            "UNSUPPORTED_OPERATION",
            { operation: e }
          );
          const { fragment: s, tag: i, topics: o } = await nh(t, n),
            { addr: a, subs: c } = eh(t);
          let l = c.get(i);
          if (!l) {
            const e = { address: a || t, topics: o },
              u = (e) => {
                let r = s;
                if (null == r)
                  try {
                    r = t.interface.getEvent(e.topics[0]);
                  } catch (t) {}
                if (r) {
                  const i = r,
                    o = s
                      ? t.interface.decodeEventLog(s, e.data, e.topics)
                      : [];
                  oh(t, n, o, (r) => new $u(t, r, n, i, e));
                } else oh(t, n, [], (r) => new ju(t, r, n, e));
              };
            let h = [];
            (l = {
              tag: i,
              listeners: [],
              start: () => {
                h.length || h.push(r.on(e, u));
              },
              stop: async () => {
                if (0 == h.length) return;
                let t = h;
                (h = []), await Promise.all(t), r.off(e, u);
              },
            }),
              c.set(i, l);
          }
          return l;
        }
        let ih = Promise.resolve();
        async function oh(t, e, n, r) {
          try {
            await ih;
          } catch (t) {}
          const s = (async function (t, e, n, r) {
            await ih;
            const s = await rh(t, e);
            if (!s) return !1;
            const i = s.listeners.length;
            return (
              (s.listeners = s.listeners.filter(({ listener: e, once: s }) => {
                const i = Array.from(n);
                r && i.push(r(s ? null : e));
                try {
                  e.call(t, ...i);
                } catch (t) {}
                return !s;
              })),
              0 === s.listeners.length && (s.stop(), eh(t).subs.delete(s.tag)),
              i > 0
            );
          })(t, e, n, r);
          return (ih = s), await s;
        }
        const ah = ["then"];
        class ch {
          target;
          interface;
          runner;
          filters;
          [Xu];
          fallback;
          constructor(t, e, n, r) {
            sr(
              "string" == typeof t || Zo(t),
              "invalid value for Contract target",
              "target",
              t
            ),
              null == n && (n = null);
            const s = Cu.from(e);
            let i;
            Zn(this, { target: t, runner: n, interface: s }),
              Object.defineProperty(this, Xu, { value: {} });
            let o = null,
              a = null;
            if (r) {
              const t = _u(n);
              a = new zu(this.interface, t, r);
            }
            let c = new Map();
            if ("string" == typeof t)
              if (hr(t)) (o = t), (i = Promise.resolve(t));
              else {
                const e = Ku(n, "resolveName");
                if (!Vu(e))
                  throw nr(
                    "contract runner does not support name resolution",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  );
                i = e.resolveName(t).then((e) => {
                  if (null == e)
                    throw nr(
                      "an ENS name used for a contract target must be correctly configured",
                      "UNCONFIGURED_NAME",
                      { value: t }
                    );
                  return (eh(this).addr = e), e;
                });
              }
            else
              i = t.getAddress().then((t) => {
                if (null == t) throw new Error("TODO");
                return (eh(this).addr = t), t;
              });
            var l, u;
            (l = this),
              (u = { addrPromise: i, addr: o, deployTx: a, subs: c }),
              th.set(l[Xu], u);
            const h = new Proxy(
              {},
              {
                get: (t, e, n) => {
                  if (ah.indexOf(e) >= 0) return Reflect.get(t, e, n);
                  const r = String(e),
                    s = this.getEvent(r);
                  if (s) return s;
                  throw new Error(`unknown contract event: ${r}`);
                },
                has: (t, e) =>
                  ah.indexOf(e) >= 0
                    ? Reflect.has(t, e)
                    : Reflect.has(t, e) || this.interface.hasEvent(String(e)),
              }
            );
            return (
              Zn(this, { filters: h }),
              Zn(this, { fallback: s.receive || s.fallback ? Yu(this) : null }),
              new Proxy(this, {
                get: (t, e, n) => {
                  if (e in t || ah.indexOf(e) >= 0) return Reflect.get(t, e, n);
                  const r = String(e),
                    s = t.getFunction(r);
                  if (s) return s;
                  throw new Error(`unknown contract method: ${r}`);
                },
                has: (t, e) =>
                  e in t || ah.indexOf(e) >= 0
                    ? Reflect.has(t, e)
                    : t.interface.hasFunction(String(e)),
              })
            );
          }
          connect(t) {
            return new ch(this.target, this.interface, t);
          }
          attach(t) {
            return new ch(t, this.interface, this.runner);
          }
          async getAddress() {
            return await eh(this).addrPromise;
          }
          async getDeployedCode() {
            const t = _u(this.runner);
            rr(
              t,
              "runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "getDeployedCode" }
            );
            const e = await t.getCode(await this.getAddress());
            return "0x" === e ? null : e;
          }
          async waitForDeployment() {
            const t = this.deploymentTransaction();
            if (t) return await t.wait(), this;
            if (null != (await this.getDeployedCode())) return this;
            const e = _u(this.runner);
            return (
              rr(
                null != e,
                "contract runner does not support .provider",
                "UNSUPPORTED_OPERATION",
                { operation: "waitForDeployment" }
              ),
              new Promise((t, n) => {
                const r = async () => {
                  try {
                    if (null != (await this.getDeployedCode())) return t(this);
                    e.once("block", r);
                  } catch (t) {
                    n(t);
                  }
                };
                r();
              })
            );
          }
          deploymentTransaction() {
            return eh(this).deployTx;
          }
          getFunction(t) {
            "string" != typeof t && (t = t.format());
            return Zu(this, t);
          }
          getEvent(t) {
            return (
              "string" != typeof t && (t = t.format()),
              (function (t, e) {
                const n = function (...n) {
                    const r = t.interface.getEvent(e, n);
                    return (
                      rr(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                        operation: "fragment",
                      }),
                      r
                    );
                  },
                  r = function (...e) {
                    return new Wu(t, n(...e), e);
                  };
                return (
                  Zn(r, {
                    name: t.interface.getEventName(e),
                    _contract: t,
                    _key: e,
                    getFragment: n,
                  }),
                  Object.defineProperty(r, "fragment", {
                    configurable: !1,
                    enumerable: !0,
                    get: () => {
                      const n = t.interface.getEvent(e);
                      return (
                        rr(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                          operation: "fragment",
                        }),
                        n
                      );
                    },
                  }),
                  r
                );
              })(this, t)
            );
          }
          async queryTransaction(t) {
            throw new Error("@TODO");
          }
          async queryFilter(t, e, n) {
            null == e && (e = 0), null == n && (n = "latest");
            const { addr: r, addrPromise: s } = eh(this),
              i = r || (await s),
              { fragment: o, topics: a } = await nh(this, t),
              c = { address: i, topics: a, fromBlock: e, toBlock: n },
              l = _u(this.runner);
            return (
              rr(
                l,
                "contract runner does not have a provider",
                "UNSUPPORTED_OPERATION",
                { operation: "queryFilter" }
              ),
              (await l.getLogs(c)).map((t) => {
                let e = o;
                if (null == e)
                  try {
                    e = this.interface.getEvent(t.topics[0]);
                  } catch (t) {}
                return e ? new Du(t, this.interface, e) : new Ou(t, l);
              })
            );
          }
          async on(t, e) {
            const n = await sh(this, "on", t);
            return n.listeners.push({ listener: e, once: !1 }), n.start(), this;
          }
          async once(t, e) {
            const n = await sh(this, "once", t);
            return n.listeners.push({ listener: e, once: !0 }), n.start(), this;
          }
          async emit(t, ...e) {
            return await oh(this, t, e, null);
          }
          async listenerCount(t) {
            if (t) {
              const e = await rh(this, t);
              return e ? e.listeners.length : 0;
            }
            const { subs: e } = eh(this);
            let n = 0;
            for (const { listeners: t } of e.values()) n += t.length;
            return n;
          }
          async listeners(t) {
            if (t) {
              const e = await rh(this, t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            const { subs: e } = eh(this);
            let n = [];
            for (const { listeners: t } of e.values())
              n = n.concat(t.map(({ listener: t }) => t));
            return n;
          }
          async off(t, e) {
            const n = await rh(this, t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (null != e && 0 !== n.listeners.length) ||
                (n.stop(), eh(this).subs.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const e = await rh(this, t);
              if (!e) return this;
              e.stop(), eh(this).subs.delete(e.tag);
            } else {
              const { subs: t } = eh(this);
              for (const { tag: e, stop: n } of t.values()) n(), t.delete(e);
            }
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return await this.off(t, e);
          }
          static buildClass(t) {
            return class extends ch {
              constructor(e, n = null) {
                super(e, t, n);
              }
            };
          }
          static from(t, e, n) {
            null == n && (n = null);
            return new this(t, e, n);
          }
        }
        class lh extends (function () {
          return ch;
        })() {}
        function uh(t) {
          return (
            t.match(/^ipfs:\/\/ipfs\//i)
              ? (t = t.substring(12))
              : t.match(/^ipfs:\/\//i)
              ? (t = t.substring(7))
              : sr(!1, "unsupported IPFS format", "link", t),
            `https://gateway.ipfs.io/ipfs/${t}`
          );
        }
        class hh {
          name;
          constructor(t) {
            Zn(this, { name: t });
          }
          connect(t) {
            return this;
          }
          supportsCoinType(t) {
            return !1;
          }
          async encodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
          async decodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
        }
        const dh = new RegExp("^(ipfs)://(.*)$", "i"),
          fh = [
            new RegExp("^(https)://(.*)$", "i"),
            new RegExp("^(data):(.*)$", "i"),
            dh,
            new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
          ];
        class ph {
          provider;
          address;
          name;
          #wt;
          #At;
          constructor(t, e, n) {
            Zn(this, { provider: t, address: e, name: n }),
              (this.#wt = null),
              (this.#At = new lh(
                e,
                [
                  "function supportsInterface(bytes4) view returns (bool)",
                  "function resolve(bytes, bytes) view returns (bytes)",
                  "function addr(bytes32) view returns (address)",
                  "function addr(bytes32, uint) view returns (bytes)",
                  "function text(bytes32, string) view returns (string)",
                  "function contenthash(bytes32) view returns (bytes)",
                ],
                t
              ));
          }
          async supportsWildcard() {
            return (
              null == this.#wt &&
                (this.#wt = (async () => {
                  try {
                    return await this.#At.supportsInterface("0x9061b923");
                  } catch (t) {
                    if (tr(t, "CALL_EXCEPTION")) return !1;
                    throw ((this.#wt = null), t);
                  }
                })()),
              await this.#wt
            );
          }
          async #vt(t, e) {
            e = (e || []).slice();
            const n = this.#At.interface;
            e.unshift(Hc(this.name));
            let r = null;
            var s;
            (await this.supportsWildcard()) &&
              ((r = n.getFunction(t)),
              rr(r, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName: t },
              }),
              (e = [
                ((s = this.name),
                fr(
                  pr(
                    Gc(s).map((t) => {
                      if (t.length > 63)
                        throw new Error(
                          "invalid DNS encoded entry; length exceeds 63 bytes"
                        );
                      const e = new Uint8Array(t.length + 1);
                      return e.set(t, 1), (e[0] = e.length - 1), e;
                    })
                  )
                ) + "00"),
                n.encodeFunctionData(r, e),
              ]),
              (t = "resolve(bytes,bytes)")),
              e.push({ enableCcipRead: !0 });
            try {
              const s = await this.#At[t](...e);
              return r ? n.decodeFunctionResult(r, s)[0] : s;
            } catch (t) {
              if (!tr(t, "CALL_EXCEPTION")) throw t;
            }
            return null;
          }
          async getAddress(t) {
            if ((null == t && (t = 60), 60 === t))
              try {
                const t = await this.#vt("addr(bytes32)");
                return null == t || t === Ro ? null : t;
              } catch (t) {
                if (tr(t, "CALL_EXCEPTION")) return null;
                throw t;
              }
            if (t >= 0 && t < 2147483648) {
              let e = t + 2147483648;
              const n = await this.#vt("addr(bytes32,uint)", [e]);
              if (hr(n, 20)) return Yo(n);
            }
            let e = null;
            for (const n of this.provider.plugins)
              if (n instanceof hh && n.supportsCoinType(t)) {
                e = n;
                break;
              }
            if (null == e) return null;
            const n = await this.#vt("addr(bytes32,uint)", [t]);
            if (null == n || "0x" === n) return null;
            const r = await e.decodeAddress(t, n);
            if (null != r) return r;
            rr(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${t})`,
              info: { coinType: t, data: n },
            });
          }
          async getText(t) {
            const e = await this.#vt("text(bytes32,string)", [t]);
            return null == e || "0x" === e ? null : e;
          }
          async getContentHash() {
            const t = await this.#vt("contenthash(bytes32)");
            if (null == t || "0x" === t) return null;
            const e = t.match(
              /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
            );
            if (e) {
              const t = "e3010170" === e[1] ? "ipfs" : "ipns",
                n = parseInt(e[4], 16);
              if (e[5].length === 2 * n)
                return `${t}://${(function (t) {
                  let e = Sr(lr(t)),
                    n = "";
                  for (; e; )
                    (n =
                      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"[
                        Number(e % Or)
                      ] + n),
                      (e /= Or);
                  return n;
                })("0x" + e[2])}`;
            }
            const n = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (n && 64 === n[1].length) return `bzz://${n[1]}`;
            rr(
              !1,
              "invalid or unsupported content hash data",
              "UNSUPPORTED_OPERATION",
              { operation: "getContentHash()", info: { data: t } }
            );
          }
          async getAvatar() {
            return (await this._getAvatar()).url;
          }
          async _getAvatar() {
            const t = [{ type: "name", value: this.name }];
            try {
              const e = await this.getText("avatar");
              if (null == e)
                return (
                  t.push({ type: "!avatar", value: "" }),
                  { url: null, linkage: t }
                );
              t.push({ type: "avatar", value: e });
              for (let n = 0; n < fh.length; n++) {
                const r = e.match(fh[n]);
                if (null == r) continue;
                const s = r[1].toLowerCase();
                switch (s) {
                  case "https":
                  case "data":
                    return (
                      t.push({ type: "url", value: e }), { linkage: t, url: e }
                    );
                  case "ipfs": {
                    const n = uh(e);
                    return (
                      t.push({ type: "ipfs", value: e }),
                      t.push({ type: "url", value: n }),
                      { linkage: t, url: n }
                    );
                  }
                  case "erc721":
                  case "erc1155": {
                    const n =
                      "erc721" === s ? "tokenURI(uint256)" : "uri(uint256)";
                    t.push({ type: s, value: e });
                    const i = await this.getAddress();
                    if (null == i)
                      return (
                        t.push({ type: "!owner", value: "" }),
                        { url: null, linkage: t }
                      );
                    const o = (r[2] || "").split("/");
                    if (2 !== o.length)
                      return (
                        t.push({ type: `!${s}caip`, value: r[2] || "" }),
                        { url: null, linkage: t }
                      );
                    const a = o[1],
                      c = new lh(
                        o[0],
                        [
                          "function tokenURI(uint) view returns (string)",
                          "function ownerOf(uint) view returns (address)",
                          "function uri(uint) view returns (string)",
                          "function balanceOf(address, uint256) view returns (uint)",
                        ],
                        this.provider
                      );
                    if ("erc721" === s) {
                      const e = await c.ownerOf(a);
                      if (i !== e)
                        return (
                          t.push({ type: "!owner", value: e }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "owner", value: e });
                    } else if ("erc1155" === s) {
                      const e = await c.balanceOf(i, a);
                      if (!e)
                        return (
                          t.push({ type: "!balance", value: "0" }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "balance", value: e.toString() });
                    }
                    let l = await c[n](a);
                    if (null == l || "0x" === l)
                      return (
                        t.push({ type: "!metadata-url", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata-url-base", value: l }),
                      "erc1155" === s &&
                        ((l = l.replace("{id}", Nr(a, 32).substring(2))),
                        t.push({ type: "metadata-url-expanded", value: l })),
                      l.match(/^ipfs:/i) && (l = uh(l)),
                      t.push({ type: "metadata-url", value: l });
                    let u = {};
                    const h = await new Kr(l).send();
                    h.assertOk();
                    try {
                      u = h.bodyJson;
                    } catch (e) {
                      try {
                        t.push({ type: "!metadata", value: h.bodyText });
                      } catch (e) {
                        const n = h.body;
                        return (
                          n && t.push({ type: "!metadata", value: fr(n) }),
                          { url: null, linkage: t }
                        );
                      }
                      return { url: null, linkage: t };
                    }
                    if (!u)
                      return (
                        t.push({ type: "!metadata", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata", value: JSON.stringify(u) });
                    let d = u.image;
                    if ("string" != typeof d)
                      return (
                        t.push({ type: "!imageUrl", value: "" }),
                        { url: null, linkage: t }
                      );
                    if (d.match(/^(https:\/\/|data:)/i));
                    else {
                      if (null == d.match(dh))
                        return (
                          t.push({ type: "!imageUrl-ipfs", value: d }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "imageUrl-ipfs", value: d }), (d = uh(d));
                    }
                    return (
                      t.push({ type: "url", value: d }), { linkage: t, url: d }
                    );
                  }
                }
              }
            } catch (t) {}
            return { linkage: t, url: null };
          }
          static async getEnsAddress(t) {
            const e = await t.getNetwork(),
              n = e.getPlugin("org.ethers.plugins.network.Ens");
            return (
              rr(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                operation: "getEnsAddress",
                info: { network: e },
              }),
              n.address
            );
          }
          static async #xt(t, e) {
            const n = await ph.getEnsAddress(t);
            try {
              const r = new lh(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  t
                ),
                s = await r.resolver(Hc(e), { enableCcipRead: !0 });
              return s === Ro ? null : s;
            } catch (t) {
              throw t;
            }
            return null;
          }
          static async fromName(t, e) {
            let n = e;
            for (;;) {
              if ("" === n || "." === n) return null;
              if ("eth" !== e && "eth" === n) return null;
              const r = await ph.#xt(t, n);
              if (null != r) {
                const s = new ph(t, r, e);
                return n === e || (await s.supportsWildcard()) ? s : null;
              }
              n = n.split(".").slice(1).join(".");
            }
          }
        }
        const gh = BigInt(0);
        function mh(t, e) {
          return function (n) {
            return null == n ? e : t(n);
          };
        }
        function yh(t) {
          return (e) => {
            if (!Array.isArray(e)) throw new Error("not an array");
            return e.map((e) => t(e));
          };
        }
        function bh(t, e) {
          return (n) => {
            const r = {};
            for (const s in t) {
              let i = s;
              if (e && s in e && !(i in n))
                for (const t of e[s])
                  if (t in n) {
                    i = t;
                    break;
                  }
              try {
                const e = t[s](n[i]);
                void 0 !== e && (r[s] = e);
              } catch (t) {
                rr(
                  !1,
                  `invalid value for value.${s} (${
                    t instanceof Error ? t.message : "not-an-error"
                  })`,
                  "BAD_DATA",
                  { value: n }
                );
              }
            }
            return r;
          };
        }
        function wh(t) {
          return sr(hr(t, !0), "invalid data", "value", t), t;
        }
        function Ah(t) {
          return sr(hr(t, 32), "invalid hash", "value", t), t;
        }
        const vh = bh(
          {
            address: Yo,
            blockHash: Ah,
            blockNumber: Ir,
            data: wh,
            index: Ir,
            removed: mh(function (t) {
              switch (t) {
                case !0:
                case "true":
                  return !0;
                case !1:
                case "false":
                  return !1;
              }
              sr(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
            }, !1),
            topics: yh(Ah),
            transactionHash: Ah,
            transactionIndex: Ir,
          },
          { index: ["logIndex"] }
        );
        const xh = bh({
          hash: mh(Ah),
          parentHash: Ah,
          number: Ir,
          timestamp: Ir,
          nonce: mh(wh),
          difficulty: kr,
          gasLimit: kr,
          gasUsed: kr,
          miner: mh(Yo),
          extraData: wh,
          baseFeePerGas: mh(kr),
        });
        const Eh = bh(
          {
            transactionIndex: Ir,
            blockNumber: Ir,
            transactionHash: Ah,
            address: Yo,
            topics: yh(Ah),
            data: wh,
            index: Ir,
            blockHash: Ah,
          },
          { index: ["logIndex"] }
        );
        const kh = bh(
          {
            to: mh(Yo, null),
            from: mh(Yo, null),
            contractAddress: mh(Yo, null),
            index: Ir,
            root: mh(fr),
            gasUsed: kr,
            logsBloom: mh(wh),
            blockHash: Ah,
            hash: Ah,
            logs: yh(function (t) {
              return Eh(t);
            }),
            blockNumber: Ir,
            cumulativeGasUsed: kr,
            effectiveGasPrice: mh(kr),
            status: mh(Ir),
            type: mh(Ir, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
        function Ch(t) {
          t.to &&
            kr(t.to) === gh &&
            (t.to = "0x0000000000000000000000000000000000000000");
          const e = bh(
            {
              hash: Ah,
              type: (t) => ("0x" === t || null == t ? 0 : Ir(t)),
              accessList: mh(Vc, null),
              blockHash: mh(Ah, null),
              blockNumber: mh(Ir, null),
              transactionIndex: mh(Ir, null),
              from: Yo,
              gasPrice: mh(kr),
              maxPriorityFeePerGas: mh(kr),
              maxFeePerGas: mh(kr),
              gasLimit: kr,
              to: mh(Yo, null),
              value: kr,
              nonce: Ir,
              data: wh,
              creates: mh(Yo, null),
              chainId: mh(kr, null),
            },
            { data: ["input"], gasLimit: ["gas"] }
          )(t);
          if (
            (null == e.to &&
              null == e.creates &&
              (e.creates = (function (t) {
                const e = Yo(t.from);
                let n = kr(t.nonce, "tx.nonce").toString(16);
                return (
                  (n = "0" === n ? "0x" : n.length % 2 ? "0x0" + n : "0x" + n),
                  Yo(mr(Ni(gs([e, n])), 12))
                );
              })(e)),
            (1 !== t.type && 2 !== t.type) ||
              null != t.accessList ||
              (e.accessList = []),
            t.signature
              ? (e.signature = Ho.from(t.signature))
              : (e.signature = Ho.from(t)),
            null == e.chainId)
          ) {
            const t = e.signature.legacyChainId;
            null != t && (e.chainId = t);
          }
          return (
            e.blockHash && kr(e.blockHash) === gh && (e.blockHash = null), e
          );
        }
        class Ph {
          name;
          constructor(t) {
            Zn(this, { name: t });
          }
          clone() {
            return new Ph(this.name);
          }
        }
        class Sh extends Ph {
          effectiveBlock;
          txBase;
          txCreate;
          txDataZero;
          txDataNonzero;
          txAccessListStorageKey;
          txAccessListAddress;
          constructor(t, e) {
            null == t && (t = 0),
              super(`org.ethers.network.plugins.GasCost#${t || 0}`);
            const n = { effectiveBlock: t };
            function r(t, r) {
              let s = (e || {})[t];
              null == s && (s = r),
                sr("number" == typeof s, `invalud value for ${t}`, "costs", e),
                (n[t] = s);
            }
            r("txBase", 21e3),
              r("txCreate", 32e3),
              r("txDataZero", 4),
              r("txDataNonzero", 16),
              r("txAccessListStorageKey", 1900),
              r("txAccessListAddress", 2400),
              Zn(this, n);
          }
          clone() {
            return new Sh(this.effectiveBlock, this);
          }
        }
        class Ih extends Ph {
          address;
          targetNetwork;
          constructor(t, e) {
            super("org.ethers.plugins.network.Ens"),
              Zn(this, {
                address: t || "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                targetNetwork: null == e ? 1 : e,
              });
          }
          clone() {
            return new Ih(this.address, this.targetNetwork);
          }
        }
        const Nh = new Map();
        class Bh {
          #Et;
          #Y;
          #kt;
          constructor(t, e) {
            (this.#Et = t), (this.#Y = kr(e)), (this.#kt = new Map());
          }
          toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
          }
          get name() {
            return this.#Et;
          }
          set name(t) {
            this.#Et = t;
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = kr(t, "chainId");
          }
          matches(t) {
            if (null == t) return !1;
            if ("string" == typeof t) {
              try {
                return this.chainId === kr(t);
              } catch (t) {}
              return this.name === t;
            }
            if ("number" == typeof t || "bigint" == typeof t) {
              try {
                return this.chainId === kr(t);
              } catch (t) {}
              return !1;
            }
            if ("object" == typeof t) {
              if (null != t.chainId) {
                try {
                  return this.chainId === kr(t.chainId);
                } catch (t) {}
                return !1;
              }
              return null != t.name && this.name === t.name;
            }
            return !1;
          }
          get plugins() {
            return Array.from(this.#kt.values());
          }
          attachPlugin(t) {
            if (this.#kt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#kt.set(t.name, t.clone()), this;
          }
          getPlugin(t) {
            return this.#kt.get(t) || null;
          }
          getPlugins(t) {
            return this.plugins.filter((e) => e.name.split("#")[0] === t);
          }
          clone() {
            const t = new Bh(this.name, this.chainId);
            return (
              this.plugins.forEach((e) => {
                t.attachPlugin(e.clone());
              }),
              t
            );
          }
          computeIntrinsicGas(t) {
            const e =
              this.getPlugin("org.ethers.plugins.network.GasCost") || new Sh();
            let n = e.txBase;
            if ((null == t.to && (n += e.txCreate), t.data))
              for (let r = 2; r < t.data.length; r += 2)
                "00" === t.data.substring(r, r + 2)
                  ? (n += e.txDataZero)
                  : (n += e.txDataNonzero);
            if (t.accessList) {
              const r = Vc(t.accessList);
              for (const t in r)
                n +=
                  e.txAccessListAddress +
                  e.txAccessListStorageKey * r[t].storageKeys.length;
            }
            return n;
          }
          static from(t) {
            if (
              ((function () {
                if (Th) return;
                function t(t, e, n) {
                  const r = function () {
                    const r = new Bh(t, e);
                    return (
                      null != n.ensNetwork &&
                        r.attachPlugin(new Ih(null, n.ensNetwork)),
                      n.priorityFee,
                      r.attachPlugin(new Sh()),
                      r
                    );
                  };
                  Bh.register(t, r),
                    Bh.register(e, r),
                    n.altNames &&
                      n.altNames.forEach((t) => {
                        Bh.register(t, r);
                      });
                }
                (Th = !0),
                  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
                  t("ropsten", 3, { ensNetwork: 3 }),
                  t("rinkeby", 4, { ensNetwork: 4 }),
                  t("goerli", 5, { ensNetwork: 5 }),
                  t("kovan", 42, { ensNetwork: 42 }),
                  t("sepolia", 11155111, {}),
                  t("classic", 61, {}),
                  t("classicKotti", 6, {}),
                  t("xdai", 100, { ensNetwork: 1 }),
                  t("optimism", 10, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api-optimistic.etherscan.io/" },
                  }),
                  t("optimism-goerli", 420, {
                    etherscan: {
                      url: "https://api-goerli-optimistic.etherscan.io/",
                    },
                  }),
                  t("arbitrum", 42161, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.arbiscan.io/" },
                  }),
                  t("arbitrum-goerli", 421613, {
                    etherscan: { url: "https://api-goerli.arbiscan.io/" },
                  }),
                  t("matic", 137, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.polygonscan.com/" },
                  }),
                  t("matic-mumbai", 80001, {
                    altNames: ["maticMumbai", "maticmum"],
                    etherscan: { url: "https://api-testnet.polygonscan.com/" },
                  }),
                  t("bnb", 56, {
                    ensNetwork: 1,
                    etherscan: { url: "http://api.bscscan.com" },
                  }),
                  t("bnbt", 97, {
                    etherscan: { url: "http://api-testnet.bscscan.com" },
                  });
              })(),
              null == t)
            )
              return Bh.from("mainnet");
            if (
              ("number" == typeof t && (t = BigInt(t)),
              "string" == typeof t || "bigint" == typeof t)
            ) {
              const e = Nh.get(t);
              if (e) return e();
              if ("bigint" == typeof t) return new Bh("unknown", t);
              sr(!1, "unknown network", "network", t);
            }
            if ("function" == typeof t.clone) {
              return t.clone();
            }
            if ("object" == typeof t) {
              sr(
                "string" == typeof t.name && "number" == typeof t.chainId,
                "invalid network object name or chainId",
                "network",
                t
              );
              const e = new Bh(t.name, t.chainId);
              return (
                (t.ensAddress || null != t.ensNetwork) &&
                  e.attachPlugin(new Ih(t.ensAddress, t.ensNetwork)),
                e
              );
            }
            sr(!1, "invalid network", "network", t);
          }
          static register(t, e) {
            "number" == typeof t && (t = BigInt(t));
            const n = Nh.get(t);
            n &&
              sr(
                !1,
                `conflicting network for ${JSON.stringify(n.name)}`,
                "nameOrChainId",
                t
              ),
              Nh.set(t, e);
          }
        }
        let Th = !1;
        function Oh(t) {
          return JSON.parse(JSON.stringify(t));
        }
        class Rh {
          #Ct;
          #Pt;
          #St;
          #It;
          constructor(t) {
            (this.#Ct = t),
              (this.#Pt = null),
              (this.#St = 4e3),
              (this.#It = -2);
          }
          get pollingInterval() {
            return this.#St;
          }
          set pollingInterval(t) {
            this.#St = t;
          }
          async #Nt() {
            try {
              const t = await this.#Ct.getBlockNumber();
              if (-2 === this.#It) return void (this.#It = t);
              if (t !== this.#It) {
                for (let e = this.#It + 1; e <= t; e++) {
                  if (null == this.#Pt) return;
                  await this.#Ct.emit("block", e);
                }
                this.#It = t;
              }
            } catch (t) {}
            null != this.#Pt &&
              (this.#Pt = this.#Ct._setTimeout(this.#Nt.bind(this), this.#St));
          }
          start() {
            this.#Pt ||
              ((this.#Pt = this.#Ct._setTimeout(this.#Nt.bind(this), this.#St)),
              this.#Nt());
          }
          stop() {
            this.#Pt && (this.#Ct._clearTimeout(this.#Pt), (this.#Pt = null));
          }
          pause(t) {
            this.stop(), t && (this.#It = -2);
          }
          resume() {
            this.start();
          }
        }
        class Lh {
          #Ct;
          #Nt;
          #Bt;
          constructor(t) {
            (this.#Ct = t),
              (this.#Bt = !1),
              (this.#Nt = (t) => {
                this._poll(t, this.#Ct);
              });
          }
          async _poll(t, e) {
            throw new Error("sub-classes must override this");
          }
          start() {
            this.#Bt ||
              ((this.#Bt = !0), this.#Nt(-2), this.#Ct.on("block", this.#Nt));
          }
          stop() {
            this.#Bt && ((this.#Bt = !1), this.#Ct.off("block", this.#Nt));
          }
          pause(t) {
            this.stop();
          }
          resume() {
            this.start();
          }
        }
        class Uh extends Lh {
          #bt;
          constructor(t, e) {
            super(t), (this.#bt = Oh(e));
          }
          async _poll(t, e) {
            throw new Error("@TODO");
          }
        }
        class Fh extends Lh {
          #Tt;
          constructor(t, e) {
            super(t), (this.#Tt = e);
          }
          async _poll(t, e) {
            const n = await e.getTransactionReceipt(this.#Tt);
            n && e.emit(this.#Tt, n);
          }
        }
        class Dh {
          #Ct;
          #bt;
          #Pt;
          #Bt;
          #It;
          constructor(t, e) {
            (this.#Ct = t),
              (this.#bt = Oh(e)),
              (this.#Pt = this.#Nt.bind(this)),
              (this.#Bt = !1),
              (this.#It = -2);
          }
          async #Nt(t) {
            if (-2 === this.#It) return;
            const e = Oh(this.#bt);
            (e.fromBlock = this.#It + 1), (e.toBlock = t);
            const n = await this.#Ct.getLogs(e);
            if (0 !== n.length)
              for (const t of n)
                this.#Ct.emit(this.#bt, t), (this.#It = t.blockNumber);
            else this.#It < t - 60 && (this.#It = t - 60);
          }
          start() {
            this.#Bt ||
              ((this.#Bt = !0),
              -2 === this.#It &&
                this.#Ct.getBlockNumber().then((t) => {
                  this.#It = t;
                }),
              this.#Ct.on("block", this.#Pt));
          }
          stop() {
            this.#Bt && ((this.#Bt = !1), this.#Ct.off("block", this.#Pt));
          }
          pause(t) {
            this.stop(), t && (this.#It = -2);
          }
          resume() {
            this.start();
          }
        }
        const Mh = BigInt(2);
        function zh(t) {
          return t && "function" == typeof t.then;
        }
        function jh(t, e) {
          return (
            t +
            ":" +
            JSON.stringify(e, (t, e) => {
              if (null == e) return "null";
              if ("bigint" == typeof e) return `bigint:${e.toString()}`;
              if ("string" == typeof e) return e.toLowerCase();
              if ("object" == typeof e && !Array.isArray(e)) {
                const t = Object.keys(e);
                return t.sort(), t.reduce((t, n) => ((t[n] = e[n]), t), {});
              }
              return e;
            })
          );
        }
        class $h {
          name;
          constructor(t) {
            Zn(this, { name: t });
          }
          start() {}
          stop() {}
          pause(t) {}
          resume() {}
        }
        function Gh(t) {
          return (t = Array.from(new Set(t).values())).sort(), t;
        }
        async function Hh(t, e) {
          if (null == t) throw new Error("invalid event");
          if ((Array.isArray(t) && (t = { topics: t }), "string" == typeof t))
            switch (t) {
              case "block":
              case "pending":
              case "debug":
              case "error":
              case "network":
                return { type: t, tag: t };
            }
          if (hr(t, 32)) {
            const e = t.toLowerCase();
            return { type: "transaction", tag: jh("tx", { hash: e }), hash: e };
          }
          if (t.orphan) {
            const e = t;
            return {
              type: "orphan",
              tag: jh("orphan", e),
              filter: ((n = e), JSON.parse(JSON.stringify(n))),
            };
          }
          var n;
          if (t.address || t.topics) {
            const n = t,
              r = {
                topics: (n.topics || []).map((t) =>
                  null == t
                    ? null
                    : Array.isArray(t)
                    ? Gh(t.map((t) => t.toLowerCase()))
                    : t.toLowerCase()
                ),
              };
            if (n.address) {
              const t = [],
                s = [],
                i = (n) => {
                  hr(n)
                    ? t.push(n)
                    : s.push(
                        (async () => {
                          t.push(await ta(n, e));
                        })()
                      );
                };
              Array.isArray(n.address) ? n.address.forEach(i) : i(n.address),
                s.length && (await Promise.all(s)),
                (r.address = Gh(t.map((t) => t.toLowerCase())));
            }
            return { filter: r, tag: jh("event", r), type: "event" };
          }
          sr(!1, "unknown ProviderEvent", "event", t);
        }
        function Qh() {
          return new Date().getTime();
        }
        const Vh = { cacheTimeout: 250 };
        class Jh {
          #Ot;
          #kt;
          #Rt;
          #Lt;
          #Ut;
          #Ft;
          #Dt;
          #Mt;
          #zt;
          #jt;
          #$t;
          #G;
          constructor(t, e) {
            if (((this.#G = Object.assign({}, Vh, e || {})), "any" === t))
              (this.#Ft = !0), (this.#Ut = null);
            else if (t) {
              const e = Bh.from(t);
              (this.#Ft = !1),
                (this.#Ut = Promise.resolve(e)),
                setTimeout(() => {
                  this.emit("network", e, null);
                }, 0);
            } else (this.#Ft = !1), (this.#Ut = null);
            (this.#Mt = -1),
              (this.#Dt = new Map()),
              (this.#Ot = new Map()),
              (this.#kt = new Map()),
              (this.#Rt = null),
              (this.#Lt = !1),
              (this.#zt = 1),
              (this.#jt = new Map()),
              (this.#$t = !1);
          }
          get provider() {
            return this;
          }
          get plugins() {
            return Array.from(this.#kt.values());
          }
          attachPlugin(t) {
            if (this.#kt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#kt.set(t.name, t.connect(this)), this;
          }
          getPlugin(t) {
            return this.#kt.get(t) || null;
          }
          get disableCcipRead() {
            return this.#$t;
          }
          set disableCcipRead(t) {
            this.#$t = !!t;
          }
          async #Gt(t) {
            const e = this.#G.cacheTimeout;
            if (e < 0) return await this._perform(t);
            const n = jh(t.method, t);
            let r = this.#Dt.get(n);
            return (
              r ||
                ((r = this._perform(t)),
                this.#Dt.set(n, r),
                setTimeout(() => {
                  this.#Dt.get(n) === r && this.#Dt.delete(n);
                }, e)),
              await r
            );
          }
          async ccipReadFetch(t, e, n) {
            if (this.disableCcipRead || 0 === n.length || null == t.to)
              return null;
            const r = t.to.toLowerCase(),
              s = e.toLowerCase(),
              i = [];
            for (let e = 0; e < n.length; e++) {
              const o = n[e],
                a = o.replace("{sender}", r).replace("{data}", s),
                c = new Kr(a);
              -1 === o.indexOf("{data}") && (c.body = { data: s, sender: r }),
                this.emit("debug", {
                  action: "sendCcipReadFetchRequest",
                  request: c,
                  index: e,
                  urls: n,
                });
              let l = "unknown error";
              const u = await c.send();
              try {
                const t = u.bodyJson;
                if (t.data)
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadFetchResult",
                      request: c,
                      result: t,
                    }),
                    t.data
                  );
                t.message && (l = t.message),
                  this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: c,
                    result: t,
                  });
              } catch (t) {}
              rr(
                u.statusCode < 400 || u.statusCode >= 500,
                `response not found during CCIP fetch: ${l}`,
                "OFFCHAIN_FAULT",
                {
                  reason: "404_MISSING_RESOURCE",
                  transaction: t,
                  info: { url: o, errorMessage: l },
                }
              ),
                i.push(l);
            }
            rr(
              !1,
              `error encountered during CCIP fetch: ${i
                .map((t) => JSON.stringify(t))
                .join(", ")}`,
              "OFFCHAIN_FAULT",
              {
                reason: "500_SERVER_ERROR",
                transaction: t,
                info: { urls: n, errorMessages: i },
              }
            );
          }
          _wrapBlock(t, e) {
            return new Tu(
              (function (t) {
                const e = xh(t);
                return (
                  (e.transactions = t.transactions.map((t) =>
                    "string" == typeof t ? t : Ch(t)
                  )),
                  e
                );
              })(t),
              this
            );
          }
          _wrapLog(t, e) {
            return new Ou(
              (function (t) {
                return vh(t);
              })(t),
              this
            );
          }
          _wrapTransactionReceipt(t, e) {
            return new Ru(
              (function (t) {
                return kh(t);
              })(t),
              this
            );
          }
          _wrapTransactionResponse(t, e) {
            return new Lu(Ch(t), this);
          }
          _detectNetwork() {
            rr(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
              operation: "_detectNetwork",
            });
          }
          async _perform(t) {
            rr(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
              operation: t.method,
              info: t,
            });
          }
          async getBlockNumber() {
            const t = Ir(
              await this.#Gt({ method: "getBlockNumber" }),
              "%response"
            );
            return this.#Mt >= 0 && (this.#Mt = t), t;
          }
          _getAddress(t) {
            return ta(t, this);
          }
          _getBlockTag(t) {
            if (null == t) return "latest";
            switch (t) {
              case "earliest":
                return "0x0";
              case "latest":
              case "pending":
              case "safe":
              case "finalized":
                return t;
            }
            return hr(t)
              ? hr(t, 32)
                ? t
                : Tr(t)
              : ("bigint" == typeof t && (t = Ir(t, "blockTag")),
                "number" == typeof t
                  ? t >= 0
                    ? Tr(t)
                    : this.#Mt >= 0
                    ? Tr(this.#Mt + t)
                    : this.getBlockNumber().then((e) => Tr(e + t))
                  : void sr(!1, "invalid blockTag", "blockTag", t));
          }
          _getFilter(t) {
            const e = (t.topics || []).map((t) =>
                null == t
                  ? null
                  : Array.isArray(t)
                  ? Gh(t.map((t) => t.toLowerCase()))
                  : t.toLowerCase()
              ),
              n = "blockHash" in t ? t.blockHash : void 0,
              r = (t, r, s) => {
                let i;
                switch (t.length) {
                  case 0:
                    break;
                  case 1:
                    i = t[0];
                    break;
                  default:
                    t.sort(), (i = t);
                }
                if (n && (null != r || null != s))
                  throw new Error("invalid filter");
                const o = {};
                return (
                  i && (o.address = i),
                  e.length && (o.topics = e),
                  r && (o.fromBlock = r),
                  s && (o.toBlock = s),
                  n && (o.blockHash = n),
                  o
                );
              };
            let s,
              i,
              o = [];
            if (t.address)
              if (Array.isArray(t.address))
                for (const e of t.address) o.push(this._getAddress(e));
              else o.push(this._getAddress(t.address));
            return (
              "fromBlock" in t && (s = this._getBlockTag(t.fromBlock)),
              "toBlock" in t && (i = this._getBlockTag(t.toBlock)),
              o.filter((t) => "string" != typeof t).length ||
              (null != s && "string" != typeof s) ||
              (null != i && "string" != typeof i)
                ? Promise.all([Promise.all(o), s, i]).then((t) =>
                    r(t[0], t[1], t[2])
                  )
                : r(o, s, i)
            );
          }
          _getTransactionRequest(t) {
            const e = Bu(t),
              n = [];
            if (
              (["to", "from"].forEach((t) => {
                if (null == e[t]) return;
                const r = ta(e[t]);
                zh(r)
                  ? n.push(
                      (async function () {
                        e[t] = await r;
                      })()
                    )
                  : (e[t] = r);
              }),
              null != e.blockTag)
            ) {
              const t = this._getBlockTag(e.blockTag);
              zh(t)
                ? n.push(
                    (async function () {
                      e.blockTag = await t;
                    })()
                  )
                : (e.blockTag = t);
            }
            return n.length
              ? (async function () {
                  return await Promise.all(n), e;
                })()
              : e;
          }
          async getNetwork() {
            if (null == this.#Ut) {
              const t = this._detectNetwork().then(
                (t) => (this.emit("network", t, null), t),
                (e) => {
                  throw (this.#Ut === t && (this.#Ut = null), e);
                }
              );
              return (this.#Ut = t), (await t).clone();
            }
            const t = this.#Ut,
              [e, n] = await Promise.all([t, this._detectNetwork()]);
            return (
              e.chainId !== n.chainId &&
                (this.#Ft
                  ? (this.emit("network", n, e),
                    this.#Ut === t && (this.#Ut = Promise.resolve(n)))
                  : rr(
                      !1,
                      `network changed: ${e.chainId} => ${n.chainId} `,
                      "NETWORK_ERROR",
                      { event: "changed" }
                    )),
              e.clone()
            );
          }
          async getFeeData() {
            const { block: t, gasPrice: e } = await Yn({
              block: this.getBlock("latest"),
              gasPrice: (async () => {
                try {
                  return kr(
                    await this.#Gt({ method: "getGasPrice" }),
                    "%response"
                  );
                } catch (t) {}
                return null;
              })(),
            });
            let n = null,
              r = null;
            return (
              t &&
                t.baseFeePerGas &&
                ((r = BigInt("1000000000")), (n = t.baseFeePerGas * Mh + r)),
              new Nu(e, n, r)
            );
          }
          async estimateGas(t) {
            let e = this._getTransactionRequest(t);
            return (
              zh(e) && (e = await e),
              kr(
                await this.#Gt({ method: "estimateGas", transaction: e }),
                "%response"
              )
            );
          }
          async #Ht(t, e, n) {
            rr(
              n < 10,
              "CCIP read exceeded maximum redirections",
              "OFFCHAIN_FAULT",
              {
                reason: "TOO_MANY_REDIRECTS",
                transaction: Object.assign({}, t, {
                  blockTag: e,
                  enableCcipRead: !0,
                }),
              }
            );
            const r = Bu(t);
            try {
              return fr(
                await this._perform({
                  method: "call",
                  transaction: r,
                  blockTag: e,
                })
              );
            } catch (t) {
              if (
                !this.disableCcipRead &&
                er(t) &&
                t.data &&
                n >= 0 &&
                "latest" === e &&
                null != r.to &&
                "0x556f1830" === mr(t.data, 0, 4)
              ) {
                const s = t.data,
                  i = await ta(r.to, this);
                let o;
                try {
                  o = (function (t) {
                    const e = {
                      sender: "",
                      urls: [],
                      calldata: "",
                      selector: "",
                      extraData: "",
                      errorArgs: [],
                    };
                    rr(
                      gr(t) >= 160,
                      "insufficient OffchainLookup data",
                      "OFFCHAIN_FAULT",
                      { reason: "insufficient OffchainLookup data" }
                    );
                    const n = mr(t, 0, 32);
                    rr(
                      mr(n, 0, 12) === mr(Xh, 0, 12),
                      "corrupt OffchainLookup sender",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup sender" }
                    ),
                      (e.sender = mr(n, 12));
                    try {
                      const n = [],
                        r = Ir(mr(t, 32, 64)),
                        s = Ir(mr(t, r, r + 32)),
                        i = mr(t, r + 32);
                      for (let t = 0; t < s; t++) {
                        const e = Wh(i, 32 * t);
                        if (null == e) throw new Error("abort");
                        n.push(e);
                      }
                      e.urls = n;
                    } catch (t) {
                      rr(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
                        reason: "corrupt OffchainLookup urls",
                      });
                    }
                    try {
                      const n = Kh(t, 64);
                      if (null == n) throw new Error("abort");
                      e.calldata = n;
                    } catch (t) {
                      rr(
                        !1,
                        "corrupt OffchainLookup calldata",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup calldata" }
                      );
                    }
                    rr(
                      mr(t, 100, 128) === mr(Xh, 0, 28),
                      "corrupt OffchainLookup callbaackSelector",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup callbaackSelector" }
                    ),
                      (e.selector = mr(t, 96, 100));
                    try {
                      const n = Kh(t, 128);
                      if (null == n) throw new Error("abort");
                      e.extraData = n;
                    } catch (t) {
                      rr(
                        !1,
                        "corrupt OffchainLookup extraData",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup extraData" }
                      );
                    }
                    return (
                      (e.errorArgs = "sender,urls,calldata,selector,extraData"
                        .split(/,/)
                        .map((t) => e[t])),
                      e
                    );
                  })(mr(t.data, 4));
                } catch (t) {
                  rr(!1, t.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: r,
                    info: { data: s },
                  });
                }
                rr(
                  o.sender.toLowerCase() === i.toLowerCase(),
                  "CCIP Read sender mismatch",
                  "CALL_EXCEPTION",
                  {
                    action: "call",
                    data: s,
                    reason: "OffchainLookup",
                    transaction: r,
                    invocation: null,
                    revert: {
                      signature:
                        "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      name: "OffchainLookup",
                      args: o.errorArgs,
                    },
                  }
                );
                const a = await this.ccipReadFetch(r, o.calldata, o.urls);
                rr(
                  null != a,
                  "CCIP Read failed to fetch data",
                  "OFFCHAIN_FAULT",
                  {
                    reason: "FETCH_FAILED",
                    transaction: r,
                    info: { data: t.data, errorArgs: o.errorArgs },
                  }
                );
                const c = {
                  to: i,
                  data: pr([o.selector, Zh([a, o.extraData])]),
                };
                this.emit("debug", {
                  action: "sendCcipReadCall",
                  transaction: c,
                });
                try {
                  const t = await this.#Ht(c, e, n + 1);
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadCallResult",
                      transaction: Object.assign({}, c),
                      result: t,
                    }),
                    t
                  );
                } catch (t) {
                  throw (
                    (this.emit("debug", {
                      action: "receiveCcipReadCallError",
                      transaction: Object.assign({}, c),
                      error: t,
                    }),
                    t)
                  );
                }
              }
              throw t;
            }
          }
          async #Qt(t) {
            const { value: e } = await Yn({
              network: this.getNetwork(),
              value: t,
            });
            return e;
          }
          async call(t) {
            const { tx: e, blockTag: n } = await Yn({
              tx: this._getTransactionRequest(t),
              blockTag: this._getBlockTag(t.blockTag),
            });
            return await this.#Qt(this.#Ht(e, n, t.enableCcipRead ? 0 : -1));
          }
          async #Vt(t, e, n) {
            let r = this._getAddress(e),
              s = this._getBlockTag(n);
            return (
              ("string" == typeof r && "string" == typeof s) ||
                ([r, s] = await Promise.all([r, s])),
              await this.#Qt(
                this.#Gt(Object.assign(t, { address: r, blockTag: s }))
              )
            );
          }
          async getBalance(t, e) {
            return kr(
              await this.#Vt({ method: "getBalance" }, t, e),
              "%response"
            );
          }
          async getTransactionCount(t, e) {
            return Ir(
              await this.#Vt({ method: "getTransactionCount" }, t, e),
              "%response"
            );
          }
          async getCode(t, e) {
            return fr(await this.#Vt({ method: "getCode" }, t, e));
          }
          async getStorage(t, e, n) {
            const r = kr(e, "position");
            return fr(
              await this.#Vt({ method: "getStorage", position: r }, t, n)
            );
          }
          async broadcastTransaction(t) {
            const {
                blockNumber: e,
                hash: n,
                network: r,
              } = await Yn({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                  method: "broadcastTransaction",
                  signedTransaction: t,
                }),
                network: this.getNetwork(),
              }),
              s = ll.from(t);
            if (s.hash !== n)
              throw new Error("@TODO: the returned hash did not match");
            return this._wrapTransactionResponse(s, r).replaceableTransaction(
              e
            );
          }
          async #Jt(t, e) {
            if (hr(t, 32))
              return await this.#Gt({
                method: "getBlock",
                blockHash: t,
                includeTransactions: e,
              });
            let n = this._getBlockTag(t);
            return (
              "string" != typeof n && (n = await n),
              await this.#Gt({
                method: "getBlock",
                blockTag: n,
                includeTransactions: e,
              })
            );
          }
          async getBlock(t, e) {
            const { network: n, params: r } = await Yn({
              network: this.getNetwork(),
              params: this.#Jt(t, !!e),
            });
            return null == r ? null : this._wrapBlock(r, n);
          }
          async getTransaction(t) {
            const { network: e, params: n } = await Yn({
              network: this.getNetwork(),
              params: this.#Gt({ method: "getTransaction", hash: t }),
            });
            return null == n ? null : this._wrapTransactionResponse(n, e);
          }
          async getTransactionReceipt(t) {
            const { network: e, params: n } = await Yn({
              network: this.getNetwork(),
              params: this.#Gt({ method: "getTransactionReceipt", hash: t }),
            });
            if (null == n) return null;
            if (null == n.gasPrice && null == n.effectiveGasPrice) {
              const e = await this.#Gt({ method: "getTransaction", hash: t });
              if (null == e)
                throw new Error(
                  "report this; could not find tx or effectiveGasPrice"
                );
              n.effectiveGasPrice = e.gasPrice;
            }
            return this._wrapTransactionReceipt(n, e);
          }
          async getTransactionResult(t) {
            const { result: e } = await Yn({
              network: this.getNetwork(),
              result: this.#Gt({ method: "getTransactionResult", hash: t }),
            });
            return null == e ? null : fr(e);
          }
          async getLogs(t) {
            let e = this._getFilter(t);
            zh(e) && (e = await e);
            const { network: n, params: r } = await Yn({
              network: this.getNetwork(),
              params: this.#Gt({ method: "getLogs", filter: e }),
            });
            return r.map((t) => this._wrapLog(t, n));
          }
          _getProvider(t) {
            rr(
              !1,
              "provider cannot connect to target network",
              "UNSUPPORTED_OPERATION",
              { operation: "_getProvider()" }
            );
          }
          async getResolver(t) {
            return await ph.fromName(this, t);
          }
          async getAvatar(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAvatar() : null;
          }
          async resolveName(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAddress() : null;
          }
          async lookupAddress(t) {
            const e = Hc(
              (t = Yo(t)).substring(2).toLowerCase() + ".addr.reverse"
            );
            try {
              const n = await ph.getEnsAddress(this),
                r = new lh(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  this
                ),
                s = await r.resolver(e);
              if (null == s || s === Ro) return null;
              const i = new lh(
                  s,
                  ["function name(bytes32) view returns (string)"],
                  this
                ),
                o = await i.name(e);
              return (await this.resolveName(o)) !== t ? null : o;
            } catch (t) {
              if (tr(t, "BAD_DATA") && "0x" === t.value) return null;
              if (tr(t, "CALL_EXCEPTION")) return null;
              throw t;
            }
            return null;
          }
          async waitForTransaction(t, e, n) {
            const r = null != e ? e : 1;
            return 0 === r
              ? this.getTransactionReceipt(t)
              : new Promise(async (e, s) => {
                  let i = null;
                  const o = async (n) => {
                    try {
                      const s = await this.getTransactionReceipt(t);
                      if (null != s && n - s.blockNumber + 1 >= r)
                        return e(s), void (i && (clearTimeout(i), (i = null)));
                    } catch (t) {
                      console.log("EEE", t);
                    }
                    this.once("block", o);
                  };
                  null != n &&
                    (i = setTimeout(() => {
                      null != i &&
                        ((i = null),
                        this.off("block", o),
                        s(nr("timeout", "TIMEOUT", { reason: "timeout" })));
                    }, n)),
                    o(await this.getBlockNumber());
                });
          }
          async waitForBlock(t) {
            rr(!1, "not implemented yet", "NOT_IMPLEMENTED", {
              operation: "waitForBlock",
            });
          }
          _clearTimeout(t) {
            const e = this.#jt.get(t);
            e && (e.timer && clearTimeout(e.timer), this.#jt.delete(t));
          }
          _setTimeout(t, e) {
            null == e && (e = 0);
            const n = this.#zt++,
              r = () => {
                this.#jt.delete(n), t();
              };
            if (this.paused) this.#jt.set(n, { timer: null, func: r, time: e });
            else {
              const t = setTimeout(r, e);
              this.#jt.set(n, { timer: t, func: r, time: Qh() });
            }
            return n;
          }
          _forEachSubscriber(t) {
            for (const e of this.#Ot.values()) t(e.subscriber);
          }
          _getSubscriber(t) {
            switch (t.type) {
              case "debug":
              case "error":
              case "network":
                return new $h(t.type);
              case "block":
                return new Rh(this);
              case "event":
                return new Dh(this, t.filter);
              case "transaction":
                return new Fh(this, t.hash);
              case "orphan":
                return new Uh(this, t.filter);
            }
            throw new Error(`unsupported event: ${t.type}`);
          }
          _recoverSubscriber(t, e) {
            for (const n of this.#Ot.values())
              if (n.subscriber === t) {
                n.started && n.subscriber.stop(),
                  (n.subscriber = e),
                  n.started && e.start(),
                  null != this.#Rt && e.pause(this.#Rt);
                break;
              }
          }
          async #Wt(t, e) {
            let n = await Hh(t, this);
            return (
              "event" === n.type &&
                e &&
                e.length > 0 &&
                !0 === e[0].removed &&
                (n = await Hh({ orphan: "drop-log", log: e[0] }, this)),
              this.#Ot.get(n.tag) || null
            );
          }
          async #Kt(t) {
            const e = await Hh(t, this),
              n = e.tag;
            let r = this.#Ot.get(n);
            if (!r) {
              (r = {
                subscriber: this._getSubscriber(e),
                tag: n,
                addressableMap: new WeakMap(),
                nameMap: new Map(),
                started: !1,
                listeners: [],
              }),
                this.#Ot.set(n, r);
            }
            return r;
          }
          async on(t, e) {
            const n = await this.#Kt(t);
            return (
              n.listeners.push({ listener: e, once: !1 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Rt && n.subscriber.pause(this.#Rt)),
              this
            );
          }
          async once(t, e) {
            const n = await this.#Kt(t);
            return (
              n.listeners.push({ listener: e, once: !0 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Rt && n.subscriber.pause(this.#Rt)),
              this
            );
          }
          async emit(t, ...e) {
            const n = await this.#Wt(t, e);
            if (!n || 0 === n.listeners.length) return !1;
            const r = n.listeners.length;
            return (
              (n.listeners = n.listeners.filter(({ listener: n, once: r }) => {
                const s = new Rr(this, r ? null : n, t);
                try {
                  n.call(this, ...e, s);
                } catch (t) {}
                return !r;
              })),
              0 === n.listeners.length &&
                (n.started && n.subscriber.stop(), this.#Ot.delete(n.tag)),
              r > 0
            );
          }
          async listenerCount(t) {
            if (t) {
              const e = await this.#Wt(t);
              return e ? e.listeners.length : 0;
            }
            let e = 0;
            for (const { listeners: t } of this.#Ot.values()) e += t.length;
            return e;
          }
          async listeners(t) {
            if (t) {
              const e = await this.#Wt(t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            let e = [];
            for (const { listeners: t } of this.#Ot.values())
              e = e.concat(t.map(({ listener: t }) => t));
            return e;
          }
          async off(t, e) {
            const n = await this.#Wt(t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (e && 0 !== n.listeners.length) ||
                (n.started && n.subscriber.stop(), this.#Ot.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const { tag: e, started: n, subscriber: r } = await this.#Kt(t);
              n && r.stop(), this.#Ot.delete(e);
            } else
              for (const [t, { started: e, subscriber: n }] of this.#Ot)
                e && n.stop(), this.#Ot.delete(t);
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return this.off(t, e);
          }
          get destroyed() {
            return this.#Lt;
          }
          destroy() {
            this.removeAllListeners();
            for (const t of this.#jt.keys()) this._clearTimeout(t);
            this.#Lt = !0;
          }
          get paused() {
            return null != this.#Rt;
          }
          set paused(t) {
            !!t !== this.paused &&
              (this.paused ? this.resume() : this.pause(!1));
          }
          pause(t) {
            if (((this.#Mt = -1), null != this.#Rt)) {
              if (this.#Rt == !!t) return;
              rr(
                !1,
                "cannot change pause type; resume first",
                "UNSUPPORTED_OPERATION",
                { operation: "pause" }
              );
            }
            this._forEachSubscriber((e) => e.pause(t)), (this.#Rt = !!t);
            for (const t of this.#jt.values())
              t.timer && clearTimeout(t.timer), (t.time = Qh() - t.time);
          }
          resume() {
            if (null != this.#Rt) {
              this._forEachSubscriber((t) => t.resume()), (this.#Rt = null);
              for (const t of this.#jt.values()) {
                let e = t.time;
                e < 0 && (e = 0), (t.time = Qh()), setTimeout(t.func, e);
              }
            }
          }
        }
        function Wh(t, e) {
          try {
            const n = Kh(t, e);
            if (n) return Dr(n);
          } catch (t) {}
          return null;
        }
        function Kh(t, e) {
          if ("0x" === t) return null;
          try {
            const n = Ir(mr(t, e, e + 32)),
              r = Ir(mr(t, n, n + 32));
            return mr(t, n + 32, n + 32 + r);
          } catch (t) {}
          return null;
        }
        function _h(t) {
          const e = Br(t);
          if (e.length > 32) throw new Error("internal; should not happen");
          const n = new Uint8Array(32);
          return n.set(e, 32 - e.length), n;
        }
        function qh(t) {
          if (t.length % 32 == 0) return t;
          const e = new Uint8Array(32 * Math.ceil(t.length / 32));
          return e.set(t), e;
        }
        const Yh = new Uint8Array([]);
        function Zh(t) {
          const e = [];
          let n = 0;
          for (let r = 0; r < t.length; r++) e.push(Yh), (n += 32);
          for (let r = 0; r < t.length; r++) {
            const s = lr(t[r]);
            (e[r] = _h(n)),
              e.push(_h(s.length)),
              e.push(qh(s)),
              (n += 32 + 32 * Math.ceil(s.length / 32));
          }
          return pr(e);
        }
        const Xh =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        function td(t, e) {
          if (t.provider) return t.provider;
          rr(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
        }
        async function ed(t, e) {
          let n = Bu(e);
          if ((null != n.to && (n.to = ta(n.to, t)), null != n.from)) {
            const e = n.from;
            n.from = Promise.all([t.getAddress(), ta(e, t)]).then(
              ([t, e]) => (
                sr(
                  t.toLowerCase() === e.toLowerCase(),
                  "transaction from mismatch",
                  "tx.from",
                  e
                ),
                t
              )
            );
          } else n.from = t.getAddress();
          return await Yn(n);
        }
        class nd {
          provider;
          constructor(t) {
            Zn(this, { provider: t || null });
          }
          async getNonce(t) {
            return td(this, "getTransactionCount").getTransactionCount(
              await this.getAddress(),
              t
            );
          }
          async populateCall(t) {
            return await ed(this, t);
          }
          async populateTransaction(t) {
            const e = td(this, "populateTransaction"),
              n = await ed(this, t);
            null == n.nonce && (n.nonce = await this.getNonce("pending")),
              null == n.gasLimit && (n.gasLimit = await this.estimateGas(n));
            const r = await this.provider.getNetwork();
            if (null != n.chainId) {
              sr(
                kr(n.chainId) === r.chainId,
                "transaction chainId mismatch",
                "tx.chainId",
                t.chainId
              );
            } else n.chainId = r.chainId;
            const s = null != n.maxFeePerGas || null != n.maxPriorityFeePerGas;
            if (
              (null == n.gasPrice || (2 !== n.type && !s)
                ? (0 !== n.type && 1 !== n.type) ||
                  !s ||
                  sr(
                    !1,
                    "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                    "tx",
                    t
                  )
                : sr(
                    !1,
                    "eip-1559 transaction do not support gasPrice",
                    "tx",
                    t
                  ),
              (2 !== n.type && null != n.type) ||
                null == n.maxFeePerGas ||
                null == n.maxPriorityFeePerGas)
            )
              if (0 === n.type || 1 === n.type) {
                const t = await e.getFeeData();
                rr(
                  null != t.gasPrice,
                  "network does not support gasPrice",
                  "UNSUPPORTED_OPERATION",
                  { operation: "getGasPrice" }
                ),
                  null == n.gasPrice && (n.gasPrice = t.gasPrice);
              } else {
                const t = await e.getFeeData();
                if (null == n.type)
                  if (null != t.maxFeePerGas && null != t.maxPriorityFeePerGas)
                    if (((n.type = 2), null != n.gasPrice)) {
                      const t = n.gasPrice;
                      delete n.gasPrice,
                        (n.maxFeePerGas = t),
                        (n.maxPriorityFeePerGas = t);
                    } else
                      null == n.maxFeePerGas &&
                        (n.maxFeePerGas = t.maxFeePerGas),
                        null == n.maxPriorityFeePerGas &&
                          (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas);
                  else
                    null != t.gasPrice
                      ? (rr(
                          !s,
                          "network does not support EIP-1559",
                          "UNSUPPORTED_OPERATION",
                          { operation: "populateTransaction" }
                        ),
                        null == n.gasPrice && (n.gasPrice = t.gasPrice),
                        (n.type = 0))
                      : rr(
                          !1,
                          "failed to get consistent fee data",
                          "UNSUPPORTED_OPERATION",
                          { operation: "signer.getFeeData" }
                        );
                else
                  2 === n.type &&
                    (null == n.maxFeePerGas &&
                      (n.maxFeePerGas = t.maxFeePerGas),
                    null == n.maxPriorityFeePerGas &&
                      (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas));
              }
            else n.type = 2;
            return await Yn(n);
          }
          async estimateGas(t) {
            return td(this, "estimateGas").estimateGas(
              await this.populateCall(t)
            );
          }
          async call(t) {
            return td(this, "call").call(await this.populateCall(t));
          }
          async resolveName(t) {
            const e = td(this, "resolveName");
            return await e.resolveName(t);
          }
          async sendTransaction(t) {
            const e = td(this, "sendTransaction"),
              n = await this.populateTransaction(t);
            delete n.from;
            const r = ll.from(n);
            return await e.broadcastTransaction(await this.signTransaction(r));
          }
        }
        class rd {
          #Ct;
          #_t;
          #Pt;
          #Bt;
          #qt;
          #Yt;
          constructor(t) {
            (this.#Ct = t),
              (this.#_t = null),
              (this.#Pt = this.#Nt.bind(this)),
              (this.#Bt = !1),
              (this.#qt = null),
              (this.#Yt = !1);
          }
          _subscribe(t) {
            throw new Error("subclasses must override this");
          }
          _emitResults(t, e) {
            throw new Error("subclasses must override this");
          }
          _recover(t) {
            throw new Error("subclasses must override this");
          }
          async #Nt(t) {
            try {
              null == this.#_t && (this.#_t = this._subscribe(this.#Ct));
              let t = null;
              try {
                t = await this.#_t;
              } catch (t) {
                if (
                  !tr(t, "UNSUPPORTED_OPERATION") ||
                  "eth_newFilter" !== t.operation
                )
                  throw t;
              }
              if (null == t)
                return (
                  (this.#_t = null),
                  void this.#Ct._recoverSubscriber(
                    this,
                    this._recover(this.#Ct)
                  )
                );
              const e = await this.#Ct.getNetwork();
              if ((this.#qt || (this.#qt = e), this.#qt.chainId !== e.chainId))
                throw new Error("chaid changed");
              if (this.#Yt) return;
              const n = await this.#Ct.send("eth_getFilterChanges", [t]);
              await this._emitResults(this.#Ct, n);
            } catch (t) {
              console.log("@TODO", t);
            }
            this.#Ct.once("block", this.#Pt);
          }
          #Zt() {
            const t = this.#_t;
            t &&
              ((this.#_t = null),
              t.then((t) => {
                this.#Ct.send("eth_uninstallFilter", [t]);
              }));
          }
          start() {
            this.#Bt || ((this.#Bt = !0), this.#Nt(-2));
          }
          stop() {
            this.#Bt &&
              ((this.#Bt = !1),
              (this.#Yt = !0),
              this.#Zt(),
              this.#Ct.off("block", this.#Pt));
          }
          pause(t) {
            t && this.#Zt(), this.#Ct.off("block", this.#Pt);
          }
          resume() {
            this.start();
          }
        }
        class sd extends rd {
          #Xt;
          constructor(t, e) {
            var n;
            super(t), (this.#Xt = ((n = e), JSON.parse(JSON.stringify(n))));
          }
          _recover(t) {
            return new Dh(t, this.#Xt);
          }
          async _subscribe(t) {
            return await t.send("eth_newFilter", [this.#Xt]);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit(this.#Xt, t._wrapLog(n, t._network));
          }
        }
        class id extends rd {
          async _subscribe(t) {
            return await t.send("eth_newPendingTransactionFilter", []);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit("pending", n);
          }
        }
        const od = "bigint,boolean,function,number,string,symbol".split(/,/g);
        function ad(t) {
          if (null == t || od.indexOf(typeof t) >= 0) return t;
          if ("function" == typeof t.getAddress) return t;
          if (Array.isArray(t)) return t.map(ad);
          if ("object" == typeof t)
            return Object.keys(t).reduce((e, n) => ((e[n] = t[n]), e), {});
          throw new Error(`should not happen: ${t} (${typeof t})`);
        }
        function cd(t) {
          return new Promise((e) => {
            setTimeout(e, t);
          });
        }
        function ld(t) {
          return t ? t.toLowerCase() : t;
        }
        function ud(t) {
          return t && "number" == typeof t.pollingInterval;
        }
        const hd = {
          polling: !1,
          staticNetwork: null,
          batchStallTime: 10,
          batchMaxSize: 1 << 20,
          batchMaxCount: 100,
          cacheTimeout: 250,
        };
        class dd extends nd {
          address;
          constructor(t, e) {
            super(t), Zn(this, { address: (e = Yo(e)) });
          }
          connect(t) {
            rr(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
              operation: "signer.connect",
            });
          }
          async getAddress() {
            return this.address;
          }
          async populateTransaction(t) {
            return await this.populateCall(t);
          }
          async sendUncheckedTransaction(t) {
            const e = ad(t),
              n = [];
            if (e.from) {
              const r = e.from;
              n.push(
                (async () => {
                  const n = await ta(r, this.provider);
                  sr(
                    null != n && n.toLowerCase() === this.address.toLowerCase(),
                    "from address mismatch",
                    "transaction",
                    t
                  ),
                    (e.from = n);
                })()
              );
            } else e.from = this.address;
            if (
              (null == e.gasLimit &&
                n.push(
                  (async () => {
                    e.gasLimit = await this.provider.estimateGas({
                      ...e,
                      from: this.address,
                    });
                  })()
                ),
              null != e.to)
            ) {
              const t = e.to;
              n.push(
                (async () => {
                  e.to = await ta(t, this.provider);
                })()
              );
            }
            n.length && (await Promise.all(n));
            const r = this.provider.getRpcTransaction(e);
            return this.provider.send("eth_sendTransaction", [r]);
          }
          async sendTransaction(t) {
            const e = await this.provider.getBlockNumber(),
              n = await this.sendUncheckedTransaction(t);
            return await new Promise((t, r) => {
              const s = [1e3, 100],
                i = async () => {
                  const r = await this.provider.getTransaction(n);
                  null == r
                    ? this.provider._setTimeout(() => {
                        i();
                      }, s.pop() || 4e3)
                    : t(r.replaceableTransaction(e));
                };
              i();
            });
          }
          async signTransaction(t) {
            const e = ad(t);
            if (e.from) {
              const n = await ta(e.from, this.provider);
              sr(
                null != n && n.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                t
              ),
                (e.from = n);
            } else e.from = this.address;
            const n = this.provider.getRpcTransaction(e);
            return await this.provider.send("eth_signTransaction", [n]);
          }
          async signMessage(t) {
            const e = "string" == typeof t ? Fr(t) : t;
            return await this.provider.send("personal_sign", [
              fr(e),
              this.address.toLowerCase(),
            ]);
          }
          async signTypedData(t, e, n) {
            const r = ad(n),
              s = await El.resolveNames(t, e, r, async (t) => {
                const e = await ta(t);
                return (
                  sr(
                    null != e,
                    "TypedData does not support null address",
                    "value",
                    t
                  ),
                  e
                );
              });
            return await this.provider.send("eth_signTypedData_v4", [
              this.address.toLowerCase(),
              JSON.stringify(El.getPayload(s.domain, e, s.value)),
            ]);
          }
          async unlock(t) {
            return this.provider.send("personal_unlockAccount", [
              this.address.toLowerCase(),
              t,
              null,
            ]);
          }
          async _legacySignMessage(t) {
            const e = "string" == typeof t ? Fr(t) : t;
            return await this.provider.send("eth_sign", [
              this.address.toLowerCase(),
              fr(e),
            ]);
          }
        }
        class fd extends Jh {
          #G;
          #te;
          #ee;
          #ne;
          #re;
          #qt;
          #se() {
            if (this.#ne) return;
            const t =
              1 === this._getOption("batchMaxCount")
                ? 0
                : this._getOption("batchStallTime");
            this.#ne = setTimeout(() => {
              this.#ne = null;
              const t = this.#ee;
              for (this.#ee = []; t.length; ) {
                const e = [t.shift()];
                for (; t.length && e.length !== this.#G.batchMaxCount; ) {
                  e.push(t.shift());
                  const n = JSON.stringify(e.map((t) => t.payload));
                  if (n.length > this.#G.batchMaxSize) {
                    t.unshift(e.pop());
                    break;
                  }
                }
                (async () => {
                  const t =
                    1 === e.length ? e[0].payload : e.map((t) => t.payload);
                  this.emit("debug", { action: "sendRpcPayload", payload: t });
                  try {
                    const n = await this._send(t);
                    this.emit("debug", {
                      action: "receiveRpcResult",
                      result: n,
                    });
                    for (const { resolve: t, reject: r, payload: s } of e) {
                      if (this.destroyed) {
                        r(
                          nr(
                            "provider destroyed; cancelled request",
                            "UNSUPPORTED_OPERATION",
                            { operation: s.method }
                          )
                        );
                        continue;
                      }
                      const e = n.filter((t) => t.id === s.id)[0];
                      if (null != e)
                        "error" in e ? r(this.getRpcError(s, e)) : t(e.result);
                      else {
                        const t = nr(
                          "missing response for request",
                          "BAD_DATA",
                          { value: n, info: { payload: s } }
                        );
                        this.emit("error", t), r(t);
                      }
                    }
                  } catch (t) {
                    this.emit("debug", { action: "receiveRpcError", error: t });
                    for (const { reject: n } of e) n(t);
                  }
                })();
              }
            }, t);
          }
          constructor(t, e) {
            const n = {};
            e && null != e.cacheTimeout && (n.cacheTimeout = e.cacheTimeout),
              super(t, n),
              (this.#te = 1),
              (this.#G = Object.assign({}, hd, e || {})),
              (this.#ee = []),
              (this.#ne = null),
              (this.#qt = null);
            {
              let t = null;
              const e = new Promise((e) => {
                t = e;
              });
              this.#re = { promise: e, resolve: t };
            }
            const r = this._getOption("staticNetwork");
            r &&
              (sr(
                null == t || r.matches(t),
                "staticNetwork MUST match network object",
                "options",
                e
              ),
              (this.#qt = r));
          }
          _getOption(t) {
            return this.#G[t];
          }
          get _network() {
            return (
              rr(this.#qt, "network is not available yet", "NETWORK_ERROR"),
              this.#qt
            );
          }
          async _perform(t) {
            if ("call" === t.method || "estimateGas" === t.method) {
              let e = t.transaction;
              if (
                e &&
                null != e.type &&
                kr(e.type) &&
                null == e.maxFeePerGas &&
                null == e.maxPriorityFeePerGas
              ) {
                const n = await this.getFeeData();
                null == n.maxFeePerGas &&
                  null == n.maxPriorityFeePerGas &&
                  (t = Object.assign({}, t, {
                    transaction: Object.assign({}, e, { type: void 0 }),
                  }));
              }
            }
            const e = this.getRpcRequest(t);
            return null != e
              ? await this.send(e.method, e.args)
              : super._perform(t);
          }
          async _detectNetwork() {
            const t = this._getOption("staticNetwork");
            if (t) return t;
            if (this.ready)
              return Bh.from(kr(await this.send("eth_chainId", [])));
            const e = {
              id: this.#te++,
              method: "eth_chainId",
              params: [],
              jsonrpc: "2.0",
            };
            let n;
            this.emit("debug", { action: "sendRpcPayload", payload: e });
            try {
              n = (await this._send(e))[0];
            } catch (t) {
              throw (
                (this.emit("debug", { action: "receiveRpcError", error: t }), t)
              );
            }
            if (
              (this.emit("debug", { action: "receiveRpcResult", result: n }),
              "result" in n)
            )
              return Bh.from(kr(n.result));
            throw this.getRpcError(e, n);
          }
          _start() {
            null != this.#re &&
              null != this.#re.resolve &&
              (this.#re.resolve(),
              (this.#re = null),
              (async () => {
                for (; null == this.#qt && !this.destroyed; )
                  try {
                    this.#qt = await this._detectNetwork();
                  } catch (t) {
                    console.log(
                      "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                    ),
                      this.emit(
                        "error",
                        nr(
                          "failed to bootstrap network detection",
                          "NETWORK_ERROR",
                          {
                            event: "initial-network-discovery",
                            info: { error: t },
                          }
                        )
                      ),
                      await cd(1e3);
                  }
                this.#se();
              })());
          }
          async _waitUntilReady() {
            if (null != this.#re) return await this.#re.promise;
          }
          _getSubscriber(t) {
            return "pending" === t.type
              ? new id(this)
              : "event" === t.type
              ? this._getOption("polling")
                ? new Dh(this, t.filter)
                : new sd(this, t.filter)
              : "orphan" === t.type && "drop-log" === t.filter.orphan
              ? new $h("orphan")
              : super._getSubscriber(t);
          }
          get ready() {
            return null == this.#re;
          }
          getRpcTransaction(t) {
            const e = {};
            return (
              [
                "chainId",
                "gasLimit",
                "gasPrice",
                "type",
                "maxFeePerGas",
                "maxPriorityFeePerGas",
                "nonce",
                "value",
              ].forEach((n) => {
                if (null == t[n]) return;
                let r = n;
                "gasLimit" === n && (r = "gas"),
                  (e[r] = Tr(kr(t[n], `tx.${n}`)));
              }),
              ["from", "to", "data"].forEach((n) => {
                null != t[n] && (e[n] = fr(t[n]));
              }),
              t.accessList && (e.accessList = Vc(t.accessList)),
              e
            );
          }
          getRpcRequest(t) {
            switch (t.method) {
              case "chainId":
                return { method: "eth_chainId", args: [] };
              case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
              case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
              case "getBalance":
                return {
                  method: "eth_getBalance",
                  args: [ld(t.address), t.blockTag],
                };
              case "getTransactionCount":
                return {
                  method: "eth_getTransactionCount",
                  args: [ld(t.address), t.blockTag],
                };
              case "getCode":
                return {
                  method: "eth_getCode",
                  args: [ld(t.address), t.blockTag],
                };
              case "getStorage":
                return {
                  method: "eth_getStorageAt",
                  args: [
                    ld(t.address),
                    "0x" + t.position.toString(16),
                    t.blockTag,
                  ],
                };
              case "broadcastTransaction":
                return {
                  method: "eth_sendRawTransaction",
                  args: [t.signedTransaction],
                };
              case "getBlock":
                if ("blockTag" in t)
                  return {
                    method: "eth_getBlockByNumber",
                    args: [t.blockTag, !!t.includeTransactions],
                  };
                if ("blockHash" in t)
                  return {
                    method: "eth_getBlockByHash",
                    args: [t.blockHash, !!t.includeTransactions],
                  };
                break;
              case "getTransaction":
                return { method: "eth_getTransactionByHash", args: [t.hash] };
              case "getTransactionReceipt":
                return { method: "eth_getTransactionReceipt", args: [t.hash] };
              case "call":
                return {
                  method: "eth_call",
                  args: [this.getRpcTransaction(t.transaction), t.blockTag],
                };
              case "estimateGas":
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(t.transaction)],
                };
              case "getLogs":
                return (
                  t.filter &&
                    null != t.filter.address &&
                    (Array.isArray(t.filter.address)
                      ? (t.filter.address = t.filter.address.map(ld))
                      : (t.filter.address = ld(t.filter.address))),
                  { method: "eth_getLogs", args: [t.filter] }
                );
            }
            return null;
          }
          getRpcError(t, e) {
            const { method: n } = t,
              { error: r } = e;
            if ("eth_estimateGas" === n && r.message) {
              const e = r.message;
              if (!e.match(/revert/i) && e.match(/insufficient funds/i))
                return nr("insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: t.params[0],
                  info: { payload: t, error: r },
                });
            }
            if ("eth_call" === n || "eth_estimateGas" === n) {
              const e = gd(r),
                s = bu.getBuiltinCallException(
                  "eth_call" === n ? "call" : "estimateGas",
                  t.params[0],
                  e ? e.data : null
                );
              return (s.info = { error: r, payload: t }), s;
            }
            const s = JSON.stringify(
              (function (t) {
                const e = [];
                return md(t, e), e;
              })(r)
            );
            if (
              "string" == typeof r.message &&
              r.message.match(/user denied|ethers-user-denied/i)
            ) {
              return nr("user rejected action", "ACTION_REJECTED", {
                action:
                  {
                    eth_sign: "signMessage",
                    personal_sign: "signMessage",
                    eth_signTypedData_v4: "signTypedData",
                    eth_signTransaction: "signTransaction",
                    eth_sendTransaction: "sendTransaction",
                    eth_requestAccounts: "requestAccess",
                    wallet_requestAccounts: "requestAccess",
                  }[n] || "unknown",
                reason: "rejected",
                info: { payload: t, error: r },
              });
            }
            if ("eth_sendRawTransaction" === n || "eth_sendTransaction" === n) {
              const e = t.params[0];
              if (s.match(/insufficient funds|base fee exceeds gas limit/i))
                return nr(
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: e, info: { error: r } }
                );
              if (s.match(/nonce/i) && s.match(/too low/i))
                return nr("nonce has already been used", "NONCE_EXPIRED", {
                  transaction: e,
                  info: { error: r },
                });
              if (
                s.match(/replacement transaction/i) &&
                s.match(/underpriced/i)
              )
                return nr(
                  "replacement fee too low",
                  "REPLACEMENT_UNDERPRICED",
                  { transaction: e, info: { error: r } }
                );
              if (s.match(/only replay-protected/i))
                return nr(
                  "legacy pre-eip-155 transactions not supported",
                  "UNSUPPORTED_OPERATION",
                  { operation: n, info: { transaction: e, info: { error: r } } }
                );
            }
            let i = !!s.match(/the method .* does not exist/i);
            return (
              i ||
                (r &&
                  r.details &&
                  r.details.startsWith("Unauthorized method:") &&
                  (i = !0)),
              i
                ? nr("unsupported operation", "UNSUPPORTED_OPERATION", {
                    operation: t.method,
                    info: { error: r, payload: t },
                  })
                : nr("could not coalesce error", "UNKNOWN_ERROR", {
                    error: r,
                    payload: t,
                  })
            );
          }
          send(t, e) {
            if (this.destroyed)
              return Promise.reject(
                nr(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t }
                )
              );
            const n = this.#te++,
              r = new Promise((r, s) => {
                this.#ee.push({
                  resolve: r,
                  reject: s,
                  payload: { method: t, params: e, id: n, jsonrpc: "2.0" },
                });
              });
            return this.#se(), r;
          }
          async getSigner(t) {
            null == t && (t = 0);
            const e = this.send("eth_accounts", []);
            if ("number" == typeof t) {
              const n = await e;
              if (t >= n.length) throw new Error("no such account");
              return new dd(this, n[t]);
            }
            const { accounts: n } = await Yn({
              network: this.getNetwork(),
              accounts: e,
            });
            t = Yo(t);
            for (const e of n) if (Yo(e) === t) return new dd(this, t);
            throw new Error("invalid account");
          }
          async listAccounts() {
            return (await this.send("eth_accounts", [])).map(
              (t) => new dd(this, t)
            );
          }
          destroy() {
            this.#ne && (clearTimeout(this.#ne), (this.#ne = null));
            for (const { payload: t, reject: e } of this.#ee)
              e(
                nr(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t.method }
                )
              );
            (this.#ee = []), super.destroy();
          }
        }
        class pd extends fd {
          #ie;
          constructor(t, e) {
            super(t, e), (this.#ie = 4e3);
          }
          _getSubscriber(t) {
            const e = super._getSubscriber(t);
            return ud(e) && (e.pollingInterval = this.#ie), e;
          }
          get pollingInterval() {
            return this.#ie;
          }
          set pollingInterval(t) {
            if (!Number.isInteger(t) || t < 0)
              throw new Error("invalid interval");
            (this.#ie = t),
              this._forEachSubscriber((t) => {
                ud(t) && (t.pollingInterval = this.#ie);
              });
          }
        }
        function gd(t) {
          if (null == t) return null;
          if (
            "string" == typeof t.message &&
            t.message.match(/revert/i) &&
            hr(t.data)
          )
            return { message: t.message, data: t.data };
          if ("object" == typeof t) {
            for (const e in t) {
              const n = gd(t[e]);
              if (n) return n;
            }
            return null;
          }
          if ("string" == typeof t)
            try {
              return gd(JSON.parse(t));
            } catch (t) {}
          return null;
        }
        function md(t, e) {
          if (null != t) {
            if (
              ("string" == typeof t.message && e.push(t.message),
              "object" == typeof t)
            )
              for (const n in t) md(t[n], e);
            if ("string" == typeof t)
              try {
                return md(JSON.parse(t), e);
              } catch (t) {}
          }
        }
        class yd extends pd {
          #A;
          constructor(t, e) {
            super(e, { batchMaxCount: 1 }),
              (this.#A = async (e, n) => {
                const r = { method: e, params: n };
                this.emit("debug", {
                  action: "sendEip1193Request",
                  payload: r,
                });
                try {
                  const e = await t.request(r);
                  return (
                    this.emit("debug", {
                      action: "receiveEip1193Result",
                      result: e,
                    }),
                    e
                  );
                } catch (t) {
                  const e = new Error(t.message);
                  throw (
                    ((e.code = t.code),
                    (e.data = t.data),
                    (e.payload = r),
                    this.emit("debug", {
                      action: "receiveEip1193Error",
                      error: e,
                    }),
                    e)
                  );
                }
              });
          }
          async send(t, e) {
            return await this._start(), await super.send(t, e);
          }
          async _send(t) {
            sr(
              !Array.isArray(t),
              "EIP-1193 does not support batch request",
              "payload",
              t
            );
            try {
              const e = await this.#A(t.method, t.params || []);
              return [{ id: t.id, result: e }];
            } catch (e) {
              return [
                {
                  id: t.id,
                  error: { code: e.code, data: e.data, message: e.message },
                },
              ];
            }
          }
          getRpcError(t, e) {
            switch ((e = JSON.parse(JSON.stringify(e))).error.code || -1) {
              case 4001:
                e.error.message = `ethers-user-denied: ${e.error.message}`;
                break;
              case 4200:
                e.error.message = `ethers-unsupported: ${e.error.message}`;
            }
            return super.getRpcError(t, e);
          }
          async hasSigner(t) {
            null == t && (t = 0);
            const e = await this.send("eth_accounts", []);
            return "number" == typeof t
              ? e.length > t
              : ((t = t.toLowerCase()),
                0 !== e.filter((e) => e.toLowerCase() === t).length);
          }
          async getSigner(t) {
            if ((null == t && (t = 0), !(await this.hasSigner(t))))
              try {
                await this.#A("eth_requestAccounts", []);
              } catch (t) {
                const e = t.payload;
                throw this.getRpcError(e, { id: e.id, error: t });
              }
            return await super.getSigner(t);
          }
        }
        function bd(t) {
          let e, n, r;
          return {
            c() {
              (e = A("p")), (n = x("Account ")), (r = x(t[0]));
            },
            m(t, s) {
              b(t, e, s), m(e, n), m(e, r);
            },
            p(t, e) {
              1 & e && N(r, t[0]);
            },
            d(t) {
              t && w(e);
            },
          };
        }
        function wd(e) {
          let n;
          return {
            c() {
              (n = A("p")),
                (n.textContent = "My application is not yet connected");
            },
            m(t, e) {
              b(t, n, e);
            },
            p: t,
            d(t) {
              t && w(n);
            },
          };
        }
        function Ad(t) {
          let e,
            n,
            r,
            i,
            o,
            a,
            c,
            l,
            u,
            h,
            d,
            f,
            p,
            g,
            m,
            y,
            v,
            x,
            S,
            I,
            N,
            T,
            O,
            R = t[1] && xd(t);
          const L = [kd, Ed],
            U = [];
          function F(t, e) {
            return null !== t[7] ? 0 : 1;
          }
          (y = F(t)), (v = U[y] = L[y](t));
          let D = t[6] && Sd(t),
            M = t[8] && Id(t);
          return {
            c() {
              (e = A("h2")),
                (e.textContent = "Create Escrow Portal"),
                (n = E()),
                (r = A("button")),
                (r.textContent = "Get balance"),
                (i = E()),
                R && R.c(),
                (o = E()),
                (a = A("br")),
                (c = E()),
                (l = A("br")),
                (u = E()),
                (h = A("br")),
                (d = E()),
                (f = A("input")),
                (p = E()),
                (g = A("input")),
                (m = E()),
                v.c(),
                (x = E()),
                D && D.c(),
                (S = E()),
                M && M.c(),
                (I = k()),
                P(f, "placeholder", "Escrow details"),
                P(g, "type", "Amount"),
                P(g, "placeholder", "Escrow amount");
            },
            m(s, w) {
              b(s, e, w),
                b(s, n, w),
                b(s, r, w),
                b(s, i, w),
                R && R.m(s, w),
                b(s, o, w),
                b(s, a, w),
                b(s, c, w),
                b(s, l, w),
                b(s, u, w),
                b(s, h, w),
                b(s, d, w),
                b(s, f, w),
                B(f, t[4]),
                b(s, p, w),
                b(s, g, w),
                B(g, t[5]),
                b(s, m, w),
                U[y].m(s, w),
                b(s, x, w),
                D && D.m(s, w),
                b(s, S, w),
                M && M.m(s, w),
                b(s, I, w),
                (N = !0),
                T ||
                  ((O = [
                    C(r, "click", t[12]),
                    C(f, "input", t[13]),
                    C(g, "input", t[14]),
                  ]),
                  (T = !0));
            },
            p(t, e) {
              t[1]
                ? R
                  ? R.p(t, e)
                  : ((R = xd(t)), R.c(), R.m(o.parentNode, o))
                : R && (R.d(1), (R = null)),
                16 & e && f.value !== t[4] && B(f, t[4]),
                32 & e && B(g, t[5]);
              let n = y;
              (y = F(t)),
                y === n
                  ? U[y].p(t, e)
                  : (Z(),
                    et(U[n], 1, 1, () => {
                      U[n] = null;
                    }),
                    X(),
                    (v = U[y]),
                    v ? v.p(t, e) : ((v = U[y] = L[y](t)), v.c()),
                    tt(v, 1),
                    v.m(x.parentNode, x)),
                t[6]
                  ? D
                    ? D.p(t, e)
                    : ((D = Sd(t)), D.c(), D.m(S.parentNode, S))
                  : D && (D.d(1), (D = null)),
                t[8]
                  ? M
                    ? M.p(t, e)
                    : ((M = Id(t)), M.c(), M.m(I.parentNode, I))
                  : M && (M.d(1), (M = null));
            },
            i(t) {
              N || (tt(v), (N = !0));
            },
            o(t) {
              et(v), (N = !1);
            },
            d(t) {
              t && w(e),
                t && w(n),
                t && w(r),
                t && w(i),
                R && R.d(t),
                t && w(o),
                t && w(a),
                t && w(c),
                t && w(l),
                t && w(u),
                t && w(h),
                t && w(d),
                t && w(f),
                t && w(p),
                t && w(g),
                t && w(m),
                U[y].d(t),
                t && w(x),
                D && D.d(t),
                t && w(S),
                M && M.d(t),
                t && w(I),
                (T = !1),
                s(O);
            },
          };
        }
        function vd(e) {
          let n,
            r,
            s,
            i,
            o,
            a,
            c,
            l,
            u = e[3] && Nd(e),
            h = e[2] && Bd(e);
          return {
            c() {
              (n = A("h2")),
                (n.textContent = "Buyer Portal"),
                (r = E()),
                (s = A("button")),
                (s.textContent = "Get Contract Details"),
                (i = E()),
                u && u.c(),
                (o = E()),
                h && h.c(),
                (a = k());
            },
            m(t, d) {
              b(t, n, d),
                b(t, r, d),
                b(t, s, d),
                b(t, i, d),
                u && u.m(t, d),
                b(t, o, d),
                h && h.m(t, d),
                b(t, a, d),
                c || ((l = C(s, "click", e[10])), (c = !0));
            },
            p(t, e) {
              t[3]
                ? u
                  ? u.p(t, e)
                  : ((u = Nd(t)), u.c(), u.m(o.parentNode, o))
                : u && (u.d(1), (u = null)),
                t[2]
                  ? h
                    ? h.p(t, e)
                    : ((h = Bd(t)), h.c(), h.m(a.parentNode, a))
                  : h && (h.d(1), (h = null));
            },
            i: t,
            o: t,
            d(t) {
              t && w(n),
                t && w(r),
                t && w(s),
                t && w(i),
                u && u.d(t),
                t && w(o),
                h && h.d(t),
                t && w(a),
                (c = !1),
                l();
            },
          };
        }
        function xd(t) {
          let e, n, r, s;
          return {
            c() {
              (e = A("h2")),
                (n = x("Balance ")),
                (r = A("strong")),
                (s = x(t[1]));
            },
            m(t, i) {
              b(t, e, i), m(e, n), m(e, r), m(r, s);
            },
            p(t, e) {
              2 & e && N(s, t[1]);
            },
            d(t) {
              t && w(e);
            },
          };
        }
        function Ed(t) {
          let e, n;
          return (
            (e = new Wn({
              props: { $$slots: { default: [Cd] }, $$scope: { ctx: t } },
            })),
            e.$on("click", t[11]),
            {
              c() {
                rt(e.$$.fragment);
              },
              m(t, r) {
                st(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                262144 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (tt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                it(e, t);
              },
            }
          );
        }
        function kd(t) {
          let e, n, r, s, i;
          return (
            (e = new Wn({
              props: {
                loading: !0,
                $$slots: { default: [Pd] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                rt(e.$$.fragment), (n = E()), (r = A("p")), (s = x(t[7]));
              },
              m(t, o) {
                st(e, t, o), b(t, n, o), b(t, r, o), m(r, s), (i = !0);
              },
              p(t, n) {
                const r = {};
                262144 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r),
                  (!i || 128 & n) && N(s, t[7]);
              },
              i(t) {
                i || (tt(e.$$.fragment, t), (i = !0));
              },
              o(t) {
                et(e.$$.fragment, t), (i = !1);
              },
              d(t) {
                it(e, t), t && w(n), t && w(r);
              },
            }
          );
        }
        function Cd(t) {
          let e;
          return {
            c() {
              e = x("Create Escrow");
            },
            m(t, n) {
              b(t, e, n);
            },
            d(t) {
              t && w(e);
            },
          };
        }
        function Pd(t) {
          let e;
          return {
            c() {
              e = x("Create Escrow");
            },
            m(t, n) {
              b(t, e, n);
            },
            d(t) {
              t && w(e);
            },
          };
        }
        function Sd(t) {
          let e, n;
          return {
            c() {
              (e = A("p")), (n = x(t[6]));
            },
            m(t, r) {
              b(t, e, r), m(e, n);
            },
            p(t, e) {
              64 & e && N(n, t[6]);
            },
            d(t) {
              t && w(e);
            },
          };
        }
        function Id(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            c,
            l,
            u = window.location.href + "";
          return {
            c() {
              (e = A("p")),
                (n = x("Escrow created with number ")),
                (r = x(t[8])),
                (s = E()),
                (i = A("a")),
                (o = x(u)),
                (a = x("?escrowID=")),
                (c = x(t[8])),
                P(i, "href", (l = `${window.location.href}?escrowID=${t[8]}`)),
                P(i, "target", "_blank");
            },
            m(t, l) {
              b(t, e, l),
                m(e, n),
                m(e, r),
                b(t, s, l),
                b(t, i, l),
                m(i, o),
                m(i, a),
                m(i, c);
            },
            p(t, e) {
              256 & e && N(r, t[8]),
                256 & e && N(c, t[8]),
                256 & e &&
                  l !== (l = `${window.location.href}?escrowID=${t[8]}`) &&
                  P(i, "href", l);
            },
            d(t) {
              t && w(e), t && w(s), t && w(i);
            },
          };
        }
        function Nd(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            c,
            l,
            u,
            h,
            d,
            f,
            p,
            g,
            y,
            v,
            k,
            C,
            P = t[3].merchant + "",
            S = t[3].buyer + "",
            I = t[3].amount + "",
            B = t[3].details + "",
            T = t[3].isDead + "";
          return {
            c() {
              (e = A("p")),
                (n = x("merchant: ")),
                (r = x(P)),
                (s = E()),
                (i = A("p")),
                (o = x("buyer: ")),
                (a = x(S)),
                (c = E()),
                (l = A("p")),
                (u = x("amount: ")),
                (h = x(I)),
                (d = E()),
                (f = A("p")),
                (p = x("details: ")),
                (g = x(B)),
                (y = E()),
                (v = A("p")),
                (k = x("isDead: ")),
                (C = x(T));
            },
            m(t, w) {
              b(t, e, w),
                m(e, n),
                m(e, r),
                b(t, s, w),
                b(t, i, w),
                m(i, o),
                m(i, a),
                b(t, c, w),
                b(t, l, w),
                m(l, u),
                m(l, h),
                b(t, d, w),
                b(t, f, w),
                m(f, p),
                m(f, g),
                b(t, y, w),
                b(t, v, w),
                m(v, k),
                m(v, C);
            },
            p(t, e) {
              8 & e && P !== (P = t[3].merchant + "") && N(r, P),
                8 & e && S !== (S = t[3].buyer + "") && N(a, S),
                8 & e && I !== (I = t[3].amount + "") && N(h, I),
                8 & e && B !== (B = t[3].details + "") && N(g, B),
                8 & e && T !== (T = t[3].isDead + "") && N(C, T);
            },
            d(t) {
              t && w(e),
                t && w(s),
                t && w(i),
                t && w(c),
                t && w(l),
                t && w(d),
                t && w(f),
                t && w(y),
                t && w(v);
            },
          };
        }
        function Bd(t) {
          let e, n;
          return {
            c() {
              (e = A("p")), (n = x(t[2]));
            },
            m(t, r) {
              b(t, e, r), m(e, n);
            },
            p(t, e) {
              4 & e && N(n, t[2]);
            },
            d(t) {
              t && w(e);
            },
          };
        }
        function Td(t) {
          let e, n, r, s, i, o, a;
          function c(t, e) {
            return t[0] ? bd : wd;
          }
          let l = c(t),
            u = l(t);
          const h = [vd, Ad],
            d = [];
          return (
            (s = (function (t, e) {
              return t[9] ? 0 : 1;
            })(t)),
            (i = d[s] = h[s](t)),
            {
              c() {
                (e = A("h1")),
                  (e.textContent = "Trading app"),
                  (n = E()),
                  u.c(),
                  (r = E()),
                  i.c(),
                  (o = k());
              },
              m(t, i) {
                b(t, e, i),
                  b(t, n, i),
                  u.m(t, i),
                  b(t, r, i),
                  d[s].m(t, i),
                  b(t, o, i),
                  (a = !0);
              },
              p(t, e) {
                l === (l = c(t)) && u
                  ? u.p(t, e)
                  : (u.d(1), (u = l(t)), u && (u.c(), u.m(r.parentNode, r))),
                  i.p(t, e);
              },
              i(t) {
                a || (tt(i), (a = !0));
              },
              o(t) {
                et(i), (a = !1);
              },
              d(t) {
                t && w(e), t && w(n), u.d(t), t && w(r), d[s].d(t), t && w(o);
              },
            }
          );
        }
        function Od(t) {
          let e, n, r, s;
          return (
            (r = new St({
              props: {
                themeObserver: "dark",
                $$slots: { default: [Td] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = A("meta")),
                  (n = E()),
                  rt(r.$$.fragment),
                  (document.title = "Home"),
                  P(e, "name", "description"),
                  P(e, "content", "Trading App");
              },
              m(t, i) {
                m(document.head, e), b(t, n, i), st(r, t, i), (s = !0);
              },
              p(t, [e]) {
                const n = {};
                262655 & e && (n.$$scope = { dirty: e, ctx: t }), r.$set(n);
              },
              i(t) {
                s || (tt(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                et(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                w(e), t && w(n), it(r, t);
              },
            }
          );
        }
        const Rd = "0x8276EF08D33D4D805f1d19F00851023660c0ae13";
        function Ld(t, e, n) {
          const r =
              new URLSearchParams(window.location.search).get("escrowID") ||
              null,
            s = new yd(window.ethereum);
          let i = null,
            o = null;
          D(() => {
            !(async function () {
              const t = await window.ethereum
                .request({ method: "eth_requestAccounts" })
                .catch((t) => {
                  4001 === t.code
                    ? console.log("Please connect to MetaMask.")
                    : console.error(t);
                });
              n(0, (i = t[0]));
            })(),
              r && l();
          });
          let a = null,
            c = null;
          async function l() {
            n(2, (a = null));
            let t = null;
            try {
              t = Number(r);
            } catch (t) {
              return (
                console.log("Please enter a valid escrow number"),
                void n(2, (a = "Please enter a valid escrow number"))
              );
            }
            if (!t)
              return (
                console.log("Please enter escrow number"),
                void n(2, (a = "Please enter escrow number"))
              );
            const e = await s.getSigner(),
              i = new lh(Rd, Kn, e),
              o = await i.escrows(t);
            if ("0x0000000000000000000000000000000000000000" === o.merchant)
              return (
                console.log("Escrow does not exist"),
                void n(2, (a = "Escrow does not exist"))
              );
            n(3, (c = o));
          }
          let u = null,
            h = null,
            d = null,
            f = null,
            p = null;
          return [
            i,
            o,
            a,
            c,
            u,
            h,
            d,
            f,
            p,
            r,
            l,
            async function () {
              var t;
              if (
                (n(6, (d = null)), n(7, (f = "Creating escrow...")), !u || !h)
              )
                return (
                  console.log("Please enter details and amount"),
                  n(6, (d = "Please enter details and amount")),
                  void n(7, (f = null))
                );
              const e = ys(h.toString()),
                r = await s.getSigner(),
                i = new lh(Rd, Kn, r),
                o = await i.createEscrow(e, u, {
                  value: ys((h / 4).toString()),
                });
              n(
                7,
                (f =
                  "Escrow request signed and sent. Waiting for confirmation...")
              );
              const a = await o.wait();
              console.log("receipt", a),
                n(7, (f = `Escrow created in block ${a.blockNumber}`));
              const c = i.filters["EscrowCreated(uint256,address,uint256)"],
                l = await i.queryFilter(c, a.blockNumber);
              console.log("events", l);
              const g =
                null === (t = l[0].args) || void 0 === t ? void 0 : t._escrowId;
              console.log("escrowID", g),
                n(8, (p = Number(g))),
                n(7, (f = null));
            },
            async function () {
              const t = await window.ethereum
                  .request({ method: "eth_getBalance", params: [i, "latest"] })
                  .catch((t) => {
                    4001 === t.code
                      ? console.log("Please connect to MetaMask.")
                      : console.error(t);
                  }),
                e = parseInt(t, 16);
              n(1, (o = (e / 10 ** 18).toString()));
            },
            function () {
              (u = this.value), n(4, u);
            },
            function () {
              (h = this.value), n(5, h);
            },
          ];
        }
        return new (class extends at {
          constructor(t) {
            super(), ot(this, t, Ld, Od, o, {});
          }
        })({ target: document.body, props: { name: "world" } });
      })();
      //# sourceMappingURL=bundle.js.map
    </script>
  </body>
</html>
