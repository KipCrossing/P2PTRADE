<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trading App</title>
  </head>
  <body>
    <div id="app"></div>
    <script>
      var app = (function () {
        "use strict";
        function t() {}
        function e(t) {
          return t();
        }
        function n() {
          return Object.create(null);
        }
        function r(t) {
          t.forEach(e);
        }
        function s(t) {
          return "function" == typeof t;
        }
        function i(t, e) {
          return t != t
            ? e == e
            : t !== e || (t && "object" == typeof t) || "function" == typeof t;
        }
        function a(t, e) {
          t.appendChild(e);
        }
        function o(t, e, n) {
          const r = (function (t) {
            if (!t) return document;
            const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;
            if (e && e.host) return e;
            return t.ownerDocument;
          })(t);
          if (!r.getElementById(e)) {
            const t = u("style");
            (t.id = e),
              (t.textContent = n),
              (function (t, e) {
                a(t.head || t, e), e.sheet;
              })(r, t);
          }
        }
        function c(t, e, n) {
          t.insertBefore(e, n || null);
        }
        function l(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
        function u(t) {
          return document.createElement(t);
        }
        function h(t) {
          return document.createTextNode(t);
        }
        function f() {
          return h(" ");
        }
        function d() {
          return h("");
        }
        function p(t, e, n, r) {
          return (
            t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r)
          );
        }
        function g(t, e, n) {
          null == n
            ? t.removeAttribute(e)
            : t.getAttribute(e) !== n && t.setAttribute(e, n);
        }
        function m(t, e) {
          (e = "" + e), t.data !== e && (t.data = e);
        }
        function y(t, e) {
          t.value = null == e ? "" : e;
        }
        let w;
        function A(t) {
          w = t;
        }
        function b(t) {
          (function () {
            if (!w)
              throw new Error(
                "Function called outside component initialization"
              );
            return w;
          })().$$.on_mount.push(t);
        }
        const v = [],
          E = [];
        let x = [];
        const P = [],
          k = Promise.resolve();
        let C = !1;
        function N(t) {
          x.push(t);
        }
        const I = new Set();
        let B = 0;
        function T() {
          if (0 !== B) return;
          const t = w;
          do {
            try {
              for (; B < v.length; ) {
                const t = v[B];
                B++, A(t), O(t.$$);
              }
            } catch (t) {
              throw ((v.length = 0), (B = 0), t);
            }
            for (A(null), v.length = 0, B = 0; E.length; ) E.pop()();
            for (let t = 0; t < x.length; t += 1) {
              const e = x[t];
              I.has(e) || (I.add(e), e());
            }
            x.length = 0;
          } while (v.length);
          for (; P.length; ) P.pop()();
          (C = !1), I.clear(), A(t);
        }
        function O(t) {
          if (null !== t.fragment) {
            t.update(), r(t.before_update);
            const e = t.dirty;
            (t.dirty = [-1]),
              t.fragment && t.fragment.p(t.ctx, e),
              t.after_update.forEach(N);
          }
        }
        const S = new Set();
        function R(t, e) {
          const n = t.$$;
          null !== n.fragment &&
            (!(function (t) {
              const e = [],
                n = [];
              x.forEach((r) => (-1 === t.indexOf(r) ? e.push(r) : n.push(r))),
                n.forEach((t) => t()),
                (x = e);
            })(n.after_update),
            r(n.on_destroy),
            n.fragment && n.fragment.d(e),
            (n.on_destroy = n.fragment = null),
            (n.ctx = []));
        }
        function U(t, e) {
          -1 === t.$$.dirty[0] &&
            (v.push(t), C || ((C = !0), k.then(T)), t.$$.dirty.fill(0)),
            (t.$$.dirty[(e / 31) | 0] |= 1 << e % 31);
        }
        function L(i, a, o, c, u, h, f, d = [-1]) {
          const p = w;
          A(i);
          const g = (i.$$ = {
            fragment: null,
            ctx: [],
            props: h,
            update: t,
            not_equal: u,
            bound: n(),
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(a.context || (p ? p.$$.context : [])),
            callbacks: n(),
            dirty: d,
            skip_bound: !1,
            root: a.target || p.$$.root,
          });
          f && f(g.root);
          let m = !1;
          if (
            ((g.ctx = o
              ? o(i, a.props || {}, (t, e, ...n) => {
                  const r = n.length ? n[0] : e;
                  return (
                    g.ctx &&
                      u(g.ctx[t], (g.ctx[t] = r)) &&
                      (!g.skip_bound && g.bound[t] && g.bound[t](r),
                      m && U(i, t)),
                    e
                  );
                })
              : []),
            g.update(),
            (m = !0),
            r(g.before_update),
            (g.fragment = !!c && c(g.ctx)),
            a.target)
          ) {
            if (a.hydrate) {
              const t = (function (t) {
                return Array.from(t.childNodes);
              })(a.target);
              g.fragment && g.fragment.l(t), t.forEach(l);
            } else g.fragment && g.fragment.c();
            a.intro && (y = i.$$.fragment) && y.i && (S.delete(y), y.i(b)),
              (function (t, n, i, a) {
                const { fragment: o, after_update: c } = t.$$;
                o && o.m(n, i),
                  a ||
                    N(() => {
                      const n = t.$$.on_mount.map(e).filter(s);
                      t.$$.on_destroy ? t.$$.on_destroy.push(...n) : r(n),
                        (t.$$.on_mount = []);
                    }),
                  c.forEach(N);
              })(i, a.target, a.anchor, a.customElement),
              T();
          }
          var y, b;
          A(p);
        }
        class F {
          $destroy() {
            R(this, 1), (this.$destroy = t);
          }
          $on(e, n) {
            if (!s(n)) return t;
            const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
            return (
              r.push(n),
              () => {
                const t = r.indexOf(n);
                -1 !== t && r.splice(t, 1);
              }
            );
          }
          $set(t) {
            var e;
            this.$$set &&
              ((e = t), 0 !== Object.keys(e).length) &&
              ((this.$$.skip_bound = !0),
              this.$$set(t),
              (this.$$.skip_bound = !1));
          }
        }
        const D = [
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "Deposit",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
              ],
              name: "EscrowCancelled",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_merchant",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "EscrowCreated",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
              ],
              name: "TradeCompleted",
              type: "event",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "cancelEscrow",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "completeTrade",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "string", name: "_details", type: "string" },
              ],
              name: "createEscrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "deposit",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "escrows",
              outputs: [
                { internalType: "address", name: "buyer", type: "address" },
                { internalType: "address", name: "merchant", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
                { internalType: "string", name: "details", type: "string" },
                { internalType: "bool", name: "isDead", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "nextEscrowId",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          ],
          M = "6.6.4";
        function G(t, e, n) {
          const r = e.split("|").map((t) => t.trim());
          for (let n = 0; n < r.length; n++)
            switch (e) {
              case "any":
                return;
              case "bigint":
              case "boolean":
              case "number":
              case "string":
                if (typeof t === e) return;
            }
          const s = new Error(`invalid value for type ${e}`);
          throw (
            ((s.code = "INVALID_ARGUMENT"),
            (s.argument = `value.${n}`),
            (s.value = t),
            s)
          );
        }
        async function H(t) {
          const e = Object.keys(t);
          return (
            await Promise.all(e.map((e) => Promise.resolve(t[e])))
          ).reduce((t, n, r) => ((t[e[r]] = n), t), {});
        }
        function j(t, e, n) {
          for (let r in e) {
            let s = e[r];
            const i = n ? n[r] : null;
            i && G(s, i, r),
              Object.defineProperty(t, r, {
                enumerable: !0,
                value: s,
                writable: !1,
              });
          }
        }
        function Q(t) {
          if (null == t) return "null";
          if (Array.isArray(t)) return "[ " + t.map(Q).join(", ") + " ]";
          if (t instanceof Uint8Array) {
            const e = "0123456789abcdef";
            let n = "0x";
            for (let r = 0; r < t.length; r++)
              (n += e[t[r] >> 4]), (n += e[15 & t[r]]);
            return n;
          }
          if ("object" == typeof t && "function" == typeof t.toJSON)
            return Q(t.toJSON());
          switch (typeof t) {
            case "boolean":
            case "symbol":
            case "number":
              return t.toString();
            case "bigint":
              return BigInt(t).toString();
            case "string":
              return JSON.stringify(t);
            case "object": {
              const e = Object.keys(t);
              return (
                e.sort(),
                "{ " + e.map((e) => `${Q(e)}: ${Q(t[e])}`).join(", ") + " }"
              );
            }
          }
          return "[ COULD NOT SERIALIZE ]";
        }
        function V(t, e) {
          return t && t.code === e;
        }
        function J(t) {
          return V(t, "CALL_EXCEPTION");
        }
        function z(t, e, n) {
          {
            const r = [];
            if (n) {
              if ("message" in n || "code" in n || "name" in n)
                throw new Error(
                  `value will overwrite populated values: ${Q(n)}`
                );
              for (const t in n) {
                const e = n[t];
                r.push(t + "=" + Q(e));
              }
            }
            r.push(`code=${e}`),
              r.push(`version=${M}`),
              r.length && (t += " (" + r.join(", ") + ")");
          }
          let r;
          switch (e) {
            case "INVALID_ARGUMENT":
              r = new TypeError(t);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              r = new RangeError(t);
              break;
            default:
              r = new Error(t);
          }
          return j(r, { code: e }), n && Object.assign(r, n), r;
        }
        function K(t, e, n, r) {
          if (!t) throw z(e, n, r);
        }
        function _(t, e, n, r) {
          K(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
        }
        function q(t, e, n) {
          null == n && (n = ""),
            n && (n = ": " + n),
            K(t >= e, "missing arguemnt" + n, "MISSING_ARGUMENT", {
              count: t,
              expectedCount: e,
            }),
            K(t <= e, "too many arguemnts" + n, "UNEXPECTED_ARGUMENT", {
              count: t,
              expectedCount: e,
            });
        }
        const W = ["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
          try {
            if ("test" !== "test".normalize(e)) throw new Error("bad");
            if ("NFD" === e) {
              const t = String.fromCharCode(233).normalize("NFD");
              if (t !== String.fromCharCode(101, 769))
                throw new Error("broken");
            }
            t.push(e);
          } catch (t) {}
          return t;
        }, []);
        function Z(t, e, n) {
          if ((null == n && (n = ""), t !== e)) {
            let t = n,
              e = "new";
            n && ((t += "."), (e += " " + n)),
              K(
                !1,
                `private constructor; use ${t}from* methods`,
                "UNSUPPORTED_OPERATION",
                { operation: e }
              );
          }
        }
        function Y(t, e, n) {
          if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
          if ("string" == typeof t && t.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
            const e = new Uint8Array((t.length - 2) / 2);
            let n = 2;
            for (let r = 0; r < e.length; r++)
              (e[r] = parseInt(t.substring(n, n + 2), 16)), (n += 2);
            return e;
          }
          _(!1, "invalid BytesLike value", e || "value", t);
        }
        function X(t, e) {
          return Y(t, e, !1);
        }
        function $(t, e) {
          return Y(t, e, !0);
        }
        function tt(t, e) {
          return (
            !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/)) &&
            ("number" != typeof e || t.length === 2 + 2 * e) &&
            (!0 !== e || t.length % 2 == 0)
          );
        }
        const et = "0123456789abcdef";
        function nt(t) {
          const e = X(t);
          let n = "0x";
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            n += et[(240 & r) >> 4] + et[15 & r];
          }
          return n;
        }
        function rt(t) {
          return "0x" + t.map((t) => nt(t).substring(2)).join("");
        }
        function st(t) {
          return tt(t, !0) ? (t.length - 2) / 2 : X(t).length;
        }
        function it(t, e, n) {
          const r = X(t);
          return (
            null != n &&
              n > r.length &&
              K(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
                buffer: r,
                length: r.length,
                offset: n,
              }),
            nt(r.slice(null == e ? 0 : e, null == n ? r.length : n))
          );
        }
        function at(t, e) {
          return (function (t, e, n) {
            const r = X(t);
            K(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
              buffer: new Uint8Array(r),
              length: e,
              offset: e + 1,
            });
            const s = new Uint8Array(e);
            return s.fill(0), n ? s.set(r, e - r.length) : s.set(r, 0), nt(s);
          })(t, e, !0);
        }
        const ot = BigInt(0),
          ct = BigInt(1),
          lt = 9007199254740991;
        function ut(t, e) {
          const n = pt(t, "value"),
            r = BigInt(yt(e, "width"));
          if (
            (K(n >> r === ot, "overflow", "NUMERIC_FAULT", {
              operation: "fromTwos",
              fault: "overflow",
              value: t,
            }),
            n >> (r - ct))
          ) {
            return -((~n & ((ct << r) - ct)) + ct);
          }
          return n;
        }
        function ht(t, e) {
          let n = dt(t, "value");
          const r = BigInt(yt(e, "width")),
            s = ct << (r - ct);
          if (n < ot) {
            (n = -n),
              K(n <= s, "too low", "NUMERIC_FAULT", {
                operation: "toTwos",
                fault: "overflow",
                value: t,
              });
            return (~n & ((ct << r) - ct)) + ct;
          }
          return (
            K(n < s, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: t,
            }),
            n
          );
        }
        function ft(t, e) {
          const n = pt(t, "value"),
            r = BigInt(yt(e, "bits"));
          return n & ((ct << r) - ct);
        }
        function dt(t, e) {
          switch (typeof t) {
            case "bigint":
              return t;
            case "number":
              return (
                _(Number.isInteger(t), "underflow", e || "value", t),
                _(t >= -lt && t <= lt, "overflow", e || "value", t),
                BigInt(t)
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return "-" === t[0] && "-" !== t[1]
                  ? -BigInt(t.substring(1))
                  : BigInt(t);
              } catch (n) {
                _(
                  !1,
                  `invalid BigNumberish string: ${n.message}`,
                  e || "value",
                  t
                );
              }
          }
          _(!1, "invalid BigNumberish value", e || "value", t);
        }
        function pt(t, e) {
          const n = dt(t, e);
          return (
            K(n >= ot, "unsigned value cannot be negative", "NUMERIC_FAULT", {
              fault: "overflow",
              operation: "getUint",
              value: t,
            }),
            n
          );
        }
        const gt = "0123456789abcdef";
        function mt(t) {
          if (t instanceof Uint8Array) {
            let e = "0x0";
            for (const n of t) (e += gt[n >> 4]), (e += gt[15 & n]);
            return BigInt(e);
          }
          return dt(t);
        }
        function yt(t, e) {
          switch (typeof t) {
            case "bigint":
              return (
                _(t >= -lt && t <= lt, "overflow", e || "value", t), Number(t)
              );
            case "number":
              return (
                _(Number.isInteger(t), "underflow", e || "value", t),
                _(t >= -lt && t <= lt, "overflow", e || "value", t),
                t
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return yt(BigInt(t), e);
              } catch (n) {
                _(!1, `invalid numeric string: ${n.message}`, e || "value", t);
              }
          }
          _(!1, "invalid numeric value", e || "value", t);
        }
        function wt(t, e) {
          let n = pt(t, "value").toString(16);
          if (null == e) n.length % 2 && (n = "0" + n);
          else {
            const r = yt(e, "width");
            for (
              K(
                2 * r >= n.length,
                `value exceeds width (${r} bits)`,
                "NUMERIC_FAULT",
                { operation: "toBeHex", fault: "overflow", value: t }
              );
              n.length < 2 * r;

            )
              n = "0" + n;
          }
          return "0x" + n;
        }
        function At(t) {
          const e = pt(t, "value");
          if (e === ot) return new Uint8Array([]);
          let n = e.toString(16);
          n.length % 2 && (n = "0" + n);
          const r = new Uint8Array(n.length / 2);
          for (let t = 0; t < r.length; t++) {
            const e = 2 * t;
            r[t] = parseInt(n.substring(e, e + 2), 16);
          }
          return r;
        }
        function bt(t) {
          let e = nt(
            (function (t) {
              return tt(t, !0) || t instanceof Uint8Array;
            })(t)
              ? t
              : At(t)
          ).substring(2);
          for (; e.startsWith("0"); ) e = e.substring(1);
          return "" === e && (e = "0"), "0x" + e;
        }
        BigInt(0);
        const vt = BigInt(58);
        class Et {
          filter;
          emitter;
          #t;
          constructor(t, e, n) {
            (this.#t = e), j(this, { emitter: t, filter: n });
          }
          async removeListener() {
            null != this.#t && (await this.emitter.off(this.filter, this.#t));
          }
        }
        function xt(t, e, n, r, s) {
          if ("BAD_PREFIX" === t || "UNEXPECTED_CONTINUE" === t) {
            let t = 0;
            for (let r = e + 1; r < n.length && n[r] >> 6 == 2; r++) t++;
            return t;
          }
          return "OVERRUN" === t ? n.length - e - 1 : 0;
        }
        const Pt = Object.freeze({
          error: function (t, e, n, r, s) {
            _(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
          },
          ignore: xt,
          replace: function (t, e, n, r, s) {
            return "OVERLONG" === t
              ? (_(
                  "number" == typeof s,
                  "invalid bad code point for replacement",
                  "badCodepoint",
                  s
                ),
                r.push(s),
                0)
              : (r.push(65533), xt(t, e, n));
          },
        });
        function kt(t, e) {
          null != e &&
            (!(function (t) {
              K(
                W.indexOf(t) >= 0,
                "platform missing String.prototype.normalize",
                "UNSUPPORTED_OPERATION",
                { operation: "String.prototype.normalize", info: { form: t } }
              );
            })(e),
            (t = t.normalize(e)));
          let n = [];
          for (let e = 0; e < t.length; e++) {
            const r = t.charCodeAt(e);
            if (r < 128) n.push(r);
            else if (r < 2048) n.push((r >> 6) | 192), n.push((63 & r) | 128);
            else if (55296 == (64512 & r)) {
              e++;
              const s = t.charCodeAt(e);
              _(
                e < t.length && 56320 == (64512 & s),
                "invalid surrogate pair",
                "str",
                t
              );
              const i = 65536 + ((1023 & r) << 10) + (1023 & s);
              n.push((i >> 18) | 240),
                n.push(((i >> 12) & 63) | 128),
                n.push(((i >> 6) & 63) | 128),
                n.push((63 & i) | 128);
            } else
              n.push((r >> 12) | 224),
                n.push(((r >> 6) & 63) | 128),
                n.push((63 & r) | 128);
          }
          return new Uint8Array(n);
        }
        function Ct(t, e) {
          return (
            (n = (function (t, e) {
              null == e && (e = Pt.error);
              const n = X(t, "bytes"),
                r = [];
              let s = 0;
              for (; s < n.length; ) {
                const t = n[s++];
                if (t >> 7 == 0) {
                  r.push(t);
                  continue;
                }
                let i = null,
                  a = null;
                if (192 == (224 & t)) (i = 1), (a = 127);
                else if (224 == (240 & t)) (i = 2), (a = 2047);
                else {
                  if (240 != (248 & t)) {
                    s += e(
                      128 == (192 & t) ? "UNEXPECTED_CONTINUE" : "BAD_PREFIX",
                      s - 1,
                      n,
                      r
                    );
                    continue;
                  }
                  (i = 3), (a = 65535);
                }
                if (s - 1 + i >= n.length) {
                  s += e("OVERRUN", s - 1, n, r);
                  continue;
                }
                let o = t & ((1 << (8 - i - 1)) - 1);
                for (let t = 0; t < i; t++) {
                  let t = n[s];
                  if (128 != (192 & t)) {
                    (s += e("MISSING_CONTINUE", s, n, r)), (o = null);
                    break;
                  }
                  (o = (o << 6) | (63 & t)), s++;
                }
                null !== o &&
                  (o > 1114111
                    ? (s += e("OUT_OF_RANGE", s - 1 - i, n, r, o))
                    : o >= 55296 && o <= 57343
                    ? (s += e("UTF16_SURROGATE", s - 1 - i, n, r, o))
                    : o <= a
                    ? (s += e("OVERLONG", s - 1 - i, n, r, o))
                    : r.push(o));
              }
              return r;
            })(t, e)),
            n
              .map((t) =>
                t <= 65535
                  ? String.fromCharCode(t)
                  : ((t -= 65536),
                    String.fromCharCode(
                      55296 + ((t >> 10) & 1023),
                      56320 + (1023 & t)
                    ))
              )
              .join("")
          );
          var n;
        }
        let Nt = async function (t, e) {
          const n = t.url.split(":")[0].toLowerCase();
          let r;
          if (
            (K(
              "http" === n || "https" === n,
              `unsupported protocol ${n}`,
              "UNSUPPORTED_OPERATION",
              { info: { protocol: n }, operation: "request" }
            ),
            K(
              "https" === n || !t.credentials || t.allowInsecureAuthentication,
              "insecure authorized connections unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "request" }
            ),
            e)
          ) {
            const t = new AbortController();
            (r = t.signal),
              e.addListener(() => {
                t.abort();
              });
          }
          const s = {
              method: t.method,
              headers: new Headers(Array.from(t)),
              body: t.body || void 0,
              signal: r,
            },
            i = await fetch(t.url, s),
            a = {};
          i.headers.forEach((t, e) => {
            a[e.toLowerCase()] = t;
          });
          const o = await i.arrayBuffer(),
            c = null == o ? null : new Uint8Array(o);
          return {
            statusCode: i.status,
            statusMessage: i.statusText,
            headers: a,
            body: c,
          };
        };
        const It = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
          Bt = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
        let Tt = !1;
        async function Ot(t, e) {
          try {
            const e = t.match(It);
            if (!e) throw new Error("invalid data");
            return new Mt(
              200,
              "OK",
              { "content-type": e[1] || "text/plain" },
              e[2]
                ? (function (t) {
                    t = atob(t);
                    const e = new Uint8Array(t.length);
                    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
                    return X(e);
                  })(e[3])
                : kt(
                    e[3].replace(/%([0-9a-f][0-9a-f])/gi, (t, e) =>
                      String.fromCharCode(parseInt(e, 16))
                    )
                  )
            );
          } catch (e) {
            return new Mt(
              599,
              "BAD REQUEST (invalid data: URI)",
              {},
              null,
              new Dt(t)
            );
          }
        }
        function St(t) {
          return async function (e, n) {
            try {
              const n = e.match(Bt);
              if (!n) throw new Error("invalid link");
              return new Dt(`${t}${n[2]}`);
            } catch (t) {
              return new Mt(
                599,
                "BAD REQUEST (invalid IPFS URI)",
                {},
                null,
                new Dt(e)
              );
            }
          };
        }
        const Rt = { data: Ot, ipfs: St("https://gateway.ipfs.io/ipfs/") },
          Ut = new WeakMap();
        class Lt {
          #e;
          #n;
          constructor(t) {
            (this.#e = []),
              (this.#n = !1),
              Ut.set(t, () => {
                if (!this.#n) {
                  this.#n = !0;
                  for (const t of this.#e)
                    setTimeout(() => {
                      t();
                    }, 0);
                  this.#e = [];
                }
              });
          }
          addListener(t) {
            K(!this.#n, "singal already cancelled", "UNSUPPORTED_OPERATION", {
              operation: "fetchCancelSignal.addCancelListener",
            }),
              this.#e.push(t);
          }
          get cancelled() {
            return this.#n;
          }
          checkSignal() {
            K(!this.cancelled, "cancelled", "CANCELLED", {});
          }
        }
        function Ft(t) {
          if (null == t) throw new Error("missing signal; should not happen");
          return t.checkSignal(), t;
        }
        class Dt {
          #r;
          #s;
          #i;
          #a;
          #o;
          #c;
          #l;
          #u;
          #h;
          #f;
          #d;
          #p;
          #g;
          #m;
          get url() {
            return this.#c;
          }
          set url(t) {
            this.#c = String(t);
          }
          get body() {
            return null == this.#l ? null : new Uint8Array(this.#l);
          }
          set body(t) {
            if (null == t) (this.#l = void 0), (this.#u = void 0);
            else if ("string" == typeof t)
              (this.#l = kt(t)), (this.#u = "text/plain");
            else if (t instanceof Uint8Array)
              (this.#l = t), (this.#u = "application/octet-stream");
            else {
              if ("object" != typeof t) throw new Error("invalid body");
              (this.#l = kt(JSON.stringify(t))), (this.#u = "application/json");
            }
          }
          hasBody() {
            return null != this.#l;
          }
          get method() {
            return this.#a ? this.#a : this.hasBody() ? "POST" : "GET";
          }
          set method(t) {
            null == t && (t = ""), (this.#a = String(t).toUpperCase());
          }
          get headers() {
            const t = Object.assign({}, this.#i);
            return (
              this.#h &&
                (t.authorization = `Basic ${(function (t) {
                  const e = X(t);
                  let n = "";
                  for (let t = 0; t < e.length; t++)
                    n += String.fromCharCode(e[t]);
                  return btoa(n);
                })(kt(this.#h))}`),
              this.allowGzip && (t["accept-encoding"] = "gzip"),
              null == t["content-type"] &&
                this.#u &&
                (t["content-type"] = this.#u),
              this.body && (t["content-length"] = String(this.body.length)),
              t
            );
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          setHeader(t, e) {
            this.#i[String(t).toLowerCase()] = String(e);
          }
          clearHeaders() {
            this.#i = {};
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          get credentials() {
            return this.#h || null;
          }
          setCredentials(t, e) {
            _(
              !t.match(/:/),
              "invalid basic authentication username",
              "username",
              "[REDACTED]"
            ),
              (this.#h = `${t}:${e}`);
          }
          get allowGzip() {
            return this.#s;
          }
          set allowGzip(t) {
            this.#s = !!t;
          }
          get allowInsecureAuthentication() {
            return !!this.#r;
          }
          set allowInsecureAuthentication(t) {
            this.#r = !!t;
          }
          get timeout() {
            return this.#o;
          }
          set timeout(t) {
            _(t >= 0, "timeout must be non-zero", "timeout", t), (this.#o = t);
          }
          get preflightFunc() {
            return this.#f || null;
          }
          set preflightFunc(t) {
            this.#f = t;
          }
          get processFunc() {
            return this.#d || null;
          }
          set processFunc(t) {
            this.#d = t;
          }
          get retryFunc() {
            return this.#p || null;
          }
          set retryFunc(t) {
            this.#p = t;
          }
          constructor(t) {
            (this.#c = String(t)),
              (this.#r = !1),
              (this.#s = !0),
              (this.#i = {}),
              (this.#a = ""),
              (this.#o = 3e5),
              (this.#m = { slotInterval: 250, maxAttempts: 12 });
          }
          toString() {
            return `<FetchRequest method=${JSON.stringify(
              this.method
            )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
              this.headers
            )} body=${this.#l ? nt(this.#l) : "null"}>`;
          }
          setThrottleParams(t) {
            null != t.slotInterval && (this.#m.slotInterval = t.slotInterval),
              null != t.maxAttempts && (this.#m.maxAttempts = t.maxAttempts);
          }
          async #y(t, e, n, r, s) {
            if (t >= this.#m.maxAttempts)
              return s.makeServerError("exceeded maximum retry limit");
            K(Gt() <= e, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: r,
            }),
              n > 0 &&
                (await (function (t) {
                  return new Promise((e) => setTimeout(e, t));
                })(n));
            let i = this.clone();
            const a = (i.url.split(":")[0] || "").toLowerCase();
            if (a in Rt) {
              const t = await Rt[a](i.url, Ft(r.#g));
              if (t instanceof Mt) {
                let e = t;
                if (this.processFunc) {
                  Ft(r.#g);
                  try {
                    e = await this.processFunc(i, e);
                  } catch (t) {
                    (null != t.throttle && "number" == typeof t.stall) ||
                      e
                        .makeServerError("error in post-processing function", t)
                        .assertOk();
                  }
                }
                return e;
              }
              i = t;
            }
            this.preflightFunc && (i = await this.preflightFunc(i));
            const o = await Nt(i, Ft(r.#g));
            let c = new Mt(o.statusCode, o.statusMessage, o.headers, o.body, r);
            if (301 === c.statusCode || 302 === c.statusCode) {
              try {
                const n = c.headers.location || "";
                return i.redirect(n).#y(t + 1, e, 0, r, c);
              } catch (t) {}
              return c;
            }
            if (
              429 === c.statusCode &&
              (null == this.retryFunc || (await this.retryFunc(i, c, t)))
            ) {
              const n = c.headers["retry-after"];
              let s =
                this.#m.slotInterval *
                Math.trunc(Math.random() * Math.pow(2, t));
              return (
                "string" == typeof n &&
                  n.match(/^[1-9][0-9]*$/) &&
                  (s = parseInt(n)),
                i.clone().#y(t + 1, e, s, r, c)
              );
            }
            if (this.processFunc) {
              Ft(r.#g);
              try {
                c = await this.processFunc(i, c);
              } catch (n) {
                (null != n.throttle && "number" == typeof n.stall) ||
                  c
                    .makeServerError("error in post-processing function", n)
                    .assertOk();
                let s =
                  this.#m.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, t));
                return (
                  n.stall >= 0 && (s = n.stall), i.clone().#y(t + 1, e, s, r, c)
                );
              }
            }
            return c;
          }
          send() {
            return (
              K(
                null == this.#g,
                "request already sent",
                "UNSUPPORTED_OPERATION",
                { operation: "fetchRequest.send" }
              ),
              (this.#g = new Lt(this)),
              this.#y(
                0,
                Gt() + this.timeout,
                0,
                this,
                new Mt(0, "", {}, null, this)
              )
            );
          }
          cancel() {
            K(
              null != this.#g,
              "request has not been sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.cancel" }
            );
            const t = Ut.get(this);
            if (!t) throw new Error("missing signal; should not happen");
            t();
          }
          redirect(t) {
            const e = this.url.split(":")[0].toLowerCase(),
              n = t.split(":")[0].toLowerCase();
            K(
              "GET" === this.method &&
                ("https" !== e || "http" !== n) &&
                t.match(/^https?:/),
              "unsupported redirect",
              "UNSUPPORTED_OPERATION",
              {
                operation: `redirect(${this.method} ${JSON.stringify(
                  this.url
                )} => ${JSON.stringify(t)})`,
              }
            );
            const r = new Dt(t);
            return (
              (r.method = "GET"),
              (r.allowGzip = this.allowGzip),
              (r.timeout = this.timeout),
              (r.#i = Object.assign({}, this.#i)),
              this.#l && (r.#l = new Uint8Array(this.#l)),
              (r.#u = this.#u),
              r
            );
          }
          clone() {
            const t = new Dt(this.url);
            return (
              (t.#a = this.#a),
              this.#l && (t.#l = this.#l),
              (t.#u = this.#u),
              (t.#i = Object.assign({}, this.#i)),
              (t.#h = this.#h),
              this.allowGzip && (t.allowGzip = !0),
              (t.timeout = this.timeout),
              this.allowInsecureAuthentication &&
                (t.allowInsecureAuthentication = !0),
              (t.#f = this.#f),
              (t.#d = this.#d),
              (t.#p = this.#p),
              t
            );
          }
          static lockConfig() {
            Tt = !0;
          }
          static getGateway(t) {
            return Rt[t.toLowerCase()] || null;
          }
          static registerGateway(t, e) {
            if ("http" === (t = t.toLowerCase()) || "https" === t)
              throw new Error(`cannot intercept ${t}; use registerGetUrl`);
            if (Tt) throw new Error("gateways locked");
            Rt[t] = e;
          }
          static registerGetUrl(t) {
            if (Tt) throw new Error("gateways locked");
            Nt = t;
          }
          static createDataGateway() {
            return Ot;
          }
          static createIpfsGatewayFunc(t) {
            return St(t);
          }
        }
        class Mt {
          #w;
          #A;
          #i;
          #l;
          #b;
          #v;
          toString() {
            return `<FetchResponse status=${this.statusCode} body=${
              this.#l ? nt(this.#l) : "null"
            }>`;
          }
          get statusCode() {
            return this.#w;
          }
          get statusMessage() {
            return this.#A;
          }
          get headers() {
            return Object.assign({}, this.#i);
          }
          get body() {
            return null == this.#l ? null : new Uint8Array(this.#l);
          }
          get bodyText() {
            try {
              return null == this.#l ? "" : Ct(this.#l);
            } catch (t) {
              K(
                !1,
                "response body is not valid UTF-8 data",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyText", info: { response: this } }
              );
            }
          }
          get bodyJson() {
            try {
              return JSON.parse(this.bodyText);
            } catch (t) {
              K(
                !1,
                "response body is not valid JSON",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyJson", info: { response: this } }
              );
            }
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          constructor(t, e, n, r, s) {
            (this.#w = t),
              (this.#A = e),
              (this.#i = Object.keys(n).reduce(
                (t, e) => ((t[e.toLowerCase()] = String(n[e])), t),
                {}
              )),
              (this.#l = null == r ? null : new Uint8Array(r)),
              (this.#b = s || null),
              (this.#v = { message: "" });
          }
          makeServerError(t, e) {
            let n;
            n = t
              ? `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})`
              : `CLIENT ESCALATED SERVER ERROR (${(t = `${this.statusCode} ${this.statusMessage}`)})`;
            const r = new Mt(
              599,
              n,
              this.headers,
              this.body,
              this.#b || void 0
            );
            return (r.#v = { message: t, error: e }), r;
          }
          throwThrottleError(t, e) {
            null == e
              ? (e = -1)
              : _(
                  Number.isInteger(e) && e >= 0,
                  "invalid stall timeout",
                  "stall",
                  e
                );
            const n = new Error(t || "throttling requests");
            throw (j(n, { stall: e, throttle: !0 }), n);
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          hasBody() {
            return null != this.#l;
          }
          get request() {
            return this.#b;
          }
          ok() {
            return (
              "" === this.#v.message &&
              this.statusCode >= 200 &&
              this.statusCode < 300
            );
          }
          assertOk() {
            if (this.ok()) return;
            let { message: t, error: e } = this.#v;
            "" === t &&
              (t = `server response ${this.statusCode} ${this.statusMessage}`),
              K(!1, t, "SERVER_ERROR", {
                request: this.request || "unknown request",
                response: this,
                error: e,
              });
          }
        }
        function Gt() {
          return new Date().getTime();
        }
        const Ht = BigInt(-1),
          jt = BigInt(0),
          Qt = BigInt(1),
          Vt = BigInt(5),
          Jt = {};
        let zt = "0000";
        for (; zt.length < 80; ) zt += zt;
        function Kt(t) {
          let e = zt;
          for (; e.length < t; ) e += e;
          return BigInt("1" + e.substring(0, t));
        }
        function _t(t, e, n) {
          const r = BigInt(e.width);
          if (e.signed) {
            const e = Qt << (r - Qt);
            K(null == n || (t >= -e && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = t > jt ? ut(ft(t, r), r) : -ut(ft(-t, r), r));
          } else {
            const e = Qt << r;
            K(null == n || (t >= 0 && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = ((t % e) + e) % e & (e - Qt));
          }
          return t;
        }
        function qt(t) {
          "number" == typeof t && (t = `fixed128x${t}`);
          let e = !0,
            n = 128,
            r = 18;
          if ("string" == typeof t)
            if ("fixed" === t);
            else if ("ufixed" === t) e = !1;
            else {
              const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              _(s, "invalid fixed format", "format", t),
                (e = "u" !== s[1]),
                (n = parseInt(s[2])),
                (r = parseInt(s[3]));
            }
          else if (t) {
            const s = t,
              i = (t, e, n) =>
                null == s[t]
                  ? n
                  : (_(
                      typeof s[t] === e,
                      "invalid fixed format (" + t + " not " + e + ")",
                      "format." + t,
                      s[t]
                    ),
                    s[t]);
            (e = i("signed", "boolean", e)),
              (n = i("width", "number", n)),
              (r = i("decimals", "number", r));
          }
          _(
            n % 8 == 0,
            "invalid FixedNumber width (not byte aligned)",
            "format.width",
            n
          ),
            _(
              r <= 80,
              "invalid FixedNumber decimals (too large)",
              "format.decimals",
              r
            );
          return {
            signed: e,
            width: n,
            decimals: r,
            name: (e ? "" : "u") + "fixed" + String(n) + "x" + String(r),
          };
        }
        class Wt {
          format;
          #E;
          #x;
          #P;
          _value;
          constructor(t, e, n) {
            Z(t, Jt, "FixedNumber"), (this.#x = e), (this.#E = n);
            const r = (function (t, e) {
              let n = "";
              t < jt && ((n = "-"), (t *= Ht));
              let r = t.toString();
              if (0 === e) return n + r;
              for (; r.length <= e; ) r = zt + r;
              const s = r.length - e;
              for (
                r = r.substring(0, s) + "." + r.substring(s);
                "0" === r[0] && "." !== r[1];

              )
                r = r.substring(1);
              for (; "0" === r[r.length - 1] && "." !== r[r.length - 2]; )
                r = r.substring(0, r.length - 1);
              return n + r;
            })(e, n.decimals);
            j(this, { format: n.name, _value: r }), (this.#P = Kt(n.decimals));
          }
          get signed() {
            return this.#E.signed;
          }
          get width() {
            return this.#E.width;
          }
          get decimals() {
            return this.#E.decimals;
          }
          get value() {
            return this.#x;
          }
          #k(t) {
            _(
              this.format === t.format,
              "incompatible format; use fixedNumber.toFormat",
              "other",
              t
            );
          }
          #C(t, e) {
            return (t = _t(t, this.#E, e)), new Wt(Jt, t, this.#E);
          }
          #N(t, e) {
            return this.#k(t), this.#C(this.#x + t.#x, e);
          }
          addUnsafe(t) {
            return this.#N(t);
          }
          add(t) {
            return this.#N(t, "add");
          }
          #I(t, e) {
            return this.#k(t), this.#C(this.#x - t.#x, e);
          }
          subUnsafe(t) {
            return this.#I(t);
          }
          sub(t) {
            return this.#I(t, "sub");
          }
          #B(t, e) {
            return this.#k(t), this.#C((this.#x * t.#x) / this.#P, e);
          }
          mulUnsafe(t) {
            return this.#B(t);
          }
          mul(t) {
            return this.#B(t, "mul");
          }
          mulSignal(t) {
            this.#k(t);
            const e = this.#x * t.#x;
            return (
              K(
                e % this.#P === jt,
                "precision lost during signalling mul",
                "NUMERIC_FAULT",
                { operation: "mulSignal", fault: "underflow", value: this }
              ),
              this.#C(e / this.#P, "mulSignal")
            );
          }
          #T(t, e) {
            return (
              K(t.#x !== jt, "division by zero", "NUMERIC_FAULT", {
                operation: "div",
                fault: "divide-by-zero",
                value: this,
              }),
              this.#k(t),
              this.#C((this.#x * this.#P) / t.#x, e)
            );
          }
          divUnsafe(t) {
            return this.#T(t);
          }
          div(t) {
            return this.#T(t, "div");
          }
          divSignal(t) {
            K(t.#x !== jt, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            }),
              this.#k(t);
            const e = this.#x * this.#P;
            return (
              K(
                e % t.#x === jt,
                "precision lost during signalling div",
                "NUMERIC_FAULT",
                { operation: "divSignal", fault: "underflow", value: this }
              ),
              this.#C(e / t.#x, "divSignal")
            );
          }
          cmp(t) {
            let e = this.value,
              n = t.value;
            const r = this.decimals - t.decimals;
            return (
              r > 0 ? (n *= Kt(r)) : r < 0 && (e *= Kt(-r)),
              e < n ? -1 : e > n ? 1 : 0
            );
          }
          eq(t) {
            return 0 === this.cmp(t);
          }
          lt(t) {
            return this.cmp(t) < 0;
          }
          lte(t) {
            return this.cmp(t) <= 0;
          }
          gt(t) {
            return this.cmp(t) > 0;
          }
          gte(t) {
            return this.cmp(t) >= 0;
          }
          floor() {
            let t = this.#x;
            return (
              this.#x < jt && (t -= this.#P - Qt),
              (t = (this.#x / this.#P) * this.#P),
              this.#C(t, "floor")
            );
          }
          ceiling() {
            let t = this.#x;
            return (
              this.#x > jt && (t += this.#P - Qt),
              (t = (this.#x / this.#P) * this.#P),
              this.#C(t, "ceiling")
            );
          }
          round(t) {
            if ((null == t && (t = 0), t >= this.decimals)) return this;
            const e = this.decimals - t,
              n = Vt * Kt(e - 1);
            let r = this.value + n;
            const s = Kt(e);
            return (
              (r = (r / s) * s), _t(r, this.#E, "round"), new Wt(Jt, r, this.#E)
            );
          }
          isZero() {
            return this.#x === jt;
          }
          isNegative() {
            return this.#x < jt;
          }
          toString() {
            return this._value;
          }
          toUnsafeFloat() {
            return parseFloat(this.toString());
          }
          toFormat(t) {
            return Wt.fromString(this.toString(), t);
          }
          static fromValue(t, e, n) {
            const r = null == e ? 0 : yt(e),
              s = qt(n);
            let i = dt(t, "value");
            const a = r - s.decimals;
            if (a > 0) {
              const e = Kt(a);
              K(
                i % e === jt,
                "value loses precision for format",
                "NUMERIC_FAULT",
                { operation: "fromValue", fault: "underflow", value: t }
              ),
                (i /= e);
            } else a < 0 && (i *= Kt(-a));
            return _t(i, s, "fromValue"), new Wt(Jt, i, s);
          }
          static fromString(t, e) {
            const n = t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            _(
              n && n[2].length + n[3].length > 0,
              "invalid FixedNumber string value",
              "value",
              t
            );
            const r = qt(e);
            let s = n[2] || "0",
              i = n[3] || "";
            for (; i.length < r.decimals; ) i += zt;
            K(
              i.substring(r.decimals).match(/^0*$/),
              "too many decimals for format",
              "NUMERIC_FAULT",
              { operation: "fromString", fault: "underflow", value: t }
            ),
              (i = i.substring(0, r.decimals));
            const a = BigInt(n[1] + s + i);
            return _t(a, r, "fromString"), new Wt(Jt, a, r);
          }
          static fromBytes(t, e) {
            let n = mt(X(t, "value"));
            const r = qt(e);
            return (
              r.signed && (n = ut(n, r.width)),
              _t(n, r, "fromBytes"),
              new Wt(Jt, n, r)
            );
          }
        }
        function Zt(t) {
          let e = t.toString(16);
          for (; e.length < 2; ) e = "0" + e;
          return "0x" + e;
        }
        function Yt(t, e, n) {
          let r = 0;
          for (let s = 0; s < n; s++) r = 256 * r + t[e + s];
          return r;
        }
        function Xt(t, e, n, r) {
          const s = [];
          for (; n < e + 1 + r; ) {
            const i = $t(t, n);
            s.push(i.result),
              K(
                (n += i.consumed) <= e + 1 + r,
                "child data too short",
                "BUFFER_OVERRUN",
                { buffer: t, length: r, offset: e }
              );
          }
          return { consumed: 1 + r, result: s };
        }
        function $t(t, e) {
          K(0 !== t.length, "data too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: 0,
            offset: 1,
          });
          const n = (e) => {
            K(e <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
              buffer: t,
              length: t.length,
              offset: e,
            });
          };
          if (t[e] >= 248) {
            const r = t[e] - 247;
            n(e + 1 + r);
            const s = Yt(t, e + 1, r);
            return n(e + 1 + r + s), Xt(t, e, e + 1 + r, r + s);
          }
          if (t[e] >= 192) {
            const r = t[e] - 192;
            return n(e + 1 + r), Xt(t, e, e + 1, r);
          }
          if (t[e] >= 184) {
            const r = t[e] - 183;
            n(e + 1 + r);
            const s = Yt(t, e + 1, r);
            n(e + 1 + r + s);
            return {
              consumed: 1 + r + s,
              result: nt(t.slice(e + 1 + r, e + 1 + r + s)),
            };
          }
          if (t[e] >= 128) {
            const r = t[e] - 128;
            n(e + 1 + r);
            return { consumed: 1 + r, result: nt(t.slice(e + 1, e + 1 + r)) };
          }
          return { consumed: 1, result: Zt(t[e]) };
        }
        function te(t) {
          const e = X(t, "data"),
            n = $t(e, 0);
          return (
            _(
              n.consumed === e.length,
              "unexpected junk after rlp payload",
              "data",
              t
            ),
            n.result
          );
        }
        function ee(t) {
          const e = [];
          for (; t; ) e.unshift(255 & t), (t >>= 8);
          return e;
        }
        function ne(t) {
          if (Array.isArray(t)) {
            let e = [];
            if (
              (t.forEach(function (t) {
                e = e.concat(ne(t));
              }),
              e.length <= 55)
            )
              return e.unshift(192 + e.length), e;
            const n = ee(e.length);
            return n.unshift(247 + n.length), n.concat(e);
          }
          const e = Array.prototype.slice.call(X(t, "object"));
          if (1 === e.length && e[0] <= 127) return e;
          if (e.length <= 55) return e.unshift(128 + e.length), e;
          const n = ee(e.length);
          return n.unshift(183 + n.length), n.concat(e);
        }
        const re = "0123456789abcdef";
        function se(t) {
          let e = "0x";
          for (const n of ne(t)) (e += re[n >> 4]), (e += re[15 & n]);
          return e;
        }
        const ie = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
        function ae(t) {
          return (function (t, e) {
            _("string" == typeof t, "value must be a string", "value", t);
            let n = 18;
            if ("string" == typeof e) {
              const t = ie.indexOf(e);
              _(t >= 0, "invalid unit", "unit", e), (n = 3 * t);
            } else null != e && (n = yt(e, "unit"));
            return Wt.fromString(t, { decimals: n, width: 512 }).value;
          })(t, 18);
        }
        const oe = 32,
          ce = new Uint8Array(oe),
          le = ["then"],
          ue = {};
        function he(t, e) {
          const n = new Error(
            `deferred error during ABI decoding triggered accessing ${t}`
          );
          throw ((n.error = e), n);
        }
        class fe extends Array {
          #O;
          constructor(...t) {
            const e = t[0];
            let n = t[1],
              r = (t[2] || []).slice(),
              s = !0;
            e !== ue && ((n = t), (r = []), (s = !1)),
              super(n.length),
              n.forEach((t, e) => {
                this[e] = t;
              });
            const i = r.reduce(
              (t, e) => (
                "string" == typeof e && t.set(e, (t.get(e) || 0) + 1), t
              ),
              new Map()
            );
            if (
              ((this.#O = Object.freeze(
                n.map((t, e) => {
                  const n = r[e];
                  return null != n && 1 === i.get(n) ? n : null;
                })
              )),
              s)
            )
              return (
                Object.freeze(this),
                new Proxy(this, {
                  get: (t, e, n) => {
                    if ("string" == typeof e) {
                      if (e.match(/^[0-9]+$/)) {
                        const n = yt(e, "%index");
                        if (n < 0 || n >= this.length)
                          throw new RangeError("out of result range");
                        const r = t[n];
                        return r instanceof Error && he(`index ${n}`, r), r;
                      }
                      if (le.indexOf(e) >= 0) return Reflect.get(t, e, n);
                      const r = t[e];
                      if (r instanceof Function)
                        return function (...e) {
                          return r.apply(this === n ? t : this, e);
                        };
                      if (!(e in t))
                        return t.getValue.apply(this === n ? t : this, [e]);
                    }
                    return Reflect.get(t, e, n);
                  },
                })
              );
          }
          toArray() {
            const t = [];
            return (
              this.forEach((e, n) => {
                e instanceof Error && he(`index ${n}`, e), t.push(e);
              }),
              t
            );
          }
          toObject() {
            return this.#O.reduce(
              (t, e, n) => (
                K(
                  null != e,
                  "value at index ${ index } unnamed",
                  "UNSUPPORTED_OPERATION",
                  { operation: "toObject()" }
                ),
                e in t || (t[e] = this.getValue(e)),
                t
              ),
              {}
            );
          }
          slice(t, e) {
            null == t && (t = 0),
              t < 0 && (t += this.length) < 0 && (t = 0),
              null == e && (e = this.length),
              e < 0 && (e += this.length) < 0 && (e = 0),
              e > this.length && (e = this.length);
            const n = [],
              r = [];
            for (let s = t; s < e; s++) n.push(this[s]), r.push(this.#O[s]);
            return new fe(ue, n, r);
          }
          filter(t, e) {
            const n = [],
              r = [];
            for (let s = 0; s < this.length; s++) {
              const i = this[s];
              i instanceof Error && he(`index ${s}`, i),
                t.call(e, i, s, this) && (n.push(i), r.push(this.#O[s]));
            }
            return new fe(ue, n, r);
          }
          map(t, e) {
            const n = [];
            for (let r = 0; r < this.length; r++) {
              const s = this[r];
              s instanceof Error && he(`index ${r}`, s),
                n.push(t.call(e, s, r, this));
            }
            return n;
          }
          getValue(t) {
            const e = this.#O.indexOf(t);
            if (-1 === e) return;
            const n = this[e];
            return (
              n instanceof Error &&
                he(`property ${JSON.stringify(t)}`, n.error),
              n
            );
          }
          static fromItems(t, e) {
            return new fe(ue, t, e);
          }
        }
        function de(t) {
          let e = At(t);
          return (
            K(e.length <= oe, "value out-of-bounds", "BUFFER_OVERRUN", {
              buffer: e,
              length: oe,
              offset: e.length,
            }),
            e.length !== oe && (e = $(rt([ce.slice(e.length % oe), e]))),
            e
          );
        }
        class pe {
          name;
          type;
          localName;
          dynamic;
          constructor(t, e, n, r) {
            j(
              this,
              { name: t, type: e, localName: n, dynamic: r },
              {
                name: "string",
                type: "string",
                localName: "string",
                dynamic: "boolean",
              }
            );
          }
          _throwError(t, e) {
            _(!1, t, this.localName, e);
          }
        }
        class ge {
          #S;
          #R;
          constructor() {
            (this.#S = []), (this.#R = 0);
          }
          get data() {
            return rt(this.#S);
          }
          get length() {
            return this.#R;
          }
          #U(t) {
            return this.#S.push(t), (this.#R += t.length), t.length;
          }
          appendWriter(t) {
            return this.#U($(t.data));
          }
          writeBytes(t) {
            let e = $(t);
            const n = e.length % oe;
            return n && (e = $(rt([e, ce.slice(n)]))), this.#U(e);
          }
          writeValue(t) {
            return this.#U(de(t));
          }
          writeUpdatableValue() {
            const t = this.#S.length;
            return (
              this.#S.push(ce),
              (this.#R += oe),
              (e) => {
                this.#S[t] = de(e);
              }
            );
          }
        }
        class me {
          allowLoose;
          #S;
          #L;
          constructor(t, e) {
            j(this, { allowLoose: !!e }), (this.#S = $(t)), (this.#L = 0);
          }
          get data() {
            return nt(this.#S);
          }
          get dataLength() {
            return this.#S.length;
          }
          get consumed() {
            return this.#L;
          }
          get bytes() {
            return new Uint8Array(this.#S);
          }
          #F(t, e, n) {
            let r = Math.ceil(e / oe) * oe;
            return (
              this.#L + r > this.#S.length &&
                (this.allowLoose && n && this.#L + e <= this.#S.length
                  ? (r = e)
                  : K(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                      buffer: $(this.#S),
                      length: this.#S.length,
                      offset: this.#L + r,
                    })),
              this.#S.slice(this.#L, this.#L + r)
            );
          }
          subReader(t) {
            return new me(this.#S.slice(this.#L + t), this.allowLoose);
          }
          readBytes(t, e) {
            let n = this.#F(0, t, !!e);
            return (this.#L += n.length), n.slice(0, t);
          }
          readValue() {
            return mt(this.readBytes(oe));
          }
          readIndex() {
            return yt(mt(this.readBytes(oe)));
          }
        }
        function ye(t) {
          if (!Number.isSafeInteger(t) || t < 0)
            throw new Error(`Wrong positive integer: ${t}`);
        }
        function we(t, ...e) {
          if (!(t instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          if (e.length > 0 && !e.includes(t.length))
            throw new TypeError(
              `Expected Uint8Array of length ${e}, not of length=${t.length}`
            );
        }
        const Ae = {
            number: ye,
            bool: function (t) {
              if ("boolean" != typeof t)
                throw new Error(`Expected boolean, not ${t}`);
            },
            bytes: we,
            hash: function (t) {
              if ("function" != typeof t || "function" != typeof t.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              ye(t.outputLen), ye(t.blockLen);
            },
            exists: function (t, e = !0) {
              if (t.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (e && t.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (t, e) {
              we(t);
              const n = e.outputLen;
              if (t.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          be = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
          ve = (t, e) => (t << (32 - e)) | (t >>> e);
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ if (
          !(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])
        )
          throw new Error("Non little-endian hardware is not supported");
        function Ee(t) {
          if (
            ("string" == typeof t &&
              (t = (function (t) {
                if ("string" != typeof t)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof t
                  );
                return new TextEncoder().encode(t);
              })(t)),
            !(t instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof t})`
            );
          return t;
        }
        Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
        class xe {
          clone() {
            return this._cloneInto();
          }
        }
        function Pe(t) {
          const e = (e) => t().update(Ee(e)).digest(),
            n = t();
          return (
            (e.outputLen = n.outputLen),
            (e.blockLen = n.blockLen),
            (e.create = () => t()),
            e
          );
        }
        class ke extends xe {
          constructor(t, e) {
            super(), (this.finished = !1), (this.destroyed = !1), Ae.hash(t);
            const n = Ee(e);
            if (((this.iHash = t.create()), !(this.iHash instanceof xe)))
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            const r = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const s = new Uint8Array(r);
            s.set(
              n.length > this.iHash.blockLen ? t.create().update(n).digest() : n
            );
            for (let t = 0; t < s.length; t++) s[t] ^= 54;
            this.iHash.update(s), (this.oHash = t.create());
            for (let t = 0; t < s.length; t++) s[t] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(t) {
            return Ae.exists(this), this.iHash.update(t), this;
          }
          digestInto(t) {
            Ae.exists(this),
              Ae.bytes(t, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(t),
              this.oHash.update(t),
              this.oHash.digestInto(t),
              this.destroy();
          }
          digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t), t;
          }
          _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: e,
              iHash: n,
              finished: r,
              destroyed: s,
              blockLen: i,
              outputLen: a,
            } = this;
            return (
              (t.finished = r),
              (t.destroyed = s),
              (t.blockLen = i),
              (t.outputLen = a),
              (t.oHash = e._cloneInto(t.oHash)),
              (t.iHash = n._cloneInto(t.iHash)),
              t
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const Ce = (t, e, n) => new ke(t, e).update(n).digest();
        Ce.create = (t, e) => new ke(t, e);
        class Ne extends xe {
          constructor(t, e, n, r) {
            super(),
              (this.blockLen = t),
              (this.outputLen = e),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(t)),
              (this.view = be(this.buffer));
          }
          update(t) {
            Ae.exists(this);
            const { view: e, buffer: n, blockLen: r } = this,
              s = (t = Ee(t)).length;
            for (let i = 0; i < s; ) {
              const a = Math.min(r - this.pos, s - i);
              if (a !== r)
                n.set(t.subarray(i, i + a), this.pos),
                  (this.pos += a),
                  (i += a),
                  this.pos === r && (this.process(e, 0), (this.pos = 0));
              else {
                const e = be(t);
                for (; r <= s - i; i += r) this.process(e, i);
              }
            }
            return (this.length += t.length), this.roundClean(), this;
          }
          digestInto(t) {
            Ae.exists(this), Ae.output(t, this), (this.finished = !0);
            const { buffer: e, view: n, blockLen: r, isLE: s } = this;
            let { pos: i } = this;
            (e[i++] = 128),
              this.buffer.subarray(i).fill(0),
              this.padOffset > r - i && (this.process(n, 0), (i = 0));
            for (let t = i; t < r; t++) e[t] = 0;
            !(function (t, e, n, r) {
              if ("function" == typeof t.setBigUint64)
                return t.setBigUint64(e, n, r);
              const s = BigInt(32),
                i = BigInt(4294967295),
                a = Number((n >> s) & i),
                o = Number(n & i),
                c = r ? 4 : 0,
                l = r ? 0 : 4;
              t.setUint32(e + c, a, r), t.setUint32(e + l, o, r);
            })(n, r - 8, BigInt(8 * this.length), s),
              this.process(n, 0);
            const a = be(t);
            this.get().forEach((t, e) => a.setUint32(4 * e, t, s));
          }
          digest() {
            const { buffer: t, outputLen: e } = this;
            this.digestInto(t);
            const n = t.slice(0, e);
            return this.destroy(), n;
          }
          _cloneInto(t) {
            t || (t = new this.constructor()), t.set(...this.get());
            const {
              blockLen: e,
              buffer: n,
              length: r,
              finished: s,
              destroyed: i,
              pos: a,
            } = this;
            return (
              (t.length = r),
              (t.pos = a),
              (t.finished = s),
              (t.destroyed = i),
              r % e && t.buffer.set(n),
              t
            );
          }
        }
        const Ie = (t, e, n) => (t & e) ^ (~t & n),
          Be = (t, e, n) => (t & e) ^ (t & n) ^ (e & n),
          Te = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          Oe = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          Se = new Uint32Array(64);
        class Re extends Ne {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | Oe[0]),
              (this.B = 0 | Oe[1]),
              (this.C = 0 | Oe[2]),
              (this.D = 0 | Oe[3]),
              (this.E = 0 | Oe[4]),
              (this.F = 0 | Oe[5]),
              (this.G = 0 | Oe[6]),
              (this.H = 0 | Oe[7]);
          }
          get() {
            const { A: t, B: e, C: n, D: r, E: s, F: i, G: a, H: o } = this;
            return [t, e, n, r, s, i, a, o];
          }
          set(t, e, n, r, s, i, a, o) {
            (this.A = 0 | t),
              (this.B = 0 | e),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | s),
              (this.F = 0 | i),
              (this.G = 0 | a),
              (this.H = 0 | o);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4) Se[n] = t.getUint32(e, !1);
            for (let t = 16; t < 64; t++) {
              const e = Se[t - 15],
                n = Se[t - 2],
                r = ve(e, 7) ^ ve(e, 18) ^ (e >>> 3),
                s = ve(n, 17) ^ ve(n, 19) ^ (n >>> 10);
              Se[t] = (s + Se[t - 7] + r + Se[t - 16]) | 0;
            }
            let { A: n, B: r, C: s, D: i, E: a, F: o, G: c, H: l } = this;
            for (let t = 0; t < 64; t++) {
              const e =
                  (l +
                    (ve(a, 6) ^ ve(a, 11) ^ ve(a, 25)) +
                    Ie(a, o, c) +
                    Te[t] +
                    Se[t]) |
                  0,
                u = ((ve(n, 2) ^ ve(n, 13) ^ ve(n, 22)) + Be(n, r, s)) | 0;
              (l = c),
                (c = o),
                (o = a),
                (a = (i + e) | 0),
                (i = s),
                (s = r),
                (r = n),
                (n = (e + u) | 0);
            }
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (s = (s + this.C) | 0),
              (i = (i + this.D) | 0),
              (a = (a + this.E) | 0),
              (o = (o + this.F) | 0),
              (c = (c + this.G) | 0),
              (l = (l + this.H) | 0),
              this.set(n, r, s, i, a, o, c, l);
          }
          roundClean() {
            Se.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        const Ue = Pe(() => new Re()),
          Le = BigInt(2 ** 32 - 1),
          Fe = BigInt(32);
        function De(t, e = !1) {
          return e
            ? { h: Number(t & Le), l: Number((t >> Fe) & Le) }
            : { h: 0 | Number((t >> Fe) & Le), l: 0 | Number(t & Le) };
        }
        const Me = {
            fromBig: De,
            split: function (t, e = !1) {
              let n = new Uint32Array(t.length),
                r = new Uint32Array(t.length);
              for (let s = 0; s < t.length; s++) {
                const { h: i, l: a } = De(t[s], e);
                [n[s], r[s]] = [i, a];
              }
              return [n, r];
            },
            toBig: (t, e) => (BigInt(t >>> 0) << Fe) | BigInt(e >>> 0),
            shrSH: (t, e, n) => t >>> n,
            shrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrSH: (t, e, n) => (t >>> n) | (e << (32 - n)),
            rotrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrBH: (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
            rotrBL: (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
            rotr32H: (t, e) => e,
            rotr32L: (t, e) => t,
            rotlSH: (t, e, n) => (t << n) | (e >>> (32 - n)),
            rotlSL: (t, e, n) => (e << n) | (t >>> (32 - n)),
            rotlBH: (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
            rotlBL: (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
            add: function (t, e, n, r) {
              const s = (e >>> 0) + (r >>> 0);
              return { h: (t + n + ((s / 2 ** 32) | 0)) | 0, l: 0 | s };
            },
            add3L: (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
            add3H: (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
            add4L: (t, e, n, r) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
            add4H: (t, e, n, r, s) => (e + n + r + s + ((t / 2 ** 32) | 0)) | 0,
            add5H: (t, e, n, r, s, i) =>
              (e + n + r + s + i + ((t / 2 ** 32) | 0)) | 0,
            add5L: (t, e, n, r, s) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0),
          },
          [Ge, He] = Me.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((t) => BigInt(t))
          ),
          je = new Uint32Array(80),
          Qe = new Uint32Array(80);
        class Ve extends Ne {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: t,
              Al: e,
              Bh: n,
              Bl: r,
              Ch: s,
              Cl: i,
              Dh: a,
              Dl: o,
              Eh: c,
              El: l,
              Fh: u,
              Fl: h,
              Gh: f,
              Gl: d,
              Hh: p,
              Hl: g,
            } = this;
            return [t, e, n, r, s, i, a, o, c, l, u, h, f, d, p, g];
          }
          set(t, e, n, r, s, i, a, o, c, l, u, h, f, d, p, g) {
            (this.Ah = 0 | t),
              (this.Al = 0 | e),
              (this.Bh = 0 | n),
              (this.Bl = 0 | r),
              (this.Ch = 0 | s),
              (this.Cl = 0 | i),
              (this.Dh = 0 | a),
              (this.Dl = 0 | o),
              (this.Eh = 0 | c),
              (this.El = 0 | l),
              (this.Fh = 0 | u),
              (this.Fl = 0 | h),
              (this.Gh = 0 | f),
              (this.Gl = 0 | d),
              (this.Hh = 0 | p),
              (this.Hl = 0 | g);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4)
              (je[n] = t.getUint32(e)), (Qe[n] = t.getUint32((e += 4)));
            for (let t = 16; t < 80; t++) {
              const e = 0 | je[t - 15],
                n = 0 | Qe[t - 15],
                r = Me.rotrSH(e, n, 1) ^ Me.rotrSH(e, n, 8) ^ Me.shrSH(e, n, 7),
                s = Me.rotrSL(e, n, 1) ^ Me.rotrSL(e, n, 8) ^ Me.shrSL(e, n, 7),
                i = 0 | je[t - 2],
                a = 0 | Qe[t - 2],
                o =
                  Me.rotrSH(i, a, 19) ^ Me.rotrBH(i, a, 61) ^ Me.shrSH(i, a, 6),
                c =
                  Me.rotrSL(i, a, 19) ^ Me.rotrBL(i, a, 61) ^ Me.shrSL(i, a, 6),
                l = Me.add4L(s, c, Qe[t - 7], Qe[t - 16]),
                u = Me.add4H(l, r, o, je[t - 7], je[t - 16]);
              (je[t] = 0 | u), (Qe[t] = 0 | l);
            }
            let {
              Ah: n,
              Al: r,
              Bh: s,
              Bl: i,
              Ch: a,
              Cl: o,
              Dh: c,
              Dl: l,
              Eh: u,
              El: h,
              Fh: f,
              Fl: d,
              Gh: p,
              Gl: g,
              Hh: m,
              Hl: y,
            } = this;
            for (let t = 0; t < 80; t++) {
              const e =
                  Me.rotrSH(u, h, 14) ^
                  Me.rotrSH(u, h, 18) ^
                  Me.rotrBH(u, h, 41),
                w =
                  Me.rotrSL(u, h, 14) ^
                  Me.rotrSL(u, h, 18) ^
                  Me.rotrBL(u, h, 41),
                A = (u & f) ^ (~u & p),
                b = (h & d) ^ (~h & g),
                v = Me.add5L(y, w, b, He[t], Qe[t]),
                E = Me.add5H(v, m, e, A, Ge[t], je[t]),
                x = 0 | v,
                P =
                  Me.rotrSH(n, r, 28) ^
                  Me.rotrBH(n, r, 34) ^
                  Me.rotrBH(n, r, 39),
                k =
                  Me.rotrSL(n, r, 28) ^
                  Me.rotrBL(n, r, 34) ^
                  Me.rotrBL(n, r, 39),
                C = (n & s) ^ (n & a) ^ (s & a),
                N = (r & i) ^ (r & o) ^ (i & o);
              (m = 0 | p),
                (y = 0 | g),
                (p = 0 | f),
                (g = 0 | d),
                (f = 0 | u),
                (d = 0 | h),
                ({ h: u, l: h } = Me.add(0 | c, 0 | l, 0 | E, 0 | x)),
                (c = 0 | a),
                (l = 0 | o),
                (a = 0 | s),
                (o = 0 | i),
                (s = 0 | n),
                (i = 0 | r);
              const I = Me.add3L(x, k, N);
              (n = Me.add3H(I, E, P, C)), (r = 0 | I);
            }
            ({ h: n, l: r } = Me.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
              ({ h: s, l: i } = Me.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | i)),
              ({ h: a, l: o } = Me.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)),
              ({ h: c, l: l } = Me.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
              ({ h: u, l: h } = Me.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | h)),
              ({ h: f, l: d } = Me.add(0 | this.Fh, 0 | this.Fl, 0 | f, 0 | d)),
              ({ h: p, l: g } = Me.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
              ({ h: m, l: y } = Me.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
              this.set(n, r, s, i, a, o, c, l, u, h, f, d, p, g, m, y);
          }
          roundClean() {
            je.fill(0), Qe.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class Je extends Ve {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class ze extends Ve {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        const Ke = Pe(() => new Ve());
        Pe(() => new Je()), Pe(() => new ze());
        const _e = (function () {
          if ("undefined" != typeof self) return self;
          if ("undefined" != typeof window) return window;
          if ("undefined" != typeof global) return global;
          throw new Error("unable to locate global object");
        })();
        _e.crypto || _e.msCrypto;
        let qe = !1;
        const We = function (t, e, n) {
          return (function (t, e) {
            const n = { sha256: Ue, sha512: Ke }[t];
            return (
              _(null != n, "invalid hmac algorithm", "algorithm", t),
              Ce.create(n, e)
            );
          })(t, e)
            .update(n)
            .digest();
        };
        let Ze = We;
        function Ye(t, e, n) {
          const r = X(e, "key"),
            s = X(n, "data");
          return nt(Ze(t, r, s));
        }
        (Ye._ = We),
          (Ye.lock = function () {
            qe = !0;
          }),
          (Ye.register = function (t) {
            if (qe) throw new Error("computeHmac is locked");
            Ze = t;
          }),
          Object.freeze(Ye);
        const [Xe, $e, tn] = [[], [], []],
          en = BigInt(0),
          nn = BigInt(1),
          rn = BigInt(2),
          sn = BigInt(7),
          an = BigInt(256),
          on = BigInt(113);
        for (let t = 0, e = nn, n = 1, r = 0; t < 24; t++) {
          ([n, r] = [r, (2 * n + 3 * r) % 5]),
            Xe.push(2 * (5 * r + n)),
            $e.push((((t + 1) * (t + 2)) / 2) % 64);
          let s = en;
          for (let t = 0; t < 7; t++)
            (e = ((e << nn) ^ ((e >> sn) * on)) % an),
              e & rn && (s ^= nn << ((nn << BigInt(t)) - nn));
          tn.push(s);
        }
        const [cn, ln] = Me.split(tn, !0),
          un = (t, e, n) => (n > 32 ? Me.rotlBH(t, e, n) : Me.rotlSH(t, e, n)),
          hn = (t, e, n) => (n > 32 ? Me.rotlBL(t, e, n) : Me.rotlSL(t, e, n));
        class fn extends xe {
          constructor(t, e, n, r = !1, s = 24) {
            if (
              (super(),
              (this.blockLen = t),
              (this.suffix = e),
              (this.outputLen = n),
              (this.enableXOF = r),
              (this.rounds = s),
              (this.pos = 0),
              (this.posOut = 0),
              (this.finished = !1),
              (this.destroyed = !1),
              Ae.number(n),
              0 >= this.blockLen || this.blockLen >= 200)
            )
              throw new Error("Sha3 supports only keccak-f1600 function");
            var i;
            (this.state = new Uint8Array(200)),
              (this.state32 =
                ((i = this.state),
                new Uint32Array(
                  i.buffer,
                  i.byteOffset,
                  Math.floor(i.byteLength / 4)
                )));
          }
          keccak() {
            !(function (t, e = 24) {
              const n = new Uint32Array(10);
              for (let r = 24 - e; r < 24; r++) {
                for (let e = 0; e < 10; e++)
                  n[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
                for (let e = 0; e < 10; e += 2) {
                  const r = (e + 8) % 10,
                    s = (e + 2) % 10,
                    i = n[s],
                    a = n[s + 1],
                    o = un(i, a, 1) ^ n[r],
                    c = hn(i, a, 1) ^ n[r + 1];
                  for (let n = 0; n < 50; n += 10)
                    (t[e + n] ^= o), (t[e + n + 1] ^= c);
                }
                let e = t[2],
                  s = t[3];
                for (let n = 0; n < 24; n++) {
                  const r = $e[n],
                    i = un(e, s, r),
                    a = hn(e, s, r),
                    o = Xe[n];
                  (e = t[o]), (s = t[o + 1]), (t[o] = i), (t[o + 1] = a);
                }
                for (let e = 0; e < 50; e += 10) {
                  for (let r = 0; r < 10; r++) n[r] = t[e + r];
                  for (let r = 0; r < 10; r++)
                    t[e + r] ^= ~n[(r + 2) % 10] & n[(r + 4) % 10];
                }
                (t[0] ^= cn[r]), (t[1] ^= ln[r]);
              }
              n.fill(0);
            })(this.state32, this.rounds),
              (this.posOut = 0),
              (this.pos = 0);
          }
          update(t) {
            Ae.exists(this);
            const { blockLen: e, state: n } = this,
              r = (t = Ee(t)).length;
            for (let s = 0; s < r; ) {
              const i = Math.min(e - this.pos, r - s);
              for (let e = 0; e < i; e++) n[this.pos++] ^= t[s++];
              this.pos === e && this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            const { state: t, suffix: e, pos: n, blockLen: r } = this;
            (t[n] ^= e),
              0 != (128 & e) && n === r - 1 && this.keccak(),
              (t[r - 1] ^= 128),
              this.keccak();
          }
          writeInto(t) {
            Ae.exists(this, !1), Ae.bytes(t), this.finish();
            const e = this.state,
              { blockLen: n } = this;
            for (let r = 0, s = t.length; r < s; ) {
              this.posOut >= n && this.keccak();
              const i = Math.min(n - this.posOut, s - r);
              t.set(e.subarray(this.posOut, this.posOut + i), r),
                (this.posOut += i),
                (r += i);
            }
            return t;
          }
          xofInto(t) {
            if (!this.enableXOF)
              throw new Error("XOF is not possible for this instance");
            return this.writeInto(t);
          }
          xof(t) {
            return Ae.number(t), this.xofInto(new Uint8Array(t));
          }
          digestInto(t) {
            if ((Ae.output(t, this), this.finished))
              throw new Error("digest() was already called");
            return this.writeInto(t), this.destroy(), t;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            (this.destroyed = !0), this.state.fill(0);
          }
          _cloneInto(t) {
            const {
              blockLen: e,
              suffix: n,
              outputLen: r,
              rounds: s,
              enableXOF: i,
            } = this;
            return (
              t || (t = new fn(e, n, r, i, s)),
              t.state32.set(this.state32),
              (t.pos = this.pos),
              (t.posOut = this.posOut),
              (t.finished = this.finished),
              (t.rounds = s),
              (t.suffix = n),
              (t.outputLen = r),
              (t.enableXOF = i),
              (t.destroyed = this.destroyed),
              t
            );
          }
        }
        const dn = (t, e, n) => Pe(() => new fn(e, t, n));
        dn(6, 144, 28),
          dn(6, 136, 32),
          dn(6, 104, 48),
          dn(6, 72, 64),
          dn(1, 144, 28);
        const pn = dn(1, 136, 32);
        dn(1, 104, 48), dn(1, 72, 64);
        const gn = (t, e, n) =>
          (function (t) {
            const e = (e, n) => t(n).update(Ee(e)).digest(),
              n = t({});
            return (
              (e.outputLen = n.outputLen),
              (e.blockLen = n.blockLen),
              (e.create = (e) => t(e)),
              e
            );
          })((r = {}) => new fn(e, t, void 0 === r.dkLen ? n : r.dkLen, !0));
        gn(31, 168, 16), gn(31, 136, 32);
        let mn = !1;
        const yn = function (t) {
          return pn(t);
        };
        let wn = yn;
        function An(t) {
          const e = X(t, "data");
          return nt(wn(e));
        }
        (An._ = yn),
          (An.lock = function () {
            mn = !0;
          }),
          (An.register = function (t) {
            if (mn) throw new TypeError("keccak256 is locked");
            wn = t;
          }),
          Object.freeze(An);
        var bn = Object.freeze({ __proto__: null, default: {} });
        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
        const vn = BigInt(0),
          En = BigInt(1),
          xn = BigInt(2),
          Pn = BigInt(3),
          kn = BigInt(8),
          Cn = Object.freeze({
            a: vn,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
            ),
            h: En,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          }),
          Nn = (t, e) => (t + e / xn) / e,
          In = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar(t) {
              const { n: e } = Cn,
                n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -En * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                i = n,
                a = BigInt("0x100000000000000000000000000000000"),
                o = Nn(i * t, e),
                c = Nn(-r * t, e);
              let l = nr(t - o * n - c * s, e),
                u = nr(-o * r - c * i, e);
              const h = l > a,
                f = u > a;
              if ((h && (l = e - l), f && (u = e - u), l > a || u > a))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
              return { k1neg: h, k1: l, k2neg: f, k2: u };
            },
          },
          Bn = 32,
          Tn = 32,
          On = Bn + 1,
          Sn = 2 * Bn + 1;
        function Rn(t) {
          const { a: e, b: n } = Cn,
            r = nr(t * t),
            s = nr(r * t);
          return nr(s + e * t + n);
        }
        const Un = Cn.a === vn;
        class Ln extends Error {
          constructor(t) {
            super(t);
          }
        }
        function Fn(t) {
          if (!(t instanceof Dn)) throw new TypeError("JacobianPoint expected");
        }
        class Dn {
          constructor(t, e, n) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          static fromAffine(t) {
            if (!(t instanceof Hn))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(Hn.ZERO) ? Dn.ZERO : new Dn(t.x, t.y, En);
          }
          static toAffineBatch(t) {
            const e = (function (t, e = Cn.P) {
              const n = new Array(t.length),
                r = sr(
                  t.reduce(
                    (t, r, s) => (r === vn ? t : ((n[s] = t), nr(t * r, e))),
                    En
                  ),
                  e
                );
              return (
                t.reduceRight(
                  (t, r, s) =>
                    r === vn ? t : ((n[s] = nr(t * n[s], e)), nr(t * r, e)),
                  r
                ),
                n
              );
            })(t.map((t) => t.z));
            return t.map((t, n) => t.toAffine(e[n]));
          }
          static normalizeZ(t) {
            return Dn.toAffineBatch(t).map(Dn.fromAffine);
          }
          equals(t) {
            Fn(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: a } = t,
              o = nr(r * r),
              c = nr(a * a),
              l = nr(e * c),
              u = nr(s * o),
              h = nr(nr(n * a) * c),
              f = nr(nr(i * r) * o);
            return l === u && h === f;
          }
          negate() {
            return new Dn(this.x, nr(-this.y), this.z);
          }
          double() {
            const { x: t, y: e, z: n } = this,
              r = nr(t * t),
              s = nr(e * e),
              i = nr(s * s),
              a = t + s,
              o = nr(xn * (nr(a * a) - r - i)),
              c = nr(Pn * r),
              l = nr(c * c),
              u = nr(l - xn * o),
              h = nr(c * (o - u) - kn * i),
              f = nr(xn * e * n);
            return new Dn(u, h, f);
          }
          add(t) {
            Fn(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: a } = t;
            if (s === vn || i === vn) return this;
            if (e === vn || n === vn) return t;
            const o = nr(r * r),
              c = nr(a * a),
              l = nr(e * c),
              u = nr(s * o),
              h = nr(nr(n * a) * c),
              f = nr(nr(i * r) * o),
              d = nr(u - l),
              p = nr(f - h);
            if (d === vn) return p === vn ? this.double() : Dn.ZERO;
            const g = nr(d * d),
              m = nr(d * g),
              y = nr(l * g),
              w = nr(p * p - m - xn * y),
              A = nr(p * (y - w) - h * m),
              b = nr(r * a * d);
            return new Dn(w, A, b);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiplyUnsafe(t) {
            const e = Dn.ZERO;
            if ("bigint" == typeof t && t === vn) return e;
            let n = er(t);
            if (n === En) return this;
            if (!Un) {
              let t = e,
                r = this;
              for (; n > vn; )
                n & En && (t = t.add(r)), (r = r.double()), (n >>= En);
              return t;
            }
            let { k1neg: r, k1: s, k2neg: i, k2: a } = In.splitScalar(n),
              o = e,
              c = e,
              l = this;
            for (; s > vn || a > vn; )
              s & En && (o = o.add(l)),
                a & En && (c = c.add(l)),
                (l = l.double()),
                (s >>= En),
                (a >>= En);
            return (
              r && (o = o.negate()),
              i && (c = c.negate()),
              (c = new Dn(nr(c.x * In.beta), c.y, c.z)),
              o.add(c)
            );
          }
          precomputeWindow(t) {
            const e = Un ? 128 / t + 1 : 256 / t + 1,
              n = [];
            let r = this,
              s = r;
            for (let i = 0; i < e; i++) {
              (s = r), n.push(s);
              for (let e = 1; e < 2 ** (t - 1); e++) (s = s.add(r)), n.push(s);
              r = s.double();
            }
            return n;
          }
          wNAF(t, e) {
            !e && this.equals(Dn.BASE) && (e = Hn.BASE);
            const n = (e && e._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = e && Gn.get(e);
            r ||
              ((r = this.precomputeWindow(n)),
              e && 1 !== n && ((r = Dn.normalizeZ(r)), Gn.set(e, r)));
            let s = Dn.ZERO,
              i = Dn.BASE;
            const a = 1 + (Un ? 128 / n : 256 / n),
              o = 2 ** (n - 1),
              c = BigInt(2 ** n - 1),
              l = 2 ** n,
              u = BigInt(n);
            for (let e = 0; e < a; e++) {
              const n = e * o;
              let a = Number(t & c);
              (t >>= u), a > o && ((a -= l), (t += En));
              const h = n,
                f = n + Math.abs(a) - 1,
                d = e % 2 != 0,
                p = a < 0;
              0 === a ? (i = i.add(Mn(d, r[h]))) : (s = s.add(Mn(p, r[f])));
            }
            return { p: s, f: i };
          }
          multiply(t, e) {
            let n,
              r,
              s = er(t);
            if (Un) {
              const { k1neg: t, k1: i, k2neg: a, k2: o } = In.splitScalar(s);
              let { p: c, f: l } = this.wNAF(i, e),
                { p: u, f: h } = this.wNAF(o, e);
              (c = Mn(t, c)),
                (u = Mn(a, u)),
                (u = new Dn(nr(u.x * In.beta), u.y, u.z)),
                (n = c.add(u)),
                (r = l.add(h));
            } else {
              const { p: t, f: i } = this.wNAF(s, e);
              (n = t), (r = i);
            }
            return Dn.normalizeZ([n, r])[0];
          }
          toAffine(t) {
            const { x: e, y: n, z: r } = this,
              s = this.equals(Dn.ZERO);
            null == t && (t = s ? kn : sr(r));
            const i = t,
              a = nr(i * i),
              o = nr(a * i),
              c = nr(e * a),
              l = nr(n * o),
              u = nr(r * i);
            if (s) return Hn.ZERO;
            if (u !== En) throw new Error("invZ was invalid");
            return new Hn(c, l);
          }
        }
        function Mn(t, e) {
          const n = e.negate();
          return t ? n : e;
        }
        (Dn.BASE = new Dn(Cn.Gx, Cn.Gy, En)), (Dn.ZERO = new Dn(vn, En, vn));
        const Gn = new WeakMap();
        class Hn {
          constructor(t, e) {
            (this.x = t), (this.y = e);
          }
          _setWindowSize(t) {
            (this._WINDOW_SIZE = t), Gn.delete(this);
          }
          hasEvenY() {
            return this.y % xn === vn;
          }
          static fromCompressedHex(t) {
            const e = 32 === t.length,
              n = $n(e ? t : t.subarray(1));
            if (!ur(n)) throw new Error("Point is not on curve");
            let r = (function (t) {
              const { P: e } = Cn,
                n = BigInt(6),
                r = BigInt(11),
                s = BigInt(22),
                i = BigInt(23),
                a = BigInt(44),
                o = BigInt(88),
                c = (t * t * t) % e,
                l = (c * c * t) % e,
                u = (rr(l, Pn) * l) % e,
                h = (rr(u, Pn) * l) % e,
                f = (rr(h, xn) * c) % e,
                d = (rr(f, r) * f) % e,
                p = (rr(d, s) * d) % e,
                g = (rr(p, a) * p) % e,
                m = (rr(g, o) * g) % e,
                y = (rr(m, a) * p) % e,
                w = (rr(y, Pn) * l) % e,
                A = (rr(w, i) * d) % e,
                b = (rr(A, n) * c) % e,
                v = rr(b, xn);
              if ((v * v) % e !== t) throw new Error("Cannot find square root");
              return v;
            })(Rn(n));
            const s = (r & En) === En;
            if (e) s && (r = nr(-r));
            else {
              (1 == (1 & t[0])) !== s && (r = nr(-r));
            }
            const i = new Hn(n, r);
            return i.assertValidity(), i;
          }
          static fromUncompressedHex(t) {
            const e = $n(t.subarray(1, Bn + 1)),
              n = $n(t.subarray(Bn + 1, 2 * Bn + 1)),
              r = new Hn(e, n);
            return r.assertValidity(), r;
          }
          static fromHex(t) {
            const e = tr(t),
              n = e.length,
              r = e[0];
            if (n === Bn) return this.fromCompressedHex(e);
            if (n === On && (2 === r || 3 === r))
              return this.fromCompressedHex(e);
            if (n === Sn && 4 === r) return this.fromUncompressedHex(e);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${On} compressed bytes or ${Sn} uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(t) {
            return Hn.BASE.multiply(fr(t));
          }
          static fromSignature(t, e, n) {
            const { r: r, s: s } = (function (t) {
              if (t instanceof Vn) return t.assertValidity(), t;
              try {
                return Vn.fromDER(t);
              } catch (e) {
                return Vn.fromCompact(t);
              }
            })(e);
            if (![0, 1, 2, 3].includes(n))
              throw new Error("Cannot recover: invalid recovery bit");
            const i = ir(tr(t)),
              { n: a } = Cn,
              o = 2 === n || 3 === n ? r + a : r,
              c = sr(o, a),
              l = nr(-i * c, a),
              u = nr(s * c, a),
              h = 1 & n ? "03" : "02",
              f = Hn.fromHex(h + qn(o)),
              d = Hn.BASE.multiplyAndAddUnsafe(f, l, u);
            if (!d)
              throw new Error("Cannot recover signature: point at infinify");
            return d.assertValidity(), d;
          }
          toRawBytes(t = !1) {
            return Xn(this.toHex(t));
          }
          toHex(t = !1) {
            const e = qn(this.x);
            if (t) {
              return `${this.hasEvenY() ? "02" : "03"}${e}`;
            }
            return `04${e}${qn(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const t = "Point is not on elliptic curve",
              { x: e, y: n } = this;
            if (!ur(e) || !ur(n)) throw new Error(t);
            const r = nr(n * n);
            if (nr(r - Rn(e)) !== vn) throw new Error(t);
          }
          equals(t) {
            return this.x === t.x && this.y === t.y;
          }
          negate() {
            return new Hn(this.x, nr(-this.y));
          }
          double() {
            return Dn.fromAffine(this).double().toAffine();
          }
          add(t) {
            return Dn.fromAffine(this).add(Dn.fromAffine(t)).toAffine();
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            return Dn.fromAffine(this).multiply(t, this).toAffine();
          }
          multiplyAndAddUnsafe(t, e, n) {
            const r = Dn.fromAffine(this),
              s =
                e === vn || e === En || this !== Hn.BASE
                  ? r.multiplyUnsafe(e)
                  : r.multiply(e),
              i = Dn.fromAffine(t).multiplyUnsafe(n),
              a = s.add(i);
            return a.equals(Dn.ZERO) ? void 0 : a.toAffine();
          }
        }
        function jn(t) {
          return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t;
        }
        function Qn(t) {
          if (t.length < 2 || 2 !== t[0])
            throw new Error(`Invalid signature integer tag: ${Kn(t)}`);
          const e = t[1],
            n = t.subarray(2, e + 2);
          if (!e || n.length !== e)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: $n(n), left: t.subarray(e + 2) };
        }
        (Hn.BASE = new Hn(Cn.Gx, Cn.Gy)), (Hn.ZERO = new Hn(vn, vn));
        let Vn = class t {
          constructor(t, e) {
            (this.r = t), (this.s = e), this.assertValidity();
          }
          static fromCompact(e) {
            const n = e instanceof Uint8Array,
              r = "Signature.fromCompact";
            if ("string" != typeof e && !n)
              throw new TypeError(`${r}: Expected string or Uint8Array`);
            const s = n ? Kn(e) : e;
            if (128 !== s.length) throw new Error(`${r}: Expected 64-byte hex`);
            return new t(Yn(s.slice(0, 64)), Yn(s.slice(64, 128)));
          }
          static fromDER(e) {
            const n = e instanceof Uint8Array;
            if ("string" != typeof e && !n)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: r, s: s } = (function (t) {
              if (t.length < 2 || 48 != t[0])
                throw new Error(`Invalid signature tag: ${Kn(t)}`);
              if (t[1] !== t.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: e, left: n } = Qn(t.subarray(2)),
                { data: r, left: s } = Qn(n);
              if (s.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${Kn(s)}`
                );
              return { r: e, s: r };
            })(n ? e : Xn(e));
            return new t(r, s);
          }
          static fromHex(t) {
            return this.fromDER(t);
          }
          assertValidity() {
            const { r: t, s: e } = this;
            if (!lr(t))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!lr(e))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const t = Cn.n >> En;
            return this.s > t;
          }
          normalizeS() {
            return this.hasHighS() ? new t(this.r, nr(-this.s, Cn.n)) : this;
          }
          toDERRawBytes() {
            return Xn(this.toDERHex());
          }
          toDERHex() {
            const t = jn(Zn(this.s)),
              e = jn(Zn(this.r)),
              n = t.length / 2,
              r = e.length / 2,
              s = Zn(n),
              i = Zn(r);
            return `30${Zn(r + n + 4)}02${i}${e}02${s}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return Xn(this.toCompactHex());
          }
          toCompactHex() {
            return qn(this.r) + qn(this.s);
          }
        };
        function Jn(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            n = new Uint8Array(e);
          for (let e = 0, r = 0; e < t.length; e++) {
            const s = t[e];
            n.set(s, r), (r += s.length);
          }
          return n;
        }
        const zn = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0")
        );
        function Kn(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let e = "";
          for (let n = 0; n < t.length; n++) e += zn[t[n]];
          return e;
        }
        const _n = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000"
        );
        function qn(t) {
          if ("bigint" != typeof t) throw new Error("Expected bigint");
          if (!(vn <= t && t < _n))
            throw new Error("Expected number 0 <= n < 2^256");
          return t.toString(16).padStart(64, "0");
        }
        function Wn(t) {
          const e = Xn(qn(t));
          if (32 !== e.length) throw new Error("Error: expected 32 bytes");
          return e;
        }
        function Zn(t) {
          const e = t.toString(16);
          return 1 & e.length ? `0${e}` : e;
        }
        function Yn(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof t
            );
          return BigInt(`0x${t}`);
        }
        function Xn(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + t.length
            );
          const e = new Uint8Array(t.length / 2);
          for (let n = 0; n < e.length; n++) {
            const r = 2 * n,
              s = t.slice(r, r + 2),
              i = Number.parseInt(s, 16);
            if (Number.isNaN(i) || i < 0)
              throw new Error("Invalid byte sequence");
            e[n] = i;
          }
          return e;
        }
        function $n(t) {
          return Yn(Kn(t));
        }
        function tr(t) {
          return t instanceof Uint8Array ? Uint8Array.from(t) : Xn(t);
        }
        function er(t) {
          if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
          if ("bigint" == typeof t && lr(t)) return t;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function nr(t, e = Cn.P) {
          const n = t % e;
          return n >= vn ? n : e + n;
        }
        function rr(t, e) {
          const { P: n } = Cn;
          let r = t;
          for (; e-- > vn; ) (r *= r), (r %= n);
          return r;
        }
        function sr(t, e = Cn.P) {
          if (t === vn || e <= vn)
            throw new Error(
              `invert: expected positive integers, got n=${t} mod=${e}`
            );
          let n = nr(t, e),
            r = e,
            s = vn,
            i = En;
          for (; n !== vn; ) {
            const t = r % n,
              e = s - i * (r / n);
            (r = n), (n = t), (s = i), (i = e);
          }
          if (r !== En) throw new Error("invert: does not exist");
          return nr(s, e);
        }
        function ir(t, e = !1) {
          const n = (function (t) {
            const e = 8 * t.length - 8 * Tn,
              n = $n(t);
            return e > 0 ? n >> BigInt(e) : n;
          })(t);
          if (e) return n;
          const { n: r } = Cn;
          return n >= r ? n - r : n;
        }
        let ar, or;
        class cr {
          constructor(t, e) {
            if (
              ((this.hashLen = t),
              (this.qByteLen = e),
              "number" != typeof t || t < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(t).fill(1)),
              (this.k = new Uint8Array(t).fill(0)),
              (this.counter = 0);
          }
          hmac(...t) {
            return vr.hmacSha256(this.k, ...t);
          }
          hmacSync(...t) {
            return or(this.k, ...t);
          }
          checkSync() {
            if ("function" != typeof or)
              throw new Ln("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed(t = new Uint8Array()) {
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), t)),
              (this.v = await this.hmac(this.v)),
              0 !== t.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), t)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync(t = new Uint8Array()) {
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), t)),
              (this.v = this.hmacSync(this.v)),
              0 !== t.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), t)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return Jn(...e);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return Jn(...e);
          }
        }
        function lr(t) {
          return vn < t && t < Cn.n;
        }
        function ur(t) {
          return vn < t && t < Cn.P;
        }
        function hr(t, e, n, r = !0) {
          const { n: s } = Cn,
            i = ir(t, !0);
          if (!lr(i)) return;
          const a = sr(i, s),
            o = Hn.BASE.multiply(i),
            c = nr(o.x, s);
          if (c === vn) return;
          const l = nr(a * nr(e + n * c, s), s);
          if (l === vn) return;
          let u = new Vn(c, l),
            h = (o.x === u.r ? 0 : 2) | Number(o.y & En);
          return (
            r && u.hasHighS() && ((u = u.normalizeS()), (h ^= 1)),
            { sig: u, recovery: h }
          );
        }
        function fr(t) {
          let e;
          if ("bigint" == typeof t) e = t;
          else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
          else if ("string" == typeof t) {
            if (t.length !== 2 * Tn)
              throw new Error("Expected 32 bytes of private key");
            e = Yn(t);
          } else {
            if (!(t instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (t.length !== Tn)
              throw new Error("Expected 32 bytes of private key");
            e = $n(t);
          }
          if (!lr(e)) throw new Error("Expected private key: 0 < key < n");
          return e;
        }
        function dr(t) {
          const e = t instanceof Uint8Array,
            n = "string" == typeof t,
            r = (e || n) && t.length;
          return e
            ? r === On || r === Sn
            : n
            ? r === 2 * On || r === 2 * Sn
            : t instanceof Hn;
        }
        function pr(t, e, n = !1) {
          if (dr(t))
            throw new TypeError(
              "getSharedSecret: first arg must be private key"
            );
          if (!dr(e))
            throw new TypeError(
              "getSharedSecret: second arg must be public key"
            );
          const r =
            (s = e) instanceof Hn ? (s.assertValidity(), s) : Hn.fromHex(s);
          var s;
          return r.assertValidity(), r.multiply(fr(t)).toRawBytes(n);
        }
        function gr(t) {
          return $n(t.length > Bn ? t.slice(0, Bn) : t);
        }
        function mr(t) {
          const e = gr(t),
            n = nr(e, Cn.n);
          return yr(n < vn ? e : n);
        }
        function yr(t) {
          return Wn(t);
        }
        function wr(t, e, n = {}) {
          const {
              seed: r,
              m: s,
              d: i,
            } = (function (t, e, n) {
              if (null == t)
                throw new Error(
                  `sign: expected valid message hash, not "${t}"`
                );
              const r = tr(t),
                s = fr(e),
                i = [yr(s), mr(r)];
              if (null != n) {
                !0 === n && (n = vr.randomBytes(Bn));
                const t = tr(n);
                if (t.length !== Bn)
                  throw new Error(`sign: Expected ${Bn} bytes of extra data`);
                i.push(t);
              }
              return { seed: Jn(...i), m: gr(r), d: s };
            })(t, e, n.extraEntropy),
            a = new cr(32, Tn);
          let o;
          for (
            a.reseedSync(r);
            !(o = hr(a.generateSync(), s, i, n.canonical));

          )
            a.reseedSync();
          return (function (t, e) {
            const { sig: n, recovery: r } = t,
              { der: s, recovered: i } = Object.assign(
                { canonical: !0, der: !0 },
                e
              ),
              a = s ? n.toDERRawBytes() : n.toCompactRawBytes();
            return i ? [a, r] : a;
          })(o, n);
        }
        Hn.BASE._setWindowSize(8);
        const Ar = {
            node: bn,
            web:
              "object" == typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          br = {},
          vr = {
            bytesToHex: Kn,
            hexToBytes: Xn,
            concatBytes: Jn,
            mod: nr,
            invert: sr,
            isValidPrivateKey(t) {
              try {
                return fr(t), !0;
              } catch (t) {
                return !1;
              }
            },
            _bigintTo32Bytes: Wn,
            _normalizePrivateKey: fr,
            hashToPrivateKey: (t) => {
              t = tr(t);
              const e = Tn + 8;
              if (t.length < e || t.length > 1024)
                throw new Error(
                  "Expected valid bytes of private key as per FIPS 186"
                );
              return Wn(nr($n(t), Cn.n - En) + En);
            },
            randomBytes: (t = 32) => {
              if (Ar.web) return Ar.web.getRandomValues(new Uint8Array(t));
              if (Ar.node) {
                const { randomBytes: e } = Ar.node;
                return Uint8Array.from(e(t));
              }
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            },
            randomPrivateKey: () => vr.hashToPrivateKey(vr.randomBytes(Tn + 8)),
            precompute(t = 8, e = Hn.BASE) {
              const n = e === Hn.BASE ? e : new Hn(e.x, e.y);
              return n._setWindowSize(t), n.multiply(Pn), n;
            },
            sha256: async (...t) => {
              if (Ar.web) {
                const e = await Ar.web.subtle.digest("SHA-256", Jn(...t));
                return new Uint8Array(e);
              }
              if (Ar.node) {
                const { createHash: e } = Ar.node,
                  n = e("sha256");
                return (
                  t.forEach((t) => n.update(t)), Uint8Array.from(n.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async (t, ...e) => {
              if (Ar.web) {
                const n = await Ar.web.subtle.importKey(
                    "raw",
                    t,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"]
                  ),
                  r = Jn(...e),
                  s = await Ar.web.subtle.sign("HMAC", n, r);
                return new Uint8Array(s);
              }
              if (Ar.node) {
                const { createHmac: n } = Ar.node,
                  r = n("sha256", t);
                return (
                  e.forEach((t) => r.update(t)), Uint8Array.from(r.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async (t, ...e) => {
              let n = br[t];
              if (void 0 === n) {
                const e = await vr.sha256(
                  Uint8Array.from(t, (t) => t.charCodeAt(0))
                );
                (n = Jn(e, e)), (br[t] = n);
              }
              return vr.sha256(n, ...e);
            },
            taggedHashSync: (t, ...e) => {
              if ("function" != typeof ar)
                throw new Ln("sha256Sync is undefined, you need to set it");
              let n = br[t];
              if (void 0 === n) {
                const e = ar(Uint8Array.from(t, (t) => t.charCodeAt(0)));
                (n = Jn(e, e)), (br[t] = n);
              }
              return ar(n, ...e);
            },
            _JacobianPoint: Dn,
          };
        Object.defineProperties(vr, {
          sha256Sync: {
            configurable: !1,
            get: () => ar,
            set(t) {
              ar || (ar = t);
            },
          },
          hmacSha256Sync: {
            configurable: !1,
            get: () => or,
            set(t) {
              or || (or = t);
            },
          },
        });
        const Er = "0x0000000000000000000000000000000000000000",
          xr =
            "0x0000000000000000000000000000000000000000000000000000000000000000",
          Pr = BigInt(0),
          kr = BigInt(1),
          Cr = BigInt(2),
          Nr = BigInt(27),
          Ir = BigInt(28),
          Br = BigInt(35),
          Tr = {};
        function Or(t) {
          return at(At(t), 32);
        }
        class Sr {
          #D;
          #M;
          #G;
          #H;
          get r() {
            return this.#D;
          }
          set r(t) {
            _(32 === st(t), "invalid r", "value", t), (this.#D = nt(t));
          }
          get s() {
            return this.#M;
          }
          set s(t) {
            _(32 === st(t), "invalid s", "value", t);
            const e = nt(t);
            _(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e),
              (this.#M = e);
          }
          get v() {
            return this.#G;
          }
          set v(t) {
            const e = yt(t, "value");
            _(27 === e || 28 === e, "invalid v", "v", t), (this.#G = e);
          }
          get networkV() {
            return this.#H;
          }
          get legacyChainId() {
            const t = this.networkV;
            return null == t ? null : Sr.getChainId(t);
          }
          get yParity() {
            return 27 === this.v ? 0 : 1;
          }
          get yParityAndS() {
            const t = X(this.s);
            return this.yParity && (t[0] |= 128), nt(t);
          }
          get compactSerialized() {
            return rt([this.r, this.yParityAndS]);
          }
          get serialized() {
            return rt([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
          }
          constructor(t, e, n, r) {
            Z(t, Tr, "Signature"),
              (this.#D = e),
              (this.#M = n),
              (this.#G = r),
              (this.#H = null);
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
          }
          clone() {
            const t = new Sr(Tr, this.r, this.s, this.v);
            return this.networkV && (t.#H = this.networkV), t;
          }
          toJSON() {
            const t = this.networkV;
            return {
              _type: "signature",
              networkV: null != t ? t.toString() : null,
              r: this.r,
              s: this.s,
              v: this.v,
            };
          }
          static getChainId(t) {
            const e = dt(t, "v");
            return e == Nr || e == Ir
              ? Pr
              : (_(e >= Br, "invalid EIP-155 v", "v", t), (e - Br) / Cr);
          }
          static getChainIdV(t, e) {
            return dt(t) * Cr + BigInt(35 + e - 27);
          }
          static getNormalizedV(t) {
            const e = dt(t);
            return e === Pr || e === Nr
              ? 27
              : e === kr || e === Ir
              ? 28
              : (_(e >= Br, "invalid v", "v", t), e & kr ? 27 : 28);
          }
          static from(t) {
            function e(e, n) {
              _(e, n, "signature", t);
            }
            if (null == t) return new Sr(Tr, xr, xr, 27);
            if ("string" == typeof t) {
              const n = X(t, "signature");
              if (64 === n.length) {
                const t = nt(n.slice(0, 32)),
                  e = n.slice(32, 64),
                  r = 128 & e[0] ? 28 : 27;
                return (e[0] &= 127), new Sr(Tr, t, nt(e), r);
              }
              if (65 === n.length) {
                const t = nt(n.slice(0, 32)),
                  r = n.slice(32, 64);
                e(0 == (128 & r[0]), "non-canonical s");
                const s = Sr.getNormalizedV(n[64]);
                return new Sr(Tr, t, nt(r), s);
              }
              e(!1, "invalid raw signature length");
            }
            if (t instanceof Sr) return t.clone();
            const n = t.r;
            e(null != n, "missing r");
            const r = Or(n),
              s = (function (t, n) {
                if (null != t) return Or(t);
                if (null != n) {
                  e(tt(n, 32), "invalid yParityAndS");
                  const t = X(n);
                  return (t[0] &= 127), nt(t);
                }
                e(!1, "missing s");
              })(t.s, t.yParityAndS);
            e(0 == (128 & X(s)[0]), "non-canonical s");
            const { networkV: i, v: a } = (function (t, n, r) {
                if (null != t) {
                  const e = dt(t);
                  return {
                    networkV: e >= Br ? e : void 0,
                    v: Sr.getNormalizedV(e),
                  };
                }
                if (null != n)
                  return (
                    e(tt(n, 32), "invalid yParityAndS"),
                    { v: 128 & X(n)[0] ? 28 : 27 }
                  );
                if (null != r) {
                  switch (yt(r, "sig.yParity")) {
                    case 0:
                      return { v: 27 };
                    case 1:
                      return { v: 28 };
                  }
                  e(!1, "invalid yParity");
                }
                e(!1, "missing v");
              })(t.v, t.yParityAndS, t.yParity),
              o = new Sr(Tr, r, s, a);
            return (
              i && (o.#H = i),
              e(
                null == t.yParity || yt(t.yParity, "sig.yParity") === o.yParity,
                "yParity mismatch"
              ),
              e(
                null == t.yParityAndS || t.yParityAndS === o.yParityAndS,
                "yParityAndS mismatch"
              ),
              o
            );
          }
        }
        vr.hmacSha256Sync = function (t, ...e) {
          return X(Ye("sha256", t, rt(e)));
        };
        class Rr {
          #j;
          constructor(t) {
            _(32 === st(t), "invalid private key", "privateKey", "[REDACTED]"),
              (this.#j = nt(t));
          }
          get privateKey() {
            return this.#j;
          }
          get publicKey() {
            return Rr.computePublicKey(this.#j);
          }
          get compressedPublicKey() {
            return Rr.computePublicKey(this.#j, !0);
          }
          sign(t) {
            _(32 === st(t), "invalid digest length", "digest", t);
            const [e, n] = wr($(t), $(this.#j), {
                recovered: !0,
                canonical: !0,
              }),
              r = Vn.fromHex(e);
            return Sr.from({
              r: wt("0x" + r.r.toString(16), 32),
              s: wt("0x" + r.s.toString(16), 32),
              v: n ? 28 : 27,
            });
          }
          computeSharedSecret(t) {
            const e = Rr.computePublicKey(t);
            return nt(pr($(this.#j), X(e)));
          }
          static computePublicKey(t, e) {
            let n = X(t, "key");
            if (32 === n.length) {
              return nt(
                (function (t, e = !1) {
                  return Hn.fromPrivateKey(t).toRawBytes(e);
                })(n, !!e)
              );
            }
            if (64 === n.length) {
              const t = new Uint8Array(65);
              (t[0] = 4), t.set(n, 1), (n = t);
            }
            return nt(Hn.fromHex(n).toRawBytes(e));
          }
          static recoverPublicKey(t, e) {
            _(32 === st(t), "invalid digest length", "digest", t);
            const n = Sr.from(e),
              r = Vn.fromCompact($(rt([n.r, n.s]))).toDERRawBytes(),
              s = (function (t, e, n, r = !1) {
                return Hn.fromSignature(t, e, n).toRawBytes(r);
              })($(t), r, n.yParity);
            return (
              _(null != s, "invalid signautre for digest", "signature", e),
              nt(s)
            );
          }
          static addPoints(t, e, n) {
            const r = Hn.fromHex(Rr.computePublicKey(t).substring(2)),
              s = Hn.fromHex(Rr.computePublicKey(e).substring(2));
            return "0x" + r.add(s).toHex(!!n);
          }
        }
        const Ur = BigInt(0),
          Lr = BigInt(36);
        function Fr(t) {
          const e = (t = t.toLowerCase()).substring(2).split(""),
            n = new Uint8Array(40);
          for (let t = 0; t < 40; t++) n[t] = e[t].charCodeAt(0);
          const r = X(An(n));
          for (let t = 0; t < 40; t += 2)
            r[t >> 1] >> 4 >= 8 && (e[t] = e[t].toUpperCase()),
              (15 & r[t >> 1]) >= 8 && (e[t + 1] = e[t + 1].toUpperCase());
          return "0x" + e.join("");
        }
        const Dr = {};
        for (let t = 0; t < 10; t++) Dr[String(t)] = String(t);
        for (let t = 0; t < 26; t++)
          Dr[String.fromCharCode(65 + t)] = String(10 + t);
        const Mr = 15;
        const Gr = (function () {
          const t = {};
          for (let e = 0; e < 36; e++) {
            t["0123456789abcdefghijklmnopqrstuvwxyz"[e]] = BigInt(e);
          }
          return t;
        })();
        function Hr(t) {
          if (
            (_("string" == typeof t, "invalid address", "address", t),
            t.match(/^(0x)?[0-9a-fA-F]{40}$/))
          ) {
            t.startsWith("0x") || (t = "0x" + t);
            const e = Fr(t);
            return (
              _(
                !t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t,
                "bad address checksum",
                "address",
                t
              ),
              e
            );
          }
          if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            _(
              t.substring(2, 4) ===
                (function (t) {
                  let e = (t =
                    (t = t.toUpperCase()).substring(4) +
                    t.substring(0, 2) +
                    "00")
                    .split("")
                    .map((t) => Dr[t])
                    .join("");
                  for (; e.length >= Mr; ) {
                    let t = e.substring(0, Mr);
                    e = (parseInt(t, 10) % 97) + e.substring(t.length);
                  }
                  let n = String(98 - (parseInt(e, 10) % 97));
                  for (; n.length < 2; ) n = "0" + n;
                  return n;
                })(t),
              "bad icap checksum",
              "address",
              t
            );
            let e = (function (t) {
              t = t.toLowerCase();
              let e = Ur;
              for (let n = 0; n < t.length; n++) e = e * Lr + Gr[t[n]];
              return e;
            })(t.substring(4)).toString(16);
            for (; e.length < 40; ) e = "0" + e;
            return Fr("0x" + e);
          }
          _(!1, "invalid address", "address", t);
        }
        function jr(t) {
          return t && "function" == typeof t.getAddress;
        }
        async function Qr(t, e) {
          const n = await e;
          return (
            (null != n && "0x0000000000000000000000000000000000000000" !== n) ||
              (K(
                "string" != typeof t,
                "unconfigured name",
                "UNCONFIGURED_NAME",
                { value: t }
              ),
              _(
                !1,
                "invalid AddressLike value; did not resolve to a value address",
                "target",
                t
              )),
            Hr(n)
          );
        }
        function Vr(t, e) {
          return "string" == typeof t
            ? t.match(/^0x[0-9a-f]{40}$/i)
              ? Hr(t)
              : (K(
                  null != e,
                  "ENS resolution requires a provider",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName" }
                ),
                Qr(t, e.resolveName(t)))
            : jr(t)
            ? Qr(t, t.getAddress())
            : t && "function" == typeof t.then
            ? Qr(t, t)
            : void _(!1, "unsupported addressable value", "target", t);
        }
        const Jr = {};
        function zr(t, e) {
          let n = !1;
          return (
            e < 0 && ((n = !0), (e *= -1)),
            new qr(Jr, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e })
          );
        }
        function Kr(t, e) {
          return new qr(Jr, `bytes${e || ""}`, t, { size: e });
        }
        const _r = Symbol.for("_ethers_typed");
        class qr {
          type;
          value;
          #Q;
          _typedSymbol;
          constructor(t, e, n, r) {
            null == r && (r = null),
              Z(Jr, t, "Typed"),
              j(this, { _typedSymbol: _r, type: e, value: n }),
              (this.#Q = r),
              this.format();
          }
          format() {
            if ("array" === this.type) throw new Error("");
            if ("dynamicArray" === this.type) throw new Error("");
            return "tuple" === this.type
              ? `tuple(${this.value.map((t) => t.format()).join(",")})`
              : this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return "string" === this.type;
          }
          get tupleName() {
            if ("tuple" !== this.type) throw TypeError("not a tuple");
            return this.#Q;
          }
          get arrayLength() {
            if ("array" !== this.type) throw TypeError("not an array");
            return !0 === this.#Q
              ? -1
              : !1 === this.#Q
              ? this.value.length
              : null;
          }
          static from(t, e) {
            return new qr(Jr, t, e);
          }
          static uint8(t) {
            return zr(t, 8);
          }
          static uint16(t) {
            return zr(t, 16);
          }
          static uint24(t) {
            return zr(t, 24);
          }
          static uint32(t) {
            return zr(t, 32);
          }
          static uint40(t) {
            return zr(t, 40);
          }
          static uint48(t) {
            return zr(t, 48);
          }
          static uint56(t) {
            return zr(t, 56);
          }
          static uint64(t) {
            return zr(t, 64);
          }
          static uint72(t) {
            return zr(t, 72);
          }
          static uint80(t) {
            return zr(t, 80);
          }
          static uint88(t) {
            return zr(t, 88);
          }
          static uint96(t) {
            return zr(t, 96);
          }
          static uint104(t) {
            return zr(t, 104);
          }
          static uint112(t) {
            return zr(t, 112);
          }
          static uint120(t) {
            return zr(t, 120);
          }
          static uint128(t) {
            return zr(t, 128);
          }
          static uint136(t) {
            return zr(t, 136);
          }
          static uint144(t) {
            return zr(t, 144);
          }
          static uint152(t) {
            return zr(t, 152);
          }
          static uint160(t) {
            return zr(t, 160);
          }
          static uint168(t) {
            return zr(t, 168);
          }
          static uint176(t) {
            return zr(t, 176);
          }
          static uint184(t) {
            return zr(t, 184);
          }
          static uint192(t) {
            return zr(t, 192);
          }
          static uint200(t) {
            return zr(t, 200);
          }
          static uint208(t) {
            return zr(t, 208);
          }
          static uint216(t) {
            return zr(t, 216);
          }
          static uint224(t) {
            return zr(t, 224);
          }
          static uint232(t) {
            return zr(t, 232);
          }
          static uint240(t) {
            return zr(t, 240);
          }
          static uint248(t) {
            return zr(t, 248);
          }
          static uint256(t) {
            return zr(t, 256);
          }
          static uint(t) {
            return zr(t, 256);
          }
          static int8(t) {
            return zr(t, -8);
          }
          static int16(t) {
            return zr(t, -16);
          }
          static int24(t) {
            return zr(t, -24);
          }
          static int32(t) {
            return zr(t, -32);
          }
          static int40(t) {
            return zr(t, -40);
          }
          static int48(t) {
            return zr(t, -48);
          }
          static int56(t) {
            return zr(t, -56);
          }
          static int64(t) {
            return zr(t, -64);
          }
          static int72(t) {
            return zr(t, -72);
          }
          static int80(t) {
            return zr(t, -80);
          }
          static int88(t) {
            return zr(t, -88);
          }
          static int96(t) {
            return zr(t, -96);
          }
          static int104(t) {
            return zr(t, -104);
          }
          static int112(t) {
            return zr(t, -112);
          }
          static int120(t) {
            return zr(t, -120);
          }
          static int128(t) {
            return zr(t, -128);
          }
          static int136(t) {
            return zr(t, -136);
          }
          static int144(t) {
            return zr(t, -144);
          }
          static int152(t) {
            return zr(t, -152);
          }
          static int160(t) {
            return zr(t, -160);
          }
          static int168(t) {
            return zr(t, -168);
          }
          static int176(t) {
            return zr(t, -176);
          }
          static int184(t) {
            return zr(t, -184);
          }
          static int192(t) {
            return zr(t, -192);
          }
          static int200(t) {
            return zr(t, -200);
          }
          static int208(t) {
            return zr(t, -208);
          }
          static int216(t) {
            return zr(t, -216);
          }
          static int224(t) {
            return zr(t, -224);
          }
          static int232(t) {
            return zr(t, -232);
          }
          static int240(t) {
            return zr(t, -240);
          }
          static int248(t) {
            return zr(t, -248);
          }
          static int256(t) {
            return zr(t, -256);
          }
          static int(t) {
            return zr(t, -256);
          }
          static bytes1(t) {
            return Kr(t, 1);
          }
          static bytes2(t) {
            return Kr(t, 2);
          }
          static bytes3(t) {
            return Kr(t, 3);
          }
          static bytes4(t) {
            return Kr(t, 4);
          }
          static bytes5(t) {
            return Kr(t, 5);
          }
          static bytes6(t) {
            return Kr(t, 6);
          }
          static bytes7(t) {
            return Kr(t, 7);
          }
          static bytes8(t) {
            return Kr(t, 8);
          }
          static bytes9(t) {
            return Kr(t, 9);
          }
          static bytes10(t) {
            return Kr(t, 10);
          }
          static bytes11(t) {
            return Kr(t, 11);
          }
          static bytes12(t) {
            return Kr(t, 12);
          }
          static bytes13(t) {
            return Kr(t, 13);
          }
          static bytes14(t) {
            return Kr(t, 14);
          }
          static bytes15(t) {
            return Kr(t, 15);
          }
          static bytes16(t) {
            return Kr(t, 16);
          }
          static bytes17(t) {
            return Kr(t, 17);
          }
          static bytes18(t) {
            return Kr(t, 18);
          }
          static bytes19(t) {
            return Kr(t, 19);
          }
          static bytes20(t) {
            return Kr(t, 20);
          }
          static bytes21(t) {
            return Kr(t, 21);
          }
          static bytes22(t) {
            return Kr(t, 22);
          }
          static bytes23(t) {
            return Kr(t, 23);
          }
          static bytes24(t) {
            return Kr(t, 24);
          }
          static bytes25(t) {
            return Kr(t, 25);
          }
          static bytes26(t) {
            return Kr(t, 26);
          }
          static bytes27(t) {
            return Kr(t, 27);
          }
          static bytes28(t) {
            return Kr(t, 28);
          }
          static bytes29(t) {
            return Kr(t, 29);
          }
          static bytes30(t) {
            return Kr(t, 30);
          }
          static bytes31(t) {
            return Kr(t, 31);
          }
          static bytes32(t) {
            return Kr(t, 32);
          }
          static address(t) {
            return new qr(Jr, "address", t);
          }
          static bool(t) {
            return new qr(Jr, "bool", !!t);
          }
          static bytes(t) {
            return new qr(Jr, "bytes", t);
          }
          static string(t) {
            return new qr(Jr, "string", t);
          }
          static array(t, e) {
            throw new Error("not implemented yet");
          }
          static tuple(t, e) {
            throw new Error("not implemented yet");
          }
          static overrides(t) {
            return new qr(Jr, "overrides", Object.assign({}, t));
          }
          static isTyped(t) {
            return (
              t &&
              "object" == typeof t &&
              "_typedSymbol" in t &&
              t._typedSymbol === _r
            );
          }
          static dereference(t, e) {
            if (qr.isTyped(t)) {
              if (t.type !== e)
                throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
              return t.value;
            }
            return t;
          }
        }
        class Wr extends pe {
          constructor(t) {
            super("address", "address", t, !1);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(t, e) {
            let n = qr.dereference(e, "string");
            try {
              n = Hr(n);
            } catch (t) {
              return this._throwError(t.message, e);
            }
            return t.writeValue(n);
          }
          decode(t) {
            return Hr(wt(t.readValue(), 20));
          }
        }
        class Zr extends pe {
          coder;
          constructor(t) {
            super(t.name, t.type, "_", t.dynamic), (this.coder = t);
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(t, e) {
            return this.coder.encode(t, e);
          }
          decode(t) {
            return this.coder.decode(t);
          }
        }
        function Yr(t, e, n) {
          let r = [];
          if (Array.isArray(n)) r = n;
          else if (n && "object" == typeof n) {
            let t = {};
            r = e.map((e) => {
              const r = e.localName;
              return (
                K(
                  r,
                  "cannot encode object for signature with missing names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                K(
                  !t[r],
                  "cannot encode object for signature with duplicate names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                (t[r] = !0),
                n[r]
              );
            });
          } else _(!1, "invalid tuple value", "tuple", n);
          _(e.length === r.length, "types/value length mismatch", "tuple", n);
          let s = new ge(),
            i = new ge(),
            a = [];
          e.forEach((t, e) => {
            let n = r[e];
            if (t.dynamic) {
              let e = i.length;
              t.encode(i, n);
              let r = s.writeUpdatableValue();
              a.push((t) => {
                r(t + e);
              });
            } else t.encode(s, n);
          }),
            a.forEach((t) => {
              t(s.length);
            });
          let o = t.appendWriter(s);
          return (o += t.appendWriter(i)), o;
        }
        function Xr(t, e) {
          let n = [],
            r = [],
            s = t.subReader(0);
          return (
            e.forEach((e) => {
              let i = null;
              if (e.dynamic) {
                let n = t.readIndex(),
                  r = s.subReader(n);
                try {
                  i = e.decode(r);
                } catch (t) {
                  if (V(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              } else
                try {
                  i = e.decode(t);
                } catch (t) {
                  if (V(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              if (null == i) throw new Error("investigate");
              n.push(i), r.push(e.localName || null);
            }),
            fe.fromItems(n, r)
          );
        }
        class $r extends pe {
          coder;
          length;
          constructor(t, e, n) {
            super(
              "array",
              t.type + "[" + (e >= 0 ? e : "") + "]",
              n,
              -1 === e || t.dynamic
            ),
              j(this, { coder: t, length: e });
          }
          defaultValue() {
            const t = this.coder.defaultValue(),
              e = [];
            for (let n = 0; n < this.length; n++) e.push(t);
            return e;
          }
          encode(t, e) {
            const n = qr.dereference(e, "array");
            Array.isArray(n) || this._throwError("expected array value", n);
            let r = this.length;
            -1 === r && ((r = n.length), t.writeValue(n.length)),
              q(
                n.length,
                r,
                "coder array" + (this.localName ? " " + this.localName : "")
              );
            let s = [];
            for (let t = 0; t < n.length; t++) s.push(this.coder);
            return Yr(t, s, n);
          }
          decode(t) {
            let e = this.length;
            -1 === e &&
              ((e = t.readIndex()),
              K(
                e * oe <= t.dataLength,
                "insufficient data length",
                "BUFFER_OVERRUN",
                { buffer: t.bytes, offset: e * oe, length: t.dataLength }
              ));
            let n = [];
            for (let t = 0; t < e; t++) n.push(new Zr(this.coder));
            return Xr(t, n);
          }
        }
        class ts extends pe {
          constructor(t) {
            super("bool", "bool", t, !1);
          }
          defaultValue() {
            return !1;
          }
          encode(t, e) {
            const n = qr.dereference(e, "bool");
            return t.writeValue(n ? 1 : 0);
          }
          decode(t) {
            return !!t.readValue();
          }
        }
        class es extends pe {
          constructor(t, e) {
            super(t, t, e, !0);
          }
          defaultValue() {
            return "0x";
          }
          encode(t, e) {
            e = $(e);
            let n = t.writeValue(e.length);
            return (n += t.writeBytes(e)), n;
          }
          decode(t) {
            return t.readBytes(t.readIndex(), !0);
          }
        }
        class ns extends es {
          constructor(t) {
            super("bytes", t);
          }
          decode(t) {
            return nt(super.decode(t));
          }
        }
        class rs extends pe {
          size;
          constructor(t, e) {
            let n = "bytes" + String(t);
            super(n, n, e, !1), j(this, { size: t }, { size: "number" });
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + 2 * this.size
            );
          }
          encode(t, e) {
            let n = $(qr.dereference(e, this.type));
            return (
              n.length !== this.size &&
                this._throwError("incorrect data length", e),
              t.writeBytes(n)
            );
          }
          decode(t) {
            return nt(t.readBytes(this.size));
          }
        }
        const ss = new Uint8Array([]);
        class is extends pe {
          constructor(t) {
            super("null", "", t, !1);
          }
          defaultValue() {
            return null;
          }
          encode(t, e) {
            return (
              null != e && this._throwError("not null", e), t.writeBytes(ss)
            );
          }
          decode(t) {
            return t.readBytes(0), null;
          }
        }
        const as = BigInt(0),
          os = BigInt(1),
          cs = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        class ls extends pe {
          size;
          signed;
          constructor(t, e, n) {
            const r = (e ? "int" : "uint") + 8 * t;
            super(r, r, n, !1),
              j(
                this,
                { size: t, signed: e },
                { size: "number", signed: "boolean" }
              );
          }
          defaultValue() {
            return 0;
          }
          encode(t, e) {
            let n = dt(qr.dereference(e, this.type)),
              r = ft(cs, 256);
            if (this.signed) {
              let t = ft(r, 8 * this.size - 1);
              (n > t || n < -(t + os)) &&
                this._throwError("value out-of-bounds", e),
                (n = ht(n, 256));
            } else
              (n < as || n > ft(r, 8 * this.size)) &&
                this._throwError("value out-of-bounds", e);
            return t.writeValue(n);
          }
          decode(t) {
            let e = ft(t.readValue(), 8 * this.size);
            return this.signed && (e = ut(e, 8 * this.size)), e;
          }
        }
        class us extends es {
          constructor(t) {
            super("string", t);
          }
          defaultValue() {
            return "";
          }
          encode(t, e) {
            return super.encode(t, kt(qr.dereference(e, "string")));
          }
          decode(t) {
            return Ct(super.decode(t));
          }
        }
        class hs extends pe {
          coders;
          constructor(t, e) {
            let n = !1;
            const r = [];
            t.forEach((t) => {
              t.dynamic && (n = !0), r.push(t.type);
            });
            super("tuple", "tuple(" + r.join(",") + ")", e, n),
              j(this, { coders: Object.freeze(t.slice()) });
          }
          defaultValue() {
            const t = [];
            this.coders.forEach((e) => {
              t.push(e.defaultValue());
            });
            const e = this.coders.reduce((t, e) => {
              const n = e.localName;
              return n && (t[n] || (t[n] = 0), t[n]++), t;
            }, {});
            return (
              this.coders.forEach((n, r) => {
                let s = n.localName;
                s &&
                  1 === e[s] &&
                  ("length" === s && (s = "_length"),
                  null == t[s] && (t[s] = t[r]));
              }),
              Object.freeze(t)
            );
          }
          encode(t, e) {
            const n = qr.dereference(e, "tuple");
            return Yr(t, this.coders, n);
          }
          decode(t) {
            return Xr(t, this.coders);
          }
        }
        function fs(t) {
          return An(kt(t));
        }
        function ds(t) {
          return (function (t) {
            let e = 0;
            return () => t[e++];
          })(
            (function (t) {
              let e = 0;
              function n() {
                return (t[e++] << 8) | t[e++];
              }
              let r = n(),
                s = 1,
                i = [0, 1];
              for (let t = 1; t < r; t++) i.push((s += n()));
              let a = n(),
                o = e;
              e += a;
              let c = 0,
                l = 0;
              function u() {
                return (
                  0 == c && ((l = (l << 8) | t[e++]), (c = 8)), (l >> --c) & 1
                );
              }
              const h = 2 ** 31,
                f = h >>> 1,
                d = h - 1;
              let p = 0;
              for (let t = 0; t < 31; t++) p = (p << 1) | u();
              let g = [],
                m = 0,
                y = h;
              for (;;) {
                let t = Math.floor(((p - m + 1) * s - 1) / y),
                  e = 0,
                  n = r;
                for (; n - e > 1; ) {
                  let r = (e + n) >>> 1;
                  t < i[r] ? (n = r) : (e = r);
                }
                if (0 == e) break;
                g.push(e);
                let a = m + Math.floor((y * i[e]) / s),
                  o = m + Math.floor((y * i[e + 1]) / s) - 1;
                for (; 0 == ((a ^ o) & f); )
                  (p = ((p << 1) & d) | u()),
                    (a = (a << 1) & d),
                    (o = ((o << 1) & d) | 1);
                for (; a & ~o & 536870912; )
                  (p = (p & f) | ((p << 1) & (d >>> 1)) | u()),
                    (a = (a << 1) ^ f),
                    (o = ((o ^ f) << 1) | f | 1);
                (m = a), (y = 1 + o - a);
              }
              let w = r - 4;
              return g.map((e) => {
                switch (e - w) {
                  case 3:
                    return (
                      w + 65792 + ((t[o++] << 16) | (t[o++] << 8) | t[o++])
                    );
                  case 2:
                    return w + 256 + ((t[o++] << 8) | t[o++]);
                  case 1:
                    return w + t[o++];
                  default:
                    return e - 1;
                }
              });
            })(
              (function (t) {
                let e = [];
                [
                  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                ].forEach((t, n) => (e[t.charCodeAt(0)] = n));
                let n = t.length,
                  r = new Uint8Array((6 * n) >> 3);
                for (let s = 0, i = 0, a = 0, o = 0; s < n; s++)
                  (o = (o << 6) | e[t.charCodeAt(s)]),
                    (a += 6),
                    a >= 8 && (r[i++] = o >> (a -= 8));
                return r;
              })(t)
            )
          );
        }
        function ps(t) {
          return 1 & t ? ~t >> 1 : t >> 1;
        }
        function gs(t, e) {
          let n = Array(t);
          for (let r = 0, s = 0; r < t; r++) n[r] = s += ps(e());
          return n;
        }
        function ms(t, e = 0) {
          let n = [];
          for (;;) {
            let r = t(),
              s = t();
            if (!s) break;
            e += r;
            for (let t = 0; t < s; t++) n.push(e + t);
            e += s + 1;
          }
          return n;
        }
        function ys(t) {
          return As(() => {
            let e = ms(t);
            if (e.length) return e;
          });
        }
        function ws(t) {
          let e = [];
          for (;;) {
            let n = t();
            if (0 == n) break;
            e.push(vs(n, t));
          }
          for (;;) {
            let n = t() - 1;
            if (n < 0) break;
            e.push(Es(n, t));
          }
          return e.flat();
        }
        function As(t) {
          let e = [];
          for (;;) {
            let n = t(e.length);
            if (!n) break;
            e.push(n);
          }
          return e;
        }
        function bs(t, e, n) {
          let r = Array(t)
            .fill()
            .map(() => []);
          for (let s = 0; s < e; s++) gs(t, n).forEach((t, e) => r[e].push(t));
          return r;
        }
        function vs(t, e) {
          let n = 1 + e(),
            r = e(),
            s = As(e);
          return bs(s.length, 1 + t, e).flatMap((t, e) => {
            let [i, ...a] = t;
            return Array(s[e])
              .fill()
              .map((t, e) => {
                let s = e * r;
                return [i + e * n, a.map((t) => t + s)];
              });
          });
        }
        function Es(t, e) {
          return bs(1 + e(), 1 + t, e).map((t) => [t[0], t.slice(1)]);
        }
        var xs = ds(
          "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"
        );
        const Ps = new Map([
            [8217, "apostrophe"],
            [8260, "fraction slash"],
            [12539, "middle dot"],
          ]),
          ks = 4;
        function Cs(t) {
          return `{${(function (t) {
            return t.toString(16).toUpperCase().padStart(2, "0");
          })(t)}}`;
        }
        function Ns(t) {
          let e = t.length;
          if (e < 4096) return String.fromCodePoint(...t);
          let n = [];
          for (let r = 0; r < e; )
            n.push(String.fromCodePoint(...t.slice(r, (r += 4096))));
          return n.join("");
        }
        var Is = ds(
          "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"
        );
        function Bs(t) {
          return (t >> 24) & 255;
        }
        function Ts(t) {
          return 16777215 & t;
        }
        const Os = new Map(
            ys(Is).flatMap((t, e) => t.map((t) => [t, (e + 1) << 24]))
          ),
          Ss = new Set(ms(Is)),
          Rs = new Map(),
          Us = new Map();
        for (let [t, e] of ws(Is)) {
          if (!Ss.has(t) && 2 == e.length) {
            let [n, r] = e,
              s = Us.get(n);
            s || ((s = new Map()), Us.set(n, s)), s.set(r, t);
          }
          Rs.set(t, e.reverse());
        }
        const Ls = 44032,
          Fs = 4352,
          Ds = 4449,
          Ms = 4519,
          Gs = 28,
          Hs = 21 * Gs,
          js = Ls + 19 * Hs,
          Qs = Fs + 19,
          Vs = Ds + 21,
          Js = Ms + Gs;
        function zs(t) {
          return t >= Ls && t < js;
        }
        function Ks(t, e) {
          if (t >= Fs && t < Qs && e >= Ds && e < Vs)
            return Ls + (t - Fs) * Hs + (e - Ds) * Gs;
          if (zs(t) && e > Ms && e < Js && (t - Ls) % Gs == 0)
            return t + (e - Ms);
          {
            let n = Us.get(t);
            return n && ((n = n.get(e)), n) ? n : -1;
          }
        }
        function _s(t) {
          let e = [],
            n = [],
            r = !1;
          function s(t) {
            let n = Os.get(t);
            n && ((r = !0), (t |= n)), e.push(t);
          }
          for (let r of t)
            for (;;) {
              if (r < 128) e.push(r);
              else if (zs(r)) {
                let t = r - Ls,
                  e = ((t % Hs) / Gs) | 0,
                  n = t % Gs;
                s(Fs + ((t / Hs) | 0)), s(Ds + e), n > 0 && s(Ms + n);
              } else {
                let t = Rs.get(r);
                t ? n.push(...t) : s(r);
              }
              if (!n.length) break;
              r = n.pop();
            }
          if (r && e.length > 1) {
            let t = Bs(e[0]);
            for (let n = 1; n < e.length; n++) {
              let r = Bs(e[n]);
              if (0 == r || t <= r) {
                t = r;
                continue;
              }
              let s = n - 1;
              for (;;) {
                let n = e[s + 1];
                if (((e[s + 1] = e[s]), (e[s] = n), !s)) break;
                if (((t = Bs(e[--s])), t <= r)) break;
              }
              t = Bs(e[n]);
            }
          }
          return e;
        }
        function qs(t) {
          return _s(t).map(Ts);
        }
        function Ws(t) {
          return (function (t) {
            let e = [],
              n = [],
              r = -1,
              s = 0;
            for (let i of t) {
              let t = Bs(i),
                a = Ts(i);
              if (-1 == r) 0 == t ? (r = a) : e.push(a);
              else if (s > 0 && s >= t)
                0 == t ? (e.push(r, ...n), (n.length = 0), (r = a)) : n.push(a),
                  (s = t);
              else {
                let i = Ks(r, a);
                i >= 0
                  ? (r = i)
                  : 0 == s && 0 == t
                  ? (e.push(r), (r = a))
                  : (n.push(a), (s = t));
              }
            }
            return r >= 0 && e.push(r, ...n), e;
          })(_s(t));
        }
        const Zs = 65039,
          Ys = ".",
          Xs = 1,
          $s = 45;
        function ti() {
          return new Set(ms(xs));
        }
        const ei = new Map(ws(xs)),
          ni = ti(),
          ri = ti(),
          si = new Set(
            ms(xs).map(
              function (t) {
                return this[t];
              },
              [...ri]
            )
          ),
          ii = ti();
        ti();
        const ai = ys(xs);
        function oi() {
          return new Set([ms(xs).map((t) => ai[t]), ms(xs)].flat(2));
        }
        const ci = xs(),
          li = As((t) => {
            let e = As(xs).map((t) => t + 96);
            if (e.length) {
              let n = t >= ci;
              (e[0] -= 32), (e = Ns(e)), n && (e = `Restricted[${e}]`);
              let r = oi(),
                s = oi(),
                i = [...r, ...s].sort((t, e) => t - e);
              return { N: e, P: r, M: !xs(), R: n, V: new Set(i) };
            }
          }),
          ui = ti(),
          hi = new Map();
        [...ui, ...ti()]
          .sort((t, e) => t - e)
          .map((t, e, n) => {
            let r = xs(),
              s = (n[e] = r ? n[e - r] : { V: [], M: new Map() });
            s.V.push(t), ui.has(t) || hi.set(t, s);
          });
        for (let { V: t, M: e } of new Set(hi.values())) {
          let n = [];
          for (let e of t) {
            let t = li.filter((t) => t.V.has(e)),
              r = n.find(({ G: e }) => t.some((t) => e.has(t)));
            r || ((r = { G: new Set(), V: [] }), n.push(r)),
              r.V.push(e),
              t.forEach((t) => r.G.add(t));
          }
          let r = n.flatMap(({ G: t }) => [...t]);
          for (let { G: t, V: s } of n) {
            let n = new Set(r.filter((e) => !t.has(e)));
            for (let t of s) e.set(t, n);
          }
        }
        let fi = new Set(),
          di = new Set();
        for (let t of li) for (let e of t.V) (fi.has(e) ? di : fi).add(e);
        for (let t of fi) hi.has(t) || di.has(t) || hi.set(t, Xs);
        const pi = new Set([...fi, ...qs(fi)]),
          gi = ms(xs),
          mi = (function t(e) {
            let n = As(() => {
                let e = ms(xs).map((t) => gi[t]);
                if (e.length) return t(e);
              }).sort((t, e) => e.Q.size - t.Q.size),
              r = xs(),
              s = r % 3;
            r = (r / 3) | 0;
            let i = 1 & r;
            return (
              (r >>= 1), { B: n, V: s, F: i, S: 1 & r, C: 2 & r, Q: new Set(e) }
            );
          })([]);
        class yi extends Array {
          get is_emoji() {
            return !0;
          }
        }
        function wi(t, e = Cs) {
          let n = [];
          var r;
          (r = t[0]), ri.has(r) && n.push("");
          let s = 0,
            i = t.length;
          for (let r = 0; r < i; r++) {
            let i = t[r];
            Ei(i) && (n.push(Ns(t.slice(s, r))), n.push(e(i)), (s = r + 1));
          }
          return n.push(Ns(t.slice(s, i))), n.join("");
        }
        function Ai(t) {
          return (Ei(t) ? "" : `${bi(wi([t]))} `) + Cs(t);
        }
        function bi(t) {
          return `"${t}"`;
        }
        function vi(t) {
          for (let e = t.lastIndexOf(95); e > 0; )
            if (95 !== t[--e])
              throw new Error("underscore allowed only at start");
        }
        function Ei(t) {
          return ii.has(t);
        }
        function xi(t) {
          return (function (t) {
            return t
              .map(({ input: e, error: n, output: r }) => {
                if (n) {
                  let r = n.message;
                  throw new Error(
                    1 == t.length ? r : `Invalid label ${bi(wi(e))}: ${r}`
                  );
                }
                return Ns(r);
              })
              .join(Ys);
          })(
            (function (t, e) {
              let n = 0;
              return t.split(Ys).map((t) => {
                let r,
                  s = (function (t) {
                    let e = [];
                    for (let n = 0, r = t.length; n < r; ) {
                      let r = t.codePointAt(n);
                      (n += r < 65536 ? 1 : 2), e.push(r);
                    }
                    return e;
                  })(t),
                  i = { input: s, offset: n };
                n += s.length + 1;
                try {
                  let t,
                    n = (i.tokens = (function (t, e) {
                      let n = [],
                        r = [];
                      t = t.slice().reverse();
                      for (; t.length; ) {
                        let s = Ni(t);
                        if (s) r.length && (n.push(e(r)), (r = [])), n.push(s);
                        else {
                          let e = t.pop();
                          if (pi.has(e)) r.push(e);
                          else {
                            let t = ei.get(e);
                            if (t) r.push(...t);
                            else if (!ni.has(e)) throw Pi(e);
                          }
                        }
                      }
                      r.length && n.push(e(r));
                      return n;
                    })(s, Ws)),
                    a = n.length;
                  if (!a) throw new Error("empty label");
                  {
                    let s = n[0],
                      o = a > 1 || s.is_emoji;
                    if (!o && s.every((t) => t < 128))
                      (r = s),
                        vi(r),
                        (function (t) {
                          if (t.length >= 4 && t[2] == $s && t[3] == $s)
                            throw new Error("invalid label extension");
                        })(r),
                        (t = "ASCII");
                    else if (
                      (o &&
                        ((i.emoji = !0),
                        (s = n.flatMap((t) => (t.is_emoji ? [] : t)))),
                      (r = n.flatMap((t) =>
                        !e && t.is_emoji ? t.filter((t) => t != Zs) : t
                      )),
                      vi(r),
                      s.length)
                    ) {
                      if (ri.has(r[0])) throw Ci("leading combining mark");
                      for (let t = 1; t < a; t++) {
                        let e = n[t];
                        if (!e.is_emoji && ri.has(e[0]))
                          throw Ci(
                            `emoji + combining mark: "${Ns(n[t - 1])} + ${wi([
                              e[0],
                            ])}"`
                          );
                      }
                      !(function (t) {
                        let e = t[0],
                          n = Ps.get(e);
                        if (n) throw Ci(`leading ${n}`);
                        let r = t.length,
                          s = -1;
                        for (let i = 1; i < r; i++) {
                          e = t[i];
                          let r = Ps.get(e);
                          if (r) {
                            if (s == i) throw Ci(`${n} + ${r}`);
                            (s = i + 1), (n = r);
                          }
                        }
                        if (s == r) throw Ci(`trailing ${n}`);
                      })(r);
                      let e = [...new Set(s)],
                        [i] = (function (t) {
                          let e = li;
                          for (let n of t) {
                            let t = e.filter((t) => t.V.has(n));
                            if (!t.length) throw e === li ? Pi(n) : ki(e[0], n);
                            if (((e = t), 1 == t.length)) break;
                          }
                          return e;
                        })(e);
                      !(function (t, e) {
                        let { V: n, M: r } = t;
                        for (let r of e) if (!n.has(r)) throw ki(t, r);
                        if (r) {
                          let t = qs(e);
                          for (let e = 1, n = t.length; e < n; e++)
                            if (si.has(t[e])) {
                              let r = e + 1;
                              for (let s; r < n && si.has((s = t[r])); r++)
                                for (let n = e; n < r; n++)
                                  if (t[n] == s)
                                    throw new Error(
                                      `non-spacing marks: repeated ${Ai(s)}`
                                    );
                              if (r - e > ks)
                                throw new Error(
                                  `non-spacing marks: too many ${bi(
                                    wi(t.slice(e - 1, r))
                                  )} (${r - e}/${ks})`
                                );
                              e = r;
                            }
                        }
                      })(i, s),
                        (function (t, e) {
                          let n,
                            r = [];
                          for (let t of e) {
                            let e = hi.get(t);
                            if (e === Xs) return;
                            if (e) {
                              let r = e.M.get(t);
                              if (
                                ((n = n ? n.filter((t) => r.has(t)) : [...r]),
                                !n.length)
                              )
                                return;
                            } else r.push(t);
                          }
                          if (n)
                            for (let e of n)
                              if (r.every((t) => e.V.has(t)))
                                throw new Error(
                                  `whole-script confusable: ${t.N}/${e.N}`
                                );
                        })(i, e),
                        (t = i.N);
                    } else t = "Emoji";
                  }
                  i.type = t;
                } catch (t) {
                  i.error = t;
                }
                return (i.output = r), i;
              });
            })(t)
          );
        }
        function Pi(t) {
          return new Error(`disallowed character: ${Ai(t)}`);
        }
        function ki(t, e) {
          let n = Ai(e),
            r = li.find((t) => t.P.has(e));
          return (
            r && (n = `${r.N} ${n}`),
            new Error(`illegal mixture: ${t.N} + ${n}`)
          );
        }
        function Ci(t) {
          return new Error(`illegal placement: ${t}`);
        }
        function Ni(t, e) {
          let n,
            r,
            s = mi,
            i = [],
            a = t.length;
          for (e && (e.length = 0); a; ) {
            let o = t[--a];
            if (((s = s.B.find((t) => t.Q.has(o))), !s)) break;
            if (s.S) r = o;
            else if (s.C && o === r) break;
            i.push(o),
              s.F && (i.push(Zs), a > 0 && t[a - 1] == Zs && a--),
              s.V &&
                ((n = Ii(i, s)),
                e && e.push(...t.slice(a).reverse()),
                (t.length = a));
          }
          return n;
        }
        function Ii(t, e) {
          let n = yi.from(t);
          return 2 == e.V && n.splice(1, 1), n;
        }
        const Bi = new Uint8Array(32);
        function Ti(t) {
          return (
            _(0 !== t.length, "invalid ENS name; empty component", "comp", t), t
          );
        }
        function Oi(t) {
          const e = kt(
              (function (t) {
                try {
                  return xi(t);
                } catch (e) {
                  _(!1, `invalid ENS name (${e.message})`, "name", t);
                }
              })(t)
            ),
            n = [];
          if (0 === t.length) return n;
          let r = 0;
          for (let t = 0; t < e.length; t++) {
            46 === e[t] && (n.push(Ti(e.slice(r, t))), (r = t + 1));
          }
          return (
            _(r < e.length, "invalid ENS name; empty component", "name", t),
            n.push(Ti(e.slice(r))),
            n
          );
        }
        function Si(t) {
          _("string" == typeof t, "invalid ENS name; not a string", "name", t);
          let e = Bi;
          const n = Oi(t);
          for (; n.length; ) e = An(rt([e, An(n.pop())]));
          return nt(e);
        }
        function Ri(t, e) {
          return {
            address: Hr(t),
            storageKeys: e.map(
              (t, e) => (
                _(tt(t, 32), "invalid slot", `storageKeys[${e}]`, t),
                t.toLowerCase()
              )
            ),
          };
        }
        function Ui(t) {
          if (Array.isArray(t))
            return t.map((e, n) =>
              Array.isArray(e)
                ? (_(2 === e.length, "invalid slot set", `value[${n}]`, e),
                  Ri(e[0], e[1]))
                : (_(
                    null != e && "object" == typeof e,
                    "invalid address-slot set",
                    "value",
                    t
                  ),
                  Ri(e.address, e.storageKeys))
            );
          _(
            null != t && "object" == typeof t,
            "invalid access list",
            "value",
            t
          );
          const e = Object.keys(t).map((e) => {
            const n = t[e].reduce((t, e) => ((t[e] = !0), t), {});
            return Ri(e, Object.keys(n).sort());
          });
          return e.sort((t, e) => t.address.localeCompare(e.address)), e;
        }
        function Li(t, e) {
          return (function (t) {
            let e;
            return (
              (e =
                "string" == typeof t
                  ? Rr.computePublicKey(t, !1)
                  : t.publicKey),
              Hr(An("0x" + e.substring(4)).substring(26))
            );
          })(Rr.recoverPublicKey(t, e));
        }
        Bi.fill(0);
        const Fi = BigInt(0),
          Di = BigInt(2),
          Mi = BigInt(27),
          Gi = BigInt(28),
          Hi = BigInt(35),
          ji = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        function Qi(t) {
          return "0x" === t ? null : Hr(t);
        }
        function Vi(t, e) {
          try {
            return Ui(t);
          } catch (n) {
            _(!1, n.message, e, t);
          }
        }
        function Ji(t, e) {
          return "0x" === t ? 0 : yt(t, e);
        }
        function zi(t, e) {
          if ("0x" === t) return Fi;
          const n = dt(t, e);
          return _(n <= ji, "value exceeds uint size", e, n), n;
        }
        function Ki(t, e) {
          const n = dt(t, "value"),
            r = At(n);
          return _(r.length <= 32, "value too large", `tx.${e}`, n), r;
        }
        function _i(t) {
          return Ui(t).map((t) => [t.address, t.storageKeys]);
        }
        function qi(t, e) {
          const n = [
            Ki(t.nonce || 0, "nonce"),
            Ki(t.gasPrice || 0, "gasPrice"),
            Ki(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Hr(t.to) : "0x",
            Ki(t.value || 0, "value"),
            t.data || "0x",
          ];
          let r = Fi;
          if (t.chainId != Fi)
            (r = dt(t.chainId, "tx.chainId")),
              _(
                !e || null == e.networkV || e.legacyChainId === r,
                "tx.chainId/sig.v mismatch",
                "sig",
                e
              );
          else if (t.signature) {
            const e = t.signature.legacyChainId;
            null != e && (r = e);
          }
          if (!e)
            return (
              r !== Fi && (n.push(At(r)), n.push("0x"), n.push("0x")), se(n)
            );
          let s = BigInt(27 + e.yParity);
          return (
            r !== Fi
              ? (s = Sr.getChainIdV(r, e.v))
              : BigInt(e.v) !== s &&
                _(!1, "tx.chainId/sig.v mismatch", "sig", e),
            n.push(At(s)),
            n.push(At(e.r)),
            n.push(At(e.s)),
            se(n)
          );
        }
        function Wi(t, e) {
          let n;
          try {
            if (((n = Ji(e[0], "yParity")), 0 !== n && 1 !== n))
              throw new Error("bad yParity");
          } catch (t) {
            _(!1, "invalid yParity", "yParity", e[0]);
          }
          const r = at(e[1], 32),
            s = at(e[2], 32),
            i = Sr.from({ r: r, s: s, yParity: n });
          t.signature = i;
        }
        function Zi(t, e) {
          const n = [
            Ki(t.chainId || 0, "chainId"),
            Ki(t.nonce || 0, "nonce"),
            Ki(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
            Ki(t.maxFeePerGas || 0, "maxFeePerGas"),
            Ki(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Hr(t.to) : "0x",
            Ki(t.value || 0, "value"),
            t.data || "0x",
            _i(t.accessList || []),
          ];
          return (
            e &&
              (n.push(Ki(e.yParity, "yParity")),
              n.push(At(e.r)),
              n.push(At(e.s))),
            rt(["0x02", se(n)])
          );
        }
        function Yi(t, e) {
          const n = [
            Ki(t.chainId || 0, "chainId"),
            Ki(t.nonce || 0, "nonce"),
            Ki(t.gasPrice || 0, "gasPrice"),
            Ki(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Hr(t.to) : "0x",
            Ki(t.value || 0, "value"),
            t.data || "0x",
            _i(t.accessList || []),
          ];
          return (
            e &&
              (n.push(Ki(e.yParity, "recoveryParam")),
              n.push(At(e.r)),
              n.push(At(e.s))),
            rt(["0x01", se(n)])
          );
        }
        class Xi {
          #V;
          #J;
          #S;
          #z;
          #K;
          #_;
          #q;
          #W;
          #Z;
          #Y;
          #X;
          #$;
          get type() {
            return this.#V;
          }
          set type(t) {
            switch (t) {
              case null:
                this.#V = null;
                break;
              case 0:
              case "legacy":
                this.#V = 0;
                break;
              case 1:
              case "berlin":
              case "eip-2930":
                this.#V = 1;
                break;
              case 2:
              case "london":
              case "eip-1559":
                this.#V = 2;
                break;
              default:
                _(!1, "unsupported transaction type", "type", t);
            }
          }
          get typeName() {
            switch (this.type) {
              case 0:
                return "legacy";
              case 1:
                return "eip-2930";
              case 2:
                return "eip-1559";
            }
            return null;
          }
          get to() {
            return this.#J;
          }
          set to(t) {
            this.#J = null == t ? null : Hr(t);
          }
          get nonce() {
            return this.#z;
          }
          set nonce(t) {
            this.#z = yt(t, "value");
          }
          get gasLimit() {
            return this.#K;
          }
          set gasLimit(t) {
            this.#K = dt(t);
          }
          get gasPrice() {
            const t = this.#_;
            return null != t || (0 !== this.type && 1 !== this.type) ? t : Fi;
          }
          set gasPrice(t) {
            this.#_ = null == t ? null : dt(t, "gasPrice");
          }
          get maxPriorityFeePerGas() {
            const t = this.#q;
            return null == t ? (2 === this.type ? Fi : null) : t;
          }
          set maxPriorityFeePerGas(t) {
            this.#q = null == t ? null : dt(t, "maxPriorityFeePerGas");
          }
          get maxFeePerGas() {
            const t = this.#W;
            return null == t ? (2 === this.type ? Fi : null) : t;
          }
          set maxFeePerGas(t) {
            this.#W = null == t ? null : dt(t, "maxFeePerGas");
          }
          get data() {
            return this.#S;
          }
          set data(t) {
            this.#S = nt(t);
          }
          get value() {
            return this.#Z;
          }
          set value(t) {
            this.#Z = dt(t, "value");
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = dt(t);
          }
          get signature() {
            return this.#X || null;
          }
          set signature(t) {
            this.#X = null == t ? null : Sr.from(t);
          }
          get accessList() {
            const t = this.#$ || null;
            return null == t
              ? 1 === this.type || 2 === this.type
                ? []
                : null
              : t;
          }
          set accessList(t) {
            this.#$ = null == t ? null : Ui(t);
          }
          constructor() {
            (this.#V = null),
              (this.#J = null),
              (this.#z = 0),
              (this.#K = BigInt(0)),
              (this.#_ = null),
              (this.#q = null),
              (this.#W = null),
              (this.#S = "0x"),
              (this.#Z = BigInt(0)),
              (this.#Y = BigInt(0)),
              (this.#X = null),
              (this.#$ = null);
          }
          get hash() {
            return null == this.signature ? null : An(this.serialized);
          }
          get unsignedHash() {
            return An(this.unsignedSerialized);
          }
          get from() {
            return null == this.signature
              ? null
              : Li(this.unsignedHash, this.signature);
          }
          get fromPublicKey() {
            return null == this.signature
              ? null
              : Rr.recoverPublicKey(this.unsignedHash, this.signature);
          }
          isSigned() {
            return null != this.signature;
          }
          get serialized() {
            switch (
              (K(
                null != this.signature,
                "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
                "UNSUPPORTED_OPERATION",
                { operation: ".serialized" }
              ),
              this.inferType())
            ) {
              case 0:
                return qi(this, this.signature);
              case 1:
                return Yi(this, this.signature);
              case 2:
                return Zi(this, this.signature);
            }
            K(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".serialized",
            });
          }
          get unsignedSerialized() {
            switch (this.inferType()) {
              case 0:
                return qi(this);
              case 1:
                return Yi(this);
              case 2:
                return Zi(this);
            }
            K(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".unsignedSerialized",
            });
          }
          inferType() {
            return this.inferTypes().pop();
          }
          inferTypes() {
            const t = null != this.gasPrice,
              e =
                null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
              n = null != this.accessList;
            null != this.maxFeePerGas &&
              null != this.maxPriorityFeePerGas &&
              K(
                this.maxFeePerGas >= this.maxPriorityFeePerGas,
                "priorityFee cannot be more than maxFee",
                "BAD_DATA",
                { value: this }
              ),
              K(
                !e || (0 !== this.type && 1 !== this.type),
                "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
                "BAD_DATA",
                { value: this }
              ),
              K(
                0 !== this.type || !n,
                "legacy transaction cannot have accessList",
                "BAD_DATA",
                { value: this }
              );
            const r = [];
            return (
              null != this.type
                ? r.push(this.type)
                : e
                ? r.push(2)
                : t
                ? (r.push(1), n || r.push(0))
                : n
                ? (r.push(1), r.push(2))
                : (r.push(0), r.push(1), r.push(2)),
              r.sort(),
              r
            );
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          clone() {
            return Xi.from(this);
          }
          toJSON() {
            const t = (t) => (null == t ? null : t.toString());
            return {
              type: this.type,
              to: this.to,
              data: this.data,
              nonce: this.nonce,
              gasLimit: t(this.gasLimit),
              gasPrice: t(this.gasPrice),
              maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
              maxFeePerGas: t(this.maxFeePerGas),
              value: t(this.value),
              chainId: t(this.chainId),
              sig: this.signature ? this.signature.toJSON() : null,
              accessList: this.accessList,
            };
          }
          static from(t) {
            if (null == t) return new Xi();
            if ("string" == typeof t) {
              const e = X(t);
              if (e[0] >= 127)
                return Xi.from(
                  (function (t) {
                    const e = te(t);
                    _(
                      Array.isArray(e) && (9 === e.length || 6 === e.length),
                      "invalid field count for legacy transaction",
                      "data",
                      t
                    );
                    const n = {
                      type: 0,
                      nonce: Ji(e[0], "nonce"),
                      gasPrice: zi(e[1], "gasPrice"),
                      gasLimit: zi(e[2], "gasLimit"),
                      to: Qi(e[3]),
                      value: zi(e[4], "value"),
                      data: nt(e[5]),
                      chainId: Fi,
                    };
                    if (6 === e.length) return n;
                    const r = zi(e[6], "v"),
                      s = zi(e[7], "r"),
                      i = zi(e[8], "s");
                    if (s === Fi && i === Fi) n.chainId = r;
                    else {
                      let s = (r - Hi) / Di;
                      s < Fi && (s = Fi),
                        (n.chainId = s),
                        _(
                          s !== Fi || r === Mi || r === Gi,
                          "non-canonical legacy v",
                          "v",
                          e[6]
                        ),
                        (n.signature = Sr.from({
                          r: at(e[7], 32),
                          s: at(e[8], 32),
                          v: r,
                        })),
                        (n.hash = An(t));
                    }
                    return n;
                  })(e)
                );
              switch (e[0]) {
                case 1:
                  return Xi.from(
                    (function (t) {
                      const e = te(X(t).slice(1));
                      _(
                        Array.isArray(e) && (8 === e.length || 11 === e.length),
                        "invalid field count for transaction type: 1",
                        "data",
                        nt(t)
                      );
                      const n = {
                        type: 1,
                        chainId: zi(e[0], "chainId"),
                        nonce: Ji(e[1], "nonce"),
                        gasPrice: zi(e[2], "gasPrice"),
                        gasLimit: zi(e[3], "gasLimit"),
                        to: Qi(e[4]),
                        value: zi(e[5], "value"),
                        data: nt(e[6]),
                        accessList: Vi(e[7], "accessList"),
                      };
                      return (
                        8 === e.length || ((n.hash = An(t)), Wi(n, e.slice(8))),
                        n
                      );
                    })(e)
                  );
                case 2:
                  return Xi.from(
                    (function (t) {
                      const e = te(X(t).slice(1));
                      _(
                        Array.isArray(e) && (9 === e.length || 12 === e.length),
                        "invalid field count for transaction type: 2",
                        "data",
                        nt(t)
                      );
                      const n = zi(e[2], "maxPriorityFeePerGas"),
                        r = zi(e[3], "maxFeePerGas"),
                        s = {
                          type: 2,
                          chainId: zi(e[0], "chainId"),
                          nonce: Ji(e[1], "nonce"),
                          maxPriorityFeePerGas: n,
                          maxFeePerGas: r,
                          gasPrice: null,
                          gasLimit: zi(e[4], "gasLimit"),
                          to: Qi(e[5]),
                          value: zi(e[6], "value"),
                          data: nt(e[7]),
                          accessList: Vi(e[8], "accessList"),
                        };
                      return (
                        9 === e.length || ((s.hash = An(t)), Wi(s, e.slice(9))),
                        s
                      );
                    })(e)
                  );
              }
              K(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from",
              });
            }
            const e = new Xi();
            return (
              null != t.type && (e.type = t.type),
              null != t.to && (e.to = t.to),
              null != t.nonce && (e.nonce = t.nonce),
              null != t.gasLimit && (e.gasLimit = t.gasLimit),
              null != t.gasPrice && (e.gasPrice = t.gasPrice),
              null != t.maxPriorityFeePerGas &&
                (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas),
              null != t.maxFeePerGas && (e.maxFeePerGas = t.maxFeePerGas),
              null != t.data && (e.data = t.data),
              null != t.value && (e.value = t.value),
              null != t.chainId && (e.chainId = t.chainId),
              null != t.signature && (e.signature = Sr.from(t.signature)),
              null != t.accessList && (e.accessList = t.accessList),
              null != t.hash &&
                (_(
                  e.isSigned(),
                  "unsigned transaction cannot define hash",
                  "tx",
                  t
                ),
                _(e.hash === t.hash, "hash mismatch", "tx", t)),
              null != t.from &&
                (_(
                  e.isSigned(),
                  "unsigned transaction cannot define from",
                  "tx",
                  t
                ),
                _(
                  e.from.toLowerCase() === (t.from || "").toLowerCase(),
                  "from mismatch",
                  "tx",
                  t
                )),
              e
            );
          }
        }
        const $i = new Uint8Array(32);
        $i.fill(0);
        const ta = BigInt(-1),
          ea = BigInt(0),
          na = BigInt(1),
          ra = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        const sa = wt(na, 32),
          ia = wt(ea, 32),
          aa = {
            name: "string",
            version: "string",
            chainId: "uint256",
            verifyingContract: "address",
            salt: "bytes32",
          },
          oa = ["name", "version", "chainId", "verifyingContract", "salt"];
        function ca(t) {
          return function (e) {
            return (
              _(
                "string" == typeof e,
                `invalid domain value for ${JSON.stringify(t)}`,
                `domain.${t}`,
                e
              ),
              e
            );
          };
        }
        const la = {
          name: ca("name"),
          version: ca("version"),
          chainId: function (t) {
            const e = dt(t, "domain.chainId");
            return (
              _(e >= 0, "invalid chain ID", "domain.chainId", t),
              Number.isSafeInteger(e) ? Number(e) : bt(e)
            );
          },
          verifyingContract: function (t) {
            try {
              return Hr(t).toLowerCase();
            } catch (t) {}
            _(
              !1,
              'invalid domain value "verifyingContract"',
              "domain.verifyingContract",
              t
            );
          },
          salt: function (t) {
            const e = X(t, "domain.salt");
            return (
              _(
                32 === e.length,
                'invalid domain value "salt"',
                "domain.salt",
                t
              ),
              nt(e)
            );
          },
        };
        function ua(t) {
          {
            const e = t.match(/^(u?)int(\d*)$/);
            if (e) {
              const n = "" === e[1],
                r = parseInt(e[2] || "256");
              _(
                r % 8 == 0 &&
                  0 !== r &&
                  r <= 256 &&
                  (null == e[2] || e[2] === String(r)),
                "invalid numeric width",
                "type",
                t
              );
              const s = ft(ra, n ? r - 1 : r),
                i = n ? (s + na) * ta : ea;
              return function (e) {
                const r = dt(e, "value");
                return (
                  _(
                    r >= i && r <= s,
                    `value out-of-bounds for ${t}`,
                    "value",
                    r
                  ),
                  wt(n ? ht(r, 256) : r, 32)
                );
              };
            }
          }
          {
            const e = t.match(/^bytes(\d+)$/);
            if (e) {
              const n = parseInt(e[1]);
              return (
                _(
                  0 !== n && n <= 32 && e[1] === String(n),
                  "invalid bytes width",
                  "type",
                  t
                ),
                function (e) {
                  return (
                    _(X(e).length === n, `invalid length for ${t}`, "value", e),
                    (function (t) {
                      const e = X(t),
                        n = e.length % 32;
                      return n ? rt([e, $i.slice(n)]) : nt(e);
                    })(e)
                  );
                }
              );
            }
          }
          switch (t) {
            case "address":
              return function (t) {
                return at(Hr(t), 32);
              };
            case "bool":
              return function (t) {
                return t ? sa : ia;
              };
            case "bytes":
              return function (t) {
                return An(t);
              };
            case "string":
              return function (t) {
                return fs(t);
              };
          }
          return null;
        }
        function ha(t, e) {
          return `${t}(${e
            .map(({ name: t, type: e }) => e + " " + t)
            .join(",")})`;
        }
        class fa {
          primaryType;
          #tt;
          get types() {
            return JSON.parse(this.#tt);
          }
          #et;
          #nt;
          constructor(t) {
            (this.#tt = JSON.stringify(t)),
              (this.#et = new Map()),
              (this.#nt = new Map());
            const e = new Map(),
              n = new Map(),
              r = new Map();
            Object.keys(t).forEach((t) => {
              e.set(t, new Set()), n.set(t, []), r.set(t, new Set());
            });
            for (const r in t) {
              const s = new Set();
              for (const i of t[r]) {
                _(
                  !s.has(i.name),
                  `duplicate variable name ${JSON.stringify(
                    i.name
                  )} in ${JSON.stringify(r)}`,
                  "types",
                  t
                ),
                  s.add(i.name);
                const a = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                _(
                  a !== r,
                  `circular type reference to ${JSON.stringify(a)}`,
                  "types",
                  t
                );
                ua(a) ||
                  (_(n.has(a), `unknown type ${JSON.stringify(a)}`, "types", t),
                  n.get(a).push(r),
                  e.get(r).add(a));
              }
            }
            const s = Array.from(n.keys()).filter((t) => 0 === n.get(t).length);
            _(0 !== s.length, "missing primary type", "types", t),
              _(
                1 === s.length,
                `ambiguous primary types or unused types: ${s
                  .map((t) => JSON.stringify(t))
                  .join(", ")}`,
                "types",
                t
              ),
              j(this, { primaryType: s[0] }),
              (function s(i, a) {
                _(
                  !a.has(i),
                  `circular type reference to ${JSON.stringify(i)}`,
                  "types",
                  t
                ),
                  a.add(i);
                for (const t of e.get(i))
                  if (n.has(t)) {
                    s(t, a);
                    for (const e of a) r.get(e).add(t);
                  }
                a.delete(i);
              })(this.primaryType, new Set());
            for (const [e, n] of r) {
              const r = Array.from(n);
              r.sort(),
                this.#et.set(
                  e,
                  ha(e, t[e]) + r.map((e) => ha(e, t[e])).join("")
                );
            }
          }
          getEncoder(t) {
            let e = this.#nt.get(t);
            return e || ((e = this.#rt(t)), this.#nt.set(t, e)), e;
          }
          #rt(t) {
            {
              const e = ua(t);
              if (e) return e;
            }
            const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (e) {
              const t = e[1],
                n = this.getEncoder(t);
              return (r) => {
                _(
                  !e[3] || parseInt(e[3]) === r.length,
                  `array length mismatch; expected length ${parseInt(e[3])}`,
                  "value",
                  r
                );
                let s = r.map(n);
                return this.#et.has(t) && (s = s.map(An)), An(rt(s));
              };
            }
            const n = this.types[t];
            if (n) {
              const e = fs(this.#et.get(t));
              return (t) => {
                const r = n.map(({ name: e, type: n }) => {
                  const r = this.getEncoder(n)(t[e]);
                  return this.#et.has(n) ? An(r) : r;
                });
                return r.unshift(e), rt(r);
              };
            }
            _(!1, `unknown type: ${t}`, "type", t);
          }
          encodeType(t) {
            const e = this.#et.get(t);
            return _(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
          }
          encodeData(t, e) {
            return this.getEncoder(t)(e);
          }
          hashStruct(t, e) {
            return An(this.encodeData(t, e));
          }
          encode(t) {
            return this.encodeData(this.primaryType, t);
          }
          hash(t) {
            return this.hashStruct(this.primaryType, t);
          }
          _visit(t, e, n) {
            if (ua(t)) return n(t, e);
            const r = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (r)
              return (
                _(
                  !r[3] || parseInt(r[3]) === e.length,
                  `array length mismatch; expected length ${parseInt(r[3])}`,
                  "value",
                  e
                ),
                e.map((t) => this._visit(r[1], t, n))
              );
            const s = this.types[t];
            if (s)
              return s.reduce(
                (t, { name: r, type: s }) => (
                  (t[r] = this._visit(s, e[r], n)), t
                ),
                {}
              );
            _(!1, `unknown type: ${t}`, "type", t);
          }
          visit(t, e) {
            return this._visit(this.primaryType, t, e);
          }
          static from(t) {
            return new fa(t);
          }
          static getPrimaryType(t) {
            return fa.from(t).primaryType;
          }
          static hashStruct(t, e, n) {
            return fa.from(e).hashStruct(t, n);
          }
          static hashDomain(t) {
            const e = [];
            for (const n in t) {
              if (null == t[n]) continue;
              const r = aa[n];
              _(
                r,
                `invalid typed-data domain key: ${JSON.stringify(n)}`,
                "domain",
                t
              ),
                e.push({ name: n, type: r });
            }
            return (
              e.sort((t, e) => oa.indexOf(t.name) - oa.indexOf(e.name)),
              fa.hashStruct("EIP712Domain", { EIP712Domain: e }, t)
            );
          }
          static encode(t, e, n) {
            return rt(["0x1901", fa.hashDomain(t), fa.from(e).hash(n)]);
          }
          static hash(t, e, n) {
            return An(fa.encode(t, e, n));
          }
          static async resolveNames(t, e, n, r) {
            t = Object.assign({}, t);
            for (const e in t) null == t[e] && delete t[e];
            const s = {};
            t.verifyingContract &&
              !tt(t.verifyingContract, 20) &&
              (s[t.verifyingContract] = "0x");
            const i = fa.from(e);
            i.visit(
              n,
              (t, e) => ("address" !== t || tt(e, 20) || (s[e] = "0x"), e)
            );
            for (const t in s) s[t] = await r(t);
            return (
              t.verifyingContract &&
                s[t.verifyingContract] &&
                (t.verifyingContract = s[t.verifyingContract]),
              {
                domain: t,
                value: (n = i.visit(n, (t, e) =>
                  "address" === t && s[e] ? s[e] : e
                )),
              }
            );
          }
          static getPayload(t, e, n) {
            fa.hashDomain(t);
            const r = {},
              s = [];
            oa.forEach((e) => {
              const n = t[e];
              null != n &&
                ((r[e] = la[e](n)), s.push({ name: e, type: aa[e] }));
            });
            const i = fa.from(e),
              a = Object.assign({}, e);
            return (
              _(
                null == a.EIP712Domain,
                "types must not contain EIP712Domain type",
                "types.EIP712Domain",
                e
              ),
              (a.EIP712Domain = s),
              i.encode(n),
              {
                types: a,
                domain: r,
                primaryType: i.primaryType,
                message: i.visit(n, (t, e) => {
                  if (t.match(/^bytes(\d*)/)) return nt(X(e));
                  if (t.match(/^u?int/)) return dt(e).toString();
                  switch (t) {
                    case "address":
                      return e.toLowerCase();
                    case "bool":
                      return !!e;
                    case "string":
                      return (
                        _("string" == typeof e, "invalid string", "value", e), e
                      );
                  }
                  _(!1, "unsupported type", "type", t);
                }),
              }
            );
          }
        }
        function da(t) {
          const e = new Set();
          return t.forEach((t) => e.add(t)), Object.freeze(e);
        }
        const pa =
            "constant external internal payable private public pure view",
          ga = da(pa.split(" ")),
          ma = "constructor error event fallback function receive struct",
          ya = da(ma.split(" ")),
          wa = "calldata memory storage payable indexed",
          Aa = da(wa.split(" ")),
          ba = da([ma, wa, "tuple returns", pa].join(" ").split(" ")),
          va = {
            "(": "OPEN_PAREN",
            ")": "CLOSE_PAREN",
            "[": "OPEN_BRACKET",
            "]": "CLOSE_BRACKET",
            ",": "COMMA",
            "@": "AT",
          },
          Ea = new RegExp("^(\\s*)"),
          xa = new RegExp("^([0-9]+)"),
          Pa = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
          ka = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
          Ca = new RegExp(
            "^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"
          );
        class Na {
          #L;
          #st;
          get offset() {
            return this.#L;
          }
          get length() {
            return this.#st.length - this.#L;
          }
          constructor(t) {
            (this.#L = 0), (this.#st = t.slice());
          }
          clone() {
            return new Na(this.#st);
          }
          reset() {
            this.#L = 0;
          }
          #it(t = 0, e = 0) {
            return new Na(
              this.#st.slice(t, e).map((e) =>
                Object.freeze(
                  Object.assign({}, e, {
                    match: e.match - t,
                    linkBack: e.linkBack - t,
                    linkNext: e.linkNext - t,
                  })
                )
              )
            );
          }
          popKeyword(t) {
            const e = this.peek();
            if ("KEYWORD" !== e.type || !t.has(e.text))
              throw new Error(`expected keyword ${e.text}`);
            return this.pop().text;
          }
          popType(t) {
            if (this.peek().type !== t)
              throw new Error(
                `expected ${t}; got ${JSON.stringify(this.peek())}`
              );
            return this.pop().text;
          }
          popParen() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = this.#it(this.#L + 1, t.match + 1);
            return (this.#L = t.match + 1), e;
          }
          popParams() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = [];
            for (; this.#L < t.match - 1; ) {
              const t = this.peek().linkNext;
              e.push(this.#it(this.#L + 1, t)), (this.#L = t);
            }
            return (this.#L = t.match + 1), e;
          }
          peek() {
            if (this.#L >= this.#st.length) throw new Error("out-of-bounds");
            return this.#st[this.#L];
          }
          peekKeyword(t) {
            const e = this.peekType("KEYWORD");
            return null != e && t.has(e) ? e : null;
          }
          peekType(t) {
            if (0 === this.length) return null;
            const e = this.peek();
            return e.type === t ? e.text : null;
          }
          pop() {
            const t = this.peek();
            return this.#L++, t;
          }
          toString() {
            const t = [];
            for (let e = this.#L; e < this.#st.length; e++) {
              const n = this.#st[e];
              t.push(`${n.type}:${n.text}`);
            }
            return `<TokenString ${t.join(" ")}>`;
          }
        }
        function Ia(t) {
          const e = [],
            n = (e) => {
              const n = i < t.length ? JSON.stringify(t[i]) : "$EOI";
              throw new Error(`invalid token ${n} at ${i}: ${e}`);
            };
          let r = [],
            s = [],
            i = 0;
          for (; i < t.length; ) {
            let a = t.substring(i),
              o = a.match(Ea);
            o && ((i += o[1].length), (a = t.substring(i)));
            const c = {
              depth: r.length,
              linkBack: -1,
              linkNext: -1,
              match: -1,
              type: "",
              text: "",
              offset: i,
              value: -1,
            };
            e.push(c);
            let l = va[a[0]] || "";
            if (l) {
              if (((c.type = l), (c.text = a[0]), i++, "OPEN_PAREN" === l))
                r.push(e.length - 1), s.push(e.length - 1);
              else if ("CLOSE_PAREN" == l)
                0 === r.length && n("no matching open bracket"),
                  (c.match = r.pop()),
                  (e[c.match].match = e.length - 1),
                  c.depth--,
                  (c.linkBack = s.pop()),
                  (e[c.linkBack].linkNext = e.length - 1);
              else if ("COMMA" === l)
                (c.linkBack = s.pop()),
                  (e[c.linkBack].linkNext = e.length - 1),
                  s.push(e.length - 1);
              else if ("OPEN_BRACKET" === l) c.type = "BRACKET";
              else if ("CLOSE_BRACKET" === l) {
                let t = e.pop().text;
                if (e.length > 0 && "NUMBER" === e[e.length - 1].type) {
                  const n = e.pop().text;
                  (t = n + t), (e[e.length - 1].value = yt(n));
                }
                if (0 === e.length || "BRACKET" !== e[e.length - 1].type)
                  throw new Error("missing opening bracket");
                e[e.length - 1].text += t;
              }
            } else if (((o = a.match(Pa)), o)) {
              if (((c.text = o[1]), (i += c.text.length), ba.has(c.text))) {
                c.type = "KEYWORD";
                continue;
              }
              if (c.text.match(Ca)) {
                c.type = "TYPE";
                continue;
              }
              c.type = "ID";
            } else {
              if (((o = a.match(xa)), !o))
                throw new Error(
                  `unexpected token ${JSON.stringify(a[0])} at position ${i}`
                );
              (c.text = o[1]), (c.type = "NUMBER"), (i += c.text.length);
            }
          }
          return new Na(e.map((t) => Object.freeze(t)));
        }
        function Ba(t, e) {
          let n = [];
          for (const r in e.keys()) t.has(r) && n.push(r);
          if (n.length > 1)
            throw new Error(`conflicting types: ${n.join(", ")}`);
        }
        function Ta(t, e) {
          if (e.peekKeyword(ya)) {
            const n = e.pop().text;
            if (n !== t) throw new Error(`expected ${t}, got ${n}`);
          }
          return e.popType("ID");
        }
        function Oa(t, e) {
          const n = new Set();
          for (;;) {
            const r = t.peekType("KEYWORD");
            if (null == r || (e && !e.has(r))) break;
            if ((t.pop(), n.has(r)))
              throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
            n.add(r);
          }
          return Object.freeze(n);
        }
        function Sa(t) {
          let e = Oa(t, ga);
          return (
            Ba(e, da("constant payable nonpayable".split(" "))),
            Ba(e, da("pure view payable nonpayable".split(" "))),
            e.has("view")
              ? "view"
              : e.has("pure")
              ? "pure"
              : e.has("payable")
              ? "payable"
              : e.has("nonpayable")
              ? "nonpayable"
              : e.has("constant")
              ? "view"
              : "nonpayable"
          );
        }
        function Ra(t, e) {
          return t.popParams().map((t) => _a.from(t, e));
        }
        function Ua(t) {
          if (t.peekType("AT")) {
            if ((t.pop(), t.peekType("NUMBER"))) return dt(t.pop().text);
            throw new Error("invalid gas");
          }
          return null;
        }
        function La(t) {
          if (t.length) throw new Error(`unexpected tokens: ${t.toString()}`);
        }
        const Fa = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function Da(t) {
          const e = t.match(Ca);
          if ((_(e, "invalid type", "type", t), "uint" === t)) return "uint256";
          if ("int" === t) return "int256";
          if (e[2]) {
            const n = parseInt(e[2]);
            _(0 !== n && n <= 32, "invalid bytes length", "type", t);
          } else if (e[3]) {
            const n = parseInt(e[3]);
            _(
              0 !== n && n <= 256 && n % 8 == 0,
              "invalid numeric width",
              "type",
              t
            );
          }
          return t;
        }
        const Ma = {},
          Ga = Symbol.for("_ethers_internal"),
          Ha = "_ParamTypeInternal",
          ja = "_ErrorInternal",
          Qa = "_EventInternal",
          Va = "_ConstructorInternal",
          Ja = "_FallbackInternal",
          za = "_FunctionInternal",
          Ka = "_StructInternal";
        class _a {
          name;
          type;
          baseType;
          indexed;
          components;
          arrayLength;
          arrayChildren;
          constructor(t, e, n, r, s, i, a, o) {
            if (
              (Z(t, Ma, "ParamType"),
              Object.defineProperty(this, Ga, { value: Ha }),
              i && (i = Object.freeze(i.slice())),
              "array" === r)
            ) {
              if (null == a || null == o) throw new Error("");
            } else if (null != a || null != o) throw new Error("");
            if ("tuple" === r) {
              if (null == i) throw new Error("");
            } else if (null != i) throw new Error("");
            j(this, {
              name: e,
              type: n,
              baseType: r,
              indexed: s,
              components: i,
              arrayLength: a,
              arrayChildren: o,
            });
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t)) {
              let e = {
                type: "tuple" === this.baseType ? "tuple" : this.type,
                name: this.name || void 0,
              };
              return (
                "boolean" == typeof this.indexed && (e.indexed = this.indexed),
                this.isTuple() &&
                  (e.components = this.components.map((e) =>
                    JSON.parse(e.format(t))
                  )),
                JSON.stringify(e)
              );
            }
            let e = "";
            return (
              this.isArray()
                ? ((e += this.arrayChildren.format(t)),
                  (e += `[${
                    this.arrayLength < 0 ? "" : String(this.arrayLength)
                  }]`))
                : this.isTuple()
                ? ("sighash" !== t && (e += this.type),
                  (e +=
                    "(" +
                    this.components
                      .map((e) => e.format(t))
                      .join("full" === t ? ", " : ",") +
                    ")"))
                : (e += this.type),
              "sighash" !== t &&
                (!0 === this.indexed && (e += " indexed"),
                "full" === t && this.name && (e += " " + this.name)),
              e
            );
          }
          isArray() {
            return "array" === this.baseType;
          }
          isTuple() {
            return "tuple" === this.baseType;
          }
          isIndexable() {
            return null != this.indexed;
          }
          walk(t, e) {
            if (this.isArray()) {
              if (!Array.isArray(t)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && t.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t) => n.arrayChildren.walk(t, e));
            }
            if (this.isTuple()) {
              if (!Array.isArray(t)) throw new Error("invalid tuple value");
              if (t.length !== this.components.length)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t, r) => n.components[r].walk(t, e));
            }
            return e(this.type, t);
          }
          #at(t, e, n, r) {
            if (this.isArray()) {
              if (!Array.isArray(e)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && e.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const s = this.arrayChildren,
                i = e.slice();
              return (
                i.forEach((e, r) => {
                  s.#at(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            if (this.isTuple()) {
              const s = this.components;
              let i;
              if (Array.isArray(e)) i = e.slice();
              else {
                if (null == e || "object" != typeof e)
                  throw new Error("invalid tuple value");
                i = s.map((t) => {
                  if (!t.name)
                    throw new Error(
                      "cannot use object value with unnamed components"
                    );
                  if (!(t.name in e))
                    throw new Error(`missing value for component ${t.name}`);
                  return e[t.name];
                });
              }
              if (i.length !== this.components.length)
                throw new Error("array is wrong length");
              return (
                i.forEach((e, r) => {
                  s[r].#at(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            const s = n(this.type, e);
            s.then
              ? t.push(
                  (async function () {
                    r(await s);
                  })()
                )
              : r(s);
          }
          async walkAsync(t, e) {
            const n = [],
              r = [t];
            return (
              this.#at(n, t, e, (t) => {
                r[0] = t;
              }),
              n.length && (await Promise.all(n)),
              r[0]
            );
          }
          static from(t, e) {
            if (_a.isParamType(t)) return t;
            if ("string" == typeof t) return _a.from(Ia(t), e);
            if (t instanceof Na) {
              let n = "",
                r = "",
                s = null;
              Oa(t, da(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN")
                ? ((r = "tuple"),
                  (s = t.popParams().map((t) => _a.from(t))),
                  (n = `tuple(${s.map((t) => t.format()).join(",")})`))
                : ((n = Da(t.popType("TYPE"))), (r = n));
              let i = null,
                a = null;
              for (; t.length && t.peekType("BRACKET"); ) {
                const e = t.pop();
                (i = new _a(Ma, "", n, r, null, s, a, i)),
                  (a = e.value),
                  (n += e.text),
                  (r = "array"),
                  (s = null);
              }
              let o = null;
              if (Oa(t, Aa).has("indexed")) {
                if (!e) throw new Error("");
                o = !0;
              }
              const c = t.peekType("ID") ? t.pop().text : "";
              if (t.length) throw new Error("leftover tokens");
              return new _a(Ma, c, n, r, o, s, a, i);
            }
            const n = t.name;
            _(
              !n || ("string" == typeof n && n.match(ka)),
              "invalid name",
              "obj.name",
              n
            );
            let r = t.indexed;
            null != r &&
              (_(e, "parameter cannot be indexed", "obj.indexed", t.indexed),
              (r = !!r));
            let s = t.type,
              i = s.match(Fa);
            if (i) {
              const e = parseInt(i[2] || "-1"),
                a = _a.from({ type: i[1], components: t.components });
              return new _a(Ma, n || "", s, "array", r, null, e, a);
            }
            if ("tuple" === s || s.startsWith("tuple(") || s.startsWith("(")) {
              const e =
                null != t.components
                  ? t.components.map((t) => _a.from(t))
                  : null;
              return new _a(Ma, n || "", s, "tuple", r, e, null, null);
            }
            return (
              (s = Da(t.type)), new _a(Ma, n || "", s, s, r, null, null, null)
            );
          }
          static isParamType(t) {
            return t && t[Ga] === Ha;
          }
        }
        class qa {
          type;
          inputs;
          constructor(t, e, n) {
            Z(t, Ma, "Fragment"),
              j(this, { type: e, inputs: (n = Object.freeze(n.slice())) });
          }
          static from(t) {
            if ("string" == typeof t) {
              try {
                qa.from(JSON.parse(t));
              } catch (t) {}
              return qa.from(Ia(t));
            }
            if (t instanceof Na) {
              switch (t.peekKeyword(ya)) {
                case "constructor":
                  return $a.from(t);
                case "error":
                  return Ya.from(t);
                case "event":
                  return Xa.from(t);
                case "fallback":
                case "receive":
                  return to.from(t);
                case "function":
                  return eo.from(t);
                case "struct":
                  return no.from(t);
              }
            } else if ("object" == typeof t) {
              switch (t.type) {
                case "constructor":
                  return $a.from(t);
                case "error":
                  return Ya.from(t);
                case "event":
                  return Xa.from(t);
                case "fallback":
                case "receive":
                  return to.from(t);
                case "function":
                  return eo.from(t);
                case "struct":
                  return no.from(t);
              }
              K(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from",
              });
            }
            _(!1, "unsupported frgament object", "obj", t);
          }
          static isConstructor(t) {
            return $a.isFragment(t);
          }
          static isError(t) {
            return Ya.isFragment(t);
          }
          static isEvent(t) {
            return Xa.isFragment(t);
          }
          static isFunction(t) {
            return eo.isFragment(t);
          }
          static isStruct(t) {
            return no.isFragment(t);
          }
        }
        class Wa extends qa {
          name;
          constructor(t, e, n, r) {
            super(t, e, r),
              _(
                "string" == typeof n && n.match(ka),
                "invalid identifier",
                "name",
                n
              ),
              (r = Object.freeze(r.slice())),
              j(this, { name: n });
          }
        }
        function Za(t, e) {
          return (
            "(" +
            e.map((e) => e.format(t)).join("full" === t ? ", " : ",") +
            ")"
          );
        }
        class Ya extends Wa {
          constructor(t, e, n) {
            super(t, "error", e, n),
              Object.defineProperty(this, Ga, { value: ja });
          }
          get selector() {
            return fs(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("error"),
              e.push(this.name + Za(t, this.inputs)),
              e.join(" ")
            );
          }
          static from(t) {
            if (Ya.isFragment(t)) return t;
            if ("string" == typeof t) return Ya.from(Ia(t));
            if (t instanceof Na) {
              const e = Ta("error", t),
                n = Ra(t);
              return La(t), new Ya(Ma, e, n);
            }
            return new Ya(Ma, t.name, t.inputs ? t.inputs.map(_a.from) : []);
          }
          static isFragment(t) {
            return t && t[Ga] === ja;
          }
        }
        class Xa extends Wa {
          anonymous;
          constructor(t, e, n, r) {
            super(t, "event", e, n),
              Object.defineProperty(this, Ga, { value: Qa }),
              j(this, { anonymous: r });
          }
          get topicHash() {
            return fs(this.format("sighash"));
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("event"),
              e.push(this.name + Za(t, this.inputs)),
              "sighash" !== t && this.anonymous && e.push("anonymous"),
              e.join(" ")
            );
          }
          static getTopicHash(t, e) {
            e = (e || []).map((t) => _a.from(t));
            return new Xa(Ma, t, e, !1).topicHash;
          }
          static from(t) {
            if (Xa.isFragment(t)) return t;
            if ("string" == typeof t) return Xa.from(Ia(t));
            if (t instanceof Na) {
              const e = Ta("event", t),
                n = Ra(t, !0),
                r = !!Oa(t, da(["anonymous"])).has("anonymous");
              return La(t), new Xa(Ma, e, n, r);
            }
            return new Xa(
              Ma,
              t.name,
              t.inputs ? t.inputs.map((t) => _a.from(t, !0)) : [],
              !!t.anonymous
            );
          }
          static isFragment(t) {
            return t && t[Ga] === Qa;
          }
        }
        class $a extends qa {
          payable;
          gas;
          constructor(t, e, n, r, s) {
            super(t, e, n),
              Object.defineProperty(this, Ga, { value: Va }),
              j(this, { payable: r, gas: s });
          }
          format(t) {
            if (
              (K(
                null != t && "sighash" !== t,
                "cannot format a constructor for sighash",
                "UNSUPPORTED_OPERATION",
                { operation: "format(sighash)" }
              ),
              "json" === t)
            )
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [`constructor${Za(t, this.inputs)}`];
            return (
              e.push(this.payable ? "payable" : "nonpayable"),
              null != this.gas && e.push(`@${this.gas.toString()}`),
              e.join(" ")
            );
          }
          static from(t) {
            if ($a.isFragment(t)) return t;
            if ("string" == typeof t) return $a.from(Ia(t));
            if (t instanceof Na) {
              Oa(t, da(["constructor"]));
              const e = Ra(t),
                n = !!Oa(t, da(["payable"])).has("payable"),
                r = Ua(t);
              return La(t), new $a(Ma, "constructor", e, n, r);
            }
            return new $a(
              Ma,
              "constructor",
              t.inputs ? t.inputs.map(_a.from) : [],
              !!t.payable,
              null != t.gas ? t.gas : null
            );
          }
          static isFragment(t) {
            return t && t[Ga] === Va;
          }
        }
        class to extends qa {
          payable;
          constructor(t, e, n) {
            super(t, "fallback", e),
              Object.defineProperty(this, Ga, { value: Ja }),
              j(this, { payable: n });
          }
          format(t) {
            const e = 0 === this.inputs.length ? "receive" : "fallback";
            if ("json" === t) {
              const t = this.payable ? "payable" : "nonpayable";
              return JSON.stringify({ type: e, stateMutability: t });
            }
            return `${e}()${this.payable ? " payable" : ""}`;
          }
          static from(t) {
            if (to.isFragment(t)) return t;
            if ("string" == typeof t) return to.from(Ia(t));
            if (t instanceof Na) {
              const e = t.toString();
              _(
                t.peekKeyword(da(["fallback", "receive"])),
                "type must be fallback or receive",
                "obj",
                e
              );
              if ("receive" === t.popKeyword(da(["fallback", "receive"]))) {
                const e = Ra(t);
                return (
                  _(
                    0 === e.length,
                    "receive cannot have arguments",
                    "obj.inputs",
                    e
                  ),
                  Oa(t, da(["payable"])),
                  La(t),
                  new to(Ma, [], !0)
                );
              }
              let n = Ra(t);
              n.length
                ? _(
                    1 === n.length && "bytes" === n[0].type,
                    "invalid fallback inputs",
                    "obj.inputs",
                    n.map((t) => t.format("minimal")).join(", ")
                  )
                : (n = [_a.from("bytes")]);
              const r = Sa(t);
              if (
                (_(
                  "nonpayable" === r || "payable" === r,
                  "fallback cannot be constants",
                  "obj.stateMutability",
                  r
                ),
                Oa(t, da(["returns"])).has("returns"))
              ) {
                const e = Ra(t);
                _(
                  1 === e.length && "bytes" === e[0].type,
                  "invalid fallback outputs",
                  "obj.outputs",
                  e.map((t) => t.format("minimal")).join(", ")
                );
              }
              return La(t), new to(Ma, n, "payable" === r);
            }
            if ("receive" === t.type) return new to(Ma, [], !0);
            if ("fallback" === t.type) {
              const e = [_a.from("bytes")],
                n = "payable" === t.stateMutability;
              return new to(Ma, e, n);
            }
            _(!1, "invalid fallback description", "obj", t);
          }
          static isFragment(t) {
            return t && t[Ga] === Ja;
          }
        }
        class eo extends Wa {
          constant;
          outputs;
          stateMutability;
          payable;
          gas;
          constructor(t, e, n, r, s, i) {
            super(t, "function", e, r),
              Object.defineProperty(this, Ga, { value: za });
            j(this, {
              constant: "view" === n || "pure" === n,
              gas: i,
              outputs: (s = Object.freeze(s.slice())),
              payable: "payable" === n,
              stateMutability: n,
            });
          }
          get selector() {
            return fs(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  "nonpayable" !== this.stateMutability
                    ? this.stateMutability
                    : void 0,
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
                outputs: this.outputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("function"),
              e.push(this.name + Za(t, this.inputs)),
              "sighash" !== t &&
                ("nonpayable" !== this.stateMutability &&
                  e.push(this.stateMutability),
                this.outputs &&
                  this.outputs.length &&
                  (e.push("returns"), e.push(Za(t, this.outputs))),
                null != this.gas && e.push(`@${this.gas.toString()}`)),
              e.join(" ")
            );
          }
          static getSelector(t, e) {
            e = (e || []).map((t) => _a.from(t));
            return new eo(Ma, t, "view", e, [], null).selector;
          }
          static from(t) {
            if (eo.isFragment(t)) return t;
            if ("string" == typeof t) return eo.from(Ia(t));
            if (t instanceof Na) {
              const e = Ta("function", t),
                n = Ra(t),
                r = Sa(t);
              let s = [];
              Oa(t, da(["returns"])).has("returns") && (s = Ra(t));
              const i = Ua(t);
              return La(t), new eo(Ma, e, r, n, s, i);
            }
            let e = t.stateMutability;
            return (
              null == e &&
                ((e = "payable"),
                "boolean" == typeof t.constant
                  ? ((e = "view"),
                    t.constant ||
                      ((e = "payable"),
                      "boolean" != typeof t.payable ||
                        t.payable ||
                        (e = "nonpayable")))
                  : "boolean" != typeof t.payable ||
                    t.payable ||
                    (e = "nonpayable")),
              new eo(
                Ma,
                t.name,
                e,
                t.inputs ? t.inputs.map(_a.from) : [],
                t.outputs ? t.outputs.map(_a.from) : [],
                null != t.gas ? t.gas : null
              )
            );
          }
          static isFragment(t) {
            return t && t[Ga] === za;
          }
        }
        class no extends Wa {
          constructor(t, e, n) {
            super(t, "struct", e, n),
              Object.defineProperty(this, Ga, { value: Ka });
          }
          format() {
            throw new Error("@TODO");
          }
          static from(t) {
            if ("string" == typeof t) return no.from(Ia(t));
            if (t instanceof Na) {
              const e = Ta("struct", t),
                n = Ra(t);
              return La(t), new no(Ma, e, n);
            }
            return new no(Ma, t.name, t.inputs ? t.inputs.map(_a.from) : []);
          }
          static isFragment(t) {
            return t && t[Ga] === Ka;
          }
        }
        const ro = new Map();
        ro.set(0, "GENERIC_PANIC"),
          ro.set(1, "ASSERT_FALSE"),
          ro.set(17, "OVERFLOW"),
          ro.set(18, "DIVIDE_BY_ZERO"),
          ro.set(33, "ENUM_RANGE_ERROR"),
          ro.set(34, "BAD_STORAGE_DATA"),
          ro.set(49, "STACK_UNDERFLOW"),
          ro.set(50, "ARRAY_RANGE_ERROR"),
          ro.set(65, "OUT_OF_MEMORY"),
          ro.set(81, "UNINITIALIZED_FUNCTION_CALL");
        const so = new RegExp(/^bytes([0-9]*)$/),
          io = new RegExp(/^(u?int)([0-9]*)$/);
        let ao = null;
        class oo {
          #ot(t) {
            if (t.isArray())
              return new $r(this.#ot(t.arrayChildren), t.arrayLength, t.name);
            if (t.isTuple())
              return new hs(
                t.components.map((t) => this.#ot(t)),
                t.name
              );
            switch (t.baseType) {
              case "address":
                return new Wr(t.name);
              case "bool":
                return new ts(t.name);
              case "string":
                return new us(t.name);
              case "bytes":
                return new ns(t.name);
              case "":
                return new is(t.name);
            }
            let e = t.type.match(io);
            if (e) {
              let n = parseInt(e[2] || "256");
              return (
                _(
                  0 !== n && n <= 256 && n % 8 == 0,
                  "invalid " + e[1] + " bit length",
                  "param",
                  t
                ),
                new ls(n / 8, "int" === e[1], t.name)
              );
            }
            if (((e = t.type.match(so)), e)) {
              let n = parseInt(e[1]);
              return (
                _(0 !== n && n <= 32, "invalid bytes length", "param", t),
                new rs(n, t.name)
              );
            }
            _(!1, "invalid type", "type", t.type);
          }
          getDefaultValue(t) {
            const e = t.map((t) => this.#ot(_a.from(t)));
            return new hs(e, "_").defaultValue();
          }
          encode(t, e) {
            q(e.length, t.length, "types/values length mismatch");
            const n = t.map((t) => this.#ot(_a.from(t))),
              r = new hs(n, "_"),
              s = new ge();
            return r.encode(s, e), s.data;
          }
          decode(t, e, n) {
            const r = t.map((t) => this.#ot(_a.from(t)));
            return new hs(r, "_").decode(new me(e, n));
          }
          static defaultAbiCoder() {
            return null == ao && (ao = new oo()), ao;
          }
          static getBuiltinCallException(t, e, n) {
            return (function (t, e, n, r) {
              let s = "missing revert data",
                i = null,
                a = null;
              if (n) {
                s = "execution reverted";
                const t = X(n);
                if (((n = nt(n)), 0 === t.length))
                  (s += " (no data present; likely require(false) occurred"),
                    (i = "require(false)");
                else if (t.length % 32 != 4)
                  s += " (could not decode reason; invalid data length)";
                else if ("0x08c379a0" === nt(t.slice(0, 4)))
                  try {
                    (i = r.decode(["string"], t.slice(4))[0]),
                      (a = {
                        signature: "Error(string)",
                        name: "Error",
                        args: [i],
                      }),
                      (s += `: ${JSON.stringify(i)}`);
                  } catch (t) {
                    s += " (could not decode reason; invalid string data)";
                  }
                else if ("0x4e487b71" === nt(t.slice(0, 4)))
                  try {
                    const e = Number(r.decode(["uint256"], t.slice(4))[0]);
                    (a = {
                      signature: "Panic(uint256)",
                      name: "Panic",
                      args: [e],
                    }),
                      (i = `Panic due to ${ro.get(e) || "UNKNOWN"}(${e})`),
                      (s += `: ${i}`);
                  } catch (t) {
                    s += " (could not decode panic code)";
                  }
                else s += " (unknown custom error)";
              }
              const o = { to: e.to ? Hr(e.to) : null, data: e.data || "0x" };
              return (
                e.from && (o.from = Hr(e.from)),
                z(s, "CALL_EXCEPTION", {
                  action: t,
                  data: n,
                  reason: i,
                  transaction: o,
                  invocation: null,
                  revert: a,
                })
              );
            })(t, e, n, oo.defaultAbiCoder());
          }
        }
        class co {
          fragment;
          name;
          signature;
          topic;
          args;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            j(this, { fragment: t, name: r, signature: s, topic: e, args: n });
          }
        }
        class lo {
          fragment;
          name;
          args;
          signature;
          selector;
          value;
          constructor(t, e, n, r) {
            const s = t.name,
              i = t.format();
            j(this, {
              fragment: t,
              name: s,
              args: n,
              signature: i,
              selector: e,
              value: r,
            });
          }
        }
        class uo {
          fragment;
          name;
          args;
          signature;
          selector;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            j(this, {
              fragment: t,
              name: r,
              args: n,
              signature: s,
              selector: e,
            });
          }
        }
        class ho {
          hash;
          _isIndexed;
          static isIndexed(t) {
            return !(!t || !t._isIndexed);
          }
          constructor(t) {
            j(this, { hash: t, _isIndexed: !0 });
          }
        }
        const fo = {
            0: "generic panic",
            1: "assert(false)",
            17: "arithmetic overflow",
            18: "division or modulo by zero",
            33: "enum overflow",
            34: "invalid encoded storage byte array accessed",
            49: "out-of-bounds array access; popping on an empty array",
            50: "out-of-bounds access of an array or bytesN",
            65: "out of memory",
            81: "uninitialized function",
          },
          po = {
            "0x08c379a0": {
              signature: "Error(string)",
              name: "Error",
              inputs: ["string"],
              reason: (t) => `reverted with reason string ${JSON.stringify(t)}`,
            },
            "0x4e487b71": {
              signature: "Panic(uint256)",
              name: "Panic",
              inputs: ["uint256"],
              reason: (t) => {
                let e = "unknown panic code";
                return (
                  t >= 0 &&
                    t <= 255 &&
                    fo[t.toString()] &&
                    (e = fo[t.toString()]),
                  `reverted with panic code 0x${t.toString(16)} (${e})`
                );
              },
            },
          };
        class go {
          fragments;
          deploy;
          fallback;
          receive;
          #ct;
          #lt;
          #ut;
          #ht;
          constructor(t) {
            let e = [];
            (e = "string" == typeof t ? JSON.parse(t) : t),
              (this.#ut = new Map()),
              (this.#ct = new Map()),
              (this.#lt = new Map());
            const n = [];
            for (const t of e)
              try {
                n.push(qa.from(t));
              } catch (t) {
                console.log("EE", t);
              }
            j(this, { fragments: Object.freeze(n) });
            let r = null,
              s = !1;
            (this.#ht = this.getAbiCoder()),
              this.fragments.forEach((t, e) => {
                let n;
                switch (t.type) {
                  case "constructor":
                    return this.deploy
                      ? void console.log("duplicate definition - constructor")
                      : void j(this, { deploy: t });
                  case "fallback":
                    return void (0 === t.inputs.length
                      ? (s = !0)
                      : (_(
                          !r || t.payable !== r.payable,
                          "conflicting fallback fragments",
                          `fragments[${e}]`,
                          t
                        ),
                        (r = t),
                        (s = r.payable)));
                  case "function":
                    n = this.#ut;
                    break;
                  case "event":
                    n = this.#lt;
                    break;
                  case "error":
                    n = this.#ct;
                    break;
                  default:
                    return;
                }
                const i = t.format();
                n.has(i) || n.set(i, t);
              }),
              this.deploy || j(this, { deploy: $a.from("constructor()") }),
              j(this, { fallback: r, receive: s });
          }
          format(t) {
            const e = t ? "minimal" : "full";
            return this.fragments.map((t) => t.format(e));
          }
          formatJson() {
            const t = this.fragments.map((t) => t.format("json"));
            return JSON.stringify(t.map((t) => JSON.parse(t)));
          }
          getAbiCoder() {
            return oo.defaultAbiCoder();
          }
          #ft(t, e, n) {
            if (tt(t)) {
              const e = t.toLowerCase();
              for (const t of this.#ut.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#ut) e.split("(")[0] === t && r.push(n);
              if (e) {
                const t = e.length > 0 ? e[e.length - 1] : null;
                let n = e.length,
                  s = !0;
                qr.isTyped(t) && "overrides" === t.type && ((s = !1), n--);
                for (let t = r.length - 1; t >= 0; t--) {
                  const e = r[t].inputs.length;
                  e === n || (s && e === n - 1) || r.splice(t, 1);
                }
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if (qr.isTyped(e[s])) {
                      if (s >= n.length) {
                        if ("overrides" === e[s].type) continue;
                        r.splice(t, 1);
                        break;
                      }
                      if (e[s].type !== n[s].baseType) {
                        r.splice(t, 1);
                        break;
                      }
                    }
                }
              }
              if (1 === r.length && e && e.length !== r[0].inputs.length) {
                const t = e[e.length - 1];
                (null == t || Array.isArray(t) || "object" != typeof t) &&
                  r.splice(0, 1);
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                _(
                  !1,
                  `ambiguous function description (i.e. matches ${r
                    .map((t) => JSON.stringify(t.format()))
                    .join(", ")})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#ut.get(eo.from(t).format());
            return r || null;
          }
          getFunctionName(t) {
            const e = this.#ft(t, null, !1);
            return _(e, "no matching function", "key", t), e.name;
          }
          hasFunction(t) {
            return !!this.#ft(t, null, !1);
          }
          getFunction(t, e) {
            return this.#ft(t, e || null, !0);
          }
          forEachFunction(t) {
            const e = Array.from(this.#ut.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ut.get(r), n);
            }
          }
          #dt(t, e, n) {
            if (tt(t)) {
              const e = t.toLowerCase();
              for (const t of this.#lt.values())
                if (e === t.topicHash) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#lt) e.split("(")[0] === t && r.push(n);
              if (e) {
                for (let t = r.length - 1; t >= 0; t--)
                  r[t].inputs.length < e.length && r.splice(t, 1);
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if (qr.isTyped(e[s]) && e[s].type !== n[s].baseType) {
                      r.splice(t, 1);
                      break;
                    }
                }
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                _(
                  !1,
                  `ambiguous event description (i.e. matches ${r
                    .map((t) => JSON.stringify(t.format()))
                    .join(", ")})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#lt.get(Xa.from(t).format());
            return r || null;
          }
          getEventName(t) {
            const e = this.#dt(t, null, !1);
            return _(e, "no matching event", "key", t), e.name;
          }
          hasEvent(t) {
            return !!this.#dt(t, null, !1);
          }
          getEvent(t, e) {
            return this.#dt(t, e || null, !0);
          }
          forEachEvent(t) {
            const e = Array.from(this.#lt.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#lt.get(r), n);
            }
          }
          getError(t, e) {
            if (tt(t)) {
              const e = t.toLowerCase();
              if (po[e]) return Ya.from(po[e].signature);
              for (const t of this.#ct.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const e = [];
              for (const [n, r] of this.#ct) n.split("(")[0] === t && e.push(r);
              if (0 === e.length)
                return "Error" === t
                  ? Ya.from("error Error(string)")
                  : "Panic" === t
                  ? Ya.from("error Panic(uint256)")
                  : null;
              if (e.length > 1) {
                _(
                  !1,
                  `ambiguous error description (i.e. ${e
                    .map((t) => JSON.stringify(t.format()))
                    .join(", ")})`,
                  "name",
                  t
                );
              }
              return e[0];
            }
            if ("Error(string)" === (t = Ya.from(t).format()))
              return Ya.from("error Error(string)");
            if ("Panic(uint256)" === t) return Ya.from("error Panic(uint256)");
            const n = this.#ct.get(t);
            return n || null;
          }
          forEachError(t) {
            const e = Array.from(this.#ct.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ct.get(r), n);
            }
          }
          _decodeParams(t, e) {
            return this.#ht.decode(t, e);
          }
          _encodeParams(t, e) {
            return this.#ht.encode(t, e);
          }
          encodeDeploy(t) {
            return this._encodeParams(this.deploy.inputs, t || []);
          }
          decodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              _(e, "unknown error", "fragment", t), (t = e);
            }
            return (
              _(
                it(e, 0, 4) === t.selector,
                `data signature does not match error ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, it(e, 4))
            );
          }
          encodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              _(e, "unknown error", "fragment", t), (t = e);
            }
            return rt([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              _(e, "unknown function", "fragment", t), (t = e);
            }
            return (
              _(
                it(e, 0, 4) === t.selector,
                `data signature does not match function ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, it(e, 4))
            );
          }
          encodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              _(e, "unknown function", "fragment", t), (t = e);
            }
            return rt([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              _(e, "unknown function", "fragment", t), (t = e);
            }
            let n = "invalid length for result data";
            const r = $(e);
            if (r.length % 32 == 0)
              try {
                return this.#ht.decode(t.outputs, r);
              } catch (t) {
                n = "could not decode result data";
              }
            K(!1, n, "BAD_DATA", {
              value: nt(r),
              info: { method: t.name, signature: t.format() },
            });
          }
          makeError(t, e) {
            const n = X(t, "data"),
              r = oo.getBuiltinCallException("call", e, n);
            if (
              r.message.startsWith("execution reverted (unknown custom error)")
            ) {
              const t = nt(n.slice(0, 4)),
                e = this.getError(t);
              if (e)
                try {
                  const t = this.#ht.decode(e.inputs, n.slice(4));
                  (r.revert = { name: e.name, signature: e.format(), args: t }),
                    (r.reason = r.revert.signature),
                    (r.message = `execution reverted: ${r.reason}`);
                } catch (t) {
                  r.message =
                    "execution reverted (coult not decode custom error)";
                }
            }
            const s = this.parseTransaction(e);
            return (
              s &&
                (r.invocation = {
                  method: s.name,
                  signature: s.signature,
                  args: s.args,
                }),
              r
            );
          }
          encodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              _(e, "unknown function", "fragment", t), (t = e);
            }
            return nt(this.#ht.encode(t.outputs, e || []));
          }
          encodeFilterTopics(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              _(e, "unknown event", "eventFragment", t), (t = e);
            }
            K(
              e.length <= t.inputs.length,
              `too many arguments for ${t.format()}`,
              "UNEXPECTED_ARGUMENT",
              { count: e.length, expectedCount: t.inputs.length }
            );
            const n = [];
            t.anonymous || n.push(t.topicHash);
            const r = (t, e) =>
              "string" === t.type
                ? fs(e)
                : "bytes" === t.type
                ? An(nt(e))
                : ("bool" === t.type &&
                    "boolean" == typeof e &&
                    (e = e ? "0x01" : "0x00"),
                  t.type.match(/^u?int/) && (e = wt(e)),
                  "address" === t.type && this.#ht.encode(["address"], [e]),
                  at(nt(e), 32));
            for (
              e.forEach((e, s) => {
                const i = t.inputs[s];
                i.indexed
                  ? null == e
                    ? n.push(null)
                    : "array" === i.baseType || "tuple" === i.baseType
                    ? _(
                        !1,
                        "filtering with tuples or arrays not supported",
                        "contract." + i.name,
                        e
                      )
                    : Array.isArray(e)
                    ? n.push(e.map((t) => r(i, t)))
                    : n.push(r(i, e))
                  : _(
                      null == e,
                      "cannot filter non-indexed parameters; must be null",
                      "contract." + i.name,
                      e
                    );
              });
              n.length && null === n[n.length - 1];

            )
              n.pop();
            return n;
          }
          encodeEventLog(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              _(e, "unknown event", "eventFragment", t), (t = e);
            }
            const n = [],
              r = [],
              s = [];
            return (
              t.anonymous || n.push(t.topicHash),
              _(
                e.length === t.inputs.length,
                "event arguments/values mismatch",
                "values",
                e
              ),
              t.inputs.forEach((t, i) => {
                const a = e[i];
                if (t.indexed)
                  if ("string" === t.type) n.push(fs(a));
                  else if ("bytes" === t.type) n.push(An(a));
                  else {
                    if ("tuple" === t.baseType || "array" === t.baseType)
                      throw new Error("not implemented");
                    n.push(this.#ht.encode([t.type], [a]));
                  }
                else r.push(t), s.push(a);
              }),
              { data: this.#ht.encode(r, s), topics: n }
            );
          }
          decodeEventLog(t, e, n) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              _(e, "unknown event", "eventFragment", t), (t = e);
            }
            if (null != n && !t.anonymous) {
              const e = t.topicHash;
              _(
                tt(n[0], 32) && n[0].toLowerCase() === e,
                "fragment/topic mismatch",
                "topics[0]",
                n[0]
              ),
                (n = n.slice(1));
            }
            const r = [],
              s = [],
              i = [];
            t.inputs.forEach((t, e) => {
              t.indexed
                ? "string" === t.type ||
                  "bytes" === t.type ||
                  "tuple" === t.baseType ||
                  "array" === t.baseType
                  ? (r.push(_a.from({ type: "bytes32", name: t.name })),
                    i.push(!0))
                  : (r.push(t), i.push(!1))
                : (s.push(t), i.push(!1));
            });
            const a = null != n ? this.#ht.decode(r, rt(n)) : null,
              o = this.#ht.decode(s, e, !0),
              c = [],
              l = [];
            let u = 0,
              h = 0;
            return (
              t.inputs.forEach((t, e) => {
                let n = null;
                if (t.indexed)
                  if (null == a) n = new ho(null);
                  else if (i[e]) n = new ho(a[h++]);
                  else
                    try {
                      n = a[h++];
                    } catch (t) {
                      n = t;
                    }
                else
                  try {
                    n = o[u++];
                  } catch (t) {
                    n = t;
                  }
                c.push(n), l.push(t.name || null);
              }),
              fe.fromItems(c, l)
            );
          }
          parseTransaction(t) {
            const e = X(t.data, "tx.data"),
              n = dt(null != t.value ? t.value : 0, "tx.value"),
              r = this.getFunction(nt(e.slice(0, 4)));
            if (!r) return null;
            const s = this.#ht.decode(r.inputs, e.slice(4));
            return new lo(r, r.selector, s, n);
          }
          parseCallResult(t) {
            throw new Error("@TODO");
          }
          parseLog(t) {
            const e = this.getEvent(t.topics[0]);
            return !e || e.anonymous
              ? null
              : new co(
                  e,
                  e.topicHash,
                  this.decodeEventLog(e, t.data, t.topics)
                );
          }
          parseError(t) {
            const e = nt(t),
              n = this.getError(it(e, 0, 4));
            if (!n) return null;
            const r = this.#ht.decode(n.inputs, it(e, 4));
            return new uo(n, n.selector, r);
          }
          static from(t) {
            return t instanceof go
              ? t
              : "string" == typeof t
              ? new go(JSON.parse(t))
              : "function" == typeof t.format
              ? new go(t.format("json"))
              : new go(t);
          }
        }
        const mo = BigInt(0);
        function yo(t) {
          return null == t ? null : t;
        }
        function wo(t) {
          return null == t ? null : t.toString();
        }
        class Ao {
          gasPrice;
          maxFeePerGas;
          maxPriorityFeePerGas;
          constructor(t, e, n) {
            j(this, {
              gasPrice: yo(t),
              maxFeePerGas: yo(e),
              maxPriorityFeePerGas: yo(n),
            });
          }
          toJSON() {
            const {
              gasPrice: t,
              maxFeePerGas: e,
              maxPriorityFeePerGas: n,
            } = this;
            return {
              _type: "FeeData",
              gasPrice: wo(t),
              maxFeePerGas: wo(e),
              maxPriorityFeePerGas: wo(n),
            };
          }
        }
        function bo(t) {
          const e = {};
          t.to && (e.to = t.to),
            t.from && (e.from = t.from),
            t.data && (e.data = nt(t.data));
          const n =
            "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
              /,/
            );
          for (const r of n)
            r in t && null != t[r] && (e[r] = dt(t[r], `request.${r}`));
          const r = "type,nonce".split(/,/);
          for (const n of r)
            n in t && null != t[n] && (e[n] = yt(t[n], `request.${n}`));
          return (
            t.accessList && (e.accessList = Ui(t.accessList)),
            "blockTag" in t && (e.blockTag = t.blockTag),
            "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead),
            "customData" in t && (e.customData = t.customData),
            e
          );
        }
        class vo {
          provider;
          number;
          hash;
          timestamp;
          parentHash;
          nonce;
          difficulty;
          gasLimit;
          gasUsed;
          miner;
          extraData;
          baseFeePerGas;
          #pt;
          constructor(t, e) {
            (this.#pt = t.transactions.map((t) =>
              "string" != typeof t ? new Po(t, e) : t
            )),
              j(this, {
                provider: e,
                hash: yo(t.hash),
                number: t.number,
                timestamp: t.timestamp,
                parentHash: t.parentHash,
                nonce: t.nonce,
                difficulty: t.difficulty,
                gasLimit: t.gasLimit,
                gasUsed: t.gasUsed,
                miner: t.miner,
                extraData: t.extraData,
                baseFeePerGas: yo(t.baseFeePerGas),
              });
          }
          get transactions() {
            return this.#pt.map((t) => ("string" == typeof t ? t : t.hash));
          }
          get prefetchedTransactions() {
            const t = this.#pt.slice();
            return 0 === t.length
              ? []
              : (K(
                  "object" == typeof t[0],
                  "transactions were not prefetched with block request",
                  "UNSUPPORTED_OPERATION",
                  { operation: "transactionResponses()" }
                ),
                t);
          }
          toJSON() {
            const {
              baseFeePerGas: t,
              difficulty: e,
              extraData: n,
              gasLimit: r,
              gasUsed: s,
              hash: i,
              miner: a,
              nonce: o,
              number: c,
              parentHash: l,
              timestamp: u,
              transactions: h,
            } = this;
            return {
              _type: "Block",
              baseFeePerGas: wo(t),
              difficulty: wo(e),
              extraData: n,
              gasLimit: wo(r),
              gasUsed: wo(s),
              hash: i,
              miner: a,
              nonce: o,
              number: c,
              parentHash: l,
              timestamp: u,
              transactions: h,
            };
          }
          [Symbol.iterator]() {
            let t = 0;
            const e = this.transactions;
            return {
              next: () =>
                t < this.length
                  ? { value: e[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get length() {
            return this.#pt.length;
          }
          get date() {
            return null == this.timestamp
              ? null
              : new Date(1e3 * this.timestamp);
          }
          async getTransaction(t) {
            let e;
            if ("number" == typeof t) e = this.#pt[t];
            else {
              const n = t.toLowerCase();
              for (const t of this.#pt) {
                if ("string" == typeof t) {
                  if (t !== n) continue;
                  e = t;
                  break;
                }
                if (t.hash !== n) {
                  e = t;
                  break;
                }
              }
            }
            if (null == e) throw new Error("no such tx");
            return "string" == typeof e
              ? await this.provider.getTransaction(e)
              : e;
          }
          getPrefetchedTransaction(t) {
            const e = this.prefetchedTransactions;
            if ("number" == typeof t) return e[t];
            t = t.toLowerCase();
            for (const n of e) if (n.hash === t) return n;
            _(!1, "no matching transaction", "indexOrHash", t);
          }
          isMined() {
            return !!this.hash;
          }
          isLondon() {
            return !!this.baseFeePerGas;
          }
          orphanedEvent() {
            if (!this.isMined()) throw new Error("");
            return {
              orphan: "drop-block",
              hash: (t = this).hash,
              number: t.number,
            };
            var t;
          }
        }
        class Eo {
          provider;
          transactionHash;
          blockHash;
          blockNumber;
          removed;
          address;
          data;
          topics;
          index;
          transactionIndex;
          constructor(t, e) {
            this.provider = e;
            const n = Object.freeze(t.topics.slice());
            j(this, {
              transactionHash: t.transactionHash,
              blockHash: t.blockHash,
              blockNumber: t.blockNumber,
              removed: t.removed,
              address: t.address,
              data: t.data,
              topics: n,
              index: t.index,
              transactionIndex: t.transactionIndex,
            });
          }
          toJSON() {
            const {
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: a,
              transactionHash: o,
              transactionIndex: c,
            } = this;
            return {
              _type: "log",
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: a,
              transactionHash: o,
              transactionIndex: c,
            };
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            return K(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.transactionHash);
            return K(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
          }
          async getTransactionReceipt() {
            const t = await this.provider.getTransactionReceipt(
              this.transactionHash
            );
            return (
              K(!!t, "failed to find transaction receipt", "UNKNOWN_ERROR", {}),
              t
            );
          }
          removedEvent() {
            return {
              orphan: "drop-log",
              log: {
                transactionHash: (t = this).transactionHash,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                address: t.address,
                data: t.data,
                topics: Object.freeze(t.topics.slice()),
                index: t.index,
              },
            };
            var t;
          }
        }
        class xo {
          provider;
          to;
          from;
          contractAddress;
          hash;
          index;
          blockHash;
          blockNumber;
          logsBloom;
          gasUsed;
          cumulativeGasUsed;
          gasPrice;
          type;
          status;
          root;
          #gt;
          constructor(t, e) {
            this.#gt = Object.freeze(t.logs.map((t) => new Eo(t, e)));
            let n = mo;
            null != t.effectiveGasPrice
              ? (n = t.effectiveGasPrice)
              : null != t.gasPrice && (n = t.gasPrice),
              j(this, {
                provider: e,
                to: t.to,
                from: t.from,
                contractAddress: t.contractAddress,
                hash: t.hash,
                index: t.index,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                logsBloom: t.logsBloom,
                gasUsed: t.gasUsed,
                cumulativeGasUsed: t.cumulativeGasUsed,
                gasPrice: n,
                type: t.type,
                status: t.status,
                root: t.root,
              });
          }
          get logs() {
            return this.#gt;
          }
          toJSON() {
            const {
              to: t,
              from: e,
              contractAddress: n,
              hash: r,
              index: s,
              blockHash: i,
              blockNumber: a,
              logsBloom: o,
              logs: c,
              status: l,
              root: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              blockHash: i,
              blockNumber: a,
              contractAddress: n,
              cumulativeGasUsed: wo(this.cumulativeGasUsed),
              from: e,
              gasPrice: wo(this.gasPrice),
              gasUsed: wo(this.gasUsed),
              hash: r,
              index: s,
              logs: c,
              logsBloom: o,
              root: u,
              status: l,
              to: t,
            };
          }
          get length() {
            return this.logs.length;
          }
          [Symbol.iterator]() {
            let t = 0;
            return {
              next: () =>
                t < this.length
                  ? { value: this.logs[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get fee() {
            return this.gasUsed * this.gasPrice;
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.hash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getResult() {
            return await this.provider.getTransactionResult(this.hash);
          }
          async confirmations() {
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          removedEvent() {
            return Co(this);
          }
          reorderedEvent(t) {
            return (
              K(
                !t || t.isMined(),
                "unmined 'other' transction cannot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "reorderedEvent(other)" }
              ),
              ko(this, t)
            );
          }
        }
        class Po {
          provider;
          blockNumber;
          blockHash;
          index;
          hash;
          type;
          to;
          from;
          nonce;
          gasLimit;
          gasPrice;
          maxPriorityFeePerGas;
          maxFeePerGas;
          data;
          value;
          chainId;
          signature;
          accessList;
          #mt;
          constructor(t, e) {
            (this.provider = e),
              (this.blockNumber = null != t.blockNumber ? t.blockNumber : null),
              (this.blockHash = null != t.blockHash ? t.blockHash : null),
              (this.hash = t.hash),
              (this.index = t.index),
              (this.type = t.type),
              (this.from = t.from),
              (this.to = t.to || null),
              (this.gasLimit = t.gasLimit),
              (this.nonce = t.nonce),
              (this.data = t.data),
              (this.value = t.value),
              (this.gasPrice = t.gasPrice),
              (this.maxPriorityFeePerGas =
                null != t.maxPriorityFeePerGas ? t.maxPriorityFeePerGas : null),
              (this.maxFeePerGas =
                null != t.maxFeePerGas ? t.maxFeePerGas : null),
              (this.chainId = t.chainId),
              (this.signature = t.signature),
              (this.accessList = null != t.accessList ? t.accessList : null),
              (this.#mt = -1);
          }
          toJSON() {
            const {
              blockNumber: t,
              blockHash: e,
              index: n,
              hash: r,
              type: s,
              to: i,
              from: a,
              nonce: o,
              data: c,
              signature: l,
              accessList: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              accessList: u,
              blockNumber: t,
              blockHash: e,
              chainId: wo(this.chainId),
              data: c,
              from: a,
              gasLimit: wo(this.gasLimit),
              gasPrice: wo(this.gasPrice),
              hash: r,
              maxFeePerGas: wo(this.maxFeePerGas),
              maxPriorityFeePerGas: wo(this.maxPriorityFeePerGas),
              nonce: o,
              signature: l,
              to: i,
              index: n,
              type: s,
              value: wo(this.value),
            };
          }
          async getBlock() {
            let t = this.blockNumber;
            if (null == t) {
              const e = await this.getTransaction();
              e && (t = e.blockNumber);
            }
            if (null == t) return null;
            const e = this.provider.getBlock(t);
            if (null == e) throw new Error("TODO");
            return e;
          }
          async getTransaction() {
            return this.provider.getTransaction(this.hash);
          }
          async confirmations() {
            if (null == this.blockNumber) {
              const { tx: t, blockNumber: e } = await H({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(),
              });
              return null == t || null == t.blockNumber
                ? 0
                : e - t.blockNumber + 1;
            }
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          async wait(t, e) {
            const n = null == t ? 1 : t,
              r = null == e ? 0 : e;
            let s = this.#mt,
              i = -1,
              a = -1 === s;
            const o = async () => {
                if (a) return null;
                const { blockNumber: t, nonce: e } = await H({
                  blockNumber: this.provider.getBlockNumber(),
                  nonce: this.provider.getTransactionCount(this.from),
                });
                if (e < this.nonce) return void (s = t);
                if (a) return null;
                const r = await this.getTransaction();
                if (!r || null == r.blockNumber)
                  for (
                    -1 === i && ((i = s - 3), i < this.#mt && (i = this.#mt));
                    i <= t;

                  ) {
                    if (a) return null;
                    const e = await this.provider.getBlock(i, !0);
                    if (null == e) return;
                    for (const t of e) if (t === this.hash) return;
                    for (let r = 0; r < e.length; r++) {
                      const i = await e.getTransaction(r);
                      if (i.from === this.from && i.nonce === this.nonce) {
                        if (a) return null;
                        const e = await this.provider.getTransactionReceipt(
                          i.hash
                        );
                        if (null == e) return;
                        if (t - e.blockNumber + 1 < n) return;
                        let r = "replaced";
                        i.data === this.data &&
                        i.to === this.to &&
                        i.value === this.value
                          ? (r = "repriced")
                          : "0x" === i.data &&
                            i.from === i.to &&
                            i.value === mo &&
                            (r = "cancelled"),
                          K(
                            !1,
                            "transaction was replaced",
                            "TRANSACTION_REPLACED",
                            {
                              cancelled: "replaced" === r || "cancelled" === r,
                              reason: r,
                              replacement: i.replaceableTransaction(s),
                              hash: i.hash,
                              receipt: e,
                            }
                          );
                      }
                    }
                    i++;
                  }
              },
              c = await this.provider.getTransactionReceipt(this.hash);
            if (0 === n) return c;
            if (c) {
              if ((await c.confirmations()) >= n) return c;
            } else if ((await o(), 0 === n)) return null;
            const l = new Promise((t, e) => {
              const i = [],
                c = () => {
                  i.forEach((t) => t());
                };
              if (
                (i.push(() => {
                  a = !0;
                }),
                r > 0)
              ) {
                const t = setTimeout(() => {
                  c(), e(z("wait for transaction timeout", "TIMEOUT"));
                }, r);
                i.push(() => {
                  clearTimeout(t);
                });
              }
              const l = async (e) => {
                (await e.confirmations()) >= n && (c(), t(e));
              };
              if (
                (i.push(() => {
                  this.provider.off(this.hash, l);
                }),
                this.provider.on(this.hash, l),
                s >= 0)
              ) {
                const t = async () => {
                  try {
                    await o();
                  } catch (t) {
                    if (V(t, "TRANSACTION_REPLACED")) return c(), void e(t);
                  }
                  a || this.provider.once("block", t);
                };
                i.push(() => {
                  this.provider.off("block", t);
                }),
                  this.provider.once("block", t);
              }
            });
            return await l;
          }
          isMined() {
            return null != this.blockHash;
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          removedEvent() {
            return (
              K(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              Co(this)
            );
          }
          reorderedEvent(t) {
            return (
              K(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              K(
                !t || t.isMined(),
                "unmined 'other' transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              ko(this, t)
            );
          }
          replaceableTransaction(t) {
            _(
              Number.isInteger(t) && t >= 0,
              "invalid startBlock",
              "startBlock",
              t
            );
            const e = new Po(this, this.provider);
            return (e.#mt = t), e;
          }
        }
        function ko(t, e) {
          return { orphan: "reorder-transaction", tx: t, other: e };
        }
        function Co(t) {
          return { orphan: "drop-transaction", tx: t };
        }
        class No extends Eo {
          interface;
          fragment;
          args;
          constructor(t, e, n) {
            super(t, t.provider);
            j(this, {
              args: e.decodeEventLog(n, t.data, t.topics),
              fragment: n,
              interface: e,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        class Io extends xo {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          get logs() {
            return super.logs.map((t) => {
              const e = t.topics.length ? this.#yt.getEvent(t.topics[0]) : null;
              return e ? new No(t, this.#yt, e) : t;
            });
          }
        }
        class Bo extends Po {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          async wait(t) {
            const e = await super.wait(t);
            return null == e ? null : new Io(this.#yt, this.provider, e);
          }
        }
        class To extends Et {
          log;
          constructor(t, e, n, r) {
            super(t, e, n), j(this, { log: r });
          }
          async getBlock() {
            return await this.log.getBlock();
          }
          async getTransaction() {
            return await this.log.getTransaction();
          }
          async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
          }
        }
        class Oo extends To {
          constructor(t, e, n, r, s) {
            super(t, e, n, new No(s, t.interface, r));
            j(this, {
              args: t.interface.decodeEventLog(
                r,
                this.log.data,
                this.log.topics
              ),
              fragment: r,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        const So = BigInt(0);
        function Ro(t) {
          return t && "function" == typeof t.call;
        }
        function Uo(t) {
          return t && "function" == typeof t.estimateGas;
        }
        function Lo(t) {
          return t && "function" == typeof t.resolveName;
        }
        function Fo(t) {
          return t && "function" == typeof t.sendTransaction;
        }
        class Do {
          #wt;
          fragment;
          constructor(t, e, n) {
            if ((j(this, { fragment: e }), e.inputs.length < n.length))
              throw new Error("too many arguments");
            const r = Mo(t.runner, "resolveName"),
              s = Lo(r) ? r : null;
            this.#wt = (async function () {
              const r = await Promise.all(
                e.inputs.map((t, e) =>
                  null == n[e]
                    ? null
                    : t.walkAsync(n[e], (t, e) =>
                        "address" === t ? Vr(e, s) : e
                      )
                )
              );
              return t.interface.encodeFilterTopics(e, r);
            })();
          }
          getTopicFilter() {
            return this.#wt;
          }
        }
        function Mo(t, e) {
          return null == t
            ? null
            : "function" == typeof t[e]
            ? t
            : t.provider && "function" == typeof t.provider[e]
            ? t.provider
            : null;
        }
        function Go(t) {
          return null == t ? null : t.provider || null;
        }
        async function Ho(t, e) {
          const n = bo(qr.dereference(t, "overrides"));
          return (
            _(
              null == n.to || (e || []).indexOf("to") >= 0,
              "cannot override to",
              "overrides.to",
              n.to
            ),
            _(
              null == n.data || (e || []).indexOf("data") >= 0,
              "cannot override data",
              "overrides.data",
              n.data
            ),
            n.from && (n.from = await Vr(n.from)),
            n
          );
        }
        function jo(t) {
          const e = async function (e) {
              const n = await Ho(e, ["data"]);
              n.to = await t.getAddress();
              const r = t.interface,
                s = dt(n.value || So, "overrides.value") === So,
                i = "0x" === (n.data || "0x");
              !r.fallback ||
                r.fallback.payable ||
                !r.receive ||
                i ||
                s ||
                _(
                  !1,
                  "cannot send data to receive or send value to non-payable fallback",
                  "overrides",
                  e
                ),
                _(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                );
              return (
                _(
                  r.receive || (r.fallback && r.fallback.payable) || s,
                  "cannot send value to non-payable fallback",
                  "overrides.value",
                  n.value
                ),
                _(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                ),
                n
              );
            },
            n = async function (n) {
              const r = t.runner;
              K(
                Fo(r),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await r.sendTransaction(await e(n)),
                i = Go(t.runner);
              return new Bo(t.interface, i, s);
            },
            r = async (t) => await n(t);
          return (
            j(r, {
              _contract: t,
              estimateGas: async function (n) {
                const r = Mo(t.runner, "estimateGas");
                return (
                  K(
                    Uo(r),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await r.estimateGas(await e(n))
                );
              },
              populateTransaction: e,
              send: n,
              staticCall: async function (n) {
                const r = Mo(t.runner, "call");
                K(
                  Ro(r),
                  "contract runner does not support calling",
                  "UNSUPPORTED_OPERATION",
                  { operation: "call" }
                );
                const s = await e(n);
                try {
                  return await r.call(s);
                } catch (e) {
                  if (J(e) && e.data) throw t.interface.makeError(e.data, s);
                  throw e;
                }
              },
            }),
            r
          );
        }
        function Qo(t, e) {
          const n = function (...n) {
              const r = t.interface.getFunction(e, n);
              return (
                K(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                  operation: "fragment",
                }),
                r
              );
            },
            r = async function (...e) {
              const r = n(...e);
              let s = {};
              if (
                (r.inputs.length + 1 === e.length && (s = await Ho(e.pop())),
                r.inputs.length !== e.length)
              )
                throw new Error(
                  "internal error: fragment inputs doesn't match arguments; should not happen"
                );
              const i = await (async function (t, e, n) {
                const r = Mo(t, "resolveName"),
                  s = Lo(r) ? r : null;
                return await Promise.all(
                  e.map((t, e) =>
                    t.walkAsync(
                      n[e],
                      (t, e) => (
                        (e = qr.dereference(e, t)),
                        "address" === t ? Vr(e, s) : e
                      )
                    )
                  )
                );
              })(t.runner, r.inputs, e);
              return Object.assign(
                {},
                s,
                await H({
                  to: t.getAddress(),
                  data: t.interface.encodeFunctionData(r, i),
                })
              );
            },
            s = async function (...t) {
              const e = await a(...t);
              return 1 === e.length ? e[0] : e;
            },
            i = async function (...e) {
              const n = t.runner;
              K(
                Fo(n),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await n.sendTransaction(await r(...e)),
                i = Go(t.runner);
              return new Bo(t.interface, i, s);
            },
            a = async function (...e) {
              const s = Mo(t.runner, "call");
              K(
                Ro(s),
                "contract runner does not support calling",
                "UNSUPPORTED_OPERATION",
                { operation: "call" }
              );
              const i = await r(...e);
              let a = "0x";
              try {
                a = await s.call(i);
              } catch (e) {
                if (J(e) && e.data) throw t.interface.makeError(e.data, i);
                throw e;
              }
              const o = n(...e);
              return t.interface.decodeFunctionResult(o, a);
            },
            o = async (...t) =>
              n(...t).constant ? await s(...t) : await i(...t);
          return (
            j(o, {
              name: t.interface.getFunctionName(e),
              _contract: t,
              _key: e,
              getFragment: n,
              estimateGas: async function (...e) {
                const n = Mo(t.runner, "estimateGas");
                return (
                  K(
                    Uo(n),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await n.estimateGas(await r(...e))
                );
              },
              populateTransaction: r,
              send: i,
              staticCall: s,
              staticCallResult: a,
            }),
            Object.defineProperty(o, "fragment", {
              configurable: !1,
              enumerable: !0,
              get: () => {
                const n = t.interface.getFunction(e);
                return (
                  K(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                    operation: "fragment",
                  }),
                  n
                );
              },
            }),
            o
          );
        }
        const Vo = Symbol.for("_ethersInternal_contract"),
          Jo = new WeakMap();
        function zo(t) {
          return Jo.get(t[Vo]);
        }
        async function Ko(t, e) {
          let n,
            r = null;
          if (Array.isArray(e)) {
            const r = function (e) {
              if (tt(e, 32)) return e;
              const n = t.interface.getEvent(e);
              return _(n, "unknown fragment", "name", e), n.topicHash;
            };
            n = e.map((t) =>
              null == t ? null : Array.isArray(t) ? t.map(r) : r(t)
            );
          } else
            "*" === e
              ? (n = [null])
              : "string" == typeof e
              ? tt(e, 32)
                ? (n = [e])
                : ((r = t.interface.getEvent(e)),
                  _(r, "unknown fragment", "event", e),
                  (n = [r.topicHash]))
              : (s = e) &&
                "object" == typeof s &&
                "getTopicFilter" in s &&
                "function" == typeof s.getTopicFilter &&
                s.fragment
              ? (n = await e.getTopicFilter())
              : "fragment" in e
              ? ((r = e.fragment), (n = [r.topicHash]))
              : _(!1, "unknown event name", "event", e);
          var s;
          n = n.map((t) => {
            if (null == t) return null;
            if (Array.isArray(t)) {
              const e = Array.from(
                new Set(t.map((t) => t.toLowerCase())).values()
              );
              return 1 === e.length ? e[0] : (e.sort(), e);
            }
            return t.toLowerCase();
          });
          return {
            fragment: r,
            tag: n
              .map((t) =>
                null == t ? "null" : Array.isArray(t) ? t.join("|") : t
              )
              .join("&"),
            topics: n,
          };
        }
        async function _o(t, e) {
          const { subs: n } = zo(t);
          return n.get((await Ko(t, e)).tag) || null;
        }
        async function qo(t, e, n) {
          const r = Go(t.runner);
          K(
            r,
            "contract runner does not support subscribing",
            "UNSUPPORTED_OPERATION",
            { operation: e }
          );
          const { fragment: s, tag: i, topics: a } = await Ko(t, n),
            { addr: o, subs: c } = zo(t);
          let l = c.get(i);
          if (!l) {
            const e = { address: o || t, topics: a },
              u = (e) => {
                let r = s;
                if (null == r)
                  try {
                    r = t.interface.getEvent(e.topics[0]);
                  } catch (t) {}
                if (r) {
                  const i = r,
                    a = s
                      ? t.interface.decodeEventLog(s, e.data, e.topics)
                      : [];
                  Zo(t, n, a, (r) => new Oo(t, r, n, i, e));
                } else Zo(t, n, [], (r) => new To(t, r, n, e));
              };
            let h = [];
            (l = {
              tag: i,
              listeners: [],
              start: () => {
                h.length || h.push(r.on(e, u));
              },
              stop: async () => {
                if (0 == h.length) return;
                let t = h;
                (h = []), await Promise.all(t), r.off(e, u);
              },
            }),
              c.set(i, l);
          }
          return l;
        }
        let Wo = Promise.resolve();
        async function Zo(t, e, n, r) {
          try {
            await Wo;
          } catch (t) {}
          const s = (async function (t, e, n, r) {
            await Wo;
            const s = await _o(t, e);
            if (!s) return !1;
            const i = s.listeners.length;
            return (
              (s.listeners = s.listeners.filter(({ listener: e, once: s }) => {
                const i = Array.from(n);
                r && i.push(r(s ? null : e));
                try {
                  e.call(t, ...i);
                } catch (t) {}
                return !s;
              })),
              0 === s.listeners.length && (s.stop(), zo(t).subs.delete(s.tag)),
              i > 0
            );
          })(t, e, n, r);
          return (Wo = s), await s;
        }
        const Yo = ["then"];
        class Xo {
          target;
          interface;
          runner;
          filters;
          [Vo];
          fallback;
          constructor(t, e, n, r) {
            _(
              "string" == typeof t || jr(t),
              "invalid value for Contract target",
              "target",
              t
            ),
              null == n && (n = null);
            const s = go.from(e);
            let i;
            j(this, { target: t, runner: n, interface: s }),
              Object.defineProperty(this, Vo, { value: {} });
            let a = null,
              o = null;
            if (r) {
              const t = Go(n);
              o = new Bo(this.interface, t, r);
            }
            let c = new Map();
            if ("string" == typeof t)
              if (tt(t)) (a = t), (i = Promise.resolve(t));
              else {
                const e = Mo(n, "resolveName");
                if (!Lo(e))
                  throw z(
                    "contract runner does not support name resolution",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  );
                i = e.resolveName(t).then((e) => {
                  if (null == e)
                    throw z(
                      "an ENS name used for a contract target must be correctly configured",
                      "UNCONFIGURED_NAME",
                      { value: t }
                    );
                  return (zo(this).addr = e), e;
                });
              }
            else
              i = t.getAddress().then((t) => {
                if (null == t) throw new Error("TODO");
                return (zo(this).addr = t), t;
              });
            var l, u;
            (l = this),
              (u = { addrPromise: i, addr: a, deployTx: o, subs: c }),
              Jo.set(l[Vo], u);
            const h = new Proxy(
              {},
              {
                get: (t, e, n) => {
                  if (Yo.indexOf(e) >= 0) return Reflect.get(t, e, n);
                  const r = String(e),
                    s = this.getEvent(r);
                  if (s) return s;
                  throw new Error(`unknown contract event: ${r}`);
                },
                has: (t, e) =>
                  Yo.indexOf(e) >= 0
                    ? Reflect.has(t, e)
                    : Reflect.has(t, e) || this.interface.hasEvent(String(e)),
              }
            );
            return (
              j(this, { filters: h }),
              j(this, { fallback: s.receive || s.fallback ? jo(this) : null }),
              new Proxy(this, {
                get: (t, e, n) => {
                  if (e in t || Yo.indexOf(e) >= 0) return Reflect.get(t, e, n);
                  const r = String(e),
                    s = t.getFunction(r);
                  if (s) return s;
                  throw new Error(`unknown contract method: ${r}`);
                },
                has: (t, e) =>
                  e in t || Yo.indexOf(e) >= 0
                    ? Reflect.has(t, e)
                    : t.interface.hasFunction(String(e)),
              })
            );
          }
          connect(t) {
            return new Xo(this.target, this.interface, t);
          }
          attach(t) {
            return new Xo(t, this.interface, this.runner);
          }
          async getAddress() {
            return await zo(this).addrPromise;
          }
          async getDeployedCode() {
            const t = Go(this.runner);
            K(t, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
              operation: "getDeployedCode",
            });
            const e = await t.getCode(await this.getAddress());
            return "0x" === e ? null : e;
          }
          async waitForDeployment() {
            const t = this.deploymentTransaction();
            if (t) return await t.wait(), this;
            if (null != (await this.getDeployedCode())) return this;
            const e = Go(this.runner);
            return (
              K(
                null != e,
                "contract runner does not support .provider",
                "UNSUPPORTED_OPERATION",
                { operation: "waitForDeployment" }
              ),
              new Promise((t, n) => {
                const r = async () => {
                  try {
                    if (null != (await this.getDeployedCode())) return t(this);
                    e.once("block", r);
                  } catch (t) {
                    n(t);
                  }
                };
                r();
              })
            );
          }
          deploymentTransaction() {
            return zo(this).deployTx;
          }
          getFunction(t) {
            "string" != typeof t && (t = t.format());
            return Qo(this, t);
          }
          getEvent(t) {
            return (
              "string" != typeof t && (t = t.format()),
              (function (t, e) {
                const n = function (...n) {
                    const r = t.interface.getEvent(e, n);
                    return (
                      K(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                        operation: "fragment",
                      }),
                      r
                    );
                  },
                  r = function (...e) {
                    return new Do(t, n(...e), e);
                  };
                return (
                  j(r, {
                    name: t.interface.getEventName(e),
                    _contract: t,
                    _key: e,
                    getFragment: n,
                  }),
                  Object.defineProperty(r, "fragment", {
                    configurable: !1,
                    enumerable: !0,
                    get: () => {
                      const n = t.interface.getEvent(e);
                      return (
                        K(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                          operation: "fragment",
                        }),
                        n
                      );
                    },
                  }),
                  r
                );
              })(this, t)
            );
          }
          async queryTransaction(t) {
            throw new Error("@TODO");
          }
          async queryFilter(t, e, n) {
            null == e && (e = 0), null == n && (n = "latest");
            const { addr: r, addrPromise: s } = zo(this),
              i = r || (await s),
              { fragment: a, topics: o } = await Ko(this, t),
              c = { address: i, topics: o, fromBlock: e, toBlock: n },
              l = Go(this.runner);
            return (
              K(
                l,
                "contract runner does not have a provider",
                "UNSUPPORTED_OPERATION",
                { operation: "queryFilter" }
              ),
              (await l.getLogs(c)).map((t) => {
                let e = a;
                if (null == e)
                  try {
                    e = this.interface.getEvent(t.topics[0]);
                  } catch (t) {}
                return e ? new No(t, this.interface, e) : new Eo(t, l);
              })
            );
          }
          async on(t, e) {
            const n = await qo(this, "on", t);
            return n.listeners.push({ listener: e, once: !1 }), n.start(), this;
          }
          async once(t, e) {
            const n = await qo(this, "once", t);
            return n.listeners.push({ listener: e, once: !0 }), n.start(), this;
          }
          async emit(t, ...e) {
            return await Zo(this, t, e, null);
          }
          async listenerCount(t) {
            if (t) {
              const e = await _o(this, t);
              return e ? e.listeners.length : 0;
            }
            const { subs: e } = zo(this);
            let n = 0;
            for (const { listeners: t } of e.values()) n += t.length;
            return n;
          }
          async listeners(t) {
            if (t) {
              const e = await _o(this, t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            const { subs: e } = zo(this);
            let n = [];
            for (const { listeners: t } of e.values())
              n = n.concat(t.map(({ listener: t }) => t));
            return n;
          }
          async off(t, e) {
            const n = await _o(this, t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (null != e && 0 !== n.listeners.length) ||
                (n.stop(), zo(this).subs.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const e = await _o(this, t);
              if (!e) return this;
              e.stop(), zo(this).subs.delete(e.tag);
            } else {
              const { subs: t } = zo(this);
              for (const { tag: e, stop: n } of t.values()) n(), t.delete(e);
            }
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return await this.off(t, e);
          }
          static buildClass(t) {
            return class extends Xo {
              constructor(e, n = null) {
                super(e, t, n);
              }
            };
          }
          static from(t, e, n) {
            null == n && (n = null);
            return new this(t, e, n);
          }
        }
        class $o extends (function () {
          return Xo;
        })() {}
        function tc(t) {
          return (
            t.match(/^ipfs:\/\/ipfs\//i)
              ? (t = t.substring(12))
              : t.match(/^ipfs:\/\//i)
              ? (t = t.substring(7))
              : _(!1, "unsupported IPFS format", "link", t),
            `https://gateway.ipfs.io/ipfs/${t}`
          );
        }
        class ec {
          name;
          constructor(t) {
            j(this, { name: t });
          }
          connect(t) {
            return this;
          }
          supportsCoinType(t) {
            return !1;
          }
          async encodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
          async decodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
        }
        const nc = new RegExp("^(ipfs)://(.*)$", "i"),
          rc = [
            new RegExp("^(https)://(.*)$", "i"),
            new RegExp("^(data):(.*)$", "i"),
            nc,
            new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
          ];
        class sc {
          provider;
          address;
          name;
          #At;
          #bt;
          constructor(t, e, n) {
            j(this, { provider: t, address: e, name: n }),
              (this.#At = null),
              (this.#bt = new $o(
                e,
                [
                  "function supportsInterface(bytes4) view returns (bool)",
                  "function resolve(bytes, bytes) view returns (bytes)",
                  "function addr(bytes32) view returns (address)",
                  "function addr(bytes32, uint) view returns (bytes)",
                  "function text(bytes32, string) view returns (string)",
                  "function contenthash(bytes32) view returns (bytes)",
                ],
                t
              ));
          }
          async supportsWildcard() {
            return (
              null == this.#At &&
                (this.#At = (async () => {
                  try {
                    return await this.#bt.supportsInterface("0x9061b923");
                  } catch (t) {
                    if (V(t, "CALL_EXCEPTION")) return !1;
                    throw ((this.#At = null), t);
                  }
                })()),
              await this.#At
            );
          }
          async #vt(t, e) {
            e = (e || []).slice();
            const n = this.#bt.interface;
            e.unshift(Si(this.name));
            let r = null;
            var s;
            (await this.supportsWildcard()) &&
              ((r = n.getFunction(t)),
              K(r, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName: t },
              }),
              (e = [
                ((s = this.name),
                nt(
                  rt(
                    Oi(s).map((t) => {
                      if (t.length > 63)
                        throw new Error(
                          "invalid DNS encoded entry; length exceeds 63 bytes"
                        );
                      const e = new Uint8Array(t.length + 1);
                      return e.set(t, 1), (e[0] = e.length - 1), e;
                    })
                  )
                ) + "00"),
                n.encodeFunctionData(r, e),
              ]),
              (t = "resolve(bytes,bytes)")),
              e.push({ enableCcipRead: !0 });
            try {
              const s = await this.#bt[t](...e);
              return r ? n.decodeFunctionResult(r, s)[0] : s;
            } catch (t) {
              if (!V(t, "CALL_EXCEPTION")) throw t;
            }
            return null;
          }
          async getAddress(t) {
            if ((null == t && (t = 60), 60 === t))
              try {
                const t = await this.#vt("addr(bytes32)");
                return null == t || t === Er ? null : t;
              } catch (t) {
                if (V(t, "CALL_EXCEPTION")) return null;
                throw t;
              }
            if (t >= 0 && t < 2147483648) {
              let e = t + 2147483648;
              const n = await this.#vt("addr(bytes32,uint)", [e]);
              if (tt(n, 20)) return Hr(n);
            }
            let e = null;
            for (const n of this.provider.plugins)
              if (n instanceof ec && n.supportsCoinType(t)) {
                e = n;
                break;
              }
            if (null == e) return null;
            const n = await this.#vt("addr(bytes32,uint)", [t]);
            if (null == n || "0x" === n) return null;
            const r = await e.decodeAddress(t, n);
            if (null != r) return r;
            K(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${t})`,
              info: { coinType: t, data: n },
            });
          }
          async getText(t) {
            const e = await this.#vt("text(bytes32,string)", [t]);
            return null == e || "0x" === e ? null : e;
          }
          async getContentHash() {
            const t = await this.#vt("contenthash(bytes32)");
            if (null == t || "0x" === t) return null;
            const e = t.match(
              /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
            );
            if (e) {
              const t = "e3010170" === e[1] ? "ipfs" : "ipns",
                n = parseInt(e[4], 16);
              if (e[5].length === 2 * n)
                return `${t}://${(function (t) {
                  let e = mt(X(t)),
                    n = "";
                  for (; e; )
                    (n =
                      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"[
                        Number(e % vt)
                      ] + n),
                      (e /= vt);
                  return n;
                })("0x" + e[2])}`;
            }
            const n = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (n && 64 === n[1].length) return `bzz://${n[1]}`;
            K(
              !1,
              "invalid or unsupported content hash data",
              "UNSUPPORTED_OPERATION",
              { operation: "getContentHash()", info: { data: t } }
            );
          }
          async getAvatar() {
            return (await this._getAvatar()).url;
          }
          async _getAvatar() {
            const t = [{ type: "name", value: this.name }];
            try {
              const e = await this.getText("avatar");
              if (null == e)
                return (
                  t.push({ type: "!avatar", value: "" }),
                  { url: null, linkage: t }
                );
              t.push({ type: "avatar", value: e });
              for (let n = 0; n < rc.length; n++) {
                const r = e.match(rc[n]);
                if (null == r) continue;
                const s = r[1].toLowerCase();
                switch (s) {
                  case "https":
                  case "data":
                    return (
                      t.push({ type: "url", value: e }), { linkage: t, url: e }
                    );
                  case "ipfs": {
                    const n = tc(e);
                    return (
                      t.push({ type: "ipfs", value: e }),
                      t.push({ type: "url", value: n }),
                      { linkage: t, url: n }
                    );
                  }
                  case "erc721":
                  case "erc1155": {
                    const n =
                      "erc721" === s ? "tokenURI(uint256)" : "uri(uint256)";
                    t.push({ type: s, value: e });
                    const i = await this.getAddress();
                    if (null == i)
                      return (
                        t.push({ type: "!owner", value: "" }),
                        { url: null, linkage: t }
                      );
                    const a = (r[2] || "").split("/");
                    if (2 !== a.length)
                      return (
                        t.push({ type: `!${s}caip`, value: r[2] || "" }),
                        { url: null, linkage: t }
                      );
                    const o = a[1],
                      c = new $o(
                        a[0],
                        [
                          "function tokenURI(uint) view returns (string)",
                          "function ownerOf(uint) view returns (address)",
                          "function uri(uint) view returns (string)",
                          "function balanceOf(address, uint256) view returns (uint)",
                        ],
                        this.provider
                      );
                    if ("erc721" === s) {
                      const e = await c.ownerOf(o);
                      if (i !== e)
                        return (
                          t.push({ type: "!owner", value: e }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "owner", value: e });
                    } else if ("erc1155" === s) {
                      const e = await c.balanceOf(i, o);
                      if (!e)
                        return (
                          t.push({ type: "!balance", value: "0" }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "balance", value: e.toString() });
                    }
                    let l = await c[n](o);
                    if (null == l || "0x" === l)
                      return (
                        t.push({ type: "!metadata-url", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata-url-base", value: l }),
                      "erc1155" === s &&
                        ((l = l.replace("{id}", wt(o, 32).substring(2))),
                        t.push({ type: "metadata-url-expanded", value: l })),
                      l.match(/^ipfs:/i) && (l = tc(l)),
                      t.push({ type: "metadata-url", value: l });
                    let u = {};
                    const h = await new Dt(l).send();
                    h.assertOk();
                    try {
                      u = h.bodyJson;
                    } catch (e) {
                      try {
                        t.push({ type: "!metadata", value: h.bodyText });
                      } catch (e) {
                        const n = h.body;
                        return (
                          n && t.push({ type: "!metadata", value: nt(n) }),
                          { url: null, linkage: t }
                        );
                      }
                      return { url: null, linkage: t };
                    }
                    if (!u)
                      return (
                        t.push({ type: "!metadata", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata", value: JSON.stringify(u) });
                    let f = u.image;
                    if ("string" != typeof f)
                      return (
                        t.push({ type: "!imageUrl", value: "" }),
                        { url: null, linkage: t }
                      );
                    if (f.match(/^(https:\/\/|data:)/i));
                    else {
                      if (null == f.match(nc))
                        return (
                          t.push({ type: "!imageUrl-ipfs", value: f }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "imageUrl-ipfs", value: f }), (f = tc(f));
                    }
                    return (
                      t.push({ type: "url", value: f }), { linkage: t, url: f }
                    );
                  }
                }
              }
            } catch (t) {}
            return { linkage: t, url: null };
          }
          static async getEnsAddress(t) {
            const e = await t.getNetwork(),
              n = e.getPlugin("org.ethers.plugins.network.Ens");
            return (
              K(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                operation: "getEnsAddress",
                info: { network: e },
              }),
              n.address
            );
          }
          static async #Et(t, e) {
            const n = await sc.getEnsAddress(t);
            try {
              const r = new $o(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  t
                ),
                s = await r.resolver(Si(e), { enableCcipRead: !0 });
              return s === Er ? null : s;
            } catch (t) {
              throw t;
            }
            return null;
          }
          static async fromName(t, e) {
            let n = e;
            for (;;) {
              if ("" === n || "." === n) return null;
              if ("eth" !== e && "eth" === n) return null;
              const r = await sc.#Et(t, n);
              if (null != r) {
                const s = new sc(t, r, e);
                return n === e || (await s.supportsWildcard()) ? s : null;
              }
              n = n.split(".").slice(1).join(".");
            }
          }
        }
        const ic = BigInt(0);
        function ac(t, e) {
          return function (n) {
            return null == n ? e : t(n);
          };
        }
        function oc(t) {
          return (e) => {
            if (!Array.isArray(e)) throw new Error("not an array");
            return e.map((e) => t(e));
          };
        }
        function cc(t, e) {
          return (n) => {
            const r = {};
            for (const s in t) {
              let i = s;
              if (e && s in e && !(i in n))
                for (const t of e[s])
                  if (t in n) {
                    i = t;
                    break;
                  }
              try {
                const e = t[s](n[i]);
                void 0 !== e && (r[s] = e);
              } catch (t) {
                K(
                  !1,
                  `invalid value for value.${s} (${
                    t instanceof Error ? t.message : "not-an-error"
                  })`,
                  "BAD_DATA",
                  { value: n }
                );
              }
            }
            return r;
          };
        }
        function lc(t) {
          return _(tt(t, !0), "invalid data", "value", t), t;
        }
        function uc(t) {
          return _(tt(t, 32), "invalid hash", "value", t), t;
        }
        const hc = cc(
          {
            address: Hr,
            blockHash: uc,
            blockNumber: yt,
            data: lc,
            index: yt,
            removed: ac(function (t) {
              switch (t) {
                case !0:
                case "true":
                  return !0;
                case !1:
                case "false":
                  return !1;
              }
              _(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
            }, !1),
            topics: oc(uc),
            transactionHash: uc,
            transactionIndex: yt,
          },
          { index: ["logIndex"] }
        );
        const fc = cc({
          hash: ac(uc),
          parentHash: uc,
          number: yt,
          timestamp: yt,
          nonce: ac(lc),
          difficulty: dt,
          gasLimit: dt,
          gasUsed: dt,
          miner: ac(Hr),
          extraData: lc,
          baseFeePerGas: ac(dt),
        });
        const dc = cc(
          {
            transactionIndex: yt,
            blockNumber: yt,
            transactionHash: uc,
            address: Hr,
            topics: oc(uc),
            data: lc,
            index: yt,
            blockHash: uc,
          },
          { index: ["logIndex"] }
        );
        const pc = cc(
          {
            to: ac(Hr, null),
            from: ac(Hr, null),
            contractAddress: ac(Hr, null),
            index: yt,
            root: ac(nt),
            gasUsed: dt,
            logsBloom: ac(lc),
            blockHash: uc,
            hash: uc,
            logs: oc(function (t) {
              return dc(t);
            }),
            blockNumber: yt,
            cumulativeGasUsed: dt,
            effectiveGasPrice: ac(dt),
            status: ac(yt),
            type: ac(yt, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
        function gc(t) {
          t.to &&
            dt(t.to) === ic &&
            (t.to = "0x0000000000000000000000000000000000000000");
          const e = cc(
            {
              hash: uc,
              type: (t) => ("0x" === t || null == t ? 0 : yt(t)),
              accessList: ac(Ui, null),
              blockHash: ac(uc, null),
              blockNumber: ac(yt, null),
              transactionIndex: ac(yt, null),
              from: Hr,
              gasPrice: ac(dt),
              maxPriorityFeePerGas: ac(dt),
              maxFeePerGas: ac(dt),
              gasLimit: dt,
              to: ac(Hr, null),
              value: dt,
              nonce: yt,
              data: lc,
              creates: ac(Hr, null),
              chainId: ac(dt, null),
            },
            { data: ["input"], gasLimit: ["gas"] }
          )(t);
          if (
            (null == e.to &&
              null == e.creates &&
              (e.creates = (function (t) {
                const e = Hr(t.from);
                let n = dt(t.nonce, "tx.nonce").toString(16);
                return (
                  (n = "0" === n ? "0x" : n.length % 2 ? "0x0" + n : "0x" + n),
                  Hr(it(An(se([e, n])), 12))
                );
              })(e)),
            (1 !== t.type && 2 !== t.type) ||
              null != t.accessList ||
              (e.accessList = []),
            t.signature
              ? (e.signature = Sr.from(t.signature))
              : (e.signature = Sr.from(t)),
            null == e.chainId)
          ) {
            const t = e.signature.legacyChainId;
            null != t && (e.chainId = t);
          }
          return (
            e.blockHash && dt(e.blockHash) === ic && (e.blockHash = null), e
          );
        }
        class mc {
          name;
          constructor(t) {
            j(this, { name: t });
          }
          clone() {
            return new mc(this.name);
          }
        }
        class yc extends mc {
          effectiveBlock;
          txBase;
          txCreate;
          txDataZero;
          txDataNonzero;
          txAccessListStorageKey;
          txAccessListAddress;
          constructor(t, e) {
            null == t && (t = 0),
              super(`org.ethers.network.plugins.GasCost#${t || 0}`);
            const n = { effectiveBlock: t };
            function r(t, r) {
              let s = (e || {})[t];
              null == s && (s = r),
                _("number" == typeof s, `invalud value for ${t}`, "costs", e),
                (n[t] = s);
            }
            r("txBase", 21e3),
              r("txCreate", 32e3),
              r("txDataZero", 4),
              r("txDataNonzero", 16),
              r("txAccessListStorageKey", 1900),
              r("txAccessListAddress", 2400),
              j(this, n);
          }
          clone() {
            return new yc(this.effectiveBlock, this);
          }
        }
        class wc extends mc {
          address;
          targetNetwork;
          constructor(t, e) {
            super("org.ethers.plugins.network.Ens"),
              j(this, {
                address: t || "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                targetNetwork: null == e ? 1 : e,
              });
          }
          clone() {
            return new wc(this.address, this.targetNetwork);
          }
        }
        const Ac = new Map();
        class bc {
          #xt;
          #Y;
          #Pt;
          constructor(t, e) {
            (this.#xt = t), (this.#Y = dt(e)), (this.#Pt = new Map());
          }
          toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
          }
          get name() {
            return this.#xt;
          }
          set name(t) {
            this.#xt = t;
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = dt(t, "chainId");
          }
          matches(t) {
            if (null == t) return !1;
            if ("string" == typeof t) {
              try {
                return this.chainId === dt(t);
              } catch (t) {}
              return this.name === t;
            }
            if ("number" == typeof t || "bigint" == typeof t) {
              try {
                return this.chainId === dt(t);
              } catch (t) {}
              return !1;
            }
            if ("object" == typeof t) {
              if (null != t.chainId) {
                try {
                  return this.chainId === dt(t.chainId);
                } catch (t) {}
                return !1;
              }
              return null != t.name && this.name === t.name;
            }
            return !1;
          }
          get plugins() {
            return Array.from(this.#Pt.values());
          }
          attachPlugin(t) {
            if (this.#Pt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#Pt.set(t.name, t.clone()), this;
          }
          getPlugin(t) {
            return this.#Pt.get(t) || null;
          }
          getPlugins(t) {
            return this.plugins.filter((e) => e.name.split("#")[0] === t);
          }
          clone() {
            const t = new bc(this.name, this.chainId);
            return (
              this.plugins.forEach((e) => {
                t.attachPlugin(e.clone());
              }),
              t
            );
          }
          computeIntrinsicGas(t) {
            const e =
              this.getPlugin("org.ethers.plugins.network.GasCost") || new yc();
            let n = e.txBase;
            if ((null == t.to && (n += e.txCreate), t.data))
              for (let r = 2; r < t.data.length; r += 2)
                "00" === t.data.substring(r, r + 2)
                  ? (n += e.txDataZero)
                  : (n += e.txDataNonzero);
            if (t.accessList) {
              const r = Ui(t.accessList);
              for (const t in r)
                n +=
                  e.txAccessListAddress +
                  e.txAccessListStorageKey * r[t].storageKeys.length;
            }
            return n;
          }
          static from(t) {
            if (
              ((function () {
                if (vc) return;
                function t(t, e, n) {
                  const r = function () {
                    const r = new bc(t, e);
                    return (
                      null != n.ensNetwork &&
                        r.attachPlugin(new wc(null, n.ensNetwork)),
                      n.priorityFee,
                      r.attachPlugin(new yc()),
                      r
                    );
                  };
                  bc.register(t, r),
                    bc.register(e, r),
                    n.altNames &&
                      n.altNames.forEach((t) => {
                        bc.register(t, r);
                      });
                }
                (vc = !0),
                  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
                  t("ropsten", 3, { ensNetwork: 3 }),
                  t("rinkeby", 4, { ensNetwork: 4 }),
                  t("goerli", 5, { ensNetwork: 5 }),
                  t("kovan", 42, { ensNetwork: 42 }),
                  t("sepolia", 11155111, {}),
                  t("classic", 61, {}),
                  t("classicKotti", 6, {}),
                  t("xdai", 100, { ensNetwork: 1 }),
                  t("optimism", 10, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api-optimistic.etherscan.io/" },
                  }),
                  t("optimism-goerli", 420, {
                    etherscan: {
                      url: "https://api-goerli-optimistic.etherscan.io/",
                    },
                  }),
                  t("arbitrum", 42161, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.arbiscan.io/" },
                  }),
                  t("arbitrum-goerli", 421613, {
                    etherscan: { url: "https://api-goerli.arbiscan.io/" },
                  }),
                  t("matic", 137, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.polygonscan.com/" },
                  }),
                  t("matic-mumbai", 80001, {
                    altNames: ["maticMumbai", "maticmum"],
                    etherscan: { url: "https://api-testnet.polygonscan.com/" },
                  }),
                  t("bnb", 56, {
                    ensNetwork: 1,
                    etherscan: { url: "http://api.bscscan.com" },
                  }),
                  t("bnbt", 97, {
                    etherscan: { url: "http://api-testnet.bscscan.com" },
                  });
              })(),
              null == t)
            )
              return bc.from("mainnet");
            if (
              ("number" == typeof t && (t = BigInt(t)),
              "string" == typeof t || "bigint" == typeof t)
            ) {
              const e = Ac.get(t);
              if (e) return e();
              if ("bigint" == typeof t) return new bc("unknown", t);
              _(!1, "unknown network", "network", t);
            }
            if ("function" == typeof t.clone) {
              return t.clone();
            }
            if ("object" == typeof t) {
              _(
                "string" == typeof t.name && "number" == typeof t.chainId,
                "invalid network object name or chainId",
                "network",
                t
              );
              const e = new bc(t.name, t.chainId);
              return (
                (t.ensAddress || null != t.ensNetwork) &&
                  e.attachPlugin(new wc(t.ensAddress, t.ensNetwork)),
                e
              );
            }
            _(!1, "invalid network", "network", t);
          }
          static register(t, e) {
            "number" == typeof t && (t = BigInt(t));
            const n = Ac.get(t);
            n &&
              _(
                !1,
                `conflicting network for ${JSON.stringify(n.name)}`,
                "nameOrChainId",
                t
              ),
              Ac.set(t, e);
          }
        }
        let vc = !1;
        function Ec(t) {
          return JSON.parse(JSON.stringify(t));
        }
        class xc {
          #kt;
          #Ct;
          #Nt;
          #It;
          constructor(t) {
            (this.#kt = t),
              (this.#Ct = null),
              (this.#Nt = 4e3),
              (this.#It = -2);
          }
          get pollingInterval() {
            return this.#Nt;
          }
          set pollingInterval(t) {
            this.#Nt = t;
          }
          async #Bt() {
            try {
              const t = await this.#kt.getBlockNumber();
              if (-2 === this.#It) return void (this.#It = t);
              if (t !== this.#It) {
                for (let e = this.#It + 1; e <= t; e++) {
                  if (null == this.#Ct) return;
                  await this.#kt.emit("block", e);
                }
                this.#It = t;
              }
            } catch (t) {}
            null != this.#Ct &&
              (this.#Ct = this.#kt._setTimeout(this.#Bt.bind(this), this.#Nt));
          }
          start() {
            this.#Ct ||
              ((this.#Ct = this.#kt._setTimeout(this.#Bt.bind(this), this.#Nt)),
              this.#Bt());
          }
          stop() {
            this.#Ct && (this.#kt._clearTimeout(this.#Ct), (this.#Ct = null));
          }
          pause(t) {
            this.stop(), t && (this.#It = -2);
          }
          resume() {
            this.start();
          }
        }
        class Pc {
          #kt;
          #Bt;
          #Tt;
          constructor(t) {
            (this.#kt = t),
              (this.#Tt = !1),
              (this.#Bt = (t) => {
                this._poll(t, this.#kt);
              });
          }
          async _poll(t, e) {
            throw new Error("sub-classes must override this");
          }
          start() {
            this.#Tt ||
              ((this.#Tt = !0), this.#Bt(-2), this.#kt.on("block", this.#Bt));
          }
          stop() {
            this.#Tt && ((this.#Tt = !1), this.#kt.off("block", this.#Bt));
          }
          pause(t) {
            this.stop();
          }
          resume() {
            this.start();
          }
        }
        class kc extends Pc {
          #wt;
          constructor(t, e) {
            super(t), (this.#wt = Ec(e));
          }
          async _poll(t, e) {
            throw new Error("@TODO");
          }
        }
        class Cc extends Pc {
          #Ot;
          constructor(t, e) {
            super(t), (this.#Ot = e);
          }
          async _poll(t, e) {
            const n = await e.getTransactionReceipt(this.#Ot);
            n && e.emit(this.#Ot, n);
          }
        }
        class Nc {
          #kt;
          #wt;
          #Ct;
          #Tt;
          #It;
          constructor(t, e) {
            (this.#kt = t),
              (this.#wt = Ec(e)),
              (this.#Ct = this.#Bt.bind(this)),
              (this.#Tt = !1),
              (this.#It = -2);
          }
          async #Bt(t) {
            if (-2 === this.#It) return;
            const e = Ec(this.#wt);
            (e.fromBlock = this.#It + 1), (e.toBlock = t);
            const n = await this.#kt.getLogs(e);
            if (0 !== n.length)
              for (const t of n)
                this.#kt.emit(this.#wt, t), (this.#It = t.blockNumber);
            else this.#It < t - 60 && (this.#It = t - 60);
          }
          start() {
            this.#Tt ||
              ((this.#Tt = !0),
              -2 === this.#It &&
                this.#kt.getBlockNumber().then((t) => {
                  this.#It = t;
                }),
              this.#kt.on("block", this.#Ct));
          }
          stop() {
            this.#Tt && ((this.#Tt = !1), this.#kt.off("block", this.#Ct));
          }
          pause(t) {
            this.stop(), t && (this.#It = -2);
          }
          resume() {
            this.start();
          }
        }
        const Ic = BigInt(2);
        function Bc(t) {
          return t && "function" == typeof t.then;
        }
        function Tc(t, e) {
          return (
            t +
            ":" +
            JSON.stringify(e, (t, e) => {
              if (null == e) return "null";
              if ("bigint" == typeof e) return `bigint:${e.toString()}`;
              if ("string" == typeof e) return e.toLowerCase();
              if ("object" == typeof e && !Array.isArray(e)) {
                const t = Object.keys(e);
                return t.sort(), t.reduce((t, n) => ((t[n] = e[n]), t), {});
              }
              return e;
            })
          );
        }
        class Oc {
          name;
          constructor(t) {
            j(this, { name: t });
          }
          start() {}
          stop() {}
          pause(t) {}
          resume() {}
        }
        function Sc(t) {
          return (t = Array.from(new Set(t).values())).sort(), t;
        }
        async function Rc(t, e) {
          if (null == t) throw new Error("invalid event");
          if ((Array.isArray(t) && (t = { topics: t }), "string" == typeof t))
            switch (t) {
              case "block":
              case "pending":
              case "debug":
              case "error":
              case "network":
                return { type: t, tag: t };
            }
          if (tt(t, 32)) {
            const e = t.toLowerCase();
            return { type: "transaction", tag: Tc("tx", { hash: e }), hash: e };
          }
          if (t.orphan) {
            const e = t;
            return {
              type: "orphan",
              tag: Tc("orphan", e),
              filter: ((n = e), JSON.parse(JSON.stringify(n))),
            };
          }
          var n;
          if (t.address || t.topics) {
            const n = t,
              r = {
                topics: (n.topics || []).map((t) =>
                  null == t
                    ? null
                    : Array.isArray(t)
                    ? Sc(t.map((t) => t.toLowerCase()))
                    : t.toLowerCase()
                ),
              };
            if (n.address) {
              const t = [],
                s = [],
                i = (n) => {
                  tt(n)
                    ? t.push(n)
                    : s.push(
                        (async () => {
                          t.push(await Vr(n, e));
                        })()
                      );
                };
              Array.isArray(n.address) ? n.address.forEach(i) : i(n.address),
                s.length && (await Promise.all(s)),
                (r.address = Sc(t.map((t) => t.toLowerCase())));
            }
            return { filter: r, tag: Tc("event", r), type: "event" };
          }
          _(!1, "unknown ProviderEvent", "event", t);
        }
        function Uc() {
          return new Date().getTime();
        }
        const Lc = { cacheTimeout: 250 };
        class Fc {
          #St;
          #Pt;
          #Rt;
          #Ut;
          #Lt;
          #Ft;
          #Dt;
          #Mt;
          #Gt;
          #Ht;
          #jt;
          #Q;
          constructor(t, e) {
            if (((this.#Q = Object.assign({}, Lc, e || {})), "any" === t))
              (this.#Ft = !0), (this.#Lt = null);
            else if (t) {
              const e = bc.from(t);
              (this.#Ft = !1),
                (this.#Lt = Promise.resolve(e)),
                setTimeout(() => {
                  this.emit("network", e, null);
                }, 0);
            } else (this.#Ft = !1), (this.#Lt = null);
            (this.#Mt = -1),
              (this.#Dt = new Map()),
              (this.#St = new Map()),
              (this.#Pt = new Map()),
              (this.#Rt = null),
              (this.#Ut = !1),
              (this.#Gt = 1),
              (this.#Ht = new Map()),
              (this.#jt = !1);
          }
          get provider() {
            return this;
          }
          get plugins() {
            return Array.from(this.#Pt.values());
          }
          attachPlugin(t) {
            if (this.#Pt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#Pt.set(t.name, t.connect(this)), this;
          }
          getPlugin(t) {
            return this.#Pt.get(t) || null;
          }
          get disableCcipRead() {
            return this.#jt;
          }
          set disableCcipRead(t) {
            this.#jt = !!t;
          }
          async #Qt(t) {
            const e = this.#Q.cacheTimeout;
            if (e < 0) return await this._perform(t);
            const n = Tc(t.method, t);
            let r = this.#Dt.get(n);
            return (
              r ||
                ((r = this._perform(t)),
                this.#Dt.set(n, r),
                setTimeout(() => {
                  this.#Dt.get(n) === r && this.#Dt.delete(n);
                }, e)),
              await r
            );
          }
          async ccipReadFetch(t, e, n) {
            if (this.disableCcipRead || 0 === n.length || null == t.to)
              return null;
            const r = t.to.toLowerCase(),
              s = e.toLowerCase(),
              i = [];
            for (let e = 0; e < n.length; e++) {
              const a = n[e],
                o = a.replace("{sender}", r).replace("{data}", s),
                c = new Dt(o);
              -1 === a.indexOf("{data}") && (c.body = { data: s, sender: r }),
                this.emit("debug", {
                  action: "sendCcipReadFetchRequest",
                  request: c,
                  index: e,
                  urls: n,
                });
              let l = "unknown error";
              const u = await c.send();
              try {
                const t = u.bodyJson;
                if (t.data)
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadFetchResult",
                      request: c,
                      result: t,
                    }),
                    t.data
                  );
                t.message && (l = t.message),
                  this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: c,
                    result: t,
                  });
              } catch (t) {}
              K(
                u.statusCode < 400 || u.statusCode >= 500,
                `response not found during CCIP fetch: ${l}`,
                "OFFCHAIN_FAULT",
                {
                  reason: "404_MISSING_RESOURCE",
                  transaction: t,
                  info: { url: a, errorMessage: l },
                }
              ),
                i.push(l);
            }
            K(
              !1,
              `error encountered during CCIP fetch: ${i
                .map((t) => JSON.stringify(t))
                .join(", ")}`,
              "OFFCHAIN_FAULT",
              {
                reason: "500_SERVER_ERROR",
                transaction: t,
                info: { urls: n, errorMessages: i },
              }
            );
          }
          _wrapBlock(t, e) {
            return new vo(
              (function (t) {
                const e = fc(t);
                return (
                  (e.transactions = t.transactions.map((t) =>
                    "string" == typeof t ? t : gc(t)
                  )),
                  e
                );
              })(t),
              this
            );
          }
          _wrapLog(t, e) {
            return new Eo(
              (function (t) {
                return hc(t);
              })(t),
              this
            );
          }
          _wrapTransactionReceipt(t, e) {
            return new xo(
              (function (t) {
                return pc(t);
              })(t),
              this
            );
          }
          _wrapTransactionResponse(t, e) {
            return new Po(gc(t), this);
          }
          _detectNetwork() {
            K(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
              operation: "_detectNetwork",
            });
          }
          async _perform(t) {
            K(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
              operation: t.method,
              info: t,
            });
          }
          async getBlockNumber() {
            const t = yt(
              await this.#Qt({ method: "getBlockNumber" }),
              "%response"
            );
            return this.#Mt >= 0 && (this.#Mt = t), t;
          }
          _getAddress(t) {
            return Vr(t, this);
          }
          _getBlockTag(t) {
            if (null == t) return "latest";
            switch (t) {
              case "earliest":
                return "0x0";
              case "latest":
              case "pending":
              case "safe":
              case "finalized":
                return t;
            }
            return tt(t)
              ? tt(t, 32)
                ? t
                : bt(t)
              : ("bigint" == typeof t && (t = yt(t, "blockTag")),
                "number" == typeof t
                  ? t >= 0
                    ? bt(t)
                    : this.#Mt >= 0
                    ? bt(this.#Mt + t)
                    : this.getBlockNumber().then((e) => bt(e + t))
                  : void _(!1, "invalid blockTag", "blockTag", t));
          }
          _getFilter(t) {
            const e = (t.topics || []).map((t) =>
                null == t
                  ? null
                  : Array.isArray(t)
                  ? Sc(t.map((t) => t.toLowerCase()))
                  : t.toLowerCase()
              ),
              n = "blockHash" in t ? t.blockHash : void 0,
              r = (t, r, s) => {
                let i;
                switch (t.length) {
                  case 0:
                    break;
                  case 1:
                    i = t[0];
                    break;
                  default:
                    t.sort(), (i = t);
                }
                if (n && (null != r || null != s))
                  throw new Error("invalid filter");
                const a = {};
                return (
                  i && (a.address = i),
                  e.length && (a.topics = e),
                  r && (a.fromBlock = r),
                  s && (a.toBlock = s),
                  n && (a.blockHash = n),
                  a
                );
              };
            let s,
              i,
              a = [];
            if (t.address)
              if (Array.isArray(t.address))
                for (const e of t.address) a.push(this._getAddress(e));
              else a.push(this._getAddress(t.address));
            return (
              "fromBlock" in t && (s = this._getBlockTag(t.fromBlock)),
              "toBlock" in t && (i = this._getBlockTag(t.toBlock)),
              a.filter((t) => "string" != typeof t).length ||
              (null != s && "string" != typeof s) ||
              (null != i && "string" != typeof i)
                ? Promise.all([Promise.all(a), s, i]).then((t) =>
                    r(t[0], t[1], t[2])
                  )
                : r(a, s, i)
            );
          }
          _getTransactionRequest(t) {
            const e = bo(t),
              n = [];
            if (
              (["to", "from"].forEach((t) => {
                if (null == e[t]) return;
                const r = Vr(e[t]);
                Bc(r)
                  ? n.push(
                      (async function () {
                        e[t] = await r;
                      })()
                    )
                  : (e[t] = r);
              }),
              null != e.blockTag)
            ) {
              const t = this._getBlockTag(e.blockTag);
              Bc(t)
                ? n.push(
                    (async function () {
                      e.blockTag = await t;
                    })()
                  )
                : (e.blockTag = t);
            }
            return n.length
              ? (async function () {
                  return await Promise.all(n), e;
                })()
              : e;
          }
          async getNetwork() {
            if (null == this.#Lt) {
              const t = this._detectNetwork().then(
                (t) => (this.emit("network", t, null), t),
                (e) => {
                  throw (this.#Lt === t && (this.#Lt = null), e);
                }
              );
              return (this.#Lt = t), (await t).clone();
            }
            const t = this.#Lt,
              [e, n] = await Promise.all([t, this._detectNetwork()]);
            return (
              e.chainId !== n.chainId &&
                (this.#Ft
                  ? (this.emit("network", n, e),
                    this.#Lt === t && (this.#Lt = Promise.resolve(n)))
                  : K(
                      !1,
                      `network changed: ${e.chainId} => ${n.chainId} `,
                      "NETWORK_ERROR",
                      { event: "changed" }
                    )),
              e.clone()
            );
          }
          async getFeeData() {
            const { block: t, gasPrice: e } = await H({
              block: this.getBlock("latest"),
              gasPrice: (async () => {
                try {
                  return dt(
                    await this.#Qt({ method: "getGasPrice" }),
                    "%response"
                  );
                } catch (t) {}
                return null;
              })(),
            });
            let n = null,
              r = null;
            return (
              t &&
                t.baseFeePerGas &&
                ((r = BigInt("1000000000")), (n = t.baseFeePerGas * Ic + r)),
              new Ao(e, n, r)
            );
          }
          async estimateGas(t) {
            let e = this._getTransactionRequest(t);
            return (
              Bc(e) && (e = await e),
              dt(
                await this.#Qt({ method: "estimateGas", transaction: e }),
                "%response"
              )
            );
          }
          async #Vt(t, e, n) {
            K(
              n < 10,
              "CCIP read exceeded maximum redirections",
              "OFFCHAIN_FAULT",
              {
                reason: "TOO_MANY_REDIRECTS",
                transaction: Object.assign({}, t, {
                  blockTag: e,
                  enableCcipRead: !0,
                }),
              }
            );
            const r = bo(t);
            try {
              return nt(
                await this._perform({
                  method: "call",
                  transaction: r,
                  blockTag: e,
                })
              );
            } catch (t) {
              if (
                !this.disableCcipRead &&
                J(t) &&
                t.data &&
                n >= 0 &&
                "latest" === e &&
                null != r.to &&
                "0x556f1830" === it(t.data, 0, 4)
              ) {
                const s = t.data,
                  i = await Vr(r.to, this);
                let a;
                try {
                  a = (function (t) {
                    const e = {
                      sender: "",
                      urls: [],
                      calldata: "",
                      selector: "",
                      extraData: "",
                      errorArgs: [],
                    };
                    K(
                      st(t) >= 160,
                      "insufficient OffchainLookup data",
                      "OFFCHAIN_FAULT",
                      { reason: "insufficient OffchainLookup data" }
                    );
                    const n = it(t, 0, 32);
                    K(
                      it(n, 0, 12) === it(Vc, 0, 12),
                      "corrupt OffchainLookup sender",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup sender" }
                    ),
                      (e.sender = it(n, 12));
                    try {
                      const n = [],
                        r = yt(it(t, 32, 64)),
                        s = yt(it(t, r, r + 32)),
                        i = it(t, r + 32);
                      for (let t = 0; t < s; t++) {
                        const e = Dc(i, 32 * t);
                        if (null == e) throw new Error("abort");
                        n.push(e);
                      }
                      e.urls = n;
                    } catch (t) {
                      K(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
                        reason: "corrupt OffchainLookup urls",
                      });
                    }
                    try {
                      const n = Mc(t, 64);
                      if (null == n) throw new Error("abort");
                      e.calldata = n;
                    } catch (t) {
                      K(
                        !1,
                        "corrupt OffchainLookup calldata",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup calldata" }
                      );
                    }
                    K(
                      it(t, 100, 128) === it(Vc, 0, 28),
                      "corrupt OffchainLookup callbaackSelector",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup callbaackSelector" }
                    ),
                      (e.selector = it(t, 96, 100));
                    try {
                      const n = Mc(t, 128);
                      if (null == n) throw new Error("abort");
                      e.extraData = n;
                    } catch (t) {
                      K(
                        !1,
                        "corrupt OffchainLookup extraData",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup extraData" }
                      );
                    }
                    return (
                      (e.errorArgs = "sender,urls,calldata,selector,extraData"
                        .split(/,/)
                        .map((t) => e[t])),
                      e
                    );
                  })(it(t.data, 4));
                } catch (t) {
                  K(!1, t.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: r,
                    info: { data: s },
                  });
                }
                K(
                  a.sender.toLowerCase() === i.toLowerCase(),
                  "CCIP Read sender mismatch",
                  "CALL_EXCEPTION",
                  {
                    action: "call",
                    data: s,
                    reason: "OffchainLookup",
                    transaction: r,
                    invocation: null,
                    revert: {
                      signature:
                        "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      name: "OffchainLookup",
                      args: a.errorArgs,
                    },
                  }
                );
                const o = await this.ccipReadFetch(r, a.calldata, a.urls);
                K(
                  null != o,
                  "CCIP Read failed to fetch data",
                  "OFFCHAIN_FAULT",
                  {
                    reason: "FETCH_FAILED",
                    transaction: r,
                    info: { data: t.data, errorArgs: a.errorArgs },
                  }
                );
                const c = {
                  to: i,
                  data: rt([a.selector, Qc([o, a.extraData])]),
                };
                this.emit("debug", {
                  action: "sendCcipReadCall",
                  transaction: c,
                });
                try {
                  const t = await this.#Vt(c, e, n + 1);
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadCallResult",
                      transaction: Object.assign({}, c),
                      result: t,
                    }),
                    t
                  );
                } catch (t) {
                  throw (
                    (this.emit("debug", {
                      action: "receiveCcipReadCallError",
                      transaction: Object.assign({}, c),
                      error: t,
                    }),
                    t)
                  );
                }
              }
              throw t;
            }
          }
          async #Jt(t) {
            const { value: e } = await H({
              network: this.getNetwork(),
              value: t,
            });
            return e;
          }
          async call(t) {
            const { tx: e, blockTag: n } = await H({
              tx: this._getTransactionRequest(t),
              blockTag: this._getBlockTag(t.blockTag),
            });
            return await this.#Jt(this.#Vt(e, n, t.enableCcipRead ? 0 : -1));
          }
          async #zt(t, e, n) {
            let r = this._getAddress(e),
              s = this._getBlockTag(n);
            return (
              ("string" == typeof r && "string" == typeof s) ||
                ([r, s] = await Promise.all([r, s])),
              await this.#Jt(
                this.#Qt(Object.assign(t, { address: r, blockTag: s }))
              )
            );
          }
          async getBalance(t, e) {
            return dt(
              await this.#zt({ method: "getBalance" }, t, e),
              "%response"
            );
          }
          async getTransactionCount(t, e) {
            return yt(
              await this.#zt({ method: "getTransactionCount" }, t, e),
              "%response"
            );
          }
          async getCode(t, e) {
            return nt(await this.#zt({ method: "getCode" }, t, e));
          }
          async getStorage(t, e, n) {
            const r = dt(e, "position");
            return nt(
              await this.#zt({ method: "getStorage", position: r }, t, n)
            );
          }
          async broadcastTransaction(t) {
            const {
                blockNumber: e,
                hash: n,
                network: r,
              } = await H({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                  method: "broadcastTransaction",
                  signedTransaction: t,
                }),
                network: this.getNetwork(),
              }),
              s = Xi.from(t);
            if (s.hash !== n)
              throw new Error("@TODO: the returned hash did not match");
            return this._wrapTransactionResponse(s, r).replaceableTransaction(
              e
            );
          }
          async #Kt(t, e) {
            if (tt(t, 32))
              return await this.#Qt({
                method: "getBlock",
                blockHash: t,
                includeTransactions: e,
              });
            let n = this._getBlockTag(t);
            return (
              "string" != typeof n && (n = await n),
              await this.#Qt({
                method: "getBlock",
                blockTag: n,
                includeTransactions: e,
              })
            );
          }
          async getBlock(t, e) {
            const { network: n, params: r } = await H({
              network: this.getNetwork(),
              params: this.#Kt(t, !!e),
            });
            return null == r ? null : this._wrapBlock(r, n);
          }
          async getTransaction(t) {
            const { network: e, params: n } = await H({
              network: this.getNetwork(),
              params: this.#Qt({ method: "getTransaction", hash: t }),
            });
            return null == n ? null : this._wrapTransactionResponse(n, e);
          }
          async getTransactionReceipt(t) {
            const { network: e, params: n } = await H({
              network: this.getNetwork(),
              params: this.#Qt({ method: "getTransactionReceipt", hash: t }),
            });
            if (null == n) return null;
            if (null == n.gasPrice && null == n.effectiveGasPrice) {
              const e = await this.#Qt({ method: "getTransaction", hash: t });
              if (null == e)
                throw new Error(
                  "report this; could not find tx or effectiveGasPrice"
                );
              n.effectiveGasPrice = e.gasPrice;
            }
            return this._wrapTransactionReceipt(n, e);
          }
          async getTransactionResult(t) {
            const { result: e } = await H({
              network: this.getNetwork(),
              result: this.#Qt({ method: "getTransactionResult", hash: t }),
            });
            return null == e ? null : nt(e);
          }
          async getLogs(t) {
            let e = this._getFilter(t);
            Bc(e) && (e = await e);
            const { network: n, params: r } = await H({
              network: this.getNetwork(),
              params: this.#Qt({ method: "getLogs", filter: e }),
            });
            return r.map((t) => this._wrapLog(t, n));
          }
          _getProvider(t) {
            K(
              !1,
              "provider cannot connect to target network",
              "UNSUPPORTED_OPERATION",
              { operation: "_getProvider()" }
            );
          }
          async getResolver(t) {
            return await sc.fromName(this, t);
          }
          async getAvatar(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAvatar() : null;
          }
          async resolveName(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAddress() : null;
          }
          async lookupAddress(t) {
            const e = Si(
              (t = Hr(t)).substring(2).toLowerCase() + ".addr.reverse"
            );
            try {
              const n = await sc.getEnsAddress(this),
                r = new $o(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  this
                ),
                s = await r.resolver(e);
              if (null == s || s === Er) return null;
              const i = new $o(
                  s,
                  ["function name(bytes32) view returns (string)"],
                  this
                ),
                a = await i.name(e);
              return (await this.resolveName(a)) !== t ? null : a;
            } catch (t) {
              if (V(t, "BAD_DATA") && "0x" === t.value) return null;
              if (V(t, "CALL_EXCEPTION")) return null;
              throw t;
            }
            return null;
          }
          async waitForTransaction(t, e, n) {
            const r = null != e ? e : 1;
            return 0 === r
              ? this.getTransactionReceipt(t)
              : new Promise(async (e, s) => {
                  let i = null;
                  const a = async (n) => {
                    try {
                      const s = await this.getTransactionReceipt(t);
                      if (null != s && n - s.blockNumber + 1 >= r)
                        return e(s), void (i && (clearTimeout(i), (i = null)));
                    } catch (t) {
                      console.log("EEE", t);
                    }
                    this.once("block", a);
                  };
                  null != n &&
                    (i = setTimeout(() => {
                      null != i &&
                        ((i = null),
                        this.off("block", a),
                        s(z("timeout", "TIMEOUT", { reason: "timeout" })));
                    }, n)),
                    a(await this.getBlockNumber());
                });
          }
          async waitForBlock(t) {
            K(!1, "not implemented yet", "NOT_IMPLEMENTED", {
              operation: "waitForBlock",
            });
          }
          _clearTimeout(t) {
            const e = this.#Ht.get(t);
            e && (e.timer && clearTimeout(e.timer), this.#Ht.delete(t));
          }
          _setTimeout(t, e) {
            null == e && (e = 0);
            const n = this.#Gt++,
              r = () => {
                this.#Ht.delete(n), t();
              };
            if (this.paused) this.#Ht.set(n, { timer: null, func: r, time: e });
            else {
              const t = setTimeout(r, e);
              this.#Ht.set(n, { timer: t, func: r, time: Uc() });
            }
            return n;
          }
          _forEachSubscriber(t) {
            for (const e of this.#St.values()) t(e.subscriber);
          }
          _getSubscriber(t) {
            switch (t.type) {
              case "debug":
              case "error":
              case "network":
                return new Oc(t.type);
              case "block":
                return new xc(this);
              case "event":
                return new Nc(this, t.filter);
              case "transaction":
                return new Cc(this, t.hash);
              case "orphan":
                return new kc(this, t.filter);
            }
            throw new Error(`unsupported event: ${t.type}`);
          }
          _recoverSubscriber(t, e) {
            for (const n of this.#St.values())
              if (n.subscriber === t) {
                n.started && n.subscriber.stop(),
                  (n.subscriber = e),
                  n.started && e.start(),
                  null != this.#Rt && e.pause(this.#Rt);
                break;
              }
          }
          async #_t(t, e) {
            let n = await Rc(t, this);
            return (
              "event" === n.type &&
                e &&
                e.length > 0 &&
                !0 === e[0].removed &&
                (n = await Rc({ orphan: "drop-log", log: e[0] }, this)),
              this.#St.get(n.tag) || null
            );
          }
          async #qt(t) {
            const e = await Rc(t, this),
              n = e.tag;
            let r = this.#St.get(n);
            if (!r) {
              (r = {
                subscriber: this._getSubscriber(e),
                tag: n,
                addressableMap: new WeakMap(),
                nameMap: new Map(),
                started: !1,
                listeners: [],
              }),
                this.#St.set(n, r);
            }
            return r;
          }
          async on(t, e) {
            const n = await this.#qt(t);
            return (
              n.listeners.push({ listener: e, once: !1 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Rt && n.subscriber.pause(this.#Rt)),
              this
            );
          }
          async once(t, e) {
            const n = await this.#qt(t);
            return (
              n.listeners.push({ listener: e, once: !0 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Rt && n.subscriber.pause(this.#Rt)),
              this
            );
          }
          async emit(t, ...e) {
            const n = await this.#_t(t, e);
            if (!n || 0 === n.listeners.length) return !1;
            const r = n.listeners.length;
            return (
              (n.listeners = n.listeners.filter(({ listener: n, once: r }) => {
                const s = new Et(this, r ? null : n, t);
                try {
                  n.call(this, ...e, s);
                } catch (t) {}
                return !r;
              })),
              0 === n.listeners.length &&
                (n.started && n.subscriber.stop(), this.#St.delete(n.tag)),
              r > 0
            );
          }
          async listenerCount(t) {
            if (t) {
              const e = await this.#_t(t);
              return e ? e.listeners.length : 0;
            }
            let e = 0;
            for (const { listeners: t } of this.#St.values()) e += t.length;
            return e;
          }
          async listeners(t) {
            if (t) {
              const e = await this.#_t(t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            let e = [];
            for (const { listeners: t } of this.#St.values())
              e = e.concat(t.map(({ listener: t }) => t));
            return e;
          }
          async off(t, e) {
            const n = await this.#_t(t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (e && 0 !== n.listeners.length) ||
                (n.started && n.subscriber.stop(), this.#St.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const { tag: e, started: n, subscriber: r } = await this.#qt(t);
              n && r.stop(), this.#St.delete(e);
            } else
              for (const [t, { started: e, subscriber: n }] of this.#St)
                e && n.stop(), this.#St.delete(t);
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return this.off(t, e);
          }
          get destroyed() {
            return this.#Ut;
          }
          destroy() {
            this.removeAllListeners();
            for (const t of this.#Ht.keys()) this._clearTimeout(t);
            this.#Ut = !0;
          }
          get paused() {
            return null != this.#Rt;
          }
          set paused(t) {
            !!t !== this.paused &&
              (this.paused ? this.resume() : this.pause(!1));
          }
          pause(t) {
            if (((this.#Mt = -1), null != this.#Rt)) {
              if (this.#Rt == !!t) return;
              K(
                !1,
                "cannot change pause type; resume first",
                "UNSUPPORTED_OPERATION",
                { operation: "pause" }
              );
            }
            this._forEachSubscriber((e) => e.pause(t)), (this.#Rt = !!t);
            for (const t of this.#Ht.values())
              t.timer && clearTimeout(t.timer), (t.time = Uc() - t.time);
          }
          resume() {
            if (null != this.#Rt) {
              this._forEachSubscriber((t) => t.resume()), (this.#Rt = null);
              for (const t of this.#Ht.values()) {
                let e = t.time;
                e < 0 && (e = 0), (t.time = Uc()), setTimeout(t.func, e);
              }
            }
          }
        }
        function Dc(t, e) {
          try {
            const n = Mc(t, e);
            if (n) return Ct(n);
          } catch (t) {}
          return null;
        }
        function Mc(t, e) {
          if ("0x" === t) return null;
          try {
            const n = yt(it(t, e, e + 32)),
              r = yt(it(t, n, n + 32));
            return it(t, n + 32, n + 32 + r);
          } catch (t) {}
          return null;
        }
        function Gc(t) {
          const e = At(t);
          if (e.length > 32) throw new Error("internal; should not happen");
          const n = new Uint8Array(32);
          return n.set(e, 32 - e.length), n;
        }
        function Hc(t) {
          if (t.length % 32 == 0) return t;
          const e = new Uint8Array(32 * Math.ceil(t.length / 32));
          return e.set(t), e;
        }
        const jc = new Uint8Array([]);
        function Qc(t) {
          const e = [];
          let n = 0;
          for (let r = 0; r < t.length; r++) e.push(jc), (n += 32);
          for (let r = 0; r < t.length; r++) {
            const s = X(t[r]);
            (e[r] = Gc(n)),
              e.push(Gc(s.length)),
              e.push(Hc(s)),
              (n += 32 + 32 * Math.ceil(s.length / 32));
          }
          return rt(e);
        }
        const Vc =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        function Jc(t, e) {
          if (t.provider) return t.provider;
          K(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
        }
        async function zc(t, e) {
          let n = bo(e);
          if ((null != n.to && (n.to = Vr(n.to, t)), null != n.from)) {
            const e = n.from;
            n.from = Promise.all([t.getAddress(), Vr(e, t)]).then(
              ([t, e]) => (
                _(
                  t.toLowerCase() === e.toLowerCase(),
                  "transaction from mismatch",
                  "tx.from",
                  e
                ),
                t
              )
            );
          } else n.from = t.getAddress();
          return await H(n);
        }
        class Kc {
          provider;
          constructor(t) {
            j(this, { provider: t || null });
          }
          async getNonce(t) {
            return Jc(this, "getTransactionCount").getTransactionCount(
              await this.getAddress(),
              t
            );
          }
          async populateCall(t) {
            return await zc(this, t);
          }
          async populateTransaction(t) {
            const e = Jc(this, "populateTransaction"),
              n = await zc(this, t);
            null == n.nonce && (n.nonce = await this.getNonce("pending")),
              null == n.gasLimit && (n.gasLimit = await this.estimateGas(n));
            const r = await this.provider.getNetwork();
            if (null != n.chainId) {
              _(
                dt(n.chainId) === r.chainId,
                "transaction chainId mismatch",
                "tx.chainId",
                t.chainId
              );
            } else n.chainId = r.chainId;
            const s = null != n.maxFeePerGas || null != n.maxPriorityFeePerGas;
            if (
              (null == n.gasPrice || (2 !== n.type && !s)
                ? (0 !== n.type && 1 !== n.type) ||
                  !s ||
                  _(
                    !1,
                    "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                    "tx",
                    t
                  )
                : _(
                    !1,
                    "eip-1559 transaction do not support gasPrice",
                    "tx",
                    t
                  ),
              (2 !== n.type && null != n.type) ||
                null == n.maxFeePerGas ||
                null == n.maxPriorityFeePerGas)
            )
              if (0 === n.type || 1 === n.type) {
                const t = await e.getFeeData();
                K(
                  null != t.gasPrice,
                  "network does not support gasPrice",
                  "UNSUPPORTED_OPERATION",
                  { operation: "getGasPrice" }
                ),
                  null == n.gasPrice && (n.gasPrice = t.gasPrice);
              } else {
                const t = await e.getFeeData();
                if (null == n.type)
                  if (null != t.maxFeePerGas && null != t.maxPriorityFeePerGas)
                    if (((n.type = 2), null != n.gasPrice)) {
                      const t = n.gasPrice;
                      delete n.gasPrice,
                        (n.maxFeePerGas = t),
                        (n.maxPriorityFeePerGas = t);
                    } else
                      null == n.maxFeePerGas &&
                        (n.maxFeePerGas = t.maxFeePerGas),
                        null == n.maxPriorityFeePerGas &&
                          (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas);
                  else
                    null != t.gasPrice
                      ? (K(
                          !s,
                          "network does not support EIP-1559",
                          "UNSUPPORTED_OPERATION",
                          { operation: "populateTransaction" }
                        ),
                        null == n.gasPrice && (n.gasPrice = t.gasPrice),
                        (n.type = 0))
                      : K(
                          !1,
                          "failed to get consistent fee data",
                          "UNSUPPORTED_OPERATION",
                          { operation: "signer.getFeeData" }
                        );
                else
                  2 === n.type &&
                    (null == n.maxFeePerGas &&
                      (n.maxFeePerGas = t.maxFeePerGas),
                    null == n.maxPriorityFeePerGas &&
                      (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas));
              }
            else n.type = 2;
            return await H(n);
          }
          async estimateGas(t) {
            return Jc(this, "estimateGas").estimateGas(
              await this.populateCall(t)
            );
          }
          async call(t) {
            return Jc(this, "call").call(await this.populateCall(t));
          }
          async resolveName(t) {
            const e = Jc(this, "resolveName");
            return await e.resolveName(t);
          }
          async sendTransaction(t) {
            const e = Jc(this, "sendTransaction"),
              n = await this.populateTransaction(t);
            delete n.from;
            const r = Xi.from(n);
            return await e.broadcastTransaction(await this.signTransaction(r));
          }
        }
        class _c {
          #kt;
          #Wt;
          #Ct;
          #Tt;
          #Zt;
          #Yt;
          constructor(t) {
            (this.#kt = t),
              (this.#Wt = null),
              (this.#Ct = this.#Bt.bind(this)),
              (this.#Tt = !1),
              (this.#Zt = null),
              (this.#Yt = !1);
          }
          _subscribe(t) {
            throw new Error("subclasses must override this");
          }
          _emitResults(t, e) {
            throw new Error("subclasses must override this");
          }
          _recover(t) {
            throw new Error("subclasses must override this");
          }
          async #Bt(t) {
            try {
              null == this.#Wt && (this.#Wt = this._subscribe(this.#kt));
              let t = null;
              try {
                t = await this.#Wt;
              } catch (t) {
                if (
                  !V(t, "UNSUPPORTED_OPERATION") ||
                  "eth_newFilter" !== t.operation
                )
                  throw t;
              }
              if (null == t)
                return (
                  (this.#Wt = null),
                  void this.#kt._recoverSubscriber(
                    this,
                    this._recover(this.#kt)
                  )
                );
              const e = await this.#kt.getNetwork();
              if ((this.#Zt || (this.#Zt = e), this.#Zt.chainId !== e.chainId))
                throw new Error("chaid changed");
              if (this.#Yt) return;
              const n = await this.#kt.send("eth_getFilterChanges", [t]);
              await this._emitResults(this.#kt, n);
            } catch (t) {
              console.log("@TODO", t);
            }
            this.#kt.once("block", this.#Ct);
          }
          #Xt() {
            const t = this.#Wt;
            t &&
              ((this.#Wt = null),
              t.then((t) => {
                this.#kt.send("eth_uninstallFilter", [t]);
              }));
          }
          start() {
            this.#Tt || ((this.#Tt = !0), this.#Bt(-2));
          }
          stop() {
            this.#Tt &&
              ((this.#Tt = !1),
              (this.#Yt = !0),
              this.#Xt(),
              this.#kt.off("block", this.#Ct));
          }
          pause(t) {
            t && this.#Xt(), this.#kt.off("block", this.#Ct);
          }
          resume() {
            this.start();
          }
        }
        class qc extends _c {
          #$t;
          constructor(t, e) {
            var n;
            super(t), (this.#$t = ((n = e), JSON.parse(JSON.stringify(n))));
          }
          _recover(t) {
            return new Nc(t, this.#$t);
          }
          async _subscribe(t) {
            return await t.send("eth_newFilter", [this.#$t]);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit(this.#$t, t._wrapLog(n, t._network));
          }
        }
        class Wc extends _c {
          async _subscribe(t) {
            return await t.send("eth_newPendingTransactionFilter", []);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit("pending", n);
          }
        }
        const Zc = "bigint,boolean,function,number,string,symbol".split(/,/g);
        function Yc(t) {
          if (null == t || Zc.indexOf(typeof t) >= 0) return t;
          if ("function" == typeof t.getAddress) return t;
          if (Array.isArray(t)) return t.map(Yc);
          if ("object" == typeof t)
            return Object.keys(t).reduce((e, n) => ((e[n] = t[n]), e), {});
          throw new Error(`should not happen: ${t} (${typeof t})`);
        }
        function Xc(t) {
          return new Promise((e) => {
            setTimeout(e, t);
          });
        }
        function $c(t) {
          return t ? t.toLowerCase() : t;
        }
        function tl(t) {
          return t && "number" == typeof t.pollingInterval;
        }
        const el = {
          polling: !1,
          staticNetwork: null,
          batchStallTime: 10,
          batchMaxSize: 1 << 20,
          batchMaxCount: 100,
          cacheTimeout: 250,
        };
        class nl extends Kc {
          address;
          constructor(t, e) {
            super(t), j(this, { address: (e = Hr(e)) });
          }
          connect(t) {
            K(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
              operation: "signer.connect",
            });
          }
          async getAddress() {
            return this.address;
          }
          async populateTransaction(t) {
            return await this.populateCall(t);
          }
          async sendUncheckedTransaction(t) {
            const e = Yc(t),
              n = [];
            if (e.from) {
              const r = e.from;
              n.push(
                (async () => {
                  const n = await Vr(r, this.provider);
                  _(
                    null != n && n.toLowerCase() === this.address.toLowerCase(),
                    "from address mismatch",
                    "transaction",
                    t
                  ),
                    (e.from = n);
                })()
              );
            } else e.from = this.address;
            if (
              (null == e.gasLimit &&
                n.push(
                  (async () => {
                    e.gasLimit = await this.provider.estimateGas({
                      ...e,
                      from: this.address,
                    });
                  })()
                ),
              null != e.to)
            ) {
              const t = e.to;
              n.push(
                (async () => {
                  e.to = await Vr(t, this.provider);
                })()
              );
            }
            n.length && (await Promise.all(n));
            const r = this.provider.getRpcTransaction(e);
            return this.provider.send("eth_sendTransaction", [r]);
          }
          async sendTransaction(t) {
            const e = await this.provider.getBlockNumber(),
              n = await this.sendUncheckedTransaction(t);
            return await new Promise((t, r) => {
              const s = [1e3, 100],
                i = async () => {
                  const r = await this.provider.getTransaction(n);
                  null == r
                    ? this.provider._setTimeout(() => {
                        i();
                      }, s.pop() || 4e3)
                    : t(r.replaceableTransaction(e));
                };
              i();
            });
          }
          async signTransaction(t) {
            const e = Yc(t);
            if (e.from) {
              const n = await Vr(e.from, this.provider);
              _(
                null != n && n.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                t
              ),
                (e.from = n);
            } else e.from = this.address;
            const n = this.provider.getRpcTransaction(e);
            return await this.provider.send("eth_signTransaction", [n]);
          }
          async signMessage(t) {
            const e = "string" == typeof t ? kt(t) : t;
            return await this.provider.send("personal_sign", [
              nt(e),
              this.address.toLowerCase(),
            ]);
          }
          async signTypedData(t, e, n) {
            const r = Yc(n),
              s = await fa.resolveNames(t, e, r, async (t) => {
                const e = await Vr(t);
                return (
                  _(
                    null != e,
                    "TypedData does not support null address",
                    "value",
                    t
                  ),
                  e
                );
              });
            return await this.provider.send("eth_signTypedData_v4", [
              this.address.toLowerCase(),
              JSON.stringify(fa.getPayload(s.domain, e, s.value)),
            ]);
          }
          async unlock(t) {
            return this.provider.send("personal_unlockAccount", [
              this.address.toLowerCase(),
              t,
              null,
            ]);
          }
          async _legacySignMessage(t) {
            const e = "string" == typeof t ? kt(t) : t;
            return await this.provider.send("eth_sign", [
              this.address.toLowerCase(),
              nt(e),
            ]);
          }
        }
        class rl extends Fc {
          #Q;
          #te;
          #ee;
          #ne;
          #re;
          #Zt;
          #se() {
            if (this.#ne) return;
            const t =
              1 === this._getOption("batchMaxCount")
                ? 0
                : this._getOption("batchStallTime");
            this.#ne = setTimeout(() => {
              this.#ne = null;
              const t = this.#ee;
              for (this.#ee = []; t.length; ) {
                const e = [t.shift()];
                for (; t.length && e.length !== this.#Q.batchMaxCount; ) {
                  e.push(t.shift());
                  if (
                    JSON.stringify(e.map((t) => t.payload)).length >
                    this.#Q.batchMaxSize
                  ) {
                    t.unshift(e.pop());
                    break;
                  }
                }
                (async () => {
                  const t =
                    1 === e.length ? e[0].payload : e.map((t) => t.payload);
                  this.emit("debug", { action: "sendRpcPayload", payload: t });
                  try {
                    const n = await this._send(t);
                    this.emit("debug", {
                      action: "receiveRpcResult",
                      result: n,
                    });
                    for (const { resolve: t, reject: r, payload: s } of e) {
                      if (this.destroyed) {
                        r(
                          z(
                            "provider destroyed; cancelled request",
                            "UNSUPPORTED_OPERATION",
                            { operation: s.method }
                          )
                        );
                        continue;
                      }
                      const e = n.filter((t) => t.id === s.id)[0];
                      if (null != e)
                        "error" in e ? r(this.getRpcError(s, e)) : t(e.result);
                      else {
                        const t = z(
                          "missing response for request",
                          "BAD_DATA",
                          { value: n, info: { payload: s } }
                        );
                        this.emit("error", t), r(t);
                      }
                    }
                  } catch (t) {
                    this.emit("debug", { action: "receiveRpcError", error: t });
                    for (const { reject: n } of e) n(t);
                  }
                })();
              }
            }, t);
          }
          constructor(t, e) {
            const n = {};
            e && null != e.cacheTimeout && (n.cacheTimeout = e.cacheTimeout),
              super(t, n),
              (this.#te = 1),
              (this.#Q = Object.assign({}, el, e || {})),
              (this.#ee = []),
              (this.#ne = null),
              (this.#Zt = null);
            {
              let t = null;
              const e = new Promise((e) => {
                t = e;
              });
              this.#re = { promise: e, resolve: t };
            }
            const r = this._getOption("staticNetwork");
            r &&
              (_(
                null == t || r.matches(t),
                "staticNetwork MUST match network object",
                "options",
                e
              ),
              (this.#Zt = r));
          }
          _getOption(t) {
            return this.#Q[t];
          }
          get _network() {
            return (
              K(this.#Zt, "network is not available yet", "NETWORK_ERROR"),
              this.#Zt
            );
          }
          async _perform(t) {
            if ("call" === t.method || "estimateGas" === t.method) {
              let e = t.transaction;
              if (
                e &&
                null != e.type &&
                dt(e.type) &&
                null == e.maxFeePerGas &&
                null == e.maxPriorityFeePerGas
              ) {
                const n = await this.getFeeData();
                null == n.maxFeePerGas &&
                  null == n.maxPriorityFeePerGas &&
                  (t = Object.assign({}, t, {
                    transaction: Object.assign({}, e, { type: void 0 }),
                  }));
              }
            }
            const e = this.getRpcRequest(t);
            return null != e
              ? await this.send(e.method, e.args)
              : super._perform(t);
          }
          async _detectNetwork() {
            const t = this._getOption("staticNetwork");
            if (t) return t;
            if (this.ready)
              return bc.from(dt(await this.send("eth_chainId", [])));
            const e = {
              id: this.#te++,
              method: "eth_chainId",
              params: [],
              jsonrpc: "2.0",
            };
            let n;
            this.emit("debug", { action: "sendRpcPayload", payload: e });
            try {
              n = (await this._send(e))[0];
            } catch (t) {
              throw (
                (this.emit("debug", { action: "receiveRpcError", error: t }), t)
              );
            }
            if (
              (this.emit("debug", { action: "receiveRpcResult", result: n }),
              "result" in n)
            )
              return bc.from(dt(n.result));
            throw this.getRpcError(e, n);
          }
          _start() {
            null != this.#re &&
              null != this.#re.resolve &&
              (this.#re.resolve(),
              (this.#re = null),
              (async () => {
                for (; null == this.#Zt && !this.destroyed; )
                  try {
                    this.#Zt = await this._detectNetwork();
                  } catch (t) {
                    console.log(
                      "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                    ),
                      this.emit(
                        "error",
                        z(
                          "failed to bootstrap network detection",
                          "NETWORK_ERROR",
                          {
                            event: "initial-network-discovery",
                            info: { error: t },
                          }
                        )
                      ),
                      await Xc(1e3);
                  }
                this.#se();
              })());
          }
          async _waitUntilReady() {
            if (null != this.#re) return await this.#re.promise;
          }
          _getSubscriber(t) {
            return "pending" === t.type
              ? new Wc(this)
              : "event" === t.type
              ? this._getOption("polling")
                ? new Nc(this, t.filter)
                : new qc(this, t.filter)
              : "orphan" === t.type && "drop-log" === t.filter.orphan
              ? new Oc("orphan")
              : super._getSubscriber(t);
          }
          get ready() {
            return null == this.#re;
          }
          getRpcTransaction(t) {
            const e = {};
            return (
              [
                "chainId",
                "gasLimit",
                "gasPrice",
                "type",
                "maxFeePerGas",
                "maxPriorityFeePerGas",
                "nonce",
                "value",
              ].forEach((n) => {
                if (null == t[n]) return;
                let r = n;
                "gasLimit" === n && (r = "gas"),
                  (e[r] = bt(dt(t[n], `tx.${n}`)));
              }),
              ["from", "to", "data"].forEach((n) => {
                null != t[n] && (e[n] = nt(t[n]));
              }),
              t.accessList && (e.accessList = Ui(t.accessList)),
              e
            );
          }
          getRpcRequest(t) {
            switch (t.method) {
              case "chainId":
                return { method: "eth_chainId", args: [] };
              case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
              case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
              case "getBalance":
                return {
                  method: "eth_getBalance",
                  args: [$c(t.address), t.blockTag],
                };
              case "getTransactionCount":
                return {
                  method: "eth_getTransactionCount",
                  args: [$c(t.address), t.blockTag],
                };
              case "getCode":
                return {
                  method: "eth_getCode",
                  args: [$c(t.address), t.blockTag],
                };
              case "getStorage":
                return {
                  method: "eth_getStorageAt",
                  args: [
                    $c(t.address),
                    "0x" + t.position.toString(16),
                    t.blockTag,
                  ],
                };
              case "broadcastTransaction":
                return {
                  method: "eth_sendRawTransaction",
                  args: [t.signedTransaction],
                };
              case "getBlock":
                if ("blockTag" in t)
                  return {
                    method: "eth_getBlockByNumber",
                    args: [t.blockTag, !!t.includeTransactions],
                  };
                if ("blockHash" in t)
                  return {
                    method: "eth_getBlockByHash",
                    args: [t.blockHash, !!t.includeTransactions],
                  };
                break;
              case "getTransaction":
                return { method: "eth_getTransactionByHash", args: [t.hash] };
              case "getTransactionReceipt":
                return { method: "eth_getTransactionReceipt", args: [t.hash] };
              case "call":
                return {
                  method: "eth_call",
                  args: [this.getRpcTransaction(t.transaction), t.blockTag],
                };
              case "estimateGas":
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(t.transaction)],
                };
              case "getLogs":
                return (
                  t.filter &&
                    null != t.filter.address &&
                    (Array.isArray(t.filter.address)
                      ? (t.filter.address = t.filter.address.map($c))
                      : (t.filter.address = $c(t.filter.address))),
                  { method: "eth_getLogs", args: [t.filter] }
                );
            }
            return null;
          }
          getRpcError(t, e) {
            const { method: n } = t,
              { error: r } = e;
            if ("eth_estimateGas" === n && r.message) {
              const e = r.message;
              if (!e.match(/revert/i) && e.match(/insufficient funds/i))
                return z("insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: t.params[0],
                  info: { payload: t, error: r },
                });
            }
            if ("eth_call" === n || "eth_estimateGas" === n) {
              const e = il(r),
                s = oo.getBuiltinCallException(
                  "eth_call" === n ? "call" : "estimateGas",
                  t.params[0],
                  e ? e.data : null
                );
              return (s.info = { error: r, payload: t }), s;
            }
            const s = JSON.stringify(
              (function (t) {
                const e = [];
                return al(t, e), e;
              })(r)
            );
            if (
              "string" == typeof r.message &&
              r.message.match(/user denied|ethers-user-denied/i)
            ) {
              return z("user rejected action", "ACTION_REJECTED", {
                action:
                  {
                    eth_sign: "signMessage",
                    personal_sign: "signMessage",
                    eth_signTypedData_v4: "signTypedData",
                    eth_signTransaction: "signTransaction",
                    eth_sendTransaction: "sendTransaction",
                    eth_requestAccounts: "requestAccess",
                    wallet_requestAccounts: "requestAccess",
                  }[n] || "unknown",
                reason: "rejected",
                info: { payload: t, error: r },
              });
            }
            if ("eth_sendRawTransaction" === n || "eth_sendTransaction" === n) {
              const e = t.params[0];
              if (s.match(/insufficient funds|base fee exceeds gas limit/i))
                return z(
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: e, info: { error: r } }
                );
              if (s.match(/nonce/i) && s.match(/too low/i))
                return z("nonce has already been used", "NONCE_EXPIRED", {
                  transaction: e,
                  info: { error: r },
                });
              if (
                s.match(/replacement transaction/i) &&
                s.match(/underpriced/i)
              )
                return z("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                  transaction: e,
                  info: { error: r },
                });
              if (s.match(/only replay-protected/i))
                return z(
                  "legacy pre-eip-155 transactions not supported",
                  "UNSUPPORTED_OPERATION",
                  { operation: n, info: { transaction: e, info: { error: r } } }
                );
            }
            let i = !!s.match(/the method .* does not exist/i);
            return (
              i ||
                (r &&
                  r.details &&
                  r.details.startsWith("Unauthorized method:") &&
                  (i = !0)),
              i
                ? z("unsupported operation", "UNSUPPORTED_OPERATION", {
                    operation: t.method,
                    info: { error: r, payload: t },
                  })
                : z("could not coalesce error", "UNKNOWN_ERROR", {
                    error: r,
                    payload: t,
                  })
            );
          }
          send(t, e) {
            if (this.destroyed)
              return Promise.reject(
                z(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t }
                )
              );
            const n = this.#te++,
              r = new Promise((r, s) => {
                this.#ee.push({
                  resolve: r,
                  reject: s,
                  payload: { method: t, params: e, id: n, jsonrpc: "2.0" },
                });
              });
            return this.#se(), r;
          }
          async getSigner(t) {
            null == t && (t = 0);
            const e = this.send("eth_accounts", []);
            if ("number" == typeof t) {
              const n = await e;
              if (t >= n.length) throw new Error("no such account");
              return new nl(this, n[t]);
            }
            const { accounts: n } = await H({
              network: this.getNetwork(),
              accounts: e,
            });
            t = Hr(t);
            for (const e of n) if (Hr(e) === t) return new nl(this, t);
            throw new Error("invalid account");
          }
          async listAccounts() {
            return (await this.send("eth_accounts", [])).map(
              (t) => new nl(this, t)
            );
          }
          destroy() {
            this.#ne && (clearTimeout(this.#ne), (this.#ne = null));
            for (const { payload: t, reject: e } of this.#ee)
              e(
                z(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t.method }
                )
              );
            (this.#ee = []), super.destroy();
          }
        }
        class sl extends rl {
          #ie;
          constructor(t, e) {
            super(t, e), (this.#ie = 4e3);
          }
          _getSubscriber(t) {
            const e = super._getSubscriber(t);
            return tl(e) && (e.pollingInterval = this.#ie), e;
          }
          get pollingInterval() {
            return this.#ie;
          }
          set pollingInterval(t) {
            if (!Number.isInteger(t) || t < 0)
              throw new Error("invalid interval");
            (this.#ie = t),
              this._forEachSubscriber((t) => {
                tl(t) && (t.pollingInterval = this.#ie);
              });
          }
        }
        function il(t) {
          if (null == t) return null;
          if (
            "string" == typeof t.message &&
            t.message.match(/revert/i) &&
            tt(t.data)
          )
            return { message: t.message, data: t.data };
          if ("object" == typeof t) {
            for (const e in t) {
              const n = il(t[e]);
              if (n) return n;
            }
            return null;
          }
          if ("string" == typeof t)
            try {
              return il(JSON.parse(t));
            } catch (t) {}
          return null;
        }
        function al(t, e) {
          if (null != t) {
            if (
              ("string" == typeof t.message && e.push(t.message),
              "object" == typeof t)
            )
              for (const n in t) al(t[n], e);
            if ("string" == typeof t)
              try {
                return al(JSON.parse(t), e);
              } catch (t) {}
          }
        }
        class ol extends sl {
          #b;
          constructor(t, e) {
            super(e, { batchMaxCount: 1 }),
              (this.#b = async (e, n) => {
                const r = { method: e, params: n };
                this.emit("debug", {
                  action: "sendEip1193Request",
                  payload: r,
                });
                try {
                  const e = await t.request(r);
                  return (
                    this.emit("debug", {
                      action: "receiveEip1193Result",
                      result: e,
                    }),
                    e
                  );
                } catch (t) {
                  const e = new Error(t.message);
                  throw (
                    ((e.code = t.code),
                    (e.data = t.data),
                    (e.payload = r),
                    this.emit("debug", {
                      action: "receiveEip1193Error",
                      error: e,
                    }),
                    e)
                  );
                }
              });
          }
          async send(t, e) {
            return await this._start(), await super.send(t, e);
          }
          async _send(t) {
            _(
              !Array.isArray(t),
              "EIP-1193 does not support batch request",
              "payload",
              t
            );
            try {
              const e = await this.#b(t.method, t.params || []);
              return [{ id: t.id, result: e }];
            } catch (e) {
              return [
                {
                  id: t.id,
                  error: { code: e.code, data: e.data, message: e.message },
                },
              ];
            }
          }
          getRpcError(t, e) {
            switch ((e = JSON.parse(JSON.stringify(e))).error.code || -1) {
              case 4001:
                e.error.message = `ethers-user-denied: ${e.error.message}`;
                break;
              case 4200:
                e.error.message = `ethers-unsupported: ${e.error.message}`;
            }
            return super.getRpcError(t, e);
          }
          async hasSigner(t) {
            null == t && (t = 0);
            const e = await this.send("eth_accounts", []);
            return "number" == typeof t
              ? e.length > t
              : ((t = t.toLowerCase()),
                0 !== e.filter((e) => e.toLowerCase() === t).length);
          }
          async getSigner(t) {
            if ((null == t && (t = 0), !(await this.hasSigner(t))))
              try {
                await this.#b("eth_requestAccounts", []);
              } catch (t) {
                const e = t.payload;
                throw this.getRpcError(e, { id: e.id, error: t });
              }
            return await super.getSigner(t);
          }
        }
        function cl(t) {
          o(
            t,
            "svelte-11onvz8",
            "section.svelte-11onvz8{display:flex;flex-direction:column;justify-content:center;align-items:center;flex:0.6}h1.svelte-11onvz8{width:100%}"
          );
        }
        function ll(t) {
          let e, n, r;
          return {
            c() {
              (e = u("p")), (n = h("Account ")), (r = h(t[0]));
            },
            m(t, s) {
              c(t, e, s), a(e, n), a(e, r);
            },
            p(t, e) {
              1 & e && m(r, t[0]);
            },
            d(t) {
              t && l(e);
            },
          };
        }
        function ul(e) {
          let n;
          return {
            c() {
              (n = u("p")),
                (n.textContent = "My application is not yet connected");
            },
            m(t, e) {
              c(t, n, e);
            },
            p: t,
            d(t) {
              t && l(n);
            },
          };
        }
        function hl(t) {
          let e,
            n,
            s,
            i,
            a,
            o,
            h,
            m,
            w,
            A,
            b,
            v,
            E,
            x,
            P,
            k,
            C,
            N,
            I,
            B,
            T,
            O = t[1] && dl(t),
            S = t[6] && pl(t),
            R = t[7] && gl(t);
          return {
            c() {
              (e = u("h2")),
                (e.textContent = "Create Escrow Portal"),
                (n = f()),
                (s = u("button")),
                (s.textContent = "Get balance"),
                (i = f()),
                O && O.c(),
                (a = f()),
                (o = u("br")),
                (h = f()),
                (m = u("br")),
                (w = f()),
                (A = u("br")),
                (b = f()),
                (v = u("input")),
                (E = f()),
                (x = u("input")),
                (P = f()),
                (k = u("button")),
                (k.textContent = "Create Escrow"),
                (C = f()),
                S && S.c(),
                (N = f()),
                R && R.c(),
                (I = d()),
                g(v, "placeholder", "Escrow details"),
                g(x, "type", "Amount"),
                g(x, "placeholder", "Escrow amount");
            },
            m(r, l) {
              c(r, e, l),
                c(r, n, l),
                c(r, s, l),
                c(r, i, l),
                O && O.m(r, l),
                c(r, a, l),
                c(r, o, l),
                c(r, h, l),
                c(r, m, l),
                c(r, w, l),
                c(r, A, l),
                c(r, b, l),
                c(r, v, l),
                y(v, t[4]),
                c(r, E, l),
                c(r, x, l),
                y(x, t[5]),
                c(r, P, l),
                c(r, k, l),
                c(r, C, l),
                S && S.m(r, l),
                c(r, N, l),
                R && R.m(r, l),
                c(r, I, l),
                B ||
                  ((T = [
                    p(s, "click", t[11]),
                    p(v, "input", t[12]),
                    p(x, "input", t[13]),
                    p(k, "click", t[10]),
                  ]),
                  (B = !0));
            },
            p(t, e) {
              t[1]
                ? O
                  ? O.p(t, e)
                  : ((O = dl(t)), O.c(), O.m(a.parentNode, a))
                : O && (O.d(1), (O = null)),
                16 & e && v.value !== t[4] && y(v, t[4]),
                32 & e && y(x, t[5]),
                t[6]
                  ? S
                    ? S.p(t, e)
                    : ((S = pl(t)), S.c(), S.m(N.parentNode, N))
                  : S && (S.d(1), (S = null)),
                t[7]
                  ? R
                    ? R.p(t, e)
                    : ((R = gl(t)), R.c(), R.m(I.parentNode, I))
                  : R && (R.d(1), (R = null));
            },
            d(t) {
              t && l(e),
                t && l(n),
                t && l(s),
                t && l(i),
                O && O.d(t),
                t && l(a),
                t && l(o),
                t && l(h),
                t && l(m),
                t && l(w),
                t && l(A),
                t && l(b),
                t && l(v),
                t && l(E),
                t && l(x),
                t && l(P),
                t && l(k),
                t && l(C),
                S && S.d(t),
                t && l(N),
                R && R.d(t),
                t && l(I),
                (B = !1),
                r(T);
            },
          };
        }
        function fl(t) {
          let e,
            n,
            r,
            s,
            i,
            a,
            o,
            h,
            g = t[3] && ml(t),
            m = t[2] && yl(t);
          return {
            c() {
              (e = u("h2")),
                (e.textContent = "Buyer Portal"),
                (n = f()),
                (r = u("button")),
                (r.textContent = "Get Contract Details"),
                (s = f()),
                g && g.c(),
                (i = f()),
                m && m.c(),
                (a = d());
            },
            m(l, u) {
              c(l, e, u),
                c(l, n, u),
                c(l, r, u),
                c(l, s, u),
                g && g.m(l, u),
                c(l, i, u),
                m && m.m(l, u),
                c(l, a, u),
                o || ((h = p(r, "click", t[9])), (o = !0));
            },
            p(t, e) {
              t[3]
                ? g
                  ? g.p(t, e)
                  : ((g = ml(t)), g.c(), g.m(i.parentNode, i))
                : g && (g.d(1), (g = null)),
                t[2]
                  ? m
                    ? m.p(t, e)
                    : ((m = yl(t)), m.c(), m.m(a.parentNode, a))
                  : m && (m.d(1), (m = null));
            },
            d(t) {
              t && l(e),
                t && l(n),
                t && l(r),
                t && l(s),
                g && g.d(t),
                t && l(i),
                m && m.d(t),
                t && l(a),
                (o = !1),
                h();
            },
          };
        }
        function dl(t) {
          let e, n, r, s;
          return {
            c() {
              (e = u("h2")),
                (n = h("Balance ")),
                (r = u("strong")),
                (s = h(t[1]));
            },
            m(t, i) {
              c(t, e, i), a(e, n), a(e, r), a(r, s);
            },
            p(t, e) {
              2 & e && m(s, t[1]);
            },
            d(t) {
              t && l(e);
            },
          };
        }
        function pl(t) {
          let e, n;
          return {
            c() {
              (e = u("p")), (n = h(t[6]));
            },
            m(t, r) {
              c(t, e, r), a(e, n);
            },
            p(t, e) {
              64 & e && m(n, t[6]);
            },
            d(t) {
              t && l(e);
            },
          };
        }
        function gl(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            d,
            p,
            y,
            w = window.location.href + "";
          return {
            c() {
              (e = u("p")),
                (n = h("Escrow created with number ")),
                (r = h(t[7])),
                (s = f()),
                (i = u("a")),
                (o = h(w)),
                (d = h("?escrowID=")),
                (p = h(t[7])),
                g(i, "href", (y = `${window.location.href}?escrowID=${t[7]}`)),
                g(i, "target", "_blank");
            },
            m(t, l) {
              c(t, e, l),
                a(e, n),
                a(e, r),
                c(t, s, l),
                c(t, i, l),
                a(i, o),
                a(i, d),
                a(i, p);
            },
            p(t, e) {
              128 & e && m(r, t[7]),
                128 & e && m(p, t[7]),
                128 & e &&
                  y !== (y = `${window.location.href}?escrowID=${t[7]}`) &&
                  g(i, "href", y);
            },
            d(t) {
              t && l(e), t && l(s), t && l(i);
            },
          };
        }
        function ml(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            d,
            p,
            g,
            y,
            w,
            A,
            b,
            v,
            E,
            x,
            P,
            k,
            C,
            N = t[3].merchant + "",
            I = t[3].buyer + "",
            B = t[3].amount + "",
            T = t[3].details + "",
            O = t[3].isDead + "";
          return {
            c() {
              (e = u("p")),
                (n = h("merchant: ")),
                (r = h(N)),
                (s = f()),
                (i = u("p")),
                (o = h("buyer: ")),
                (d = h(I)),
                (p = f()),
                (g = u("p")),
                (y = h("amount: ")),
                (w = h(B)),
                (A = f()),
                (b = u("p")),
                (v = h("details: ")),
                (E = h(T)),
                (x = f()),
                (P = u("p")),
                (k = h("isDead: ")),
                (C = h(O));
            },
            m(t, l) {
              c(t, e, l),
                a(e, n),
                a(e, r),
                c(t, s, l),
                c(t, i, l),
                a(i, o),
                a(i, d),
                c(t, p, l),
                c(t, g, l),
                a(g, y),
                a(g, w),
                c(t, A, l),
                c(t, b, l),
                a(b, v),
                a(b, E),
                c(t, x, l),
                c(t, P, l),
                a(P, k),
                a(P, C);
            },
            p(t, e) {
              8 & e && N !== (N = t[3].merchant + "") && m(r, N),
                8 & e && I !== (I = t[3].buyer + "") && m(d, I),
                8 & e && B !== (B = t[3].amount + "") && m(w, B),
                8 & e && T !== (T = t[3].details + "") && m(E, T),
                8 & e && O !== (O = t[3].isDead + "") && m(C, O);
            },
            d(t) {
              t && l(e),
                t && l(s),
                t && l(i),
                t && l(p),
                t && l(g),
                t && l(A),
                t && l(b),
                t && l(x),
                t && l(P);
            },
          };
        }
        function yl(t) {
          let e, n;
          return {
            c() {
              (e = u("p")), (n = h(t[2]));
            },
            m(t, r) {
              c(t, e, r), a(e, n);
            },
            p(t, e) {
              4 & e && m(n, t[2]);
            },
            d(t) {
              t && l(e);
            },
          };
        }
        function wl(e) {
          let n, r, s, i, o, h;
          function d(t, e) {
            return t[0] ? ll : ul;
          }
          let p = d(e),
            m = p(e);
          let y = (function (t, e) {
              return t[8] ? fl : hl;
            })(e),
            w = y(e);
          return {
            c() {
              (n = u("meta")),
                (r = f()),
                (s = u("section")),
                (i = u("h1")),
                (i.textContent = "Trading app"),
                (o = f()),
                m.c(),
                (h = f()),
                w.c(),
                (document.title = "Home"),
                g(n, "name", "description"),
                g(n, "content", "Trading App"),
                g(i, "class", "svelte-11onvz8"),
                g(s, "class", "svelte-11onvz8");
            },
            m(t, e) {
              a(document.head, n),
                c(t, r, e),
                c(t, s, e),
                a(s, i),
                a(s, o),
                m.m(s, null),
                a(s, h),
                w.m(s, null);
            },
            p(t, [e]) {
              p === (p = d(t)) && m
                ? m.p(t, e)
                : (m.d(1), (m = p(t)), m && (m.c(), m.m(s, h))),
                w.p(t, e);
            },
            i: t,
            o: t,
            d(t) {
              l(n), t && l(r), t && l(s), m.d(), w.d();
            },
          };
        }
        const Al = "0x8276EF08D33D4D805f1d19F00851023660c0ae13";
        function bl(t, e, n) {
          const r =
              new URLSearchParams(window.location.search).get("escrowID") ||
              null,
            s = new ol(window.ethereum);
          let i = null,
            a = null;
          b(() => {
            !(async function () {
              const t = await window.ethereum
                .request({ method: "eth_requestAccounts" })
                .catch((t) => {
                  4001 === t.code
                    ? console.log("Please connect to MetaMask.")
                    : console.error(t);
                });
              n(0, (i = t[0]));
            })(),
              r && l();
          });
          let o = null,
            c = null;
          async function l() {
            n(2, (o = null));
            let t = null;
            try {
              t = Number(r);
            } catch (t) {
              return (
                console.log("Please enter a valid escrow number"),
                void n(2, (o = "Please enter a valid escrow number"))
              );
            }
            if (!t)
              return (
                console.log("Please enter escrow number"),
                void n(2, (o = "Please enter escrow number"))
              );
            const e = await s.getSigner(),
              i = new $o(Al, D, e),
              a = await i.escrows(t);
            if ("0x0000000000000000000000000000000000000000" === a.merchant)
              return (
                console.log("Escrow does not exist"),
                void n(2, (o = "Escrow does not exist"))
              );
            n(3, (c = a));
          }
          let u = null,
            h = null,
            f = null,
            d = null;
          return [
            i,
            a,
            o,
            c,
            u,
            h,
            f,
            d,
            r,
            l,
            async function () {
              var t;
              if ((n(6, (f = null)), !u || !h))
                return (
                  console.log("Please enter details and amount"),
                  void n(6, (f = "Please enter details and amount"))
                );
              const e = ae(h.toString()),
                r = await s.getSigner(),
                i = new $o(Al, D, r),
                a = await i.createEscrow(e, u, {
                  value: ae((h / 4).toString()),
                }),
                o = await a.wait();
              console.log("receipt", o);
              const c = i.filters["EscrowCreated(uint256,address,uint256)"],
                l = await i.queryFilter(c, o.blockNumber);
              console.log("events", l);
              const p =
                null === (t = l[0].args) || void 0 === t ? void 0 : t._escrowId;
              console.log("escrowID", p), n(7, (d = Number(p)));
            },
            async function () {
              const t = await window.ethereum
                  .request({ method: "eth_getBalance", params: [i, "latest"] })
                  .catch((t) => {
                    4001 === t.code
                      ? console.log("Please connect to MetaMask.")
                      : console.error(t);
                  }),
                e = parseInt(t, 16);
              n(1, (a = (e / 10 ** 18).toString()));
            },
            function () {
              (u = this.value), n(4, u);
            },
            function () {
              (h = this.value), n(5, h);
            },
          ];
        }
        return new (class extends F {
          constructor(t) {
            super(), L(this, t, bl, wl, i, {}, cl);
          }
        })({ target: document.body, props: { name: "world" } });
      })();
      //# sourceMappingURL=bundle.js.map
    </script>
  </body>
</html>
