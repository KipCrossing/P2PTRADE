<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trading App</title>
  </head>
  <body>
    <div id="app"></div>
    <script>
      var app = (function () {
        "use strict";
        function t() {}
        const e = (t) => t;
        function n(t, e) {
          for (const n in e) t[n] = e[n];
          return t;
        }
        function r(t) {
          return t();
        }
        function s() {
          return Object.create(null);
        }
        function i(t) {
          t.forEach(r);
        }
        function o(t) {
          return "function" == typeof t;
        }
        function a(t, e) {
          return t != t
            ? e == e
            : t !== e || (t && "object" == typeof t) || "function" == typeof t;
        }
        function l(e, n, r) {
          e.$$.on_destroy.push(
            (function (e, ...n) {
              if (null == e) return t;
              const r = e.subscribe(...n);
              return r.unsubscribe ? () => r.unsubscribe() : r;
            })(n, r)
          );
        }
        function c(t, e, n, r) {
          if (t) {
            const s = u(t, e, n, r);
            return t[0](s);
          }
        }
        function u(t, e, r, s) {
          return t[1] && s ? n(r.ctx.slice(), t[1](s(e))) : r.ctx;
        }
        function d(t, e, n, r) {
          if (t[2] && r) {
            const s = t[2](r(n));
            if (void 0 === e.dirty) return s;
            if ("object" == typeof s) {
              const t = [],
                n = Math.max(e.dirty.length, s.length);
              for (let r = 0; r < n; r += 1) t[r] = e.dirty[r] | s[r];
              return t;
            }
            return e.dirty | s;
          }
          return e.dirty;
        }
        function h(t, e, n, r, s, i) {
          if (s) {
            const o = u(e, n, r, i);
            t.p(o, s);
          }
        }
        function f(t) {
          if (t.ctx.length > 32) {
            const e = [],
              n = t.ctx.length / 32;
            for (let t = 0; t < n; t++) e[t] = -1;
            return e;
          }
          return -1;
        }
        function p(t) {
          const e = {};
          for (const n in t) "$" !== n[0] && (e[n] = t[n]);
          return e;
        }
        function g(t, e) {
          const n = {};
          e = new Set(e);
          for (const r in t) e.has(r) || "$" === r[0] || (n[r] = t[r]);
          return n;
        }
        function m(t) {
          const e = {};
          for (const n in t) e[n] = !0;
          return e;
        }
        function y(e) {
          return e && o(e.destroy) ? e.destroy : t;
        }
        const b = "undefined" != typeof window;
        let w = b ? () => window.performance.now() : () => Date.now(),
          v = b ? (t) => requestAnimationFrame(t) : t;
        const A = new Set();
        function $(t) {
          A.forEach((e) => {
            e.c(t) || (A.delete(e), e.f());
          }),
            0 !== A.size && v($);
        }
        function x(t, e) {
          t.appendChild(e);
        }
        function k(t, e, n) {
          const r = E(t);
          if (!r.getElementById(e)) {
            const t = N("style");
            (t.id = e), (t.textContent = n), S(r, t);
          }
        }
        function E(t) {
          if (!t) return document;
          const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;
          return e && e.host ? e : t.ownerDocument;
        }
        function C(t) {
          const e = N("style");
          return S(E(t), e), e.sheet;
        }
        function S(t, e) {
          return x(t.head || t, e), e.sheet;
        }
        function P(t, e, n) {
          t.insertBefore(e, n || null);
        }
        function I(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
        function N(t) {
          return document.createElement(t);
        }
        function B(t) {
          return document.createElementNS("http://www.w3.org/2000/svg", t);
        }
        function T(t) {
          return document.createTextNode(t);
        }
        function O() {
          return T(" ");
        }
        function R() {
          return T("");
        }
        function L(t, e, n, r) {
          return (
            t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r)
          );
        }
        function z(t, e, n) {
          null == n
            ? t.removeAttribute(e)
            : t.getAttribute(e) !== n && t.setAttribute(e, n);
        }
        const F = ["width", "height"];
        function U(t, e) {
          const n = Object.getOwnPropertyDescriptors(t.__proto__);
          for (const r in e)
            null == e[r]
              ? t.removeAttribute(r)
              : "style" === r
              ? (t.style.cssText = e[r])
              : "__value" === r
              ? (t.value = t[r] = e[r])
              : n[r] && n[r].set && -1 === F.indexOf(r)
              ? (t[r] = e[r])
              : z(t, r, e[r]);
        }
        function D(t, e) {
          for (const n in e) z(t, n, e[n]);
        }
        function M(t, e) {
          Object.keys(e).forEach((n) => {
            !(function (t, e, n) {
              e in t
                ? (t[e] = ("boolean" == typeof t[e] && "" === n) || n)
                : z(t, e, n);
            })(t, n, e[n]);
          });
        }
        function j(t) {
          return /-/.test(t) ? M : U;
        }
        function H(t, e) {
          (e = "" + e), t.data !== e && (t.data = e);
        }
        function G(t, e) {
          t.value = null == e ? "" : e;
        }
        function V(t, e, n, r) {
          null == n
            ? t.style.removeProperty(e)
            : t.style.setProperty(e, n, r ? "important" : "");
        }
        function W(t, e, n) {
          t.classList[n ? "add" : "remove"](e);
        }
        function Q(t, e, { bubbles: n = !1, cancelable: r = !1 } = {}) {
          const s = document.createEvent("CustomEvent");
          return s.initCustomEvent(t, n, r, e), s;
        }
        class J {
          constructor(t = !1) {
            (this.is_svg = !1), (this.is_svg = t), (this.e = this.n = null);
          }
          c(t) {
            this.h(t);
          }
          m(t, e, n = null) {
            this.e ||
              (this.is_svg
                ? (this.e = B(e.nodeName))
                : (this.e = N(11 === e.nodeType ? "TEMPLATE" : e.nodeName)),
              (this.t = "TEMPLATE" !== e.tagName ? e : e.content),
              this.c(t)),
              this.i(n);
          }
          h(t) {
            (this.e.innerHTML = t),
              (this.n = Array.from(
                "TEMPLATE" === this.e.nodeName
                  ? this.e.content.childNodes
                  : this.e.childNodes
              ));
          }
          i(t) {
            for (let e = 0; e < this.n.length; e += 1) P(this.t, this.n[e], t);
          }
          p(t) {
            this.d(), this.h(t), this.i(this.a);
          }
          d() {
            this.n.forEach(I);
          }
        }
        function _(t, e) {
          return new t(e);
        }
        const K = new Map();
        let q,
          Y = 0;
        function Z(t, e, n, r, s, i, o, a = 0) {
          const l = 16.666 / r;
          let c = "{\n";
          for (let t = 0; t <= 1; t += l) {
            const r = e + (n - e) * i(t);
            c += 100 * t + `%{${o(r, 1 - r)}}\n`;
          }
          const u = c + `100% {${o(n, 1 - n)}}\n}`,
            d = `__svelte_${(function (t) {
              let e = 5381,
                n = t.length;
              for (; n--; ) e = ((e << 5) - e) ^ t.charCodeAt(n);
              return e >>> 0;
            })(u)}_${a}`,
            h = E(t),
            { stylesheet: f, rules: p } =
              K.get(h) ||
              (function (t, e) {
                const n = { stylesheet: C(e), rules: {} };
                return K.set(t, n), n;
              })(h, t);
          p[d] ||
            ((p[d] = !0),
            f.insertRule(`@keyframes ${d} ${u}`, f.cssRules.length));
          const g = t.style.animation || "";
          return (
            (t.style.animation = `${
              g ? `${g}, ` : ""
            }${d} ${r}ms linear ${s}ms 1 both`),
            (Y += 1),
            d
          );
        }
        function X(t, e) {
          const n = (t.style.animation || "").split(", "),
            r = n.filter(
              e ? (t) => t.indexOf(e) < 0 : (t) => -1 === t.indexOf("__svelte")
            ),
            s = n.length - r.length;
          s &&
            ((t.style.animation = r.join(", ")),
            (Y -= s),
            Y ||
              v(() => {
                Y ||
                  (K.forEach((t) => {
                    const { ownerNode: e } = t.stylesheet;
                    e && I(e);
                  }),
                  K.clear());
              }));
        }
        function tt(t) {
          q = t;
        }
        function et() {
          if (!q)
            throw new Error("Function called outside component initialization");
          return q;
        }
        function nt(t) {
          et().$$.on_mount.push(t);
        }
        function rt() {
          const t = et();
          return (e, n, { cancelable: r = !1 } = {}) => {
            const s = t.$$.callbacks[e];
            if (s) {
              const i = Q(e, n, { cancelable: r });
              return (
                s.slice().forEach((e) => {
                  e.call(t, i);
                }),
                !i.defaultPrevented
              );
            }
            return !0;
          };
        }
        function st(t, e) {
          return et().$$.context.set(t, e), e;
        }
        function it(t) {
          return et().$$.context.get(t);
        }
        const ot = [],
          at = [];
        let lt = [];
        const ct = [],
          ut = Promise.resolve();
        let dt = !1;
        function ht() {
          dt || ((dt = !0), ut.then(wt));
        }
        function ft() {
          return ht(), ut;
        }
        function pt(t) {
          lt.push(t);
        }
        function gt(t) {
          ct.push(t);
        }
        const mt = new Set();
        let yt,
          bt = 0;
        function wt() {
          if (0 !== bt) return;
          const t = q;
          do {
            try {
              for (; bt < ot.length; ) {
                const t = ot[bt];
                bt++, tt(t), vt(t.$$);
              }
            } catch (t) {
              throw ((ot.length = 0), (bt = 0), t);
            }
            for (tt(null), ot.length = 0, bt = 0; at.length; ) at.pop()();
            for (let t = 0; t < lt.length; t += 1) {
              const e = lt[t];
              mt.has(e) || (mt.add(e), e());
            }
            lt.length = 0;
          } while (ot.length);
          for (; ct.length; ) ct.pop()();
          (dt = !1), mt.clear(), tt(t);
        }
        function vt(t) {
          if (null !== t.fragment) {
            t.update(), i(t.before_update);
            const e = t.dirty;
            (t.dirty = [-1]),
              t.fragment && t.fragment.p(t.ctx, e),
              t.after_update.forEach(pt);
          }
        }
        function At(t, e, n) {
          t.dispatchEvent(Q(`${e ? "intro" : "outro"}${n}`));
        }
        const $t = new Set();
        let xt;
        function kt() {
          xt = { r: 0, c: [], p: xt };
        }
        function Et() {
          xt.r || i(xt.c), (xt = xt.p);
        }
        function Ct(t, e) {
          t && t.i && ($t.delete(t), t.i(e));
        }
        function St(t, e, n, r) {
          if (t && t.o) {
            if ($t.has(t)) return;
            $t.add(t),
              xt.c.push(() => {
                $t.delete(t), r && (n && t.d(1), r());
              }),
              t.o(e);
          } else r && r();
        }
        const Pt = { duration: 0 };
        function It(n, r, s, a) {
          const l = { direction: "both" };
          let c = r(n, s, l),
            u = a ? 0 : 1,
            d = null,
            h = null,
            f = null;
          function p() {
            f && X(n, f);
          }
          function g(t, e) {
            const n = t.b - u;
            return (
              (e *= Math.abs(n)),
              {
                a: u,
                b: t.b,
                d: n,
                duration: e,
                start: t.start,
                end: t.start + e,
                group: t.group,
              }
            );
          }
          function m(r) {
            const {
                delay: s = 0,
                duration: o = 300,
                easing: a = e,
                tick: l = t,
                css: m,
              } = c || Pt,
              y = { start: w() + s, b: r };
            r || ((y.group = xt), (xt.r += 1)),
              d || h
                ? (h = y)
                : (m && (p(), (f = Z(n, u, r, o, s, a, m))),
                  r && l(0, 1),
                  (d = g(y, o)),
                  pt(() => At(n, r, "start")),
                  (function (t) {
                    let e;
                    0 === A.size && v($),
                      new Promise((n) => {
                        A.add((e = { c: t, f: n }));
                      });
                  })((t) => {
                    if (
                      (h &&
                        t > h.start &&
                        ((d = g(h, o)),
                        (h = null),
                        At(n, d.b, "start"),
                        m &&
                          (p(), (f = Z(n, u, d.b, d.duration, 0, a, c.css)))),
                      d)
                    )
                      if (t >= d.end)
                        l((u = d.b), 1 - u),
                          At(n, d.b, "end"),
                          h || (d.b ? p() : --d.group.r || i(d.group.c)),
                          (d = null);
                      else if (t >= d.start) {
                        const e = t - d.start;
                        (u = d.a + d.d * a(e / d.duration)), l(u, 1 - u);
                      }
                    return !(!d && !h);
                  }));
          }
          return {
            run(t) {
              o(c)
                ? (yt ||
                    ((yt = Promise.resolve()),
                    yt.then(() => {
                      yt = null;
                    })),
                  yt).then(() => {
                    (c = c(l)), m(t);
                  })
                : m(t);
            },
            end() {
              p(), (d = h = null);
            },
          };
        }
        function Nt(t, e) {
          const n = {},
            r = {},
            s = { $$scope: 1 };
          let i = t.length;
          for (; i--; ) {
            const o = t[i],
              a = e[i];
            if (a) {
              for (const t in o) t in a || (r[t] = 1);
              for (const t in a) s[t] || ((n[t] = a[t]), (s[t] = 1));
              t[i] = a;
            } else for (const t in o) s[t] = 1;
          }
          for (const t in r) t in n || (n[t] = void 0);
          return n;
        }
        function Bt(t) {
          return "object" == typeof t && null !== t ? t : {};
        }
        function Tt(t, e, n) {
          const r = t.$$.props[e];
          void 0 !== r && ((t.$$.bound[r] = n), n(t.$$.ctx[r]));
        }
        function Ot(t) {
          t && t.c();
        }
        function Rt(t, e, n, s) {
          const { fragment: a, after_update: l } = t.$$;
          a && a.m(e, n),
            s ||
              pt(() => {
                const e = t.$$.on_mount.map(r).filter(o);
                t.$$.on_destroy ? t.$$.on_destroy.push(...e) : i(e),
                  (t.$$.on_mount = []);
              }),
            l.forEach(pt);
        }
        function Lt(t, e) {
          const n = t.$$;
          null !== n.fragment &&
            (!(function (t) {
              const e = [],
                n = [];
              lt.forEach((r) => (-1 === t.indexOf(r) ? e.push(r) : n.push(r))),
                n.forEach((t) => t()),
                (lt = e);
            })(n.after_update),
            i(n.on_destroy),
            n.fragment && n.fragment.d(e),
            (n.on_destroy = n.fragment = null),
            (n.ctx = []));
        }
        function zt(e, n, r, o, a, l, c, u = [-1]) {
          const d = q;
          tt(e);
          const h = (e.$$ = {
            fragment: null,
            ctx: [],
            props: l,
            update: t,
            not_equal: a,
            bound: s(),
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(n.context || (d ? d.$$.context : [])),
            callbacks: s(),
            dirty: u,
            skip_bound: !1,
            root: n.target || d.$$.root,
          });
          c && c(h.root);
          let f = !1;
          if (
            ((h.ctx = r
              ? r(e, n.props || {}, (t, n, ...r) => {
                  const s = r.length ? r[0] : n;
                  return (
                    h.ctx &&
                      a(h.ctx[t], (h.ctx[t] = s)) &&
                      (!h.skip_bound && h.bound[t] && h.bound[t](s),
                      f &&
                        (function (t, e) {
                          -1 === t.$$.dirty[0] &&
                            (ot.push(t), ht(), t.$$.dirty.fill(0)),
                            (t.$$.dirty[(e / 31) | 0] |= 1 << e % 31);
                        })(e, t)),
                    n
                  );
                })
              : []),
            h.update(),
            (f = !0),
            i(h.before_update),
            (h.fragment = !!o && o(h.ctx)),
            n.target)
          ) {
            if (n.hydrate) {
              const t = (function (t) {
                return Array.from(t.childNodes);
              })(n.target);
              h.fragment && h.fragment.l(t), t.forEach(I);
            } else h.fragment && h.fragment.c();
            n.intro && Ct(e.$$.fragment),
              Rt(e, n.target, n.anchor, n.customElement),
              wt();
          }
          tt(d);
        }
        class Ft {
          $destroy() {
            Lt(this, 1), (this.$destroy = t);
          }
          $on(e, n) {
            if (!o(n)) return t;
            const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
            return (
              r.push(n),
              () => {
                const t = r.indexOf(n);
                -1 !== t && r.splice(t, 1);
              }
            );
          }
          $set(t) {
            var e;
            this.$$set &&
              ((e = t), 0 !== Object.keys(e).length) &&
              ((this.$$.skip_bound = !0),
              this.$$set(t),
              (this.$$.skip_bound = !1));
          }
        }
        function Ut(t) {
          let e,
            n,
            r = Wt(t[1], t[2]) + "";
          return {
            c() {
              (e = new J(!1)), (n = R()), (e.a = n);
            },
            m(t, s) {
              e.m(r, t, s), P(t, n, s);
            },
            p(t, n) {
              6 & n && r !== (r = Wt(t[1], t[2]) + "") && e.p(r);
            },
            d(t) {
              t && I(n), t && e.d();
            },
          };
        }
        function Dt(e) {
          let n,
            r = e[0] && Ut(e);
          return {
            c() {
              r && r.c(), (n = R());
            },
            m(t, e) {
              r && r.m(t, e), P(t, n, e);
            },
            p(t, [e]) {
              t[0]
                ? r
                  ? r.p(t, e)
                  : ((r = Ut(t)), r.c(), r.m(n.parentNode, n))
                : r && (r.d(1), (r = null));
            },
            i: t,
            o: t,
            d(t) {
              r && r.d(t), t && I(n);
            },
          };
        }
        function Mt(t, e, n) {
          let { observable: r = !1 } = e,
            { component: s } = e,
            { code: i } = e;
          return (
            (t.$$set = (t) => {
              "observable" in t && n(0, (r = t.observable)),
                "component" in t && n(1, (s = t.component)),
                "code" in t && n(2, (i = t.code));
            }),
            [r, s, i]
          );
        }
        var jt = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, Mt, Dt, a, { observable: 0, component: 1, code: 2 });
          }
        };
        const Ht = "undefined" != typeof window,
          Gt = Ht ? document.createElement("style") : void 0;
        if (Ht) {
          const t = Gt;
          (t.textContent =
            ".modal-header{padding: 2px 16px;background-color: #339af0;color: white;}.modal-body{padding: 2px 16px;}.modal-footer{padding: 2px 16px;background-color: #339af0;color: white;}.modal-content{position: relative;background-color: #fefefe;margin: auto;padding: 0;border: 1px solid #888;width: 80%;box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);animation-name: animateTop;animation-duration: 0.4s;}@keyframes animateTop {from {top: -300px; opacity: 0}to {top: 0; opacity: 1}}"),
            (t.id = "svelteui-inject");
        }
        function Vt(t, e, n) {
          Ht && document.head.appendChild(Gt);
          return `\n    <div class="modal-content">\n        <div class="modal-header">\n            <h2>[${t} Component Error]:</h2>\n            <h3>${e}</h3>\n        </div>\n        <div class="modal-body">\n            <pre>\n                ${
            n || ""
          }\n            </pre>\n        </div>\n        <div class="modal-footer">\n            <h3>Fix the code to dismiss this error.</h3>\n        </div>\n    </div>        \n    `;
        }
        function Wt(t, e) {
          const { message: n, solution: r } = e;
          return r ? Vt(t, n, r) : Vt(t, n);
        }
        function Qt(t, e) {
          const n = [];
          if (e)
            for (let r = 0; r < e.length; r++) {
              const s = e[r],
                i = Array.isArray(s) ? s[0] : s;
              Array.isArray(s) && s.length > 1
                ? n.push(i(t, s[1]))
                : n.push(i(t));
            }
          return {
            update(t) {
              if (((t && t.length) || 0) != n.length)
                throw new Error(
                  "You must not change the length of an actions array."
                );
              if (t)
                for (let e = 0; e < t.length; e++) {
                  const r = n[e];
                  if (r && r.update) {
                    const n = t[e];
                    Array.isArray(n) && n.length > 1
                      ? r.update(n[1])
                      : r.update();
                  }
                }
            },
            destroy() {
              for (let t = 0; t < n.length; t++) {
                const e = n[t];
                e && e.destroy && e.destroy();
              }
            },
          };
        }
        const Jt = "!",
          _t = new RegExp(
            `^[^${Jt}]+(?:${Jt}(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$`
          );
        function Kt(t, e = []) {
          let n;
          const r = [];
          function s(e) {
            !(function (t, e) {
              const n = t.$$.callbacks[e.type];
              n && n.slice().forEach((t) => t.call(this, e));
            })(t, e);
          }
          return (
            (t.$on = (s, i) => {
              const o = s;
              let a = () => {};
              for (const n of e) {
                if ("string" == typeof n && n === o) {
                  const e = t.$$.callbacks[o] || (t.$$.callbacks[o] = []);
                  return (
                    e.push(i),
                    () => {
                      const t = e.indexOf(i);
                      -1 !== t && e.splice(t, 1);
                    }
                  );
                }
                if ("object" == typeof n && n.name === o) {
                  const t = i;
                  i = (...e) => {
                    ("object" == typeof n && n.shouldExclude()) || t(...e);
                  };
                }
              }
              return (
                n ? (a = n(o, i)) : r.push([o, i]),
                () => {
                  a();
                }
              );
            }),
            (t) => {
              const e = [],
                i = {};
              n = (n, r) => {
                let o = n,
                  a = r,
                  l = !1;
                if (o.match(_t)) {
                  const t = o.split(Jt);
                  o = t[0];
                  const e = Object.fromEntries(t.slice(1).map((t) => [t, !0]));
                  e.passive && ((l = l || {}), (l.passive = !0)),
                    e.nonpassive && ((l = l || {}), (l.passive = !1)),
                    e.capture && ((l = l || {}), (l.capture = !0)),
                    e.once && ((l = l || {}), (l.once = !0)),
                    e.preventDefault &&
                      ((c = a),
                      (a = function (t) {
                        return t.preventDefault(), c.call(this, t);
                      })),
                    e.stopPropagation &&
                      (a = (function (t) {
                        return function (e) {
                          return e.stopPropagation(), t.call(this, e);
                        };
                      })(a));
                }
                var c;
                const u = L(t, o, a, l),
                  d = () => {
                    u();
                    const t = e.indexOf(d);
                    t > -1 && e.splice(t, 1);
                  };
                return e.push(d), o in i || (i[o] = L(t, o, s)), d;
              };
              for (let t = 0; t < r.length; t++) n(r[t][0], r[t][1]);
              return {
                destroy: () => {
                  for (let t = 0; t < e.length; t++) e[t]();
                  for (const t of Object.entries(i)) t[1]();
                },
              };
            }
          );
        }
        function qt(t) {
          const e = t - 1;
          return e * e * e + 1;
        }
        function Yt(t) {
          return -0.5 * (Math.cos(Math.PI * t) - 1);
        }
        function Zt(
          t,
          { delay: n = 0, duration: r = 400, easing: s = e } = {}
        ) {
          const i = +getComputedStyle(t).opacity;
          return {
            delay: n,
            duration: r,
            easing: s,
            css: (t) => "opacity: " + t * i,
          };
        }
        function Xt(
          t,
          {
            delay: e = 0,
            duration: n = 400,
            easing: r = qt,
            start: s = 0,
            opacity: i = 0,
          } = {}
        ) {
          const o = getComputedStyle(t),
            a = +o.opacity,
            l = "none" === o.transform ? "" : o.transform,
            c = 1 - s,
            u = a * (1 - i);
          return {
            delay: e,
            duration: n,
            easing: r,
            css: (t, e) =>
              `\n\t\t\ttransform: ${l} scale(${1 - c * e});\n\t\t\topacity: ${
                a - u * e
              }\n\t\t`,
          };
        }
        const te = {};
        function ee() {
          return it(te);
        }
        const ne = [];
        function re(e, n = t) {
          let r;
          const s = new Set();
          function i(t) {
            if (a(e, t) && ((e = t), r)) {
              const t = !ne.length;
              for (const t of s) t[1](), ne.push(t, e);
              if (t) {
                for (let t = 0; t < ne.length; t += 2) ne[t][0](ne[t + 1]);
                ne.length = 0;
              }
            }
          }
          return {
            set: i,
            update: function (t) {
              i(t(e));
            },
            subscribe: function (o, a = t) {
              const l = [o, a];
              return (
                s.add(l),
                1 === s.size && (r = n(i) || t),
                o(e),
                () => {
                  s.delete(l), 0 === s.size && r && (r(), (r = null));
                }
              );
            },
          };
        }
        const se = re("light");
        function ie() {
          let t;
          se?.subscribe((e) => {
            t = e;
          });
          return {
            ...Cn,
            colorNames: ve,
            colorScheme: t,
            dark: Nn?.selector,
            fn: {
              cover: be.cover,
              themeColor: be.themeColor,
              size: be.size,
              radius: be.radius,
              rgba: be.rgba,
              variant: be.variant,
            },
          };
        }
        function oe(t) {
          let e, r, s, a, l, u;
          const p = t[19].default,
            g = c(p, t, t[18], null);
          let m = [
              { id: "SVELTEUI_PROVIDER" },
              { class: (r = t[5](t[2], t[4].root, t[3])) },
              t[7],
            ],
            b = {};
          for (let t = 0; t < m.length; t += 1) b = n(b, m[t]);
          return {
            c() {
              (e = N("div")), g && g.c(), U(e, b);
            },
            m(n, r) {
              P(n, e, r),
                g && g.m(e, null),
                t[20](e),
                (a = !0),
                l ||
                  ((u = [
                    y((s = Qt.call(null, e, t[1]))),
                    y(t[6].call(null, e)),
                  ]),
                  (l = !0));
            },
            p(t, [n]) {
              g &&
                g.p &&
                (!a || 262144 & n) &&
                h(g, p, t, t[18], a ? d(p, t[18], n, null) : f(t[18]), null),
                U(
                  e,
                  (b = Nt(m, [
                    { id: "SVELTEUI_PROVIDER" },
                    (!a ||
                      (60 & n && r !== (r = t[5](t[2], t[4].root, t[3])))) && {
                      class: r,
                    },
                    128 & n && t[7],
                  ]))
                ),
                s && o(s.update) && 2 & n && s.update.call(null, t[1]);
            },
            i(t) {
              a || (Ct(g, t), (a = !0));
            },
            o(t) {
              St(g, t), (a = !1);
            },
            d(n) {
              n && I(e), g && g.d(n), t[20](null), (l = !1), i(u);
            },
          };
        }
        function ae(t, e, r) {
          let s, i, o, a;
          const c = [
            "use",
            "class",
            "element",
            "theme",
            "styles",
            "defaultProps",
            "themeObserver",
            "withNormalizeCSS",
            "withGlobalStyles",
            "override",
            "inherit",
          ];
          let u,
            d = g(e, c);
          l(t, se, (t) => r(21, (u = t)));
          let { $$slots: h = {}, $$scope: f } = e,
            {
              use: m = [],
              class: y = "",
              element: b,
              theme: w = ie(),
              styles: v = {},
              defaultProps: A = {},
              themeObserver: $ = "light",
              withNormalizeCSS: x = !1,
              withGlobalStyles: k = !1,
              override: E = {},
              inherit: C = !1,
            } = e;
          var S;
          (S = () => {
            const t = document.documentElement.classList;
            "dark" === u && t.add(Nn.className),
              "light" === u && t.remove(Nn.className);
          }),
            et().$$.before_update.push(S);
          const P = ee(),
            I = Se(() => ({ root: {} })),
            N = Kt(et()),
            B = ie();
          let T = null;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (d = g(e, c))),
                "use" in t && r(1, (m = t.use)),
                "class" in t && r(2, (y = t.class)),
                "element" in t && r(0, (b = t.element)),
                "theme" in t && r(8, (w = t.theme)),
                "styles" in t && r(9, (v = t.styles)),
                "defaultProps" in t && r(10, (A = t.defaultProps)),
                "themeObserver" in t && r(11, ($ = t.themeObserver)),
                "withNormalizeCSS" in t && r(12, (x = t.withNormalizeCSS)),
                "withGlobalStyles" in t && r(13, (k = t.withGlobalStyles)),
                "override" in t && r(14, (E = t.override)),
                "inherit" in t && r(15, (C = t.inherit)),
                "$$scope" in t && r(18, (f = t.$$scope));
            }),
            (t.$$.update = () => {
              34560 & t.$$.dirty &&
                r(
                  16,
                  (s = {
                    themeOverride: C ? { ...P.theme, ...w } : w,
                    styles: C ? { ...P.styles, ...v } : v,
                    defaultProps: C ? { ...P.styles, ...A } : A,
                  })
                ),
                65536 & t.$$.dirty &&
                  r(
                    17,
                    (i = (function (t, e) {
                      if (!e) return t;
                      return Object.keys(t).reduce(
                        (n, r) => (
                          (n[r] =
                            "object" == typeof e[r]
                              ? { ...t[r], ...e[r] }
                              : "number" == typeof e[r]
                              ? e[r]
                              : e[r] || t[r]),
                          n
                        ),
                        {}
                      );
                    })(B, s.themeOverride))
                  ),
                133120 & t.$$.dirty &&
                  null !== $ &&
                  r(3, (T = "light" === $ ? i : Nn)),
                8192 & t.$$.dirty && k && Bn(),
                4096 & t.$$.dirty && x && Tn(),
                65536 & t.$$.dirty &&
                  st(te, {
                    theme: s.themeOverride,
                    styles: {},
                    defaultProps: {},
                  }),
                2048 & t.$$.dirty && se.set($),
                16384 & t.$$.dirty &&
                  r(
                    5,
                    ({ cx: o, classes: a } = I(null, { override: E })),
                    o,
                    (r(4, a), r(14, E))
                  );
            }),
            [
              b,
              m,
              y,
              T,
              a,
              o,
              N,
              d,
              w,
              v,
              A,
              $,
              x,
              k,
              E,
              C,
              s,
              i,
              f,
              h,
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (b = t), r(0, b);
                });
              },
            ]
          );
        }
        var le = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, ae, oe, a, {
                use: 1,
                class: 2,
                element: 0,
                theme: 8,
                styles: 9,
                defaultProps: 10,
                themeObserver: 11,
                withNormalizeCSS: 12,
                withGlobalStyles: 13,
                override: 14,
                inherit: 15,
              });
          }
        };
        function ce(t, e = 0) {
          const n = ee()?.theme || ie();
          let r = "50";
          return (function (t) {
            let e = !1;
            switch (t) {
              case "dark":
              case "gray":
              case "red":
              case "pink":
              case "grape":
              case "violet":
              case "indigo":
              case "blue":
              case "cyan":
              case "teal":
              case "green":
              case "lime":
              case "yellow":
              case "orange":
                e = !0;
                break;
              default:
                e = !1;
            }
            return e;
          })(t)
            ? (e !== Number(0) && (r = `${e.toString()}00`),
              n.colors[`${t}${r}`]?.value)
            : t;
        }
        function ue(t) {
          return (function (t) {
            const e = t.replace("#", "");
            return (
              "string" == typeof e &&
              6 === e.length &&
              !Number.isNaN(Number(`0x${e}`))
            );
          })(t)
            ? (function (t) {
                const e = t.replace("#", ""),
                  n = parseInt(e, 16);
                return {
                  r: (n >> 16) & 255,
                  g: (n >> 8) & 255,
                  b: 255 & n,
                  a: 1,
                };
              })(t)
            : t.startsWith("rgb")
            ? (function (t) {
                const [e, n, r, s] = t
                  .replace(/[^0-9,.]/g, "")
                  .split(",")
                  .map(Number);
                return { r: e, g: n, b: r, a: s || 1 };
              })(t)
            : { r: 0, g: 0, b: 0, a: 1 };
        }
        const de = (t, e) => {
          const { themeColor: n, rgba: r } = be,
            s = {
              filled: {
                [`${Nn.selector} &`]: { backgroundColor: n(t, 8) },
                border: "transparent",
                backgroundColor: n(t, 6),
                color: "White",
                "&:hover": { backgroundColor: n(t, 7) },
              },
              light: {
                [`${Nn.selector} &`]: {
                  backgroundColor: r(n(t, 8), 0.35),
                  color: "dark" === t ? n("dark", 0) : n(t, 2),
                  "&:hover": { backgroundColor: r(n(t, 7), 0.45) },
                },
                border: "transparent",
                backgroundColor: n(t, 0),
                color: "dark" === t ? n("dark", 9) : n(t, 6),
                "&:hover": { backgroundColor: n(t, 1) },
              },
              outline: {
                [`${Nn.selector} &`]: {
                  border: `1px solid ${n(t, 4)}`,
                  color: `${n(t, 4)}`,
                  "&:hover": { backgroundColor: r(n(t, 4), 0.05) },
                },
                border: `1px solid ${n(t, 7)}`,
                backgroundColor: "transparent",
                color: n(t, 7),
                "&:hover": { backgroundColor: r(n(t, 0), 0.35) },
              },
              subtle: {
                [`${Nn.selector} &`]: {
                  color: "dark" === t ? n("dark", 0) : n(t, 2),
                  "&:hover": { backgroundColor: r(n(t, 8), 0.35) },
                },
                border: "transparent",
                backgroundColor: "transparent",
                color: "dark" === t ? n("dark", 9) : n(t, 6),
                "&:hover": { backgroundColor: n(t, 0) },
              },
              default: {
                [`${Nn.selector} &`]: {
                  border: `1px solid ${n("dark", 5)}`,
                  backgroundColor: n("dark", 5),
                  color: "White",
                  "&:hover": { backgroundColor: n("dark", 4) },
                },
                border: `1px solid ${n("gray", 4)}`,
                backgroundColor: "White",
                color: "Black",
                "&:hover": { backgroundColor: n("gray", 0) },
              },
              white: {
                border: "transparent",
                backgroundColor: "White",
                color: n(t, 7),
                "&:hover": { backgroundColor: "White" },
              },
              gradient: {},
            };
          return (
            e &&
              (s.gradient = {
                border: "transparent",
                background: `linear-gradient(${e.deg}deg, $${e.from}600 0%, $${e.to}600 100%)`,
                color: "White",
              }),
            s
          );
        };
        const he =
          ((fe = "rem"),
          (t) => {
            if ("number" == typeof t) return `${t / 16}${fe}`;
            if ("string" == typeof t) {
              const e = t.replace("px", "");
              if (!Number.isNaN(Number(e))) return `${Number(e) / 16}${fe}`;
            }
            return t;
          });
        var fe;
        function pe(t, e = 1) {
          if ("string" != typeof t || e > 1 || e < 0) return "rgba(0, 0, 0, 1)";
          const { r: n, g: r, b: s } = ue(t);
          return `rgba(${n}, ${r}, ${s}, ${e})`;
        }
        const ge = "indigo",
          me = "cyan",
          ye = 45;
        const be = {
            cover: function (t = 0) {
              return {
                position: "absolute",
                top: he(t),
                right: he(t),
                left: he(t),
                bottom: he(t),
              };
            },
            size: function (t) {
              return "number" == typeof t.size
                ? t.size
                : "number" == typeof t.sizes[t.size]
                ? t.sizes[t.size]
                : +t.sizes[t.size]?.value || +t.sizes.md?.value;
            },
            radius: function (t) {
              const e = ee()?.theme || ie();
              return "number" == typeof t ? t : e.radii[t].value;
            },
            themeColor: ce,
            variant: function ({ variant: t, color: e, gradient: n }) {
              const r = ee()?.theme || ie();
              if ("light" === t)
                return {
                  border: "transparent",
                  background: [pe(ce(e, 8), 0.35), pe(ce(e, 0), 1)],
                  color: [
                    "dark" === e ? ce("dark", 0) : ce(e, 2),
                    "dark" === e ? ce("dark", 9) : ce(e, 6),
                  ],
                  hover: [pe(ce(e, 7), 0.45), pe(ce(e, 1), 0.65)],
                };
              if ("default" === t)
                return {
                  border: [ce("dark", 5), ce("gray", 4)],
                  background: [ce("dark", 5), r.colors.white.value],
                  color: [r.colors.white.value, r.colors.black.value],
                  hover: [ce("dark", 4), ce("gray", 0)],
                };
              if ("white" === t)
                return {
                  border: "transparent",
                  background: r.colors.white.value,
                  color: ce(e, 6),
                  hover: null,
                };
              if ("outline" === t)
                return {
                  border: [ce(e, 4), ce(e, 6)],
                  background: "transparent",
                  color: [ce(e, 4), ce(e, 6)],
                  hover: [pe(ce(e, 4), 0.05), pe(ce(e, 0), 0.35)],
                };
              if ("gradient" === t) {
                const t = {
                  from: n?.from || ge,
                  to: n?.to || me,
                  deg: n?.deg || ye,
                };
                return {
                  background: `linear-gradient(${t.deg}deg, ${ce(
                    t.from,
                    6
                  )} 0%, ${ce(t.to, 6)} 100%)`,
                  color: r.colors.white.value,
                  border: "transparent",
                  hover: null,
                };
              }
              return "subtle" === t
                ? {
                    border: "transparent",
                    background: "transparent",
                    color: [
                      "dark" === e ? ce("dark", 0) : ce(e, 2),
                      "dark" === e ? ce("dark", 9) : ce(e, 6),
                    ],
                    hover: [pe(ce(e, 8), 0.35), pe(ce(e, 0), 1)],
                  }
                : {
                    border: "transparent",
                    background: [ce(e, 8), ce(e, 6)],
                    color: r.colors.white.value,
                    hover: ce(e, 7),
                  };
            },
            rgba: pe,
          },
          we = {
            primary: "#228be6",
            white: "#ffffff",
            black: "#000000",
            dark50: "#C1C2C5",
            dark100: "#A6A7AB",
            dark200: "#909296",
            dark300: "#5c5f66",
            dark400: "#373A40",
            dark500: "#2C2E33",
            dark600: "#25262b",
            dark700: "#1A1B1E",
            dark800: "#141517",
            dark900: "#101113",
            gray50: "#f8f9fa",
            gray100: "#f1f3f5",
            gray200: "#e9ecef",
            gray300: "#dee2e6",
            gray400: "#ced4da",
            gray500: "#adb5bd",
            gray600: "#868e96",
            gray700: "#495057",
            gray800: "#343a40",
            gray900: "#212529",
            red50: "#fff5f5",
            red100: "#ffe3e3",
            red200: "#ffc9c9",
            red300: "#ffa8a8",
            red400: "#ff8787",
            red500: "#ff6b6b",
            red600: "#fa5252",
            red700: "#f03e3e",
            red800: "#e03131",
            red900: "#c92a2a",
            pink50: "#fff0f6",
            pink100: "#ffdeeb",
            pink200: "#fcc2d7",
            pink300: "#faa2c1",
            pink400: "#f783ac",
            pink500: "#f06595",
            pink600: "#e64980",
            pink700: "#d6336c",
            pink800: "#c2255c",
            pink900: "#a61e4d",
            grape50: "#f8f0fc",
            grape100: "#f3d9fa",
            grape200: "#eebefa",
            grape300: "#e599f7",
            grape400: "#da77f2",
            grape500: "#cc5de8",
            grape600: "#be4bdb",
            grape700: "#ae3ec9",
            grape800: "#9c36b5",
            grape900: "#862e9c",
            violet50: "#f3f0ff",
            violet100: "#e5dbff",
            violet200: "#d0bfff",
            violet300: "#b197fc",
            violet400: "#9775fa",
            violet500: "#845ef7",
            violet600: "#7950f2",
            violet700: "#7048e8",
            violet800: "#6741d9",
            violet900: "#5f3dc4",
            indigo50: "#edf2ff",
            indigo100: "#dbe4ff",
            indigo200: "#bac8ff",
            indigo300: "#91a7ff",
            indigo400: "#748ffc",
            indigo500: "#5c7cfa",
            indigo600: "#4c6ef5",
            indigo700: "#4263eb",
            indigo800: "#3b5bdb",
            indigo900: "#364fc7",
            blue50: "#e7f5ff",
            blue100: "#d0ebff",
            blue200: "#a5d8ff",
            blue300: "#74c0fc",
            blue400: "#4dabf7",
            blue500: "#339af0",
            blue600: "#228be6",
            blue700: "#1c7ed6",
            blue800: "#1971c2",
            blue900: "#1864ab",
            cyan50: "#e3fafc",
            cyan100: "#c5f6fa",
            cyan200: "#99e9f2",
            cyan300: "#66d9e8",
            cyan400: "#3bc9db",
            cyan500: "#22b8cf",
            cyan600: "#15aabf",
            cyan700: "#1098ad",
            cyan800: "#0c8599",
            cyan900: "#0b7285",
            teal50: "#e6fcf5",
            teal100: "#c3fae8",
            teal200: "#96f2d7",
            teal300: "#63e6be",
            teal400: "#38d9a9",
            teal500: "#20c997",
            teal600: "#12b886",
            teal700: "#0ca678",
            teal800: "#099268",
            teal900: "#087f5b",
            green50: "#ebfbee",
            green100: "#d3f9d8",
            green200: "#b2f2bb",
            green300: "#8ce99a",
            green400: "#69db7c",
            green500: "#51cf66",
            green600: "#40c057",
            green700: "#37b24d",
            green800: "#2f9e44",
            green900: "#2b8a3e",
            lime50: "#f4fce3",
            lime100: "#e9fac8",
            lime200: "#d8f5a2",
            lime300: "#c0eb75",
            lime400: "#a9e34b",
            lime500: "#94d82d",
            lime600: "#82c91e",
            lime700: "#74b816",
            lime800: "#66a80f",
            lime900: "#5c940d",
            yellow50: "#fff9db",
            yellow100: "#fff3bf",
            yellow200: "#ffec99",
            yellow300: "#ffe066",
            yellow400: "#ffd43b",
            yellow500: "#fcc419",
            yellow600: "#fab005",
            yellow700: "#f59f00",
            yellow800: "#f08c00",
            yellow900: "#e67700",
            orange50: "#fff4e6",
            orange100: "#ffe8cc",
            orange200: "#ffd8a8",
            orange300: "#ffc078",
            orange400: "#ffa94d",
            orange500: "#ff922b",
            orange600: "#fd7e14",
            orange700: "#f76707",
            orange800: "#e8590c",
            orange900: "#d9480f",
          },
          ve = {
            blue: "blue",
            cyan: "cyan",
            dark: "dark",
            grape: "grape",
            gray: "gray",
            green: "green",
            indigo: "indigo",
            lime: "lime",
            orange: "orange",
            pink: "pink",
            red: "red",
            teal: "teal",
            violet: "violet",
            yellow: "yellow",
          },
          Ae = {}.hasOwnProperty;
        function $e(...t) {
          const e = [];
          for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (!r) continue;
            const s = typeof r;
            if ("string" === s || "number" === s) e.push(r);
            else if (Array.isArray(r)) {
              if (r.length) {
                const t = { ...r };
                t && e.push(t);
              }
            } else if ("object" === s)
              if (r.toString === Object.prototype.toString)
                for (const t in r) Ae.call(r, t) && r[t] && e.push(t);
              else e.push(r.toString());
          }
          return e.join(" ");
        }
        function xe() {
          return { cx: $e };
        }
        const ke = "svelteui";
        function Ee(t) {
          return `__svelteui-ref-${t || ""}`;
        }
        function Ce(t, e) {
          const n = [],
            r = {},
            s = (t) => {
              Object.keys(t).map((i) => {
                if ("variants" !== i) {
                  if (
                    ("ref" === i && n.push(t.ref),
                    "darkMode" === i && (t[`${e.dark} &`] = t.darkMode),
                    null !== t[i] && "object" == typeof t[i])
                  )
                    if ((s(t[i]), "darkMode" === i)) delete t[i];
                    else if (i.startsWith("@media"));
                    else if (!i.startsWith("&") && !i.startsWith(e.dark)) {
                      const e = $n(t[i]);
                      (r[i] = e().toString()),
                        (t[`& .${e().toString()}`] = t[i]),
                        delete t[i];
                    }
                } else
                  ((t) => {
                    const e = Object.keys(t.variation);
                    for (const n of e) s(t.variation[n]);
                  })(t[i]);
              });
            };
          return (
            s(t),
            delete t["& .root"],
            { classMap: r, refs: Array.from(new Set(n)) }
          );
        }
        function Se(t) {
          const e = "function" == typeof t ? t : () => t;
          return function (t = {}, n) {
            const r = ee()?.theme || ie(),
              { cx: s } = xe(),
              { override: i, name: o } = n || {},
              a = e(r, t, Ee),
              l = Object.assign({}, a),
              { classMap: c, refs: u } = Ce(l, r),
              d = a.root ?? void 0,
              h = void 0 !== d ? { ...d, ...l } : a,
              f = $n(h),
              p = (function (t) {
                const e = {};
                return (
                  Object.keys(t).forEach((n) => {
                    const [r, s] = t[n];
                    e[r] = s;
                  }),
                  e
                );
              })(
                Object.keys(a).map((t) => {
                  const e = u.find((e) => e.includes(t)) ?? "",
                    n = e?.split("-") ?? [],
                    r = e?.split("-")[n?.length - 1] === t,
                    s = t.toString();
                  let a = c[s] ?? s;
                  e && r && (a = `${a} ${e}`),
                    "root" === t && (a = f({ css: i }).toString());
                  let l = `${ke}-${t.toString()}`;
                  return (
                    o &&
                      ((l = `${ke}-${o}-${t.toString()}`), (a = `${a} ${l}`)),
                    [t, a]
                  );
                })
              );
            return { cx: s, theme: r, classes: p, getStyles: $n(h) };
          };
        }
        var Pe = "colors",
          Ie = "sizes",
          Ne = "space",
          Be = {
            gap: Ne,
            gridGap: Ne,
            columnGap: Ne,
            gridColumnGap: Ne,
            rowGap: Ne,
            gridRowGap: Ne,
            inset: Ne,
            insetBlock: Ne,
            insetBlockEnd: Ne,
            insetBlockStart: Ne,
            insetInline: Ne,
            insetInlineEnd: Ne,
            insetInlineStart: Ne,
            margin: Ne,
            marginTop: Ne,
            marginRight: Ne,
            marginBottom: Ne,
            marginLeft: Ne,
            marginBlock: Ne,
            marginBlockEnd: Ne,
            marginBlockStart: Ne,
            marginInline: Ne,
            marginInlineEnd: Ne,
            marginInlineStart: Ne,
            padding: Ne,
            paddingTop: Ne,
            paddingRight: Ne,
            paddingBottom: Ne,
            paddingLeft: Ne,
            paddingBlock: Ne,
            paddingBlockEnd: Ne,
            paddingBlockStart: Ne,
            paddingInline: Ne,
            paddingInlineEnd: Ne,
            paddingInlineStart: Ne,
            top: Ne,
            right: Ne,
            bottom: Ne,
            left: Ne,
            scrollMargin: Ne,
            scrollMarginTop: Ne,
            scrollMarginRight: Ne,
            scrollMarginBottom: Ne,
            scrollMarginLeft: Ne,
            scrollMarginX: Ne,
            scrollMarginY: Ne,
            scrollMarginBlock: Ne,
            scrollMarginBlockEnd: Ne,
            scrollMarginBlockStart: Ne,
            scrollMarginInline: Ne,
            scrollMarginInlineEnd: Ne,
            scrollMarginInlineStart: Ne,
            scrollPadding: Ne,
            scrollPaddingTop: Ne,
            scrollPaddingRight: Ne,
            scrollPaddingBottom: Ne,
            scrollPaddingLeft: Ne,
            scrollPaddingX: Ne,
            scrollPaddingY: Ne,
            scrollPaddingBlock: Ne,
            scrollPaddingBlockEnd: Ne,
            scrollPaddingBlockStart: Ne,
            scrollPaddingInline: Ne,
            scrollPaddingInlineEnd: Ne,
            scrollPaddingInlineStart: Ne,
            fontSize: "fontSizes",
            background: Pe,
            backgroundColor: Pe,
            backgroundImage: Pe,
            borderImage: Pe,
            border: Pe,
            borderBlock: Pe,
            borderBlockEnd: Pe,
            borderBlockStart: Pe,
            borderBottom: Pe,
            borderBottomColor: Pe,
            borderColor: Pe,
            borderInline: Pe,
            borderInlineEnd: Pe,
            borderInlineStart: Pe,
            borderLeft: Pe,
            borderLeftColor: Pe,
            borderRight: Pe,
            borderRightColor: Pe,
            borderTop: Pe,
            borderTopColor: Pe,
            caretColor: Pe,
            color: Pe,
            columnRuleColor: Pe,
            fill: Pe,
            outline: Pe,
            outlineColor: Pe,
            stroke: Pe,
            textDecorationColor: Pe,
            fontFamily: "fonts",
            fontWeight: "fontWeights",
            lineHeight: "lineHeights",
            letterSpacing: "letterSpacings",
            blockSize: Ie,
            minBlockSize: Ie,
            maxBlockSize: Ie,
            inlineSize: Ie,
            minInlineSize: Ie,
            maxInlineSize: Ie,
            width: Ie,
            minWidth: Ie,
            maxWidth: Ie,
            height: Ie,
            minHeight: Ie,
            maxHeight: Ie,
            flexBasis: Ie,
            gridTemplateColumns: Ie,
            gridTemplateRows: Ie,
            borderWidth: "borderWidths",
            borderTopWidth: "borderWidths",
            borderRightWidth: "borderWidths",
            borderBottomWidth: "borderWidths",
            borderLeftWidth: "borderWidths",
            borderStyle: "borderStyles",
            borderTopStyle: "borderStyles",
            borderRightStyle: "borderStyles",
            borderBottomStyle: "borderStyles",
            borderLeftStyle: "borderStyles",
            borderRadius: "radii",
            borderTopLeftRadius: "radii",
            borderTopRightRadius: "radii",
            borderBottomRightRadius: "radii",
            borderBottomLeftRadius: "radii",
            boxShadow: "shadows",
            textShadow: "shadows",
            transition: "transitions",
            zIndex: "zIndices",
          },
          Te = (t, e) =>
            "function" == typeof e
              ? { "()": Function.prototype.toString.call(e) }
              : e,
          Oe = () => {
            const t = Object.create(null);
            return (e, n, ...r) => {
              const s = ((t) => JSON.stringify(t, Te))(e);
              return s in t ? t[s] : (t[s] = n(e, ...r));
            };
          },
          Re = Symbol.for("sxs.internal"),
          Le = (t, e) =>
            Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)),
          ze = (t) => {
            for (const e in t) return !0;
            return !1;
          },
          { hasOwnProperty: Fe } = Object.prototype,
          Ue = (t) =>
            t.includes("-")
              ? t
              : t.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()),
          De = /\s+(?![^()]*\))/,
          Me = (t) => (e) =>
            t(...("string" == typeof e ? String(e).split(De) : [e])),
          je = {
            appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
            backfaceVisibility: (t) => ({
              WebkitBackfaceVisibility: t,
              backfaceVisibility: t,
            }),
            backdropFilter: (t) => ({
              WebkitBackdropFilter: t,
              backdropFilter: t,
            }),
            backgroundClip: (t) => ({
              WebkitBackgroundClip: t,
              backgroundClip: t,
            }),
            boxDecorationBreak: (t) => ({
              WebkitBoxDecorationBreak: t,
              boxDecorationBreak: t,
            }),
            clipPath: (t) => ({ WebkitClipPath: t, clipPath: t }),
            content: (t) => ({
              content:
                t.includes('"') ||
                t.includes("'") ||
                /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(
                  t
                )
                  ? t
                  : `"${t}"`,
            }),
            hyphens: (t) => ({ WebkitHyphens: t, hyphens: t }),
            maskImage: (t) => ({ WebkitMaskImage: t, maskImage: t }),
            maskSize: (t) => ({ WebkitMaskSize: t, maskSize: t }),
            tabSize: (t) => ({ MozTabSize: t, tabSize: t }),
            textSizeAdjust: (t) => ({
              WebkitTextSizeAdjust: t,
              textSizeAdjust: t,
            }),
            userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
            marginBlock: Me((t, e) => ({
              marginBlockStart: t,
              marginBlockEnd: e || t,
            })),
            marginInline: Me((t, e) => ({
              marginInlineStart: t,
              marginInlineEnd: e || t,
            })),
            maxSize: Me((t, e) => ({ maxBlockSize: t, maxInlineSize: e || t })),
            minSize: Me((t, e) => ({ minBlockSize: t, minInlineSize: e || t })),
            paddingBlock: Me((t, e) => ({
              paddingBlockStart: t,
              paddingBlockEnd: e || t,
            })),
            paddingInline: Me((t, e) => ({
              paddingInlineStart: t,
              paddingInlineEnd: e || t,
            })),
          },
          He = /([\d.]+)([^]*)/,
          Ge = (t, e) =>
            t.length
              ? t.reduce(
                  (t, n) => (
                    t.push(
                      ...e.map((t) =>
                        t.includes("&")
                          ? t.replace(
                              /&/g,
                              /[ +>|~]/.test(n) && /&.*&/.test(t)
                                ? `:is(${n})`
                                : n
                            )
                          : n + " " + t
                      )
                    ),
                    t
                  ),
                  []
                )
              : e,
          Ve = (t, e) =>
            t in We && "string" == typeof e
              ? e.replace(
                  /^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,
                  (e, n, r, s) =>
                    n +
                    ("stretch" === r
                      ? `-moz-available${s};${Ue(t)}:${n}-webkit-fill-available`
                      : `-moz-fit-content${s};${Ue(t)}:${n}fit-content`) +
                    s
                )
              : String(e),
          We = {
            blockSize: 1,
            height: 1,
            inlineSize: 1,
            maxBlockSize: 1,
            maxHeight: 1,
            maxInlineSize: 1,
            maxWidth: 1,
            minBlockSize: 1,
            minHeight: 1,
            minInlineSize: 1,
            minWidth: 1,
            width: 1,
          },
          Qe = (t) => (t ? t + "-" : ""),
          Je = (t, e, n) =>
            t.replace(
              /([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,
              (t, r, s, i, o) =>
                ("$" == i) == !!s
                  ? t
                  : (r || "--" == i ? "calc(" : "") +
                    "var(--" +
                    ("$" === i
                      ? Qe(e) +
                        (o.includes("$") ? "" : Qe(n)) +
                        o.replace(/\$/g, "-")
                      : o) +
                    ")" +
                    (r || "--" == i ? "*" + (r || "") + (s || "1") + ")" : "")
            ),
          _e = /\s*,\s*(?![^()]*\))/,
          Ke = Object.prototype.toString,
          qe = (t, e, n, r, s) => {
            let i, o, a;
            const l = (t, e, n) => {
              let c, u;
              const d = (t) => {
                for (c in t) {
                  const p = 64 === c.charCodeAt(0),
                    g = p && Array.isArray(t[c]) ? t[c] : [t[c]];
                  for (u of g) {
                    const t = /[A-Z]/.test((f = c))
                        ? f
                        : f.replace(/-[^]/g, (t) => t[1].toUpperCase()),
                      g =
                        "object" == typeof u &&
                        u &&
                        u.toString === Ke &&
                        (!r.utils[t] || !e.length);
                    if (t in r.utils && !g) {
                      const e = r.utils[t];
                      if (e !== o) {
                        (o = e), d(e(u)), (o = null);
                        continue;
                      }
                    } else if (t in je) {
                      const e = je[t];
                      if (e !== a) {
                        (a = e), d(e(u)), (a = null);
                        continue;
                      }
                    }
                    if (
                      (p &&
                        ((h =
                          c.slice(1) in r.media
                            ? "@media " + r.media[c.slice(1)]
                            : c),
                        (c = h.replace(
                          /\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,
                          (t, e, n, r, s, i) => {
                            const o = He.test(e),
                              a = 0.0625 * (o ? -1 : 1),
                              [l, c] = o ? [r, e] : [e, r];
                            return (
                              "(" +
                              ("=" === n[0]
                                ? ""
                                : (">" === n[0]) === o
                                ? "max-"
                                : "min-") +
                              l +
                              ":" +
                              ("=" !== n[0] && 1 === n.length
                                ? c.replace(
                                    He,
                                    (t, e, r) =>
                                      Number(e) + a * (">" === n ? 1 : -1) + r
                                  )
                                : c) +
                              (s
                                ? ") and (" +
                                  (">" === s[0] ? "min-" : "max-") +
                                  l +
                                  ":" +
                                  (1 === s.length
                                    ? i.replace(
                                        He,
                                        (t, e, n) =>
                                          Number(e) +
                                          a * (">" === s ? -1 : 1) +
                                          n
                                      )
                                    : i)
                                : "") +
                              ")"
                            );
                          }
                        ))),
                      g)
                    ) {
                      const t = p ? n.concat(c) : [...n],
                        r = p ? [...e] : Ge(e, c.split(_e));
                      void 0 !== i && s(Ye(...i)), (i = void 0), l(u, r, t);
                    } else
                      void 0 === i && (i = [[], e, n]),
                        (c =
                          p || 36 !== c.charCodeAt(0)
                            ? c
                            : `--${Qe(r.prefix)}${c
                                .slice(1)
                                .replace(/\$/g, "-")}`),
                        (u = g
                          ? u
                          : "number" == typeof u
                          ? u && t in Ze
                            ? String(u) + "px"
                            : String(u)
                          : Je(
                              Ve(t, null == u ? "" : u),
                              r.prefix,
                              r.themeMap[t]
                            )),
                        i[0].push(`${p ? `${c} ` : `${Ue(c)}:`}${u}`);
                  }
                }
                var h, f;
              };
              d(t), void 0 !== i && s(Ye(...i)), (i = void 0);
            };
            l(t, e, n);
          },
          Ye = (t, e, n) =>
            `${n.map((t) => `${t}{`).join("")}${
              e.length ? `${e.join(",")}{` : ""
            }${t.join(";")}${e.length ? "}" : ""}${Array(
              n.length ? n.length + 1 : 0
            ).join("}")}`,
          Ze = {
            animationDelay: 1,
            animationDuration: 1,
            backgroundSize: 1,
            blockSize: 1,
            border: 1,
            borderBlock: 1,
            borderBlockEnd: 1,
            borderBlockEndWidth: 1,
            borderBlockStart: 1,
            borderBlockStartWidth: 1,
            borderBlockWidth: 1,
            borderBottom: 1,
            borderBottomLeftRadius: 1,
            borderBottomRightRadius: 1,
            borderBottomWidth: 1,
            borderEndEndRadius: 1,
            borderEndStartRadius: 1,
            borderInlineEnd: 1,
            borderInlineEndWidth: 1,
            borderInlineStart: 1,
            borderInlineStartWidth: 1,
            borderInlineWidth: 1,
            borderLeft: 1,
            borderLeftWidth: 1,
            borderRadius: 1,
            borderRight: 1,
            borderRightWidth: 1,
            borderSpacing: 1,
            borderStartEndRadius: 1,
            borderStartStartRadius: 1,
            borderTop: 1,
            borderTopLeftRadius: 1,
            borderTopRightRadius: 1,
            borderTopWidth: 1,
            borderWidth: 1,
            bottom: 1,
            columnGap: 1,
            columnRule: 1,
            columnRuleWidth: 1,
            columnWidth: 1,
            containIntrinsicSize: 1,
            flexBasis: 1,
            fontSize: 1,
            gap: 1,
            gridAutoColumns: 1,
            gridAutoRows: 1,
            gridTemplateColumns: 1,
            gridTemplateRows: 1,
            height: 1,
            inlineSize: 1,
            inset: 1,
            insetBlock: 1,
            insetBlockEnd: 1,
            insetBlockStart: 1,
            insetInline: 1,
            insetInlineEnd: 1,
            insetInlineStart: 1,
            left: 1,
            letterSpacing: 1,
            margin: 1,
            marginBlock: 1,
            marginBlockEnd: 1,
            marginBlockStart: 1,
            marginBottom: 1,
            marginInline: 1,
            marginInlineEnd: 1,
            marginInlineStart: 1,
            marginLeft: 1,
            marginRight: 1,
            marginTop: 1,
            maxBlockSize: 1,
            maxHeight: 1,
            maxInlineSize: 1,
            maxWidth: 1,
            minBlockSize: 1,
            minHeight: 1,
            minInlineSize: 1,
            minWidth: 1,
            offsetDistance: 1,
            offsetRotate: 1,
            outline: 1,
            outlineOffset: 1,
            outlineWidth: 1,
            overflowClipMargin: 1,
            padding: 1,
            paddingBlock: 1,
            paddingBlockEnd: 1,
            paddingBlockStart: 1,
            paddingBottom: 1,
            paddingInline: 1,
            paddingInlineEnd: 1,
            paddingInlineStart: 1,
            paddingLeft: 1,
            paddingRight: 1,
            paddingTop: 1,
            perspective: 1,
            right: 1,
            rowGap: 1,
            scrollMargin: 1,
            scrollMarginBlock: 1,
            scrollMarginBlockEnd: 1,
            scrollMarginBlockStart: 1,
            scrollMarginBottom: 1,
            scrollMarginInline: 1,
            scrollMarginInlineEnd: 1,
            scrollMarginInlineStart: 1,
            scrollMarginLeft: 1,
            scrollMarginRight: 1,
            scrollMarginTop: 1,
            scrollPadding: 1,
            scrollPaddingBlock: 1,
            scrollPaddingBlockEnd: 1,
            scrollPaddingBlockStart: 1,
            scrollPaddingBottom: 1,
            scrollPaddingInline: 1,
            scrollPaddingInlineEnd: 1,
            scrollPaddingInlineStart: 1,
            scrollPaddingLeft: 1,
            scrollPaddingRight: 1,
            scrollPaddingTop: 1,
            shapeMargin: 1,
            textDecoration: 1,
            textDecorationThickness: 1,
            textIndent: 1,
            textUnderlineOffset: 1,
            top: 1,
            transitionDelay: 1,
            transitionDuration: 1,
            verticalAlign: 1,
            width: 1,
            wordSpacing: 1,
          },
          Xe = (t) => String.fromCharCode(t + (t > 25 ? 39 : 97)),
          tn = (t) =>
            ((t) => {
              let e,
                n = "";
              for (e = Math.abs(t); e > 52; e = (e / 52) | 0)
                n = Xe(e % 52) + n;
              return Xe(e % 52) + n;
            })(
              ((t, e) => {
                let n = e.length;
                for (; n; ) t = (33 * t) ^ e.charCodeAt(--n);
                return t;
              })(5381, JSON.stringify(t)) >>> 0
            ),
          en = [
            "themed",
            "global",
            "styled",
            "onevar",
            "resonevar",
            "allvar",
            "inline",
          ],
          nn = (t) => {
            if (t.href && !t.href.startsWith(location.origin)) return !1;
            try {
              return !!t.cssRules;
            } catch (t) {
              return !1;
            }
          },
          rn = (t) => {
            let e;
            const n = () => {
                const { cssRules: t } = e.sheet;
                return [].map
                  .call(t, (n, r) => {
                    const { cssText: s } = n;
                    let i = "";
                    if (s.startsWith("--sxs")) return "";
                    if (
                      t[r - 1] &&
                      (i = t[r - 1].cssText).startsWith("--sxs")
                    ) {
                      if (!n.cssRules.length) return "";
                      for (const t in e.rules)
                        if (e.rules[t].group === n)
                          return `--sxs{--sxs:${[...e.rules[t].cache].join(
                            " "
                          )}}${s}`;
                      return n.cssRules.length ? `${i}${s}` : "";
                    }
                    return s;
                  })
                  .join("");
              },
              r = () => {
                if (e) {
                  const { rules: t, sheet: n } = e;
                  if (!n.deleteRule) {
                    for (; 3 === Object(Object(n.cssRules)[0]).type; )
                      n.cssRules.splice(0, 1);
                    n.cssRules = [];
                  }
                  for (const e in t) delete t[e];
                }
                const s = Object(t).styleSheets || [];
                for (const t of s)
                  if (nn(t)) {
                    for (let s = 0, i = t.cssRules; i[s]; ++s) {
                      const o = Object(i[s]);
                      if (1 !== o.type) continue;
                      const a = Object(i[s + 1]);
                      if (4 !== a.type) continue;
                      ++s;
                      const { cssText: l } = o;
                      if (!l.startsWith("--sxs")) continue;
                      const c = l.slice(14, -3).trim().split(/\s+/),
                        u = en[c[0]];
                      u &&
                        (e ||
                          (e = { sheet: t, reset: r, rules: {}, toString: n }),
                        (e.rules[u] = {
                          group: a,
                          index: s,
                          cache: new Set(c),
                        }));
                    }
                    if (e) break;
                  }
                if (!e) {
                  const s = (t, e) => ({
                    type: e,
                    cssRules: [],
                    insertRule(t, e) {
                      this.cssRules.splice(
                        e,
                        0,
                        s(
                          t,
                          { import: 3, undefined: 1 }[
                            (t.toLowerCase().match(/^@([a-z]+)/) || [])[1]
                          ] || 4
                        )
                      );
                    },
                    get cssText() {
                      return "@media{}" === t
                        ? `@media{${[].map
                            .call(this.cssRules, (t) => t.cssText)
                            .join("")}}`
                        : t;
                    },
                  });
                  e = {
                    sheet: t
                      ? (t.head || t).appendChild(
                          document.createElement("style")
                        ).sheet
                      : s("", "text/css"),
                    rules: {},
                    reset: r,
                    toString: n,
                  };
                }
                const { sheet: i, rules: o } = e;
                for (let t = en.length - 1; t >= 0; --t) {
                  const e = en[t];
                  if (!o[e]) {
                    const n = en[t + 1],
                      r = o[n] ? o[n].index : i.cssRules.length;
                    i.insertRule("@media{}", r),
                      i.insertRule(`--sxs{--sxs:${t}}`, r),
                      (o[e] = {
                        group: i.cssRules[r + 1],
                        index: r,
                        cache: new Set([t]),
                      });
                  }
                  sn(o[e]);
                }
              };
            return r(), e;
          },
          sn = (t) => {
            const e = t.group;
            let n = e.cssRules.length;
            t.apply = (t) => {
              try {
                e.insertRule(t, n), ++n;
              } catch (t) {}
            };
          },
          on = Symbol(),
          an = Oe(),
          ln = (t, e) =>
            an(t, () => (...n) => {
              let r = { type: null, composers: new Set() };
              for (const e of n)
                if (null != e)
                  if (e[Re]) {
                    null == r.type && (r.type = e[Re].type);
                    for (const t of e[Re].composers) r.composers.add(t);
                  } else
                    e.constructor !== Object || e.$$typeof
                      ? null == r.type && (r.type = e)
                      : r.composers.add(cn(e, t));
              return (
                null == r.type && (r.type = "span"),
                r.composers.size ||
                  r.composers.add(["PJLV", {}, [], [], {}, []]),
                un(t, r, e)
              );
            }),
          cn = (
            { variants: t, compoundVariants: e, defaultVariants: n, ...r },
            s
          ) => {
            const i = `${Qe(s.prefix)}c-${tn(r)}`,
              o = [],
              a = [],
              l = Object.create(null),
              c = [];
            for (const t in n) l[t] = String(n[t]);
            if ("object" == typeof t && t)
              for (const e in t) {
                (u = l), (d = e), Fe.call(u, d) || (l[e] = "undefined");
                const n = t[e];
                for (const t in n) {
                  const r = { [e]: String(t) };
                  "undefined" === String(t) && c.push(e);
                  const s = n[t],
                    i = [r, s, !ze(s)];
                  o.push(i);
                }
              }
            var u, d;
            if ("object" == typeof e && e)
              for (const t of e) {
                let { css: e, ...n } = t;
                e = ("object" == typeof e && e) || {};
                for (const t in n) n[t] = String(n[t]);
                const r = [n, e, !ze(e)];
                a.push(r);
              }
            return [i, r, o, a, l, c];
          },
          un = (t, e, n) => {
            const [r, s, i, o] = dn(e.composers),
              a =
                "function" == typeof e.type || e.type.$$typeof
                  ? ((t) => {
                      function e() {
                        for (let n = 0; n < e[on].length; n++) {
                          const [r, s] = e[on][n];
                          t.rules[r].apply(s);
                        }
                        return (e[on] = []), null;
                      }
                      return (
                        (e[on] = []),
                        (e.rules = {}),
                        en.forEach(
                          (t) =>
                            (e.rules[t] = { apply: (n) => e[on].push([t, n]) })
                        ),
                        e
                      );
                    })(n)
                  : null,
              l = (a || n).rules,
              c = `.${r}${
                s.length > 1 ? `:where(.${s.slice(1).join(".")})` : ""
              }`,
              u = (u) => {
                u = ("object" == typeof u && u) || fn;
                const { css: d, ...h } = u,
                  f = {};
                for (const t in i)
                  if ((delete h[t], t in u)) {
                    let e = u[t];
                    "object" == typeof e && e
                      ? (f[t] = { "@initial": i[t], ...e })
                      : ((e = String(e)),
                        (f[t] = "undefined" !== e || o.has(t) ? e : i[t]));
                  } else f[t] = i[t];
                const p = new Set([...s]);
                for (const [r, s, i, o] of e.composers) {
                  n.rules.styled.cache.has(r) ||
                    (n.rules.styled.cache.add(r),
                    qe(s, [`.${r}`], [], t, (t) => {
                      l.styled.apply(t);
                    }));
                  const e = hn(i, f, t.media),
                    a = hn(o, f, t.media, !0);
                  for (const s of e)
                    if (void 0 !== s)
                      for (const [e, i, o] of s) {
                        const s = `${r}-${tn(i)}-${e}`;
                        p.add(s);
                        const a = (o ? n.rules.resonevar : n.rules.onevar)
                            .cache,
                          c = o ? l.resonevar : l.onevar;
                        a.has(s) ||
                          (a.add(s),
                          qe(i, [`.${s}`], [], t, (t) => {
                            c.apply(t);
                          }));
                      }
                  for (const e of a)
                    if (void 0 !== e)
                      for (const [s, i] of e) {
                        const e = `${r}-${tn(i)}-${s}`;
                        p.add(e),
                          n.rules.allvar.cache.has(e) ||
                            (n.rules.allvar.cache.add(e),
                            qe(i, [`.${e}`], [], t, (t) => {
                              l.allvar.apply(t);
                            }));
                      }
                }
                if ("object" == typeof d && d) {
                  const e = `${r}-i${tn(d)}-css`;
                  p.add(e),
                    n.rules.inline.cache.has(e) ||
                      (n.rules.inline.cache.add(e),
                      qe(d, [`.${e}`], [], t, (t) => {
                        l.inline.apply(t);
                      }));
                }
                for (const t of String(u.className || "")
                  .trim()
                  .split(/\s+/))
                  t && p.add(t);
                const g = (h.className = [...p].join(" "));
                return {
                  type: e.type,
                  className: g,
                  selector: c,
                  props: h,
                  toString: () => g,
                  deferredInjector: a,
                };
              };
            return Le(u, {
              className: r,
              selector: c,
              [Re]: e,
              toString: () => (n.rules.styled.cache.has(r) || u(), r),
            });
          },
          dn = (t) => {
            let e = "";
            const n = [],
              r = {},
              s = [];
            for (const [i, , , , o, a] of t) {
              "" === e && (e = i), n.push(i), s.push(...a);
              for (const t in o) {
                const e = o[t];
                (void 0 === r[t] || "undefined" !== e || a.includes(e)) &&
                  (r[t] = e);
              }
            }
            return [e, n, r, new Set(s)];
          },
          hn = (t, e, n, r) => {
            const s = [];
            t: for (let [i, o, a] of t) {
              if (a) continue;
              let t,
                l = 0,
                c = !1;
              for (t in i) {
                const r = i[t];
                let s = e[t];
                if (s !== r) {
                  if ("object" != typeof s || !s) continue t;
                  {
                    let t,
                      e,
                      i = 0;
                    for (const o in s) {
                      if (r === String(s[o])) {
                        if ("@initial" !== o) {
                          const t = o.slice(1);
                          (e = e || []).push(
                            t in n ? n[t] : o.replace(/^@media ?/, "")
                          ),
                            (c = !0);
                        }
                        (l += i), (t = !0);
                      }
                      ++i;
                    }
                    if (
                      (e && e.length && (o = { ["@media " + e.join(", ")]: o }),
                      !t)
                    )
                      continue t;
                  }
                }
              }
              (s[l] = s[l] || []).push([r ? "cv" : `${t}-${i[t]}`, o, c]);
            }
            return s;
          },
          fn = {},
          pn = Oe(),
          gn = (t, e) =>
            pn(t, () => (...n) => {
              const r = () => {
                for (let r of n) {
                  r = ("object" == typeof r && r) || {};
                  let n = tn(r);
                  if (!e.rules.global.cache.has(n)) {
                    if ((e.rules.global.cache.add(n), "@import" in r)) {
                      let t =
                        [].indexOf.call(
                          e.sheet.cssRules,
                          e.rules.themed.group
                        ) - 1;
                      for (let n of [].concat(r["@import"]))
                        (n = n.includes('"') || n.includes("'") ? n : `"${n}"`),
                          e.sheet.insertRule(`@import ${n};`, t++);
                      delete r["@import"];
                    }
                    qe(r, [], [], t, (t) => {
                      e.rules.global.apply(t);
                    });
                  }
                }
                return "";
              };
              return Le(r, { toString: r });
            }),
          mn = Oe(),
          yn = (t, e) =>
            mn(t, () => (n) => {
              const r = `${Qe(t.prefix)}k-${tn(n)}`,
                s = () => {
                  if (!e.rules.global.cache.has(r)) {
                    e.rules.global.cache.add(r);
                    const s = [];
                    qe(n, [], [], t, (t) => s.push(t));
                    const i = `@keyframes ${r}{${s.join("")}}`;
                    e.rules.global.apply(i);
                  }
                  return r;
                };
              return Le(s, {
                get name() {
                  return s();
                },
                toString: s,
              });
            }),
          bn = class {
            constructor(t, e, n, r) {
              (this.token = null == t ? "" : String(t)),
                (this.value = null == e ? "" : String(e)),
                (this.scale = null == n ? "" : String(n)),
                (this.prefix = null == r ? "" : String(r));
            }
            get computedValue() {
              return "var(" + this.variable + ")";
            }
            get variable() {
              return "--" + Qe(this.prefix) + Qe(this.scale) + this.token;
            }
            toString() {
              return this.computedValue;
            }
          },
          wn = Oe(),
          vn = (t, e) =>
            wn(t, () => (n, r) => {
              r = ("object" == typeof n && n) || Object(r);
              const s = `.${(n =
                  (n = "string" == typeof n ? n : "") ||
                  `${Qe(t.prefix)}t-${tn(r)}`)}`,
                i = {},
                o = [];
              for (const e in r) {
                i[e] = {};
                for (const n in r[e]) {
                  const s = `--${Qe(t.prefix)}${e}-${n}`,
                    a = Je(String(r[e][n]), t.prefix, e);
                  (i[e][n] = new bn(n, a, e, t.prefix)), o.push(`${s}:${a}`);
                }
              }
              const a = () => {
                if (o.length && !e.rules.themed.cache.has(n)) {
                  e.rules.themed.cache.add(n);
                  const s = `${r === t.theme ? ":root," : ""}.${n}{${o.join(
                    ";"
                  )}}`;
                  e.rules.themed.apply(s);
                }
                return n;
              };
              return {
                ...i,
                get className() {
                  return a();
                },
                selector: s,
                toString: a,
              };
            }),
          An = Oe();
        const {
            css: $n,
            globalCss: xn,
            keyframes: kn,
            getCssText: En,
            theme: Cn,
            createTheme: Sn,
            config: Pn,
            reset: In,
          } = ((t) => {
            let e = !1;
            const n = An(t, (t) => {
              e = !0;
              const n =
                  "prefix" in (t = ("object" == typeof t && t) || {})
                    ? String(t.prefix)
                    : "",
                r = ("object" == typeof t.media && t.media) || {},
                s =
                  "object" == typeof t.root
                    ? t.root || null
                    : globalThis.document || null,
                i = ("object" == typeof t.theme && t.theme) || {},
                o = {
                  prefix: n,
                  media: r,
                  theme: i,
                  themeMap: ("object" == typeof t.themeMap && t.themeMap) || {
                    ...Be,
                  },
                  utils: ("object" == typeof t.utils && t.utils) || {},
                },
                a = rn(s),
                l = {
                  css: ln(o, a),
                  globalCss: gn(o, a),
                  keyframes: yn(o, a),
                  createTheme: vn(o, a),
                  reset() {
                    a.reset(), l.theme.toString();
                  },
                  theme: {},
                  sheet: a,
                  config: o,
                  prefix: n,
                  getCssText: a.toString,
                  toString: a.toString,
                };
              return String((l.theme = l.createTheme(i))), l;
            });
            return e || n.reset(), n;
          })({
            prefix: "svelteui",
            theme: {
              colors: we,
              space: {
                0: "0rem",
                xs: 10,
                sm: 12,
                md: 16,
                lg: 20,
                xl: 24,
                xsPX: "10px",
                smPX: "12px",
                mdPX: "16px",
                lgPX: "20px",
                xlPX: "24px",
                1: "0.125rem",
                2: "0.25rem",
                3: "0.375rem",
                4: "0.5rem",
                5: "0.625rem",
                6: "0.75rem",
                7: "0.875rem",
                8: "1rem",
                9: "1.25rem",
                10: "1.5rem",
                11: "1.75rem",
                12: "2rem",
                13: "2.25rem",
                14: "2.5rem",
                15: "2.75rem",
                16: "3rem",
                17: "3.5rem",
                18: "4rem",
                20: "5rem",
                24: "6rem",
                28: "7rem",
                32: "8rem",
                36: "9rem",
                40: "10rem",
                44: "11rem",
                48: "12rem",
                52: "13rem",
                56: "14rem",
                60: "15rem",
                64: "16rem",
                72: "18rem",
                80: "20rem",
                96: "24rem",
              },
              fontSizes: {
                xs: "12px",
                sm: "14px",
                md: "16px",
                lg: "18px",
                xl: "20px",
              },
              fonts: {
                standard:
                  "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
                mono: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
                fallback: "Segoe UI, system-ui, sans-serif",
              },
              fontWeights: {
                thin: 100,
                extralight: 200,
                light: 300,
                normal: 400,
                medium: 500,
                semibold: 600,
                bold: 700,
                extrabold: 800,
              },
              lineHeights: { xs: 1, sm: 1.25, md: 1.5, lg: 1.625, xl: 1.75 },
              letterSpacings: {
                tighter: "-0.05em",
                tight: "-0.025em",
                normal: "0",
                wide: "0.025em",
                wider: "0.05em",
                widest: "0.1em",
              },
              sizes: {},
              radii: {
                xs: "2px",
                sm: "4px",
                md: "8px",
                lg: "16px",
                xl: "32px",
                squared: "33%",
                rounded: "50%",
                pill: "9999px",
              },
              shadows: {
                xs: "0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)",
                sm: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 10px 15px -5px, rgba(0, 0, 0, 0.04) 0px 7px 7px -5px",
                md: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 20px 25px -5px, rgba(0, 0, 0, 0.04) 0px 10px 10px -5px",
                lg: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 28px 23px -7px, rgba(0, 0, 0, 0.04) 0px 12px 12px -7px",
                xl: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 36px 28px -7px, rgba(0, 0, 0, 0.04) 0px 17px 17px -7px",
              },
              zIndices: {
                1: "100",
                2: "200",
                3: "300",
                4: "400",
                5: "500",
                10: "1000",
                max: "9999",
              },
              borderWidths: {
                light: "1px",
                normal: "2px",
                bold: "3px",
                extrabold: "4px",
                black: "5px",
                xs: "1px",
                sm: "2px",
                md: "3px",
                lg: "4px",
                xl: "5px",
              },
              breakpoints: { xs: 576, sm: 768, md: 992, lg: 1200, xl: 1400 },
              borderStyles: {},
              transitions: {},
            },
            media: {
              xs: "(min-width: 576px)",
              sm: "(min-width: 768px)",
              md: "(min-width: 992px)",
              lg: "(min-width: 1200px)",
              xl: "(min-width: 1400px)",
            },
            utils: {
              focusRing: (t) => ({
                WebkitTapHighlightColor: "transparent",
                "&:focus": {
                  outlineOffset: 2,
                  outline:
                    "always" === t || "auto" === t
                      ? "2px solid $primary"
                      : "none",
                },
                "&:focus:not(:focus-visible)": {
                  outline: "auto" === t || "never" === t ? "none" : void 0,
                },
              }),
              p: (t) => ({ padding: t }),
              pt: (t) => ({ paddingTop: t }),
              pr: (t) => ({ paddingRight: t }),
              pb: (t) => ({ paddingBottom: t }),
              pl: (t) => ({ paddingLeft: t }),
              px: (t) => ({ paddingLeft: t, paddingRight: t }),
              py: (t) => ({ paddingTop: t, paddingBottom: t }),
              m: (t) => ({ margin: t }),
              mt: (t) => ({ marginTop: t }),
              mr: (t) => ({ marginRight: t }),
              mb: (t) => ({ marginBottom: t }),
              ml: (t) => ({ marginLeft: t }),
              mx: (t) => ({ marginLeft: t, marginRight: t }),
              my: (t) => ({ marginTop: t, marginBottom: t }),
              ta: (t) => ({ textAlign: t }),
              tt: (t) => ({ textTransform: t }),
              to: (t) => ({ textOverflow: t }),
              d: (t) => ({ display: t }),
              dflex: (t) => ({
                display: "flex",
                alignItems: t,
                justifyContent: t,
              }),
              fd: (t) => ({ flexDirection: t }),
              fw: (t) => ({ flexWrap: t }),
              ai: (t) => ({ alignItems: t }),
              ac: (t) => ({ alignContent: t }),
              jc: (t) => ({ justifyContent: t }),
              as: (t) => ({ alignSelf: t }),
              fg: (t) => ({ flexGrow: t }),
              fs: (t) => ({ fontSize: t }),
              fb: (t) => ({ flexBasis: t }),
              bc: (t) => ({ backgroundColor: t }),
              bf: (t) => ({ backdropFilter: t }),
              bg: (t) => ({ background: t }),
              bgBlur: (t) => ({ bf: "saturate(180%) blur(10px)", bg: t }),
              bgColor: (t) => ({ backgroundColor: t }),
              backgroundClip: (t) => ({
                WebkitBackgroundClip: t,
                backgroundClip: t,
              }),
              bgClip: (t) => ({ WebkitBackgroundClip: t, backgroundClip: t }),
              br: (t) => ({ borderRadius: t }),
              bw: (t) => ({ borderWidth: t }),
              btrr: (t) => ({ borderTopRightRadius: t }),
              bbrr: (t) => ({ borderBottomRightRadius: t }),
              bblr: (t) => ({ borderBottomLeftRadius: t }),
              btlr: (t) => ({ borderTopLeftRadius: t }),
              bs: (t) => ({ boxShadow: t }),
              normalShadow: (t) => ({ boxShadow: `0 4px 14px 0 $${t}` }),
              lh: (t) => ({ lineHeight: t }),
              ov: (t) => ({ overflow: t }),
              ox: (t) => ({ overflowX: t }),
              oy: (t) => ({ overflowY: t }),
              pe: (t) => ({ pointerEvents: t }),
              events: (t) => ({ pointerEvents: t }),
              us: (t) => ({ WebkitUserSelect: t, userSelect: t }),
              userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
              w: (t) => ({ width: t }),
              h: (t) => ({ height: t }),
              minW: (t) => ({ minWidth: t }),
              minH: (t) => ({ minWidth: t }),
              mw: (t) => ({ maxWidth: t }),
              maxW: (t) => ({ maxWidth: t }),
              mh: (t) => ({ maxHeight: t }),
              maxH: (t) => ({ maxHeight: t }),
              size: (t) => ({ width: t, height: t }),
              minSize: (t) => ({
                minWidth: t,
                minHeight: t,
                width: t,
                height: t,
              }),
              sizeMin: (t) => ({
                minWidth: t,
                minHeight: t,
                width: t,
                height: t,
              }),
              maxSize: (t) => ({ maxWidth: t, maxHeight: t }),
              sizeMax: (t) => ({ maxWidth: t, maxHeight: t }),
              appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
              scale: (t) => ({ transform: `scale(${t})` }),
              linearGradient: (t) => ({
                backgroundImage: `linear-gradient(${t})`,
              }),
              tdl: (t) => ({ textDecorationLine: t }),
              textGradient: (t) => ({
                backgroundImage: `linear-gradient(${t})`,
                WebkitBackgroundClip: "text",
                WebkitTextFillColor: "transparent",
              }),
            },
            themeMap: {
              ...Be,
              width: "space",
              height: "space",
              minWidth: "space",
              maxWidth: "space",
              minHeight: "space",
              maxHeight: "space",
              flexBasis: "space",
              gridTemplateColumns: "space",
              gridTemplateRows: "space",
              blockSize: "space",
              minBlockSize: "space",
              maxBlockSize: "space",
              inlineSize: "space",
              minInlineSize: "space",
              maxInlineSize: "space",
              borderWidth: "borderWeights",
            },
          }),
          Nn = Sn("dark-theme", {
            colors: we,
            shadows: {
              xs: "-4px 0 15px rgb(0 0 0 / 50%)",
              sm: "0 5px 20px -5px rgba(20, 20, 20, 0.1)",
              md: "0 8px 30px rgba(20, 20, 20, 0.15)",
              lg: "0 30px 60px rgba(20, 20, 20, 0.15)",
              xl: "0 40px 80px rgba(20, 20, 20, 0.25)",
            },
          }),
          Bn = xn({
            a: { focusRing: "auto" },
            body: {
              [`${Nn.selector} &`]: {
                backgroundColor: "$dark700",
                color: "$dark50",
              },
              backgroundColor: "$white",
              color: "$black",
            },
          }),
          Tn = xn({
            html: {
              fontFamily: "sans-serif",
              lineHeight: "1.15",
              textSizeAdjust: "100%",
              margin: 0,
            },
            body: { margin: 0 },
            "article, aside, footer, header, nav, section, figcaption, figure, main":
              { display: "block" },
            h1: { fontSize: "2em", margin: 0 },
            hr: { boxSizing: "content-box", height: 0, overflow: "visible" },
            pre: { fontFamily: "monospace, monospace", fontSize: "1em" },
            a: { background: "transparent", textDecorationSkip: "objects" },
            "a:active, a:hover": { outlineWidth: 0 },
            "abbr[title]": {
              borderBottom: "none",
              textDecoration: "underline",
            },
            "b, strong": { fontWeight: "bolder" },
            "code, kbp, samp": {
              fontFamily: "monospace, monospace",
              fontSize: "1em",
            },
            dfn: { fontStyle: "italic" },
            mark: { backgroundColor: "#ff0", color: "#000" },
            small: { fontSize: "80%" },
            "sub, sup": {
              fontSize: "75%",
              lineHeight: 0,
              position: "relative",
              verticalAlign: "baseline",
            },
            sup: { top: "-0.5em" },
            sub: { bottom: "-0.25em" },
            "audio, video": { display: "inline-block" },
            "audio:not([controls])": { display: "none", height: 0 },
            img: { borderStyle: "none", verticalAlign: "middle" },
            "svg:not(:root)": { overflow: "hidden" },
            "button, input, optgroup, select, textarea": {
              fontFamily: "sans-serif",
              fontSize: "100%",
              lineHeight: "1.15",
              margin: 0,
            },
            "button, input": { overflow: "visible" },
            "button, select": { textTransform: "none" },
            "button, [type=reset], [type=submit]": {
              WebkitAppearance: "button",
            },
            "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner":
              { borderStyle: "none", padding: 0 },
            "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring":
              { outline: "1px dotted ButtonText" },
            legend: {
              boxSizing: "border-box",
              color: "inherit",
              display: "table",
              maxWidth: "100%",
              padding: 0,
              whiteSpace: "normal",
            },
            progress: { display: "inline-block", verticalAlign: "baseline" },
            textarea: { overflow: "auto" },
            "[type=checkbox], [type=radio]": {
              boxSizing: "border-box",
              padding: 0,
            },
            "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button":
              { height: "auto" },
            "[type=search]": { appearance: "textfield", outlineOffset: "-2px" },
            "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration":
              { appearance: "none" },
            "::-webkit-file-upload-button": {
              appearance: "button",
              font: "inherit",
            },
            "details, menu": { display: "block" },
            summary: { display: "list-item" },
            canvas: { display: "inline-block" },
            template: { display: "none" },
            "[hidden]": { display: "none" },
          }),
          On = {
            mt: "marginTop",
            mb: "marginBottom",
            ml: "marginLeft",
            mr: "marginRight",
            pt: "paddingTop",
            pb: "paddingBottom",
            pl: "paddingLeft",
            pr: "paddingRight",
          },
          Rn = ["-xs", "-sm", "-md", "-lg", "-xl"];
        function Ln(t) {
          return "string" == typeof t || "number" == typeof t;
        }
        function zn(t, e) {
          return Rn.includes(t)
            ? -1 * e.fn.size({ size: t.replace("-", ""), sizes: e.space })
            : e.fn.size({ size: t, sizes: e.space });
        }
        function Fn(t) {
          let e, r, s, a, l, u;
          const p = t[28].default,
            g = c(p, t, t[32], null);
          let m = [
              {
                class: (r =
                  t[2] + " " + t[7]({ css: { ...t[11](t[10]), ...t[6] } })),
              },
              t[12],
            ],
            b = {};
          for (let t = 0; t < m.length; t += 1) b = n(b, m[t]);
          return {
            c() {
              (e = N("div")), g && g.c(), U(e, b);
            },
            m(n, r) {
              P(n, e, r),
                g && g.m(e, null),
                t[31](e),
                (a = !0),
                l ||
                  ((u = [
                    y(t[8].call(null, e)),
                    y((s = Qt.call(null, e, t[1]))),
                  ]),
                  (l = !0));
            },
            p(t, n) {
              g &&
                g.p &&
                (!a || 2 & n[1]) &&
                h(g, p, t, t[32], a ? d(p, t[32], n, null) : f(t[32]), null),
                U(
                  e,
                  (b = Nt(m, [
                    (!a ||
                      (196 & n[0] &&
                        r !==
                          (r =
                            t[2] +
                            " " +
                            t[7]({ css: { ...t[11](t[10]), ...t[6] } })))) && {
                      class: r,
                    },
                    4096 & n[0] && t[12],
                  ]))
                ),
                s && o(s.update) && 2 & n[0] && s.update.call(null, t[1]);
            },
            i(t) {
              a || (Ct(g, t), (a = !0));
            },
            o(t) {
              St(g, t), (a = !1);
            },
            d(n) {
              n && I(e), g && g.d(n), t[31](null), (l = !1), i(u);
            },
          };
        }
        function Un(t) {
          let e, r, s;
          const i = [
            { use: [t[8], [Qt, t[1]]] },
            { class: t[2] + " " + t[7]({ css: { ...t[11](t[10]), ...t[6] } }) },
            t[12],
          ];
          var o = t[3];
          function a(t) {
            let e = { $$slots: { default: [Mn] }, $$scope: { ctx: t } };
            for (let t = 0; t < i.length; t += 1) e = n(e, i[t]);
            return { props: e };
          }
          return (
            o && ((e = _(o, a(t))), t[30](e)),
            {
              c() {
                e && Ot(e.$$.fragment), (r = R());
              },
              m(t, n) {
                e && Rt(e, t, n), P(t, r, n), (s = !0);
              },
              p(t, n) {
                const s =
                  7622 & n[0]
                    ? Nt(i, [
                        258 & n[0] && { use: [t[8], [Qt, t[1]]] },
                        3268 & n[0] && {
                          class:
                            t[2] +
                            " " +
                            t[7]({ css: { ...t[11](t[10]), ...t[6] } }),
                        },
                        4096 & n[0] && Bt(t[12]),
                      ])
                    : {};
                if (
                  (2 & n[1] && (s.$$scope = { dirty: n, ctx: t }),
                  8 & n[0] && o !== (o = t[3]))
                ) {
                  if (e) {
                    kt();
                    const t = e;
                    St(t.$$.fragment, 1, 0, () => {
                      Lt(t, 1);
                    }),
                      Et();
                  }
                  o
                    ? ((e = _(o, a(t))),
                      t[30](e),
                      Ot(e.$$.fragment),
                      Ct(e.$$.fragment, 1),
                      Rt(e, r.parentNode, r))
                    : (e = null);
                } else o && e.$set(s);
              },
              i(t) {
                s || (e && Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                e && St(e.$$.fragment, t), (s = !1);
              },
              d(n) {
                t[30](null), n && I(r), e && Lt(e, n);
              },
            }
          );
        }
        function Dn(t) {
          let e,
            r =
              t[9]() &&
              (function (t) {
                let e, r, s, a, l, u;
                const p = t[28].default,
                  g = c(p, t, t[32], null);
                let m = [
                    {
                      class: (r =
                        t[2] +
                        " " +
                        t[7]({ css: { ...t[11](t[10]), ...t[6] } })),
                    },
                    t[12],
                  ],
                  b = {};
                for (let t = 0; t < m.length; t += 1) b = n(b, m[t]);
                return {
                  c() {
                    (e = N(t[9]())), g && g.c(), j(t[9]())(e, b);
                  },
                  m(n, r) {
                    P(n, e, r),
                      g && g.m(e, null),
                      t[29](e),
                      (a = !0),
                      l ||
                        ((u = [
                          y(t[8].call(null, e)),
                          y((s = Qt.call(null, e, t[1]))),
                        ]),
                        (l = !0));
                  },
                  p(t, n) {
                    g &&
                      g.p &&
                      (!a || 2 & n[1]) &&
                      h(
                        g,
                        p,
                        t,
                        t[32],
                        a ? d(p, t[32], n, null) : f(t[32]),
                        null
                      ),
                      j(t[9]())(
                        e,
                        (b = Nt(m, [
                          (!a ||
                            (196 & n[0] &&
                              r !==
                                (r =
                                  t[2] +
                                  " " +
                                  t[7]({
                                    css: { ...t[11](t[10]), ...t[6] },
                                  })))) && { class: r },
                          4096 & n[0] && t[12],
                        ]))
                      ),
                      s && o(s.update) && 2 & n[0] && s.update.call(null, t[1]);
                  },
                  i(t) {
                    a || (Ct(g, t), (a = !0));
                  },
                  o(t) {
                    St(g, t), (a = !1);
                  },
                  d(n) {
                    n && I(e), g && g.d(n), t[29](null), (l = !1), i(u);
                  },
                };
              })(t);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, e) {
              t[9]() && r.p(t, e);
            },
            i(t) {
              e || (Ct(r), (e = !0));
            },
            o(t) {
              St(r), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Mn(t) {
          let e;
          const n = t[28].default,
            r = c(n, t, t[32], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2 & s[1]) &&
                h(r, n, t, t[32], e ? d(n, t[32], s, null) : f(t[32]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function jn(t) {
          let e, n, r, s;
          const i = [Dn, Un, Fn],
            o = [];
          function a(t, e) {
            return t[4] ? 0 : t[5] && "string" != typeof t[3] ? 1 : 2;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, s) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (kt(),
                      St(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      Et(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      Ct(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (Ct(n), (s = !0));
              },
              o(t) {
                St(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Hn(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "css",
            "root",
            "m",
            "my",
            "mx",
            "mt",
            "mb",
            "ml",
            "mr",
            "p",
            "py",
            "px",
            "pt",
            "pb",
            "pl",
            "pr",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e,
            {
              use: u = [],
              element: d,
              class: h = "",
              css: f = {},
              root: m,
              m: y,
              my: b,
              mx: w,
              mt: v,
              mb: A,
              ml: $,
              mr: x,
              p: k,
              py: E,
              px: C,
              pt: S,
              pb: P,
              pl: I,
              pr: N,
            } = e;
          const B = Kt(et()),
            T = ee()?.theme || ie(),
            O = "function" == typeof f ? f : () => f;
          let R, L;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(12, (a = g(e, o))),
                "use" in t && r(1, (u = t.use)),
                "element" in t && r(0, (d = t.element)),
                "class" in t && r(2, (h = t.class)),
                "css" in t && r(13, (f = t.css)),
                "root" in t && r(3, (m = t.root)),
                "m" in t && r(14, (y = t.m)),
                "my" in t && r(15, (b = t.my)),
                "mx" in t && r(16, (w = t.mx)),
                "mt" in t && r(17, (v = t.mt)),
                "mb" in t && r(18, (A = t.mb)),
                "ml" in t && r(19, ($ = t.ml)),
                "mr" in t && r(20, (x = t.mr)),
                "p" in t && r(21, (k = t.p)),
                "py" in t && r(22, (E = t.py)),
                "px" in t && r(23, (C = t.px)),
                "pt" in t && r(24, (S = t.pt)),
                "pb" in t && r(25, (P = t.pb)),
                "pl" in t && r(26, (I = t.pl)),
                "pr" in t && r(27, (N = t.pr)),
                "$$scope" in t && r(32, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              8 & t.$$.dirty[0] &&
                (r(4, (R = m && "string" == typeof m)),
                r(5, (L = m && "function" == typeof m))),
                268419072 & t.$$.dirty[0] &&
                  r(
                    6,
                    (i = (function (t, e) {
                      const n = {};
                      if (Ln(t.p)) {
                        const r = zn(t.p, e);
                        n.padding = r;
                      }
                      if (Ln(t.m)) {
                        const r = zn(t.m, e);
                        n.margin = r;
                      }
                      if (Ln(t.py)) {
                        const r = zn(t.py, e);
                        (n.paddingTop = r), (n.paddingBottom = r);
                      }
                      if (Ln(t.px)) {
                        const r = zn(t.px, e);
                        (n.paddingLeft = r), (n.paddingRight = r);
                      }
                      if (Ln(t.my)) {
                        const r = zn(t.my, e);
                        (n.marginTop = r), (n.marginBottom = r);
                      }
                      if (Ln(t.mx)) {
                        const r = zn(t.mx, e);
                        (n.marginLeft = r), (n.marginRight = r);
                      }
                      return (
                        Object.keys(On).forEach((r) => {
                          Ln(t[r]) &&
                            (n[On[r]] = e.fn.size({
                              size: zn(t[r], e),
                              sizes: e.space,
                            }));
                        }),
                        n
                      );
                    })(
                      {
                        m: y,
                        my: b,
                        mx: w,
                        mt: v,
                        mb: A,
                        ml: $,
                        mr: x,
                        p: k,
                        py: E,
                        px: C,
                        pt: S,
                        pb: P,
                        pl: I,
                        pr: N,
                      },
                      T
                    ))
                  );
            }),
            r(7, (s = $n({}))),
            [
              d,
              u,
              h,
              m,
              R,
              L,
              i,
              s,
              B,
              () => m,
              T,
              O,
              a,
              f,
              y,
              b,
              w,
              v,
              A,
              $,
              x,
              k,
              E,
              C,
              S,
              P,
              I,
              N,
              l,
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (d = t), r(0, d);
                });
              },
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (d = t), r(0, d);
                });
              },
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (d = t), r(0, d);
                });
              },
              c,
            ]
          );
        }
        var Gn = class extends Ft {
          constructor(t) {
            super(),
              zt(
                this,
                t,
                Hn,
                jn,
                a,
                {
                  use: 1,
                  element: 0,
                  class: 2,
                  css: 13,
                  root: 3,
                  m: 14,
                  my: 15,
                  mx: 16,
                  mt: 17,
                  mb: 18,
                  ml: 19,
                  mr: 20,
                  p: 21,
                  py: 22,
                  px: 23,
                  pt: 24,
                  pb: 25,
                  pl: 26,
                  pr: 27,
                },
                null,
                [-1, -1]
              );
          }
        };
        const Vn = {
          xs: { height: 30, padding: "0px 14px" },
          sm: { height: 36, padding: "0px 18px" },
          md: { height: 42, padding: "0px 22px" },
          lg: { height: 50, padding: "0px 26px" },
          xl: { height: 60, padding: "0px 32px" },
          "compact-xs": { height: 22, padding: "0 7px" },
          "compact-sm": { height: 26, padding: "0 8px" },
          "compact-md": { height: 30, padding: "0 10px" },
          "compact-lg": { height: 34, padding: "0 12px" },
          "compact-xl": { height: 40, padding: "0 14px" },
        };
        var Wn = Se(
          (
            t,
            {
              color: e,
              compact: n,
              fullSize: r,
              gradient: s,
              radius: i,
              size: o,
              variant: a,
            }
          ) => ({
            root: {
              focusRing: "auto",
              cursor: "pointer",
              position: "relative",
              boxSizing: "border-box",
              textDecoration: "none",
              outline: "none",
              userSelect: "none",
              appearance: "none",
              textAlign: "center",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              background: null,
              borderRadius: "number" == typeof i ? i : `$${i}`,
              height:
                "number" == typeof o
                  ? `${o}px`
                  : Vn[n ? `compact-${o}` : o].height,
              padding:
                "number" == typeof o
                  ? `0px ${o}px`
                  : Vn[n ? `compact-${o}` : o].padding,
              fontFamily: "$standard",
              fontWeight: "$semibold",
              fontSize: `$${o}`,
              lineHeight: 1,
              flexGrow: 0,
              width: r ? "100%" : "fit-content",
              "&:hover": {
                backgroundColor:
                  "gradient" === a ? null : t.fn.themeColor(e, 7),
                backgroundSize: "gradient" === a ? "200%" : null,
              },
              "&:active": { transform: "translateY(1px)" },
              "&:disabled": {
                pointerEvents: "none",
                borderColor: "transparent",
                background: t.fn.themeColor("gray", 2),
                backgroundColor: t.fn.themeColor("gray", 2),
                color: t.fn.themeColor("gray", 5),
                cursor: "not-allowed",
                darkMode: {
                  borderColor: "transparent",
                  backgroundColor: t.fn.themeColor("dark", 4),
                  color: t.fn.themeColor("dark", 6),
                },
              },
            },
            disabled: {
              pointerEvents: "none",
              borderColor: "transparent",
              background: t.fn.themeColor("gray", 2),
              backgroundColor: t.fn.themeColor("gray", 2),
              color: t.fn.themeColor("gray", 5),
              cursor: "not-allowed",
              darkMode: {
                backgroundColor: t.fn.themeColor("dark", 4),
                color: t.fn.themeColor("dark", 6),
              },
            },
            loading: {
              pointerEvents: "none",
              "&::before": {
                content: '""',
                position: "absolute",
                inset: -1,
                backgroundColor: "rgba(255, 255, 255, .5)",
                borderRadius: `$${i}`,
                cursor: "not-allowed",
              },
            },
            variants: {
              variation: de(e, s),
              disabled: {
                true: {
                  pointerEvents: "none",
                  borderColor: "transparent",
                  background: t.fn.themeColor("gray", 2),
                  backgroundColor: t.fn.themeColor("gray", 2),
                  color: t.fn.themeColor("gray", 5),
                  cursor: "not-allowed",
                  [`${Nn.selector} &`]: {
                    borderColor: "transparent",
                    backgroundColor: t.fn.themeColor("dark", 4),
                    color: t.fn.themeColor("dark", 6),
                  },
                },
              },
            },
          })
        );
        const Qn = Object.freeze([
          {
            error: !0,
            message:
              "If using the disabled prop, a loading cannot be set at the same time",
            solution:
              "\n                If your component looks like this:\n                \n                &lt;Button disabled loading ...&gt; Button Text &lt;/Button&gt;\n                         ^^^^^^^^ ^^^^^^^ - Try removing one of these\n                ",
          },
          {
            error: !0,
            message:
              "If using the external prop, a href prop must be associated with it. If you have an href prop there must be content inside.",
            solution:
              "\n                If your component looks like this:\n                \n                &lt;Button external ...&gt; Button Text &lt;/Button&gt;\n                         ^^^^^^^^ - Try adding the href prop too\n                ",
          },
        ]);
        function Jn(e) {
          let n, r, s, i, a, l, c, u, d, h, f;
          return {
            c() {
              (n = B("svg")),
                (r = B("g")),
                (s = B("g")),
                (i = B("circle")),
                (a = B("path")),
                (l = B("animateTransform")),
                z(i, "stroke-opacity", ".5"),
                z(i, "cx", "16"),
                z(i, "cy", "16"),
                z(i, "r", "16"),
                z(l, "attributeName", "transform"),
                z(l, "type", "rotate"),
                z(l, "from", "0 16 16"),
                z(l, "to", "360 16 16"),
                z(l, "dur", "1s"),
                z(l, "repeatCount", "indefinite"),
                z(a, "d", "M32 16c0-9.94-8.06-16-16-16"),
                z(s, "transform", "translate(2.5 2.5)"),
                z(s, "stroke-width", "5"),
                z(r, "fill", "none"),
                z(r, "fill-rule", "evenodd"),
                z(n, "width", (c = `${e[1]}px`)),
                z(n, "height", (u = `${e[1]}px`)),
                z(n, "viewBox", "0 0 38 38"),
                z(n, "xmlns", "http://www.w3.org/2000/svg"),
                z(n, "stroke", e[2]),
                z(n, "class", e[3]);
            },
            m(t, o) {
              P(t, n, o),
                x(n, r),
                x(r, s),
                x(s, i),
                x(s, a),
                x(a, l),
                h || ((f = y((d = Qt.call(null, n, e[0])))), (h = !0));
            },
            p(t, [e]) {
              2 & e && c !== (c = `${t[1]}px`) && z(n, "width", c),
                2 & e && u !== (u = `${t[1]}px`) && z(n, "height", u),
                4 & e && z(n, "stroke", t[2]),
                8 & e && z(n, "class", t[3]),
                d && o(d.update) && 1 & e && d.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && I(n), (h = !1), f();
            },
          };
        }
        function _n(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var Kn = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, _n, Jn, a, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        function qn(e) {
          let n, r, s, i, a, l, c, u, d, h, f, p, g, m, b, w, v, A, $, k;
          return {
            c() {
              (n = B("svg")),
                (r = B("rect")),
                (s = B("animate")),
                (i = B("animate")),
                (a = B("rect")),
                (l = B("animate")),
                (c = B("animate")),
                (u = B("rect")),
                (d = B("animate")),
                (h = B("animate")),
                (f = B("rect")),
                (p = B("animate")),
                (g = B("animate")),
                (m = B("rect")),
                (b = B("animate")),
                (w = B("animate")),
                z(s, "attributeName", "height"),
                z(s, "begin", "0.5s"),
                z(s, "dur", "1s"),
                z(s, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(s, "calcMode", "linear"),
                z(s, "repeatCount", "indefinite"),
                z(i, "attributeName", "y"),
                z(i, "begin", "0.5s"),
                z(i, "dur", "1s"),
                z(i, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(i, "calcMode", "linear"),
                z(i, "repeatCount", "indefinite"),
                z(r, "y", "10"),
                z(r, "width", "15"),
                z(r, "height", "120"),
                z(r, "rx", "6"),
                z(l, "attributeName", "height"),
                z(l, "begin", "0.25s"),
                z(l, "dur", "1s"),
                z(l, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(l, "calcMode", "linear"),
                z(l, "repeatCount", "indefinite"),
                z(c, "attributeName", "y"),
                z(c, "begin", "0.25s"),
                z(c, "dur", "1s"),
                z(c, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(c, "calcMode", "linear"),
                z(c, "repeatCount", "indefinite"),
                z(a, "x", "30"),
                z(a, "y", "10"),
                z(a, "width", "15"),
                z(a, "height", "120"),
                z(a, "rx", "6"),
                z(d, "attributeName", "height"),
                z(d, "begin", "0s"),
                z(d, "dur", "1s"),
                z(d, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(d, "calcMode", "linear"),
                z(d, "repeatCount", "indefinite"),
                z(h, "attributeName", "y"),
                z(h, "begin", "0s"),
                z(h, "dur", "1s"),
                z(h, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(h, "calcMode", "linear"),
                z(h, "repeatCount", "indefinite"),
                z(u, "x", "60"),
                z(u, "width", "15"),
                z(u, "height", "140"),
                z(u, "rx", "6"),
                z(p, "attributeName", "height"),
                z(p, "begin", "0.25s"),
                z(p, "dur", "1s"),
                z(p, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(p, "calcMode", "linear"),
                z(p, "repeatCount", "indefinite"),
                z(g, "attributeName", "y"),
                z(g, "begin", "0.25s"),
                z(g, "dur", "1s"),
                z(g, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(g, "calcMode", "linear"),
                z(g, "repeatCount", "indefinite"),
                z(f, "x", "90"),
                z(f, "y", "10"),
                z(f, "width", "15"),
                z(f, "height", "120"),
                z(f, "rx", "6"),
                z(b, "attributeName", "height"),
                z(b, "begin", "0.5s"),
                z(b, "dur", "1s"),
                z(b, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(b, "calcMode", "linear"),
                z(b, "repeatCount", "indefinite"),
                z(w, "attributeName", "y"),
                z(w, "begin", "0.5s"),
                z(w, "dur", "1s"),
                z(w, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(w, "calcMode", "linear"),
                z(w, "repeatCount", "indefinite"),
                z(m, "x", "120"),
                z(m, "y", "10"),
                z(m, "width", "15"),
                z(m, "height", "120"),
                z(m, "rx", "6"),
                z(n, "viewBox", "0 0 135 140"),
                z(n, "xmlns", "http://www.w3.org/2000/svg"),
                z(n, "fill", e[2]),
                z(n, "width", (v = `${e[1]}px`)),
                z(n, "class", e[3]);
            },
            m(t, o) {
              P(t, n, o),
                x(n, r),
                x(r, s),
                x(r, i),
                x(n, a),
                x(a, l),
                x(a, c),
                x(n, u),
                x(u, d),
                x(u, h),
                x(n, f),
                x(f, p),
                x(f, g),
                x(n, m),
                x(m, b),
                x(m, w),
                $ || ((k = y((A = Qt.call(null, n, e[0])))), ($ = !0));
            },
            p(t, [e]) {
              4 & e && z(n, "fill", t[2]),
                2 & e && v !== (v = `${t[1]}px`) && z(n, "width", v),
                8 & e && z(n, "class", t[3]),
                A && o(A.update) && 1 & e && A.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && I(n), ($ = !1), k();
            },
          };
        }
        function Yn(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var Zn = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, Yn, qn, a, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        function Xn(e) {
          let n, r, s, i, a, l, c, u, d, h, f, p, g, m, b;
          return {
            c() {
              (n = B("svg")),
                (r = B("circle")),
                (s = B("animate")),
                (i = B("animate")),
                (a = B("circle")),
                (l = B("animate")),
                (c = B("animate")),
                (u = B("circle")),
                (d = B("animate")),
                (h = B("animate")),
                z(s, "attributeName", "r"),
                z(s, "from", "15"),
                z(s, "to", "15"),
                z(s, "begin", "0s"),
                z(s, "dur", "0.8s"),
                z(s, "values", "15;9;15"),
                z(s, "calcMode", "linear"),
                z(s, "repeatCount", "indefinite"),
                z(i, "attributeName", "fill-opacity"),
                z(i, "from", "1"),
                z(i, "to", "1"),
                z(i, "begin", "0s"),
                z(i, "dur", "0.8s"),
                z(i, "values", "1;.5;1"),
                z(i, "calcMode", "linear"),
                z(i, "repeatCount", "indefinite"),
                z(r, "cx", "15"),
                z(r, "cy", "15"),
                z(r, "r", "15"),
                z(l, "attributeName", "r"),
                z(l, "from", "9"),
                z(l, "to", "9"),
                z(l, "begin", "0s"),
                z(l, "dur", "0.8s"),
                z(l, "values", "9;15;9"),
                z(l, "calcMode", "linear"),
                z(l, "repeatCount", "indefinite"),
                z(c, "attributeName", "fill-opacity"),
                z(c, "from", "0.5"),
                z(c, "to", "0.5"),
                z(c, "begin", "0s"),
                z(c, "dur", "0.8s"),
                z(c, "values", ".5;1;.5"),
                z(c, "calcMode", "linear"),
                z(c, "repeatCount", "indefinite"),
                z(a, "cx", "60"),
                z(a, "cy", "15"),
                z(a, "r", "9"),
                z(a, "fill-opacity", "0.3"),
                z(d, "attributeName", "r"),
                z(d, "from", "15"),
                z(d, "to", "15"),
                z(d, "begin", "0s"),
                z(d, "dur", "0.8s"),
                z(d, "values", "15;9;15"),
                z(d, "calcMode", "linear"),
                z(d, "repeatCount", "indefinite"),
                z(h, "attributeName", "fill-opacity"),
                z(h, "from", "1"),
                z(h, "to", "1"),
                z(h, "begin", "0s"),
                z(h, "dur", "0.8s"),
                z(h, "values", "1;.5;1"),
                z(h, "calcMode", "linear"),
                z(h, "repeatCount", "indefinite"),
                z(u, "cx", "105"),
                z(u, "cy", "15"),
                z(u, "r", "15"),
                z(n, "width", (f = `${e[1]}px`)),
                z(n, "height", (p = Number(e[1]) / 4 + "px")),
                z(n, "viewBox", "0 0 120 30"),
                z(n, "xmlns", "http://www.w3.org/2000/svg"),
                z(n, "fill", e[2]),
                z(n, "class", e[3]);
            },
            m(t, o) {
              P(t, n, o),
                x(n, r),
                x(r, s),
                x(r, i),
                x(n, a),
                x(a, l),
                x(a, c),
                x(n, u),
                x(u, d),
                x(u, h),
                m || ((b = y((g = Qt.call(null, n, e[0])))), (m = !0));
            },
            p(t, [e]) {
              2 & e && f !== (f = `${t[1]}px`) && z(n, "width", f),
                2 & e &&
                  p !== (p = Number(t[1]) / 4 + "px") &&
                  z(n, "height", p),
                4 & e && z(n, "fill", t[2]),
                8 & e && z(n, "class", t[3]),
                g && o(g.update) && 1 & e && g.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && I(n), (m = !1), b();
            },
          };
        }
        function tr(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var er = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, tr, Xn, a, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        const nr = { xs: 18, sm: 22, md: 36, lg: 44, xl: 58 },
          rr = (t, e = !1) => Cn.colors[e ? `${t}400` : `${t}600`].value;
        function sr(t) {
          let e, r, s;
          const i = [
            { use: [t[5], [Qt, t[1]]] },
            { color: "white" === t[4] ? "white" : rr(t[4]) },
            { size: nr[t[3]] },
            { class: t[2] },
            t[8],
          ];
          var o = t[6][t[7]];
          function a(t) {
            let e = {};
            for (let t = 0; t < i.length; t += 1) e = n(e, i[t]);
            return { props: e };
          }
          return (
            o && ((e = _(o, a())), t[10](e)),
            {
              c() {
                e && Ot(e.$$.fragment), (r = R());
              },
              m(t, n) {
                e && Rt(e, t, n), P(t, r, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  318 & n
                    ? Nt(i, [
                        34 & n && { use: [t[5], [Qt, t[1]]] },
                        16 & n && {
                          color: "white" === t[4] ? "white" : rr(t[4]),
                        },
                        8 & n && { size: nr[t[3]] },
                        4 & n && { class: t[2] },
                        256 & n && Bt(t[8]),
                      ])
                    : {};
                if (o !== (o = t[6][t[7]])) {
                  if (e) {
                    kt();
                    const t = e;
                    St(t.$$.fragment, 1, 0, () => {
                      Lt(t, 1);
                    }),
                      Et();
                  }
                  o
                    ? ((e = _(o, a())),
                      t[10](e),
                      Ot(e.$$.fragment),
                      Ct(e.$$.fragment, 1),
                      Rt(e, r.parentNode, r))
                    : (e = null);
                } else o && e.$set(s);
              },
              i(t) {
                s || (e && Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                e && St(e.$$.fragment, t), (s = !1);
              },
              d(n) {
                t[10](null), n && I(r), e && Lt(e, n);
              },
            }
          );
        }
        function ir(t, e, r) {
          const s = ["use", "element", "class", "size", "color", "variant"];
          let i = g(e, s),
            {
              use: o = [],
              element: a,
              class: l = "",
              size: c = "md",
              color: u = "blue",
              variant: d = "circle",
            } = e;
          const h = Kt(et()),
            f = { bars: Zn, circle: Kn, dots: er },
            m = d in f ? d : "circle";
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(8, (i = g(e, s))),
                "use" in t && r(1, (o = t.use)),
                "element" in t && r(0, (a = t.element)),
                "class" in t && r(2, (l = t.class)),
                "size" in t && r(3, (c = t.size)),
                "color" in t && r(4, (u = t.color)),
                "variant" in t && r(9, (d = t.variant));
            }),
            [
              a,
              o,
              l,
              c,
              u,
              h,
              f,
              m,
              i,
              d,
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (a = t), r(0, a);
                });
              },
            ]
          );
        }
        var or = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, ir, sr, a, {
                use: 1,
                element: 0,
                class: 2,
                size: 3,
                color: 4,
                variant: 9,
              });
          }
        };
        function ar(t) {
          k(
            t,
            "svelte-3pkhve",
            ".ripple.svelte-3pkhve{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-3pkhve .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-3pkhve .animation-enter{transition:none}.ripple.svelte-3pkhve .animation-in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-3pkhve .animation-out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}"
          );
        }
        function lr(e) {
          let n;
          return {
            c() {
              (n = N("div")), z(n, "class", "ripple svelte-3pkhve");
            },
            m(t, r) {
              P(t, n, r), e[4](n);
            },
            p: t,
            i: t,
            o: t,
            d(t) {
              t && I(n), e[4](null);
            },
          };
        }
        function cr(t, e) {
          (t.style.transform = e), (t.style.webkitTransform = e);
        }
        function ur(t, e) {
          t.style.opacity = e.toString();
        }
        const dr = function (t, e) {
            const n = ["touchcancel", "mouseleave", "dragstart"];
            let r = e.currentTarget || e.target;
            if (
              (r &&
                !r.classList.contains("ripple") &&
                (r = r.querySelector(".ripple")),
              !r)
            )
              return;
            const s = r.dataset.event;
            if (s && s !== t) return;
            r.dataset.event = t;
            const i = document.createElement("span"),
              {
                radius: o,
                scale: a,
                x: l,
                y: c,
                centerX: u,
                centerY: d,
              } = ((t, e) => {
                const n = e.getBoundingClientRect(),
                  r = (function (t) {
                    return "TouchEvent" === t.constructor.name;
                  })(t)
                    ? t.touches[t.touches.length - 1]
                    : t,
                  s = r.clientX - n.left,
                  i = r.clientY - n.top;
                let o = 0,
                  a = 0.3;
                const l = e.dataset.center;
                e.dataset.circle
                  ? ((a = 0.15),
                    (o = e.clientWidth / 2),
                    (o = l
                      ? o
                      : o + Math.sqrt((s - o) ** 2 + (i - o) ** 2) / 4))
                  : (o =
                      Math.sqrt(e.clientWidth ** 2 + e.clientHeight ** 2) / 2);
                const c = (e.clientWidth - 2 * o) / 2 + "px",
                  u = (e.clientHeight - 2 * o) / 2 + "px";
                return {
                  radius: o,
                  scale: a,
                  x: l ? c : s - o + "px",
                  y: l ? u : i - o + "px",
                  centerX: c,
                  centerY: u,
                };
              })(e, r),
              h = r.dataset.color,
              f = 2 * o + "px";
            (i.className = "animation"),
              (i.style.width = f),
              (i.style.height = f),
              (i.style.background = h),
              i.classList.add("animation-enter"),
              i.classList.add("animation--visible"),
              cr(i, `translate(${l}, ${c}) scale3d(${a},${a},${a})`),
              ur(i, 0),
              (i.dataset.activated = String(performance.now())),
              r.appendChild(i),
              setTimeout(() => {
                i.classList.remove("animation-enter"),
                  i.classList.add("animation-in"),
                  cr(i, `translate(${u}, ${d}) scale3d(1,1,1)`),
                  ur(i, 0.25);
              }, 0);
            const p = "mousedown" === t ? "mouseup" : "touchend",
              g = function () {
                document.removeEventListener(p, g),
                  n.forEach((t) => {
                    document.removeEventListener(t, g);
                  });
                const t = performance.now() - Number(i.dataset.activated),
                  e = Math.max(250 - t, 0);
                setTimeout(() => {
                  i.classList.remove("animation-in"),
                    i.classList.add("animation-out"),
                    ur(i, 0),
                    setTimeout(() => {
                      i && r.removeChild(i),
                        0 === r.children.length && delete r.dataset.event;
                    }, 300);
                }, e);
              };
            document.addEventListener(p, g),
              n.forEach((t) => {
                document.addEventListener(t, g, { passive: !0 });
              });
          },
          hr = function (t) {
            0 === t.button && dr(t.type, t);
          },
          fr = function (t) {
            if (t.changedTouches)
              for (let e = 0; e < t.changedTouches.length; ++e)
                dr(t.type, t.changedTouches[e]);
          };
        function pr(t, e, n) {
          let r,
            s,
            { center: i = !1 } = e,
            { circle: o = !1 } = e,
            { color: a = "currentColor" } = e;
          var l;
          return (
            nt(async () => {
              await ft();
              try {
                i && n(0, (r.dataset.center = "true"), r),
                  o && n(0, (r.dataset.circle = "true"), r),
                  n(0, (r.dataset.color = a), r),
                  (s = r.parentElement);
              } catch (t) {}
              if (!s)
                return void console.error("Ripple: Trigger element not found.");
              let t = window.getComputedStyle(s);
              (0 !== t.position.length && "static" !== t.position) ||
                (s.style.position = "relative"),
                s.addEventListener("touchstart", fr, { passive: !0 }),
                s.addEventListener("mousedown", hr, { passive: !0 });
            }),
            (l = () => {
              s &&
                (s.removeEventListener("mousedown", hr),
                s.removeEventListener("touchstart", fr));
            }),
            et().$$.on_destroy.push(l),
            (t.$$set = (t) => {
              "center" in t && n(1, (i = t.center)),
                "circle" in t && n(2, (o = t.circle)),
                "color" in t && n(3, (a = t.color));
            }),
            [
              r,
              i,
              o,
              a,
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (r = t), n(0, r);
                });
              },
            ]
          );
        }
        var gr = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, pr, lr, a, { center: 1, circle: 2, color: 3 }, ar);
          }
        };
        function mr(t) {
          k(
            t,
            "svelte-5xpm5q",
            ".uppercase.svelte-5xpm5q{text-transform:uppercase}.left-section.svelte-5xpm5q{margin-right:10px;display:flex;align-items:center;justify-content:center}.right-section.svelte-5xpm5q{margin-left:10px;display:flex;align-items:center;justify-content:center}"
          );
        }
        const yr = (t) => ({}),
          br = (t) => ({}),
          wr = (t) => ({}),
          vr = (t) => ({}),
          Ar = (t) => ({}),
          $r = (t) => ({}),
          xr = (t) => ({}),
          kr = (t) => ({});
        function Er(t) {
          let e, r, s, a, l, u, p, g, m, b, w, v, A;
          const $ = [Pr, Sr],
            k = [];
          function E(t, e) {
            return t[11] && "left" === t[5] ? 0 : t[21].leftIcon ? 1 : -1;
          }
          ~(r = E(t)) && (s = k[r] = $[r](t));
          const C = t[28].default,
            S = c(C, t, t[27], null),
            B =
              S ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("Button");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          let R = t[13] && Ir();
          const L = [Br, Nr],
            z = [];
          function F(t, e) {
            return t[11] && "right" === t[5] ? 0 : t[21].rightIcon ? 1 : -1;
          }
          ~(p = F(t)) && (g = z[p] = L[p](t));
          let D = [
              {
                class: (m = t[18](
                  t[3],
                  t[17].root,
                  t[16]({ css: t[1], variation: t[4] }),
                  { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                )),
              },
              { disabled: t[9] },
              t[20],
              { tabindex: "0" },
            ],
            M = {};
          for (let t = 0; t < D.length; t += 1) M = n(M, D[t]);
          return {
            c() {
              (e = N("button")),
                s && s.c(),
                (a = O()),
                B && B.c(),
                (l = O()),
                R && R.c(),
                (u = O()),
                g && g.c(),
                U(e, M),
                W(e, "compact", t[10]),
                W(e, "uppercase", t[12]),
                W(e, "svelte-5xpm5q", !0);
            },
            m(n, s) {
              P(n, e, s),
                ~r && k[r].m(e, null),
                x(e, a),
                B && B.m(e, null),
                x(e, l),
                R && R.m(e, null),
                x(e, u),
                ~p && z[p].m(e, null),
                e.autofocus && e.focus(),
                t[30](e),
                (w = !0),
                v ||
                  ((A = [
                    y((b = Qt.call(null, e, t[2]))),
                    y(t[19].call(null, e)),
                  ]),
                  (v = !0));
            },
            p(t, n) {
              let i = r;
              (r = E(t)),
                r === i
                  ? ~r && k[r].p(t, n)
                  : (s &&
                      (kt(),
                      St(k[i], 1, 1, () => {
                        k[i] = null;
                      }),
                      Et()),
                    ~r
                      ? ((s = k[r]),
                        s ? s.p(t, n) : ((s = k[r] = $[r](t)), s.c()),
                        Ct(s, 1),
                        s.m(e, a))
                      : (s = null)),
                S &&
                  S.p &&
                  (!w || 134217728 & n) &&
                  h(S, C, t, t[27], w ? d(C, t[27], n, null) : f(t[27]), null),
                t[13]
                  ? R
                    ? 8192 & n && Ct(R, 1)
                    : ((R = Ir()), R.c(), Ct(R, 1), R.m(e, u))
                  : R &&
                    (kt(),
                    St(R, 1, 1, () => {
                      R = null;
                    }),
                    Et());
              let l = p;
              (p = F(t)),
                p === l
                  ? ~p && z[p].p(t, n)
                  : (g &&
                      (kt(),
                      St(z[l], 1, 1, () => {
                        z[l] = null;
                      }),
                      Et()),
                    ~p
                      ? ((g = z[p]),
                        g ? g.p(t, n) : ((g = z[p] = L[p](t)), g.c()),
                        Ct(g, 1),
                        g.m(e, null))
                      : (g = null)),
                U(
                  e,
                  (M = Nt(D, [
                    (!w ||
                      (461338 & n &&
                        m !==
                          (m = t[18](
                            t[3],
                            t[17].root,
                            t[16]({ css: t[1], variation: t[4] }),
                            { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                          )))) && { class: m },
                    (!w || 512 & n) && { disabled: t[9] },
                    1048576 & n && t[20],
                    { tabindex: "0" },
                  ]))
                ),
                b && o(b.update) && 4 & n && b.update.call(null, t[2]),
                W(e, "compact", t[10]),
                W(e, "uppercase", t[12]),
                W(e, "svelte-5xpm5q", !0);
            },
            i(t) {
              w || (Ct(s), Ct(B, t), Ct(R), Ct(g), (w = !0));
            },
            o(t) {
              St(s), St(B, t), St(R), St(g), (w = !1);
            },
            d(n) {
              n && I(e),
                ~r && k[r].d(),
                B && B.d(n),
                R && R.d(),
                ~p && z[p].d(),
                t[30](null),
                (v = !1),
                i(A);
            },
          };
        }
        function Cr(t) {
          let e, r, s, a, l, u, p, g, m, b, w, v, A, $;
          const k = [Or, Tr],
            E = [];
          function C(t, e) {
            return t[11] && "left" === t[5] ? 0 : t[21].leftIcon ? 1 : -1;
          }
          ~(r = C(t)) && (s = E[r] = k[r](t));
          const S = t[28].default,
            B = c(S, t, t[27], null),
            R =
              B ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("Button");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          let L = t[13] && Rr();
          const z = [zr, Lr],
            F = [];
          function D(t, e) {
            return t[11] && "right" === t[5] ? 0 : t[21].rightIcon ? 1 : -1;
          }
          ~(p = D(t)) && (g = F[p] = z[p](t));
          let M = [
              { href: t[7] },
              {
                class: (m = t[18](
                  t[3],
                  t[17].root,
                  t[16]({ css: t[1], variation: t[4], disabled: t[9] }),
                  { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                )),
              },
              { role: "button" },
              { rel: "noreferrer noopener" },
              { target: (b = t[8] ? "_blank" : "_self") },
              t[20],
              { tabindex: "0" },
            ],
            j = {};
          for (let t = 0; t < M.length; t += 1) j = n(j, M[t]);
          return {
            c() {
              (e = N("a")),
                s && s.c(),
                (a = O()),
                R && R.c(),
                (l = O()),
                L && L.c(),
                (u = O()),
                g && g.c(),
                U(e, j),
                W(e, "compact", t[10]),
                W(e, "uppercase", t[12]),
                W(e, "svelte-5xpm5q", !0);
            },
            m(n, s) {
              P(n, e, s),
                ~r && E[r].m(e, null),
                x(e, a),
                R && R.m(e, null),
                x(e, l),
                L && L.m(e, null),
                x(e, u),
                ~p && F[p].m(e, null),
                t[29](e),
                (v = !0),
                A ||
                  (($ = [
                    y((w = Qt.call(null, e, t[2]))),
                    y(t[19].call(null, e)),
                  ]),
                  (A = !0));
            },
            p(t, n) {
              let i = r;
              (r = C(t)),
                r === i
                  ? ~r && E[r].p(t, n)
                  : (s &&
                      (kt(),
                      St(E[i], 1, 1, () => {
                        E[i] = null;
                      }),
                      Et()),
                    ~r
                      ? ((s = E[r]),
                        s ? s.p(t, n) : ((s = E[r] = k[r](t)), s.c()),
                        Ct(s, 1),
                        s.m(e, a))
                      : (s = null)),
                B &&
                  B.p &&
                  (!v || 134217728 & n) &&
                  h(B, S, t, t[27], v ? d(S, t[27], n, null) : f(t[27]), null),
                t[13]
                  ? L
                    ? 8192 & n && Ct(L, 1)
                    : ((L = Rr()), L.c(), Ct(L, 1), L.m(e, u))
                  : L &&
                    (kt(),
                    St(L, 1, 1, () => {
                      L = null;
                    }),
                    Et());
              let l = p;
              (p = D(t)),
                p === l
                  ? ~p && F[p].p(t, n)
                  : (g &&
                      (kt(),
                      St(F[l], 1, 1, () => {
                        F[l] = null;
                      }),
                      Et()),
                    ~p
                      ? ((g = F[p]),
                        g ? g.p(t, n) : ((g = F[p] = z[p](t)), g.c()),
                        Ct(g, 1),
                        g.m(e, null))
                      : (g = null)),
                U(
                  e,
                  (j = Nt(M, [
                    (!v || 128 & n) && { href: t[7] },
                    (!v ||
                      (461338 & n &&
                        m !==
                          (m = t[18](
                            t[3],
                            t[17].root,
                            t[16]({
                              css: t[1],
                              variation: t[4],
                              disabled: t[9],
                            }),
                            { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                          )))) && { class: m },
                    { role: "button" },
                    { rel: "noreferrer noopener" },
                    (!v ||
                      (256 & n && b !== (b = t[8] ? "_blank" : "_self"))) && {
                      target: b,
                    },
                    1048576 & n && t[20],
                    { tabindex: "0" },
                  ]))
                ),
                w && o(w.update) && 4 & n && w.update.call(null, t[2]),
                W(e, "compact", t[10]),
                W(e, "uppercase", t[12]),
                W(e, "svelte-5xpm5q", !0);
            },
            i(t) {
              v || (Ct(s), Ct(R, t), Ct(L), Ct(g), (v = !0));
            },
            o(t) {
              St(s), St(R, t), St(L), St(g), (v = !1);
            },
            d(n) {
              n && I(e),
                ~r && E[r].d(),
                R && R.d(n),
                L && L.d(),
                ~p && F[p].d(),
                t[29](null),
                (A = !1),
                i($);
            },
          };
        }
        function Sr(t) {
          let e, n;
          const r = t[28].leftIcon,
            s = c(r, t, t[27], vr),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = N("span")),
                i && i.c(),
                z(e, "class", "left-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, wr) : f(t[27]), vr);
            },
            i(t) {
              n || (Ct(i, t), (n = !0));
            },
            o(t) {
              St(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function Pr(t) {
          let e, n, r;
          return (
            (n = new or({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = N("span")),
                  Ot(n.$$.fragment),
                  z(e, "class", "left-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Rt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (Ct(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                St(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Lt(n);
              },
            }
          );
        }
        function Ir(t) {
          let e, n;
          return (
            (e = new gr({ props: { center: !1, circle: !1 } })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Nr(t) {
          let e, n;
          const r = t[28].rightIcon,
            s = c(r, t, t[27], br),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = N("span")),
                i && i.c(),
                z(e, "class", "right-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, yr) : f(t[27]), br);
            },
            i(t) {
              n || (Ct(i, t), (n = !0));
            },
            o(t) {
              St(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function Br(t) {
          let e, n, r;
          return (
            (n = new or({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = N("span")),
                  Ot(n.$$.fragment),
                  z(e, "class", "right-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Rt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (Ct(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                St(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Lt(n);
              },
            }
          );
        }
        function Tr(t) {
          let e, n;
          const r = t[28].leftIcon,
            s = c(r, t, t[27], kr),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = N("span")),
                i && i.c(),
                z(e, "class", "left-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, xr) : f(t[27]), kr);
            },
            i(t) {
              n || (Ct(i, t), (n = !0));
            },
            o(t) {
              St(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function Or(t) {
          let e, n, r;
          return (
            (n = new or({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = N("span")),
                  Ot(n.$$.fragment),
                  z(e, "class", "left-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Rt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (Ct(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                St(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Lt(n);
              },
            }
          );
        }
        function Rr(t) {
          let e, n;
          return (
            (e = new gr({ props: { center: !1, circle: !1 } })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Lr(t) {
          let e, n;
          const r = t[28].rightIcon,
            s = c(r, t, t[27], $r),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = N("span")),
                i && i.c(),
                z(e, "class", "right-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, Ar) : f(t[27]), $r);
            },
            i(t) {
              n || (Ct(i, t), (n = !0));
            },
            o(t) {
              St(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function zr(t) {
          let e, n, r;
          return (
            (n = new or({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = N("span")),
                  Ot(n.$$.fragment),
                  z(e, "class", "right-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Rt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (Ct(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                St(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Lt(n);
              },
            }
          );
        }
        function Fr(t) {
          let e, n, r, s, i, o;
          e = new jt({
            props: { observable: t[14], component: "Button", code: t[15] },
          });
          const a = [Cr, Er],
            l = [];
          function c(t, e) {
            return t[7] ? 0 : 1;
          }
          return (
            (r = c(t)),
            (s = l[r] = a[r](t)),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), s.c(), (i = R());
              },
              m(t, s) {
                Rt(e, t, s), P(t, n, s), l[r].m(t, s), P(t, i, s), (o = !0);
              },
              p(t, [n]) {
                const o = {};
                16384 & n && (o.observable = t[14]),
                  32768 & n && (o.code = t[15]),
                  e.$set(o);
                let u = r;
                (r = c(t)),
                  r === u
                    ? l[r].p(t, n)
                    : (kt(),
                      St(l[u], 1, 1, () => {
                        l[u] = null;
                      }),
                      Et(),
                      (s = l[r]),
                      s ? s.p(t, n) : ((s = l[r] = a[r](t)), s.c()),
                      Ct(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (Ct(e.$$.fragment, t), Ct(s), (o = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(s), (o = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), l[r].d(t), t && I(i);
              },
            }
          );
        }
        function Ur(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "variant",
            "color",
            "size",
            "radius",
            "gradient",
            "loaderPosition",
            "loaderProps",
            "href",
            "external",
            "disabled",
            "compact",
            "loading",
            "uppercase",
            "fullSize",
            "ripple",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e;
          const d = m(c);
          let {
            use: h = [],
            element: f,
            class: y = "",
            override: b = {},
            variant: w = "filled",
            color: v = "blue",
            size: A = "sm",
            radius: $ = "sm",
            gradient: x = { from: "indigo", to: "cyan", deg: 45 },
            loaderPosition: k = "left",
            loaderProps: E = { size: "xs", color: "white", variant: "circle" },
            href: C = null,
            external: S = !1,
            disabled: P = !1,
            compact: I = !1,
            loading: N = !1,
            uppercase: B = !1,
            fullSize: T = !1,
            ripple: O = !1,
          } = e;
          const R = Kt(et());
          let L,
            z = !1;
          return (
            P && N && ((z = !0), (L = Qn[0])),
            ((S && "string" != typeof C) || C?.length < 1) &&
              ((z = !0), (L = Qn[1])),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(20, (l = g(e, a))),
                "use" in t && r(2, (h = t.use)),
                "element" in t && r(0, (f = t.element)),
                "class" in t && r(3, (y = t.class)),
                "override" in t && r(1, (b = t.override)),
                "variant" in t && r(4, (w = t.variant)),
                "color" in t && r(22, (v = t.color)),
                "size" in t && r(23, (A = t.size)),
                "radius" in t && r(24, ($ = t.radius)),
                "gradient" in t && r(25, (x = t.gradient)),
                "loaderPosition" in t && r(5, (k = t.loaderPosition)),
                "loaderProps" in t && r(6, (E = t.loaderProps)),
                "href" in t && r(7, (C = t.href)),
                "external" in t && r(8, (S = t.external)),
                "disabled" in t && r(9, (P = t.disabled)),
                "compact" in t && r(10, (I = t.compact)),
                "loading" in t && r(11, (N = t.loading)),
                "uppercase" in t && r(12, (B = t.uppercase)),
                "fullSize" in t && r(26, (T = t.fullSize)),
                "ripple" in t && r(13, (O = t.ripple)),
                "$$scope" in t && r(27, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              16384 & t.$$.dirty && z && r(1, (b = { display: "none" })),
                130024464 & t.$$.dirty &&
                  r(
                    18,
                    ({
                      cx: s,
                      classes: i,
                      getStyles: o,
                    } = Wn(
                      {
                        color: v,
                        compact: I,
                        fullSize: T,
                        gradient: x,
                        radius: $,
                        size: A,
                        variant: w,
                      },
                      { name: "Button" }
                    )),
                    s,
                    (r(17, i),
                    r(22, v),
                    r(10, I),
                    r(26, T),
                    r(25, x),
                    r(24, $),
                    r(23, A),
                    r(4, w)),
                    (r(16, o),
                    r(22, v),
                    r(10, I),
                    r(26, T),
                    r(25, x),
                    r(24, $),
                    r(23, A),
                    r(4, w))
                  );
            }),
            [
              f,
              b,
              h,
              y,
              w,
              k,
              E,
              C,
              S,
              P,
              I,
              N,
              B,
              O,
              z,
              L,
              o,
              i,
              s,
              R,
              l,
              d,
              v,
              A,
              $,
              x,
              T,
              u,
              c,
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (f = t), r(0, f);
                });
              },
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (f = t), r(0, f);
                });
              },
            ]
          );
        }
        var Dr = class extends Ft {
          constructor(t) {
            super(),
              zt(
                this,
                t,
                Ur,
                Fr,
                a,
                {
                  use: 2,
                  element: 0,
                  class: 3,
                  override: 1,
                  variant: 4,
                  color: 22,
                  size: 23,
                  radius: 24,
                  gradient: 25,
                  loaderPosition: 5,
                  loaderProps: 6,
                  href: 7,
                  external: 8,
                  disabled: 9,
                  compact: 10,
                  loading: 11,
                  uppercase: 12,
                  fullSize: 26,
                  ripple: 13,
                },
                mr
              );
          }
        };
        const Mr = { xs: 18, sm: 22, md: 28, lg: 34, xl: 44 };
        function jr(t) {
          const { themeColor: e } = be;
          return {
            ...de(t),
            hover: {
              [`${Nn.selector} &`]: {
                color: e(t, 8),
                "&:hover": { backgroundColor: e("dark", 8) },
              },
              border: "1px solid transparent",
              backgroundColor: "transparent",
              color: e(t, 7),
              "&:hover": { backgroundColor: e(t) },
            },
            transparent: {
              [`${Nn.selector} &`]: {
                color: e(t, 8),
                "&:hover": { backgroundColor: null },
              },
              border: "1px solid transparent",
              backgroundColor: "transparent",
              color: e(t, 7),
              "&:hover": { backgroundColor: null },
            },
          };
        }
        var Hr = Se((t, { color: e, radius: n, size: r }) => ({
          root: {
            focusRing: "auto",
            position: "relative",
            appearance: "none",
            WebkitAppearance: "none",
            WebkitTapHighlightColor: "transparent",
            boxSizing: "border-box",
            height: "string" == typeof r ? Mr[r] : `${r}px`,
            minHeight: "string" == typeof r ? Mr[r] : `${r}px`,
            width: "string" == typeof r ? Mr[r] : `${r}px`,
            minWidth: "string" == typeof r ? Mr[r] : `${r}px`,
            borderRadius: `$${n}`,
            padding: 0,
            lineHeight: 1,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            textDecoration: "none",
            "&:not(:disabled):active": { transform: "translateY(1px)" },
            "&:disabled": {
              pointerEvents: "none",
              borderColor: "transparent",
              background: t.fn.themeColor("gray", 2),
              backgroundColor: t.fn.themeColor("gray", 2),
              color: t.fn.themeColor("gray", 5),
              cursor: "not-allowed",
              darkMode: {
                borderColor: "transparent",
                backgroundColor: t.fn.themeColor("dark", 4),
                color: t.fn.themeColor("dark", 6),
              },
            },
          },
          loading: {
            pointerEvents: "none",
            "&::before": {
              content: '""',
              position: "absolute",
              top: -1,
              left: -1,
              right: -1,
              bottom: -1,
              backgroundColor: "rgba(255, 255, 255, .5)",
              borderRadius: `$${n}`,
              cursor: "not-allowed",
            },
          },
          variants: { variation: jr(e) },
        }));
        const Gr = Object.freeze([
          {
            error: !0,
            message:
              "If using the 'href' prop, set 'root' prop to an anchor ('a') tag",
            solution:
              "\n                If your component looks like this:\n\n                &lt;ActionIcon href='https://example.com'&gt;\n                          ^^^ - Try adding prop root='a'\n                       &lt;Icon /&gt;\n                &lt;/ActionIcon&gt;\n                ",
          },
        ]);
        function Vr(t) {
          let e;
          const n = t[21].default,
            r = c(n, t, t[23], null),
            s =
              r ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("+");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              s && s.c();
            },
            m(t, n) {
              s && s.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 8388608 & s) &&
                h(r, n, t, t[23], e ? d(n, t[23], s, null) : f(t[23]), null);
            },
            i(t) {
              e || (Ct(s, t), (e = !0));
            },
            o(t) {
              St(s, t), (e = !1);
            },
            d(t) {
              s && s.d(t);
            },
          };
        }
        function Wr(t) {
          let e, n;
          return (
            (e = new or({
              props: {
                size: t[6].size,
                color: t[6].color,
                variant: t[6].variant,
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                64 & n && (r.size = t[6].size),
                  64 & n && (r.color = t[6].color),
                  64 & n && (r.variant = t[6].variant),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Qr(t) {
          let e, n, r, s;
          const i = [Wr, Vr],
            o = [];
          function a(t, e) {
            return t[7] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, s) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (kt(),
                      St(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      Et(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      Ct(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (Ct(n), (s = !0));
              },
              o(t) {
                St(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Jr(t) {
          let e, r, s, i, o;
          e = new jt({
            props: { observable: t[11], component: "ActionIcon", code: t[12] },
          });
          const a = [
            { use: [t[16], [Qt, t[2]]] },
            { tabindex: 0 },
            { disabled: t[8] || t[7] },
            {
              class: t[15](
                t[3],
                t[14].root,
                { [t[14].loading]: t[7] },
                t[13]({ css: t[1], variation: t[5] })
              ),
            },
            { target: t[10] ? "_blank" : null },
            { rel: t[10] ? "noreferrer noopener" : null },
            { root: t[4] },
            { href: t[9] },
            t[17],
          ];
          function l(e) {
            t[22](e);
          }
          let c = { $$slots: { default: [Qr] }, $$scope: { ctx: t } };
          for (let t = 0; t < a.length; t += 1) c = n(c, a[t]);
          return (
            void 0 !== t[0] && (c.element = t[0]),
            (s = new Gn({ props: c })),
            at.push(() => Tt(s, "element", l)),
            {
              c() {
                Ot(e.$$.fragment), (r = O()), Ot(s.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), P(t, r, n), Rt(s, t, n), (o = !0);
              },
              p(t, [n]) {
                const r = {};
                2048 & n && (r.observable = t[11]),
                  4096 & n && (r.code = t[12]),
                  e.$set(r);
                const o =
                  255934 & n
                    ? Nt(a, [
                        65540 & n && { use: [t[16], [Qt, t[2]]] },
                        a[1],
                        384 & n && { disabled: t[8] || t[7] },
                        57514 & n && {
                          class: t[15](
                            t[3],
                            t[14].root,
                            { [t[14].loading]: t[7] },
                            t[13]({ css: t[1], variation: t[5] })
                          ),
                        },
                        1024 & n && { target: t[10] ? "_blank" : null },
                        1024 & n && {
                          rel: t[10] ? "noreferrer noopener" : null,
                        },
                        16 & n && { root: t[4] },
                        512 & n && { href: t[9] },
                        131072 & n && Bt(t[17]),
                      ])
                    : {};
                8388800 & n && (o.$$scope = { dirty: n, ctx: t }),
                  !i &&
                    1 & n &&
                    ((i = !0), (o.element = t[0]), gt(() => (i = !1))),
                  s.$set(o);
              },
              i(t) {
                o || (Ct(e.$$.fragment, t), Ct(s.$$.fragment, t), (o = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(s.$$.fragment, t), (o = !1);
              },
              d(t) {
                Lt(e, t), t && I(r), Lt(s, t);
              },
            }
          );
        }
        function _r(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "root",
            "color",
            "variant",
            "size",
            "radius",
            "loaderProps",
            "loading",
            "disabled",
            "href",
            "external",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              root: y = "button",
              color: b = "gray",
              variant: w = "hover",
              size: v = "md",
              radius: A = "sm",
              loaderProps: $ = { size: "xs", color: "gray", variant: "circle" },
              loading: x = !1,
              disabled: k = !1,
              href: E = "",
              external: C = !1,
            } = e;
          const S = Kt(et());
          let P,
            I = !1;
          return (
            "a" !== y && e.href && ((I = !0), (P = Gr[0])),
            (t.$$set = (t) => {
              r(24, (e = n(n({}, e), p(t)))),
                r(17, (l = g(e, a))),
                "use" in t && r(2, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(3, (f = t.class)),
                "override" in t && r(1, (m = t.override)),
                "root" in t && r(4, (y = t.root)),
                "color" in t && r(18, (b = t.color)),
                "variant" in t && r(5, (w = t.variant)),
                "size" in t && r(19, (v = t.size)),
                "radius" in t && r(20, (A = t.radius)),
                "loaderProps" in t && r(6, ($ = t.loaderProps)),
                "loading" in t && r(7, (x = t.loading)),
                "disabled" in t && r(8, (k = t.disabled)),
                "href" in t && r(9, (E = t.href)),
                "external" in t && r(10, (C = t.external)),
                "$$scope" in t && r(23, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              2048 & t.$$.dirty && I && r(1, (m = { display: "none" })),
                1835008 & t.$$.dirty &&
                  r(
                    15,
                    ({
                      cx: s,
                      classes: i,
                      getStyles: o,
                    } = Hr(
                      { color: b, radius: A, size: v },
                      { name: "ActionIcon" }
                    )),
                    s,
                    (r(14, i), r(18, b), r(20, A), r(19, v)),
                    (r(13, o), r(18, b), r(20, A), r(19, v))
                  );
            }),
            (e = p(e)),
            [
              h,
              m,
              d,
              f,
              y,
              w,
              $,
              x,
              k,
              E,
              C,
              I,
              P,
              o,
              i,
              s,
              S,
              l,
              b,
              v,
              A,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Kr = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, _r, Jr, a, {
                use: 2,
                element: 0,
                class: 3,
                override: 1,
                root: 4,
                color: 18,
                variant: 5,
                size: 19,
                radius: 20,
                loaderProps: 6,
                loading: 7,
                disabled: 8,
                href: 9,
                external: 10,
              });
          }
        };
        function qr(e) {
          let r,
            s,
            i = [
              { width: e[0] },
              { height: e[1] },
              { viewBox: "0 0 15 15" },
              { fill: "none" },
              { xmlns: "http://www.w3.org/2000/svg" },
              e[2],
            ],
            o = {};
          for (let t = 0; t < i.length; t += 1) o = n(o, i[t]);
          return {
            c() {
              (r = B("svg")),
                (s = B("path")),
                z(
                  s,
                  "d",
                  "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z"
                ),
                z(s, "fill", "currentColor"),
                z(s, "fill-rule", "evenodd"),
                z(s, "clip-rule", "evenodd"),
                D(r, o);
            },
            m(t, e) {
              P(t, r, e), x(r, s);
            },
            p(t, [e]) {
              D(
                r,
                (o = Nt(i, [
                  1 & e && { width: t[0] },
                  2 & e && { height: t[1] },
                  { viewBox: "0 0 15 15" },
                  { fill: "none" },
                  { xmlns: "http://www.w3.org/2000/svg" },
                  4 & e && t[2],
                ]))
              );
            },
            i: t,
            o: t,
            d(t) {
              t && I(r);
            },
          };
        }
        function Yr(t, e, r) {
          const s = ["width", "height"];
          let i = g(e, s),
            { width: o = 16 } = e,
            { height: a = 16 } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(2, (i = g(e, s))),
                "width" in t && r(0, (o = t.width)),
                "height" in t && r(1, (a = t.height));
            }),
            [o, a, i]
          );
        }
        var Zr = class extends Ft {
          constructor(t) {
            super(), zt(this, t, Yr, qr, a, { width: 0, height: 1 });
          }
        };
        function Xr(t) {
          let e, n;
          return (
            (e = new Zr({
              props: { width: t[16][t[4]], height: t[16][t[4]] },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                16 & n && (r.width = t[16][t[4]]),
                  16 & n && (r.height = t[16][t[4]]),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function ts(t) {
          let e, r, s;
          const i = [
            { class: t[2] },
            { use: [t[15], [Qt, t[1]]] },
            { override: t[3] },
            { root: t[5] },
            { color: t[6] },
            { variant: t[7] },
            { size: t[8] },
            { radius: t[9] },
            { loaderProps: t[10] },
            { loading: t[11] },
            { disabled: t[12] },
            { href: t[13] },
            { external: t[14] },
            t[17],
          ];
          function o(e) {
            t[18](e);
          }
          let a = { $$slots: { default: [Xr] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Kr({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  196590 & n
                    ? Nt(i, [
                        4 & n && { class: t[2] },
                        32770 & n && { use: [t[15], [Qt, t[1]]] },
                        8 & n && { override: t[3] },
                        32 & n && { root: t[5] },
                        64 & n && { color: t[6] },
                        128 & n && { variant: t[7] },
                        256 & n && { size: t[8] },
                        512 & n && { radius: t[9] },
                        1024 & n && { loaderProps: t[10] },
                        2048 & n && { loading: t[11] },
                        4096 & n && { disabled: t[12] },
                        8192 & n && { href: t[13] },
                        16384 & n && { external: t[14] },
                        131072 & n && Bt(t[17]),
                      ])
                    : {};
                524304 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function es(t, e, r) {
          const s = [
            "use",
            "element",
            "class",
            "override",
            "iconSize",
            "root",
            "color",
            "variant",
            "size",
            "radius",
            "loaderProps",
            "loading",
            "disabled",
            "href",
            "external",
          ];
          let i = g(e, s),
            {
              use: o = [],
              element: a,
              class: l = "",
              override: c = {},
              iconSize: u = "md",
              root: d = "button",
              color: h = "gray",
              variant: f = "hover",
              size: m = "md",
              radius: y = "sm",
              loaderProps: b = { size: "xs", color: "gray", variant: "circle" },
              loading: w = !1,
              disabled: v = !1,
              href: A = "",
              external: $ = !1,
            } = e;
          const x = Kt(et());
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(17, (i = g(e, s))),
                "use" in t && r(1, (o = t.use)),
                "element" in t && r(0, (a = t.element)),
                "class" in t && r(2, (l = t.class)),
                "override" in t && r(3, (c = t.override)),
                "iconSize" in t && r(4, (u = t.iconSize)),
                "root" in t && r(5, (d = t.root)),
                "color" in t && r(6, (h = t.color)),
                "variant" in t && r(7, (f = t.variant)),
                "size" in t && r(8, (m = t.size)),
                "radius" in t && r(9, (y = t.radius)),
                "loaderProps" in t && r(10, (b = t.loaderProps)),
                "loading" in t && r(11, (w = t.loading)),
                "disabled" in t && r(12, (v = t.disabled)),
                "href" in t && r(13, (A = t.href)),
                "external" in t && r(14, ($ = t.external));
            }),
            [
              a,
              o,
              l,
              c,
              u,
              d,
              h,
              f,
              m,
              y,
              b,
              w,
              v,
              A,
              $,
              x,
              { xs: 12, sm: 14, md: 16, lg: 20, xl: 24 },
              i,
              function (t) {
                (a = t), r(0, a);
              },
            ]
          );
        }
        var ns = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, es, ts, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                iconSize: 4,
                root: 5,
                color: 6,
                variant: 7,
                size: 8,
                radius: 9,
                loaderProps: 10,
                loading: 11,
                disabled: 12,
                href: 13,
                external: 14,
              });
          }
        };
        const rs = /input|select|textarea|button|object/,
          ss = "a, input, select, textarea, button, object, [tabindex]";
        function is(t) {
          return "test" !== process.env.NODE_ENV && "none" === t.style.display;
        }
        function os(t) {
          const e = t.getAttribute("tabindex");
          return e ? parseInt(e, 10) : null;
        }
        function as(t) {
          const e = t.nodeName.toLowerCase(),
            n = null !== os(t);
          return (
            ((rs.test(e) && !t.disabled) ||
              (t instanceof HTMLAnchorElement && t.href) ||
              n) &&
            (function (t) {
              if (
                t.getAttribute("aria-hidden") ||
                t.getAttribute("hidden") ||
                "hidden" === t.getAttribute("type")
              )
                return !1;
              let e = t;
              for (; e && e !== document.body && 11 !== e.nodeType; ) {
                if (is(e)) return !1;
                e = e.parentNode;
              }
              return !0;
            })(t)
          );
        }
        function ls(t) {
          const e = os(t);
          return (null === e || e >= 0) && as(t);
        }
        function cs(t) {
          return Array.from(t.querySelectorAll(ss)).filter(ls);
        }
        function us(t, e = !0) {
          let n = null;
          const r = (n) => {
            e &&
              "Tab" === n.key &&
              t &&
              (function (t, e) {
                const n = cs(t);
                if (!n.length) return void e.preventDefault();
                const r = n[e.shiftKey ? 0 : n.length - 1],
                  s = t.getRootNode();
                if (r !== s.activeElement && t !== s.activeElement) return;
                e.preventDefault();
                const i = n[e.shiftKey ? n.length - 1 : 0];
                i && i.focus();
              })(t, n);
          };
          function s() {
            if (!e) return void (n && n());
            n = (function (t) {
              const e = [];
              return (
                (function t(n) {
                  if (n && n !== document.querySelector("body")) {
                    const r = n.parentElement;
                    [...Array.from(r.children)].forEach((t) => {
                      const r = t.getAttribute("aria-hidden");
                      t === n ||
                        "SCRIPT" === t.nodeName ||
                        (null !== r && "false" !== r) ||
                        e.push({ node: t, ariaHidden: r });
                    }),
                      t(r);
                  }
                })(t),
                e.map(({ node: t }) => {
                  t.setAttribute("aria-hidden", "true");
                }),
                () => {
                  e.forEach((t) => {
                    t &&
                      (null === t.ariaHidden
                        ? t.node.removeAttribute("aria-hidden")
                        : t.node.setAttribute("aria-hidden", t.ariaHidden));
                  });
                }
              );
            })(t);
            setTimeout(() => {
              t.getRootNode()
                ? (() => {
                    let e = t.querySelector("[autofocus]");
                    if (!e) {
                      const n = Array.from(t.querySelectorAll(ss));
                      (e = n.find(ls) || n.find(as) || null),
                        !e && as(t) && (e = t);
                    }
                    e
                      ? e.focus({ preventScroll: !0 })
                      : "development" === process.env.NODE_ENV &&
                        console.warn(
                          "[@svelteuidev/composables/use-focus-trap] Failed to find focusable element within provided node",
                          t
                        );
                  })()
                : "development" === process.env.NODE_ENV &&
                  console.warn(
                    "[@svelteuidev/composables/use-focus-trap] node is not part of the dom",
                    t
                  );
            });
          }
          return (
            document.addEventListener("keydown", r),
            s(),
            {
              update(t) {
                (e = t), s();
              },
              destroy() {
                document.removeEventListener("keydown", r), n && n();
              },
            }
          );
        }
        const ds = ({ disableBodyPadding: t }) => {
          const e = t
            ? null
            : "undefined" == typeof window || "undefined" == typeof document
            ? 0
            : parseInt(
                window.getComputedStyle(document.body).paddingRight,
                10
              ) +
              (window.innerWidth - document.documentElement.clientWidth);
          return `body {\n        --removed-scroll-width: ${e}px;\n        touch-action: none;\n        overflow: hidden !important;\n        position: relative !important;\n        ${
            e ? "padding-right: var(--removed-scroll-width) !important;" : ""
          }\n        `;
        };
        const hs = () => "undefined" != typeof window,
          fs = { browser: hs(), server: !hs() },
          ps = fs.browser ? window : void 0;
        function gs(t, e, n = { disableBodyPadding: !1 }) {
          const { browser: r } = fs;
          let s;
          r && (s = ps);
          let i = e ?? !1;
          const { disableBodyPadding: o } = n;
          let a;
          const l = () => {
              const t = ds({ disableBodyPadding: o }),
                e = (function () {
                  const t = document.createElement("style");
                  return (
                    (t.type = "text/css"),
                    t.setAttribute("svelteui-scroll-lock", ""),
                    t
                  );
                })();
              var n;
              !(function (t, e) {
                t.styleSheet
                  ? (t.styleSheet.cssText = e)
                  : t.appendChild(document.createTextNode(e));
              })(e, t),
                (n = e),
                (
                  document.head || document.getElementsByTagName("head")[0]
                ).appendChild(n),
                (a = e);
            },
            c = () => {
              a && (a?.parentNode?.removeChild(a), (a = null));
            };
          return (
            i ? l() : c(),
            void 0 !== e && (i = e),
            void 0 === e &&
              void 0 !== s &&
              "hidden" === s.document.body.style.overflow &&
              (i = e),
            {
              update: (t) => {
                t
                  ? l()
                  : ("visible" === s.document.body.style.overflow && (i = e),
                    c());
              },
              destroy: () => {
                c();
              },
            }
          );
        }
        function ms(t, e = "body") {
          let n;
          async function r(r) {
            if ("string" == typeof (e = r)) {
              if (
                ((n = document.querySelector(e)),
                null === n && (await ft(), (n = document.querySelector(e))),
                null === n)
              )
                throw new Error(
                  `No element found matching css selector: "${e}"`
                );
            } else {
              if (!(e instanceof HTMLElement))
                throw new TypeError(
                  `Unknown portal target type: ${
                    null === e ? "null" : typeof e
                  }. Allowed types: string (CSS selector) or HTMLElement.`
                );
              n = e;
            }
            n.appendChild(t), (t.hidden = !1);
          }
          return (
            r(e),
            {
              update: r,
              destroy: function () {
                t.parentNode && t.parentNode.removeChild(t);
              },
            }
          );
        }
        function ys(t) {
          let e, n, r, s, a, l;
          const u = t[8].default,
            p = c(u, t, t[7], null);
          return {
            c() {
              (e = N("div")),
                p && p.c(),
                z(e, "class", t[2]),
                (e.hidden = !0),
                V(e, "position", t[4]),
                V(e, "zIndex", t[5]);
            },
            m(i, o) {
              P(i, e, o),
                p && p.m(e, null),
                t[9](e),
                (s = !0),
                a ||
                  ((l = [
                    y((n = Qt.call(null, e, t[1]))),
                    y(t[6].call(null, e)),
                    y((r = ms.call(null, e, t[3]))),
                  ]),
                  (a = !0));
            },
            p(t, [i]) {
              p &&
                p.p &&
                (!s || 128 & i) &&
                h(p, u, t, t[7], s ? d(u, t[7], i, null) : f(t[7]), null),
                (!s || 4 & i) && z(e, "class", t[2]),
                (!s || 16 & i) && V(e, "position", t[4]),
                (!s || 32 & i) && V(e, "zIndex", t[5]),
                n && o(n.update) && 2 & i && n.update.call(null, t[1]),
                r && o(r.update) && 8 & i && r.update.call(null, t[3]);
            },
            i(t) {
              s || (Ct(p, t), (s = !0));
            },
            o(t) {
              St(p, t), (s = !1);
            },
            d(n) {
              n && I(e), p && p.d(n), t[9](null), (a = !1), i(l);
            },
          };
        }
        function bs(t, e, n) {
          let { $$slots: r = {}, $$scope: s } = e,
            {
              use: i = [],
              element: o,
              class: a = "",
              target: l = "body",
              position: c = "relative",
              zIndex: u = 1,
            } = e;
          const d = Kt(et());
          return (
            (t.$$set = (t) => {
              "use" in t && n(1, (i = t.use)),
                "element" in t && n(0, (o = t.element)),
                "class" in t && n(2, (a = t.class)),
                "target" in t && n(3, (l = t.target)),
                "position" in t && n(4, (c = t.position)),
                "zIndex" in t && n(5, (u = t.zIndex)),
                "$$scope" in t && n(7, (s = t.$$scope));
            }),
            [
              o,
              i,
              a,
              l,
              c,
              u,
              d,
              s,
              r,
              function (t) {
                at[t ? "unshift" : "push"](() => {
                  (o = t), n(0, o);
                });
              },
            ]
          );
        }
        var ws = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, bs, ys, a, {
                use: 1,
                element: 0,
                class: 2,
                target: 3,
                position: 4,
                zIndex: 5,
              });
          }
        };
        function vs(t) {
          let e;
          const n = t[5].default,
            r = c(n, t, t[7], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 128 & s) &&
                h(r, n, t, t[7], e ? d(n, t[7], s, null) : f(t[7]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function As(t) {
          let e, n, r;
          function s(e) {
            t[6](e);
          }
          let i = {
            class: t[3],
            use: t[2],
            target: t[4],
            $$slots: { default: [$s] },
            $$scope: { ctx: t },
          };
          return (
            void 0 !== t[0] && (i.element = t[0]),
            (e = new ws({ props: i })),
            at.push(() => Tt(e, "element", s)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (r = !0);
              },
              p(t, r) {
                const s = {};
                8 & r && (s.class = t[3]),
                  4 & r && (s.use = t[2]),
                  16 & r && (s.target = t[4]),
                  128 & r && (s.$$scope = { dirty: r, ctx: t }),
                  !n &&
                    1 & r &&
                    ((n = !0), (s.element = t[0]), gt(() => (n = !1))),
                  e.$set(s);
              },
              i(t) {
                r || (Ct(e.$$.fragment, t), (r = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (r = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function $s(t) {
          let e;
          const n = t[5].default,
            r = c(n, t, t[7], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 128 & s) &&
                h(r, n, t, t[7], e ? d(n, t[7], s, null) : f(t[7]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function xs(t) {
          let e, n, r, s;
          const i = [As, vs],
            o = [];
          function a(t, e) {
            return t[1] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, [s]) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (kt(),
                      St(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      Et(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      Ct(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (Ct(n), (s = !0));
              },
              o(t) {
                St(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function ks(t, e, n) {
          let { $$slots: r = {}, $$scope: s } = e,
            {
              withinPortal: i = !0,
              use: o = [],
              element: a,
              class: l = "",
              target: c = "body",
            } = e;
          return (
            (t.$$set = (t) => {
              "withinPortal" in t && n(1, (i = t.withinPortal)),
                "use" in t && n(2, (o = t.use)),
                "element" in t && n(0, (a = t.element)),
                "class" in t && n(3, (l = t.class)),
                "target" in t && n(4, (c = t.target)),
                "$$scope" in t && n(7, (s = t.$$scope));
            }),
            [
              a,
              i,
              o,
              l,
              c,
              r,
              function (t) {
                (a = t), n(0, a);
              },
              s,
            ]
          );
        }
        var Es = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, ks, xs, a, {
                withinPortal: 1,
                use: 2,
                element: 0,
                class: 3,
                target: 4,
              });
          }
        };
        function Cs(t) {
          let e;
          const n = t[8].default,
            r = c(n, t, t[10], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 1024 & s) &&
                h(r, n, t, t[10], e ? d(n, t[10], s, null) : f(t[10]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Ss(t) {
          let e, r, s;
          const i = [
            { class: t[2] },
            { css: { position: "fixed", ...t[5], ...t[3] } },
            { use: t[1] },
            t[7],
          ];
          function o(e) {
            t[9](e);
          }
          let a = { $$slots: { default: [Cs] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  174 & n
                    ? Nt(i, [
                        4 & n && { class: t[2] },
                        40 & n && {
                          css: { position: "fixed", ...t[5], ...t[3] },
                        },
                        2 & n && { use: t[1] },
                        128 & n && Bt(t[7]),
                      ])
                    : {};
                1024 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Ps(t) {
          let e, n;
          return (
            (e = new ws({
              props: {
                zIndex: t[6],
                target: t[4],
                $$slots: { default: [Ss] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                64 & n && (r.zIndex = t[6]),
                  16 & n && (r.target = t[4]),
                  1199 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Is(t, e, r) {
          const s = [
            "use",
            "element",
            "class",
            "override",
            "target",
            "position",
            "zIndex",
          ];
          let i = g(e, s),
            { $$slots: o = {}, $$scope: a } = e,
            {
              use: l = [],
              element: c,
              class: u = "",
              override: d = {},
              target: h = "body",
              position: f = { bottom: 0, right: 0 },
              zIndex: m = 200,
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (i = g(e, s))),
                "use" in t && r(1, (l = t.use)),
                "element" in t && r(0, (c = t.element)),
                "class" in t && r(2, (u = t.class)),
                "override" in t && r(3, (d = t.override)),
                "target" in t && r(4, (h = t.target)),
                "position" in t && r(5, (f = t.position)),
                "zIndex" in t && r(6, (m = t.zIndex)),
                "$$scope" in t && r(10, (a = t.$$scope));
            }),
            [
              c,
              l,
              u,
              d,
              h,
              f,
              m,
              i,
              o,
              function (t) {
                (c = t), r(0, c);
              },
              a,
            ]
          );
        }
        var Ns = class extends Ft {
            constructor(t) {
              super(),
                zt(this, t, Is, Ps, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 3,
                  target: 4,
                  position: 5,
                  zIndex: 6,
                });
            }
          },
          Bs = Se((t, { color: e, radius: n, variant: r }, s) => ({
            root: {
              position: "relative",
              overflow: "hidden",
              padding: `${t.space.sm.value}px ${t.space.md.value}px`,
              borderRadius: t.fn.radius(n),
              border: "1px solid transparent",
              "&.light": {
                darkMode: {
                  backgroundColor: t.fn.variant({ variant: "light", color: e })
                    .background[0],
                  color: t.fn.variant({ variant: "light", color: e }).color[0],
                },
                backgroundColor: t.fn.variant({ variant: "light", color: e })
                  .background[1],
                color: t.fn.variant({ variant: "light", color: e }).color[1],
              },
              "&.filled": {
                darkMode: {
                  backgroundColor: t.fn.variant({ variant: "filled", color: e })
                    .background[0],
                },
                backgroundColor: t.fn.variant({ variant: "filled", color: e })
                  .background[1],
                color: t.colors.white.value,
                [`& .${s("closeButton")}`]: { color: t.colors.white.value },
              },
              "&.outline": {
                darkMode: {
                  color: t.fn.variant({ variant: "outline", color: e })
                    .color[0],
                  borderColor: t.fn.variant({ variant: "outline", color: e })
                    .border[0],
                },
                color: t.fn.variant({ variant: "outline", color: e }).color[1],
                borderColor: t.fn.variant({ variant: "outline", color: e })
                  .border[1],
              },
            },
            wrapper: { display: "flex" },
            content: { flex: 1 },
            title: {
              boxSizing: "border-box",
              margin: 0,
              marginBottom: 7,
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              lineHeight: t.lineHeights.sm.value,
              fontSize: t.fontSizes.sm.value,
              fontWeight: "$bold",
            },
            label: {
              display: "block",
              overflow: "hidden",
              textOverflow: "ellipsis",
            },
            icon: {
              lineHeight: 1,
              width: 20,
              height: 20,
              display: "flex",
              alignItems: "center",
              justifyContent: "flex-start",
              marginRight: t.space.mdPX.value,
              marginTop: 1,
            },
            message: {
              darkMode: {
                color:
                  "filled" === r || "light" === r
                    ? t.colors.white.value
                    : t.fn.themeColor("dark", 0),
              },
              lineHeight: t.lineHeights.sm.value,
              textOverflow: "ellipsis",
              overflow: "hidden",
              fontSize: t.fontSizes.sm.value,
              color:
                "filled" === r ? t.colors.white.value : t.colors.black.value,
            },
            closeButton: { ref: s("closeButton"), marginTop: 2 },
          })),
          Ts = Se((t, { iconSize: e }) => ({
            root: {
              focusRing: "auto",
              position: "relative",
              appearance: "none",
              WebkitAppearance: "none",
              WebkitTapHighlightColor: "transparent",
              boxSizing: "border-box",
              height: `${t.fn.size({ size: e, sizes: t.space })}px`,
              minHeight: `${t.fn.size({ size: e, sizes: t.space })}px`,
              width: `${t.fn.size({ size: e, sizes: t.space })}px`,
              minWidth: `${t.fn.size({ size: e, sizes: t.space })}px`,
              padding: 0,
              lineHeight: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              cursor: "pointer",
              textDecoration: "none",
            },
            icon: {
              height: `${t.fn.size({ size: e, sizes: t.space })}px`,
              minHeight: `${t.fn.size({ size: e, sizes: t.space })}px`,
              position: "static",
              margin: 0,
              ml: 0,
              mr: 0,
              mt: 0,
              mb: 0,
            },
          }));
        function Os(e) {
          let n,
            r =
              (e[2] instanceof HTMLElement || e[2] instanceof SVGElement) &&
              Ls(e);
          return {
            c() {
              r && r.c(), (n = R());
            },
            m(t, e) {
              r && r.m(t, e), P(t, n, e);
            },
            p(t, e) {
              t[2] instanceof HTMLElement || t[2] instanceof SVGElement
                ? r
                  ? r.p(t, e)
                  : ((r = Ls(t)), r.c(), r.m(n.parentNode, n))
                : r && (r.d(1), (r = null));
            },
            i: t,
            o: t,
            d(t) {
              r && r.d(t), t && I(n);
            },
          };
        }
        function Rs(t) {
          let e, r, s;
          const i = [
            { class: t[6](t[0], t[4].root, t[5]({ css: t[1] })) },
            t[3],
          ];
          var o = t[2];
          function a(t) {
            let e = {};
            for (let t = 0; t < i.length; t += 1) e = n(e, i[t]);
            return { props: e };
          }
          return (
            o && (e = _(o, a())),
            {
              c() {
                e && Ot(e.$$.fragment), (r = R());
              },
              m(t, n) {
                e && Rt(e, t, n), P(t, r, n), (s = !0);
              },
              p(t, n) {
                const s =
                  123 & n
                    ? Nt(i, [
                        115 & n && {
                          class: t[6](t[0], t[4].root, t[5]({ css: t[1] })),
                        },
                        8 & n && Bt(t[3]),
                      ])
                    : {};
                if (4 & n && o !== (o = t[2])) {
                  if (e) {
                    kt();
                    const t = e;
                    St(t.$$.fragment, 1, 0, () => {
                      Lt(t, 1);
                    }),
                      Et();
                  }
                  o
                    ? ((e = _(o, a())),
                      Ot(e.$$.fragment),
                      Ct(e.$$.fragment, 1),
                      Rt(e, r.parentNode, r))
                    : (e = null);
                } else o && e.$set(s);
              },
              i(t) {
                s || (e && Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                e && St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                t && I(r), e && Lt(e, t);
              },
            }
          );
        }
        function Ls(t) {
          let e,
            n,
            r = t[2].outerHTML + "";
          return {
            c() {
              (e = N("span")),
                z(e, "class", (n = t[6](t[0], t[4].root, t[5]({ css: t[1] }))));
            },
            m(t, n) {
              P(t, e, n), (e.innerHTML = r);
            },
            p(t, s) {
              4 & s && r !== (r = t[2].outerHTML + "") && (e.innerHTML = r),
                115 & s &&
                  n !== (n = t[6](t[0], t[4].root, t[5]({ css: t[1] }))) &&
                  z(e, "class", n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function zs(t) {
          let e, n, r, s;
          const i = [Rs, Os],
            o = [];
          function a(t, e) {
            return "function" == typeof t[2] ? 0 : t[7] ? -1 : 1;
          }
          return (
            ~(e = a(t)) && (n = o[e] = i[e](t)),
            {
              c() {
                n && n.c(), (r = R());
              },
              m(t, n) {
                ~e && o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, [s]) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? ~e && o[e].p(t, s)
                    : (n &&
                        (kt(),
                        St(o[l], 1, 1, () => {
                          o[l] = null;
                        }),
                        Et()),
                      ~e
                        ? ((n = o[e]),
                          n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                          Ct(n, 1),
                          n.m(r.parentNode, r))
                        : (n = null));
              },
              i(t) {
                s || (Ct(n), (s = !0));
              },
              o(t) {
                St(n), (s = !1);
              },
              d(t) {
                ~e && o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Fs(t, e, n) {
          let r,
            s,
            i,
            {
              className: o = "",
              override: a = {},
              icon: l,
              iconSize: c = 16,
              iconProps: u = {},
            } = e;
          const d =
            "undefined" == typeof HTMLElement &&
            "undefined" == typeof SVGElement;
          return (
            (t.$$set = (t) => {
              "className" in t && n(0, (o = t.className)),
                "override" in t && n(1, (a = t.override)),
                "icon" in t && n(2, (l = t.icon)),
                "iconSize" in t && n(8, (c = t.iconSize)),
                "iconProps" in t && n(3, (u = t.iconProps));
            }),
            (t.$$.update = () => {
              256 & t.$$.dirty &&
                n(
                  6,
                  ({
                    cx: r,
                    getStyles: s,
                    classes: i,
                  } = Ts({ iconSize: c }, { name: "IconRenderer" })),
                  r,
                  (n(5, s), n(8, c)),
                  (n(4, i), n(8, c))
                ),
                20 & t.$$.dirty &&
                  !d &&
                  (l instanceof HTMLElement || l instanceof SVGElement) &&
                  l.classList.add(...i.icon.split(" "));
            }),
            [o, a, l, u, i, s, r, d, c]
          );
        }
        var Us = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, Fs, zs, a, {
                className: 0,
                override: 1,
                icon: 2,
                iconSize: 8,
                iconProps: 3,
              });
          }
        };
        function Ds(t) {
          let e, n;
          return (
            (e = new Us({
              props: {
                icon: t[5],
                className: t[10].icon,
                iconSize: t[6],
                iconProps: t[7],
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                32 & n && (r.icon = t[5]),
                  1024 & n && (r.className = t[10].icon),
                  64 & n && (r.iconSize = t[6]),
                  128 & n && (r.iconProps = t[7]),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Ms(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l = t[8] && js(t);
          return {
            c() {
              (e = N("div")),
                (n = N("span")),
                (r = T(t[3])),
                (i = O()),
                l && l.c(),
                z(n, "class", (s = t[10].label)),
                z(e, "class", (o = t[10].title));
            },
            m(t, s) {
              P(t, e, s),
                x(e, n),
                x(n, r),
                x(e, i),
                l && l.m(e, null),
                (a = !0);
            },
            p(t, i) {
              (!a || 8 & i) && H(r, t[3]),
                (!a || (1024 & i && s !== (s = t[10].label))) &&
                  z(n, "class", s),
                t[8]
                  ? l
                    ? (l.p(t, i), 256 & i && Ct(l, 1))
                    : ((l = js(t)), l.c(), Ct(l, 1), l.m(e, null))
                  : l &&
                    (kt(),
                    St(l, 1, 1, () => {
                      l = null;
                    }),
                    Et()),
                (!a || (1024 & i && o !== (o = t[10].title))) &&
                  z(e, "class", o);
            },
            i(t) {
              a || (Ct(l), (a = !0));
            },
            o(t) {
              St(l), (a = !1);
            },
            d(t) {
              t && I(e), l && l.d();
            },
          };
        }
        function js(t) {
          let e, n;
          return (
            (e = new ns({
              props: {
                class: t[10].closeButton,
                "aria-label": t[9],
                variant: "transparent",
                size: t[6],
                iconSize: t[6],
              },
            })),
            e.$on("click", t[12]),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                1024 & n && (r.class = t[10].closeButton),
                  512 & n && (r["aria-label"] = t[9]),
                  64 & n && (r.size = t[6]),
                  64 & n && (r.iconSize = t[6]),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Hs(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l,
            u,
            p = t[5] && Ds(t),
            g = t[3] && Ms(t);
          const m = t[17].default,
            y = c(m, t, t[19], null);
          return {
            c() {
              (e = N("div")),
                p && p.c(),
                (n = O()),
                (r = N("div")),
                g && g.c(),
                (s = O()),
                (i = N("div")),
                y && y.c(),
                z(i, "class", (o = t[10].message)),
                z(r, "class", (a = t[10].content)),
                z(e, "class", (l = t[10].wrapper));
            },
            m(t, o) {
              P(t, e, o),
                p && p.m(e, null),
                x(e, n),
                x(e, r),
                g && g.m(r, null),
                x(r, s),
                x(r, i),
                y && y.m(i, null),
                (u = !0);
            },
            p(t, c) {
              t[5]
                ? p
                  ? (p.p(t, c), 32 & c && Ct(p, 1))
                  : ((p = Ds(t)), p.c(), Ct(p, 1), p.m(e, n))
                : p &&
                  (kt(),
                  St(p, 1, 1, () => {
                    p = null;
                  }),
                  Et()),
                t[3]
                  ? g
                    ? (g.p(t, c), 8 & c && Ct(g, 1))
                    : ((g = Ms(t)), g.c(), Ct(g, 1), g.m(r, s))
                  : g &&
                    (kt(),
                    St(g, 1, 1, () => {
                      g = null;
                    }),
                    Et()),
                y &&
                  y.p &&
                  (!u || 524288 & c) &&
                  h(y, m, t, t[19], u ? d(m, t[19], c, null) : f(t[19]), null),
                (!u || (1024 & c && o !== (o = t[10].message))) &&
                  z(i, "class", o),
                (!u || (1024 & c && a !== (a = t[10].content))) &&
                  z(r, "class", a),
                (!u || (1024 & c && l !== (l = t[10].wrapper))) &&
                  z(e, "class", l);
            },
            i(t) {
              u || (Ct(p), Ct(g), Ct(y, t), (u = !0));
            },
            o(t) {
              St(p), St(g), St(y, t), (u = !1);
            },
            d(t) {
              t && I(e), p && p.d(), g && g.d(), y && y.d(t);
            },
          };
        }
        function Gs(t) {
          let e, r, s;
          const i = [
            { use: t[1] },
            { role: "alert" },
            { class: t[11](t[2], t[4], t[10].root) },
            t[13],
          ];
          function o(e) {
            t[18](e);
          }
          let a = { $$slots: { default: [Hs] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  11286 & n
                    ? Nt(i, [
                        2 & n && { use: t[1] },
                        i[1],
                        3092 & n && { class: t[11](t[2], t[4], t[10].root) },
                        8192 & n && Bt(t[13]),
                      ])
                    : {};
                526312 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Vs(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "override",
            "title",
            "color",
            "radius",
            "variant",
            "icon",
            "iconSize",
            "iconProps",
            "withCloseButton",
            "closeButtonLabel",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e,
            {
              use: u = [],
              element: d,
              class: h = "blue",
              override: f = {},
              title: m,
              color: y = "red",
              radius: b = "sm",
              variant: w = "light",
              icon: v,
              iconSize: A = 16,
              iconProps: $ = {},
              withCloseButton: x = !1,
              closeButtonLabel: k,
            } = e;
          const E = rt();
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(13, (a = g(e, o))),
                "use" in t && r(1, (u = t.use)),
                "element" in t && r(0, (d = t.element)),
                "class" in t && r(2, (h = t.class)),
                "override" in t && r(14, (f = t.override)),
                "title" in t && r(3, (m = t.title)),
                "color" in t && r(15, (y = t.color)),
                "radius" in t && r(16, (b = t.radius)),
                "variant" in t && r(4, (w = t.variant)),
                "icon" in t && r(5, (v = t.icon)),
                "iconSize" in t && r(6, (A = t.iconSize)),
                "iconProps" in t && r(7, ($ = t.iconProps)),
                "withCloseButton" in t && r(8, (x = t.withCloseButton)),
                "closeButtonLabel" in t && r(9, (k = t.closeButtonLabel)),
                "$$scope" in t && r(19, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              114704 & t.$$.dirty &&
                r(
                  11,
                  ({ cx: s, classes: i } = Bs(
                    { color: y, radius: b, variant: w },
                    { name: "Alert", override: f }
                  )),
                  s,
                  (r(10, i), r(15, y), r(16, b), r(4, w), r(14, f))
                );
            }),
            [
              d,
              u,
              h,
              m,
              w,
              v,
              A,
              $,
              x,
              k,
              i,
              s,
              function () {
                E("close");
              },
              a,
              f,
              y,
              b,
              l,
              function (t) {
                (d = t), r(0, d);
              },
              c,
            ]
          );
        }
        var Ws = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, Vs, Gs, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 14,
                title: 3,
                color: 15,
                radius: 16,
                variant: 4,
                icon: 5,
                iconSize: 6,
                iconProps: 7,
                withCloseButton: 8,
                closeButtonLabel: 9,
              });
          }
        };
        function Qs(t, e, n, r, s = !1) {
          return "dimmed" === e
            ? s
              ? t.fn.themeColor("dark", 2)
              : t.fn.themeColor("gray", 6)
            : "gradient" === n || r
            ? t.fn.themeColor(e, 6)
            : "link" === n
            ? s
              ? t.fn.themeColor("blue", 4)
              : t.fn.themeColor("blue", 7)
            : "text" === n
            ? s
              ? t.fn.themeColor(e, 5)
              : t.fn.themeColor(e, 7)
            : void 0;
        }
        var Js = Se(
          (
            t,
            {
              align: e,
              color: n,
              inherit: r,
              inline: s,
              lineClamp: i,
              size: o,
              tracking: a,
              transform: l,
              underline: c,
              weight: u,
              gradient: d,
              variant: h,
            }
          ) => ({
            root: {
              focusRing: "auto",
              [`${t.dark} &`]: {
                color: "dark" === n ? "$dark50" : Qs(t, n, h, d, !0),
              },
              fontFamily: r ? "inherit" : "$standard",
              fontSize: r
                ? "inherit"
                : "string" == typeof o
                ? `$${o}`
                : `${o}px`,
              fontWeight: r ? "inherit" : `$${u}`,
              letterSpacing: t.letterSpacings[a]?.value,
              lineHeight: r
                ? "inherit"
                : s
                ? 1
                : "string" == typeof o
                ? `$${o}`
                : `${o}px`,
              textTransform: l,
              textDecoration: c ? "underline" : "none",
              textAlign: e,
              cursor: "link" === h ? "pointer" : "inherit",
              color: "green" === n ? "Black" : Qs(t, n, h, d),
              backgroundImage:
                "gradient" === h
                  ? `linear-gradient(${d?.deg}deg, $${d?.from}600 0%, $${d?.to}600 100%)`
                  : null,
              WebkitBackgroundClip: "gradient" === h ? "text" : null,
              WebkitTextFillColor: "gradient" === h ? "transparent" : null,
              ...(void 0 !== i
                ? {
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    display: "-webkit-box",
                    WebkitLineClamp: i,
                    WebkitBoxOrient: "vertical",
                  }
                : {}),
              "&:hover":
                "link" === h && !0 === c
                  ? { textDecoration: "underline" }
                  : void 0,
            },
          })
        );
        const _s = Object.freeze([
          {
            error: !0,
            message:
              "If using the 'gradient' prop, set 'variant' prop to 'gradient' to apply the gradient",
            solution:
              "\n                If your component looks like this:\n\n                &lt;Text gradient={{from: 'blue', to: 'red', deg: 45}}&gt;Text string &lt;/Text&gt;\n                                                                    ^^^ - Try adding prop variant='gradient'\n                ",
          },
          {
            error: !0,
            message:
              "If using the 'link' variant, an href needs to be set and the root must be an anchor",
            solution:
              "\n                If your component looks like this:\n\n                &lt;Text variant='link'&gt;Text string &lt;/Text&gt;\n                                    ^^^ - Try adding props href && root={'a'}'\n                ",
          },
        ]);
        function Ks(t) {
          let e;
          const n = t[25].default,
            r = c(n, t, t[27], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 134217728 & s) &&
                h(r, n, t, t[27], e ? d(n, t[27], s, null) : f(t[27]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function qs(t) {
          let e, r, s, i, o;
          e = new jt({
            props: { observable: t[6], component: "Text", code: t[7] },
          });
          const a = [
            { root: t[4] },
            { use: [t[11], [Qt, t[1]]] },
            { class: t[10](t[2], t[9].root, t[8]({ css: t[3] })) },
            { href: t[5] ?? void 0 },
            t[12],
          ];
          function l(e) {
            t[26](e);
          }
          let c = { $$slots: { default: [Ks] }, $$scope: { ctx: t } };
          for (let t = 0; t < a.length; t += 1) c = n(c, a[t]);
          return (
            void 0 !== t[0] && (c.element = t[0]),
            (s = new Gn({ props: c })),
            at.push(() => Tt(s, "element", l)),
            {
              c() {
                Ot(e.$$.fragment), (r = O()), Ot(s.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), P(t, r, n), Rt(s, t, n), (o = !0);
              },
              p(t, [n]) {
                const r = {};
                64 & n && (r.observable = t[6]),
                  128 & n && (r.code = t[7]),
                  e.$set(r);
                const o =
                  7998 & n
                    ? Nt(a, [
                        16 & n && { root: t[4] },
                        2050 & n && { use: [t[11], [Qt, t[1]]] },
                        1804 & n && {
                          class: t[10](t[2], t[9].root, t[8]({ css: t[3] })),
                        },
                        32 & n && { href: t[5] ?? void 0 },
                        4096 & n && Bt(t[12]),
                      ])
                    : {};
                134217728 & n && (o.$$scope = { dirty: n, ctx: t }),
                  !i &&
                    1 & n &&
                    ((i = !0), (o.element = t[0]), gt(() => (i = !1))),
                  s.$set(o);
              },
              i(t) {
                o || (Ct(e.$$.fragment, t), Ct(s.$$.fragment, t), (o = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(s.$$.fragment, t), (o = !1);
              },
              d(t) {
                Lt(e, t), t && I(r), Lt(s, t);
              },
            }
          );
        }
        function Ys(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "align",
            "color",
            "root",
            "transform",
            "variant",
            "size",
            "weight",
            "gradient",
            "inline",
            "lineClamp",
            "underline",
            "inherit",
            "href",
            "tracking",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              align: y = "left",
              color: b = "dark",
              root: w,
              transform: v = "none",
              variant: A = "text",
              size: $ = "md",
              weight: x = "normal",
              gradient: k = { from: "indigo", to: "cyan", deg: 45 },
              inline: E = !0,
              lineClamp: C,
              underline: S = !1,
              inherit: P = !1,
              href: I = "",
              tracking: N = "normal",
            } = e;
          const B = Kt(et());
          let T,
            O = !1;
          return (
            "indigo" === k.from &&
              "cyan0" === k.to &&
              45 === k.deg &&
              "gradient" !== A &&
              ((O = !0), (T = _s[0])),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(12, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "align" in t && r(13, (y = t.align)),
                "color" in t && r(14, (b = t.color)),
                "root" in t && r(4, (w = t.root)),
                "transform" in t && r(15, (v = t.transform)),
                "variant" in t && r(16, (A = t.variant)),
                "size" in t && r(17, ($ = t.size)),
                "weight" in t && r(18, (x = t.weight)),
                "gradient" in t && r(19, (k = t.gradient)),
                "inline" in t && r(20, (E = t.inline)),
                "lineClamp" in t && r(21, (C = t.lineClamp)),
                "underline" in t && r(22, (S = t.underline)),
                "inherit" in t && r(23, (P = t.inherit)),
                "href" in t && r(5, (I = t.href)),
                "tracking" in t && r(24, (N = t.tracking)),
                "$$scope" in t && r(27, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              33546240 & t.$$.dirty &&
                r(
                  10,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = Js(
                    {
                      lineClamp: C,
                      underline: S,
                      inline: E,
                      inherit: P,
                      gradient: k,
                      variant: A,
                      align: y,
                      color: b,
                      transform: v,
                      size: $,
                      weight: x,
                      tracking: N,
                    },
                    { name: "Text" }
                  )),
                  s,
                  (r(9, i),
                  r(21, C),
                  r(22, S),
                  r(20, E),
                  r(23, P),
                  r(19, k),
                  r(16, A),
                  r(13, y),
                  r(14, b),
                  r(15, v),
                  r(17, $),
                  r(18, x),
                  r(24, N)),
                  (r(8, o),
                  r(21, C),
                  r(22, S),
                  r(20, E),
                  r(23, P),
                  r(19, k),
                  r(16, A),
                  r(13, y),
                  r(14, b),
                  r(15, v),
                  r(17, $),
                  r(18, x),
                  r(24, N))
                );
            }),
            [
              h,
              d,
              f,
              m,
              w,
              I,
              O,
              T,
              o,
              i,
              s,
              B,
              l,
              y,
              b,
              v,
              A,
              $,
              x,
              k,
              E,
              C,
              S,
              P,
              N,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Zs = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, Ys, qs, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                align: 13,
                color: 14,
                root: 4,
                transform: 15,
                variant: 16,
                size: 17,
                weight: 18,
                gradient: 19,
                inline: 20,
                lineClamp: 21,
                underline: 22,
                inherit: 23,
                href: 5,
                tracking: 24,
              });
          }
        };
        const Xs = {
            xs: { fontSize: 9, height: 16 },
            sm: { fontSize: 10, height: 18 },
            md: { fontSize: 11, height: 20 },
            lg: { fontSize: 13, height: 26 },
            xl: { fontSize: 16, height: 32 },
          },
          ti = { xs: 4, sm: 4, md: 6, lg: 8, xl: 10 };
        var ei = Se(
          (
            t,
            {
              fullWidth: e,
              radius: n,
              size: r,
              color: s,
              gradientDeg: i,
              gradientFrom: o,
              gradientTo: a,
            }
          ) => {
            const l = t.fn.size({ size: r, sizes: ti }),
              c = t.fn.variant({ color: s, variant: "light" }),
              u = t.fn.variant({ color: s, variant: "filled" }),
              d = t.fn.variant({ color: s, variant: "outline" }),
              h = t.fn.variant({
                variant: "gradient",
                gradient: { from: o, to: a, deg: i },
              }),
              { fontSize: f, height: p } = r in Xs ? Xs[r] : Xs.md;
            return {
              root: {
                focusRing: "auto",
                fontSize: f,
                height: p,
                WebkitTapHighlightColor: "transparent",
                lineHeight: p - 2 + "px",
                textDecoration: "none",
                padding: `0 ${t.fn.size({ size: r, sizes: t.space }) / 1.5}px`,
                boxSizing: "border-box",
                display: e ? "flex" : "inline-flex",
                alignItems: "center",
                justifyContent: "center",
                width: e ? "100%" : "auto",
                textTransform: "uppercase",
                borderRadius: t.fn.radius(n),
                fontWeight: 700,
                letterSpacing: 0.25,
                cursor: "default",
                textOverflow: "ellipsis",
                overflow: "hidden",
                "&.light": {
                  [`${t.dark} &`]: {
                    backgroundColor: c.background[0],
                    color: c.color[0],
                  },
                  backgroundColor: c.background[1],
                  color: c.color[1],
                  border: "1px solid transparent",
                },
                "&.filled": {
                  [`${t.dark} &`]: { backgroundColor: u.background[0] },
                  backgroundColor: u.background[1],
                  color: u.color,
                  border: "1px solid transparent",
                },
                "&.outline": {
                  [`${t.dark} &`]: {
                    color: d.color[0],
                    border: `1px solid ${d.border[0]}`,
                  },
                  backgroundColor: d.background,
                  color: d.color[1],
                  border: `1px solid ${d.border[1]}`,
                },
                "&.gradient": {
                  backgroundImage: h.background,
                  color: h.color,
                  border: 0,
                },
                "&.dot": {
                  darkMode: {
                    color: t.fn.themeColor("dark", 0),
                    border: `1px solid ${t.fn.themeColor("dark", 3)}`,
                    "&::before": { backgroundColor: t.fn.themeColor(s, 4) },
                  },
                  backgroundColor: "transparent",
                  color: t.fn.themeColor("gray", 7),
                  border: `1px solid ${t.fn.themeColor("gray", 3)}`,
                  paddingLeft:
                    t.fn.size({ size: r, sizes: t.space }) / 1.5 - l / 2,
                  "&::before": {
                    content: '""',
                    display: "block",
                    width: l,
                    height: l,
                    borderRadius: l,
                    backgroundColor: t.fn.themeColor(s, 6),
                    marginRight: l,
                  },
                },
              },
              leftSection: { marginRight: parseInt(t.space.xs.value) / 2 },
              rightSection: { marginLeft: parseInt(t.space.xs.value) / 2 },
              inner: {
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
              },
            };
          }
        );
        const ni = (t) => ({}),
          ri = (t) => ({}),
          si = (t) => ({}),
          ii = (t) => ({});
        function oi(t) {
          let e, n, r;
          const s = t[15].leftSection,
            i = c(s, t, t[17], ii);
          return {
            c() {
              (e = N("span")),
                i && i.c(),
                z(e, "class", (n = t[4].leftSection));
            },
            m(t, n) {
              P(t, e, n), i && i.m(e, null), (r = !0);
            },
            p(t, o) {
              i &&
                i.p &&
                (!r || 131072 & o) &&
                h(i, s, t, t[17], r ? d(s, t[17], o, si) : f(t[17]), ii),
                (!r || (16 & o && n !== (n = t[4].leftSection))) &&
                  z(e, "class", n);
            },
            i(t) {
              r || (Ct(i, t), (r = !0));
            },
            o(t) {
              St(i, t), (r = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function ai(t) {
          let e, n, r;
          const s = t[15].rightSection,
            i = c(s, t, t[17], ri);
          return {
            c() {
              (e = N("span")),
                i && i.c(),
                z(e, "class", (n = t[4].rightSection));
            },
            m(t, n) {
              P(t, e, n), i && i.m(e, null), (r = !0);
            },
            p(t, o) {
              i &&
                i.p &&
                (!r || 131072 & o) &&
                h(i, s, t, t[17], r ? d(s, t[17], o, ni) : f(t[17]), ri),
                (!r || (16 & o && n !== (n = t[4].rightSection))) &&
                  z(e, "class", n);
            },
            i(t) {
              r || (Ct(i, t), (r = !0));
            },
            o(t) {
              St(i, t), (r = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function li(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a = t[8].leftSection && oi(t);
          const l = t[15].default,
            u = c(l, t, t[17], null);
          let p = t[8].rightSection && ai(t);
          return {
            c() {
              a && a.c(),
                (e = O()),
                (n = N("span")),
                u && u.c(),
                (s = O()),
                p && p.c(),
                (i = R()),
                z(n, "class", (r = t[4].inner));
            },
            m(t, r) {
              a && a.m(t, r),
                P(t, e, r),
                P(t, n, r),
                u && u.m(n, null),
                P(t, s, r),
                p && p.m(t, r),
                P(t, i, r),
                (o = !0);
            },
            p(t, s) {
              t[8].leftSection
                ? a
                  ? (a.p(t, s), 256 & s && Ct(a, 1))
                  : ((a = oi(t)), a.c(), Ct(a, 1), a.m(e.parentNode, e))
                : a &&
                  (kt(),
                  St(a, 1, 1, () => {
                    a = null;
                  }),
                  Et()),
                u &&
                  u.p &&
                  (!o || 131072 & s) &&
                  h(u, l, t, t[17], o ? d(l, t[17], s, null) : f(t[17]), null),
                (!o || (16 & s && r !== (r = t[4].inner))) && z(n, "class", r),
                t[8].rightSection
                  ? p
                    ? (p.p(t, s), 256 & s && Ct(p, 1))
                    : ((p = ai(t)), p.c(), Ct(p, 1), p.m(i.parentNode, i))
                  : p &&
                    (kt(),
                    St(p, 1, 1, () => {
                      p = null;
                    }),
                    Et());
            },
            i(t) {
              o || (Ct(a), Ct(u, t), Ct(p), (o = !0));
            },
            o(t) {
              St(a), St(u, t), St(p), (o = !1);
            },
            d(t) {
              a && a.d(t),
                t && I(e),
                t && I(n),
                u && u.d(t),
                t && I(s),
                p && p.d(t),
                t && I(i);
            },
          };
        }
        function ci(t) {
          let e, r, s;
          const i = [
            { use: [t[6], [Qt, t[1]]] },
            { class: t[5](t[2], t[3], t[4].root) },
            t[7],
          ];
          function o(e) {
            t[16](e);
          }
          let a = { $$slots: { default: [li] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Nt(i, [
                        66 & n && { use: [t[6], [Qt, t[1]]] },
                        60 & n && { class: t[5](t[2], t[3], t[4].root) },
                        128 & n && Bt(t[7]),
                      ])
                    : {};
                131344 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function ui(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "override",
            "color",
            "variant",
            "gradient",
            "size",
            "radius",
            "fullWidth",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e;
          const u = m(l);
          let {
            use: d = [],
            element: h,
            class: f = "",
            override: y = {},
            color: b = "blue",
            variant: w = "light",
            gradient: v = { from: "blue", to: "cyan", deg: 45 },
            size: A = "md",
            radius: $ = "xl",
            fullWidth: x = !1,
          } = e;
          const k = Kt(et());
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (a = g(e, o))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(9, (y = t.override)),
                "color" in t && r(10, (b = t.color)),
                "variant" in t && r(3, (w = t.variant)),
                "gradient" in t && r(11, (v = t.gradient)),
                "size" in t && r(12, (A = t.size)),
                "radius" in t && r(13, ($ = t.radius)),
                "fullWidth" in t && r(14, (x = t.fullWidth)),
                "$$scope" in t && r(17, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              32256 & t.$$.dirty &&
                r(
                  5,
                  ({ cx: s, classes: i } = ei(
                    {
                      color: b,
                      fullWidth: x,
                      size: A,
                      radius: $,
                      gradientDeg: v.deg,
                      gradientFrom: v.from,
                      gradientTo: v.to,
                    },
                    { override: y, name: "Badge" }
                  )),
                  s,
                  (r(4, i),
                  r(10, b),
                  r(14, x),
                  r(12, A),
                  r(13, $),
                  r(11, v),
                  r(9, y))
                );
            }),
            [
              h,
              d,
              f,
              w,
              i,
              s,
              k,
              a,
              u,
              y,
              b,
              v,
              A,
              $,
              x,
              l,
              function (t) {
                (h = t), r(0, h);
              },
              c,
            ]
          );
        }
        var di = class extends Ft {
            constructor(t) {
              super(),
                zt(this, t, ui, ci, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 9,
                  color: 10,
                  variant: 3,
                  gradient: 11,
                  size: 12,
                  radius: 13,
                  fullWidth: 14,
                });
            }
          },
          hi = Se((t) => ({
            root: {
              position: "relative",
              overflow: "hidden",
              backgroundColor: t.colors.white.value,
            },
          })),
          fi = Se((t, { radius: e, shadow: n, withBorder: r, padding: s }) => ({
            root: {
              darkMode: {
                backgroundColor: t.fn.themeColor("dark", 7),
                color: t.fn.themeColor("dark"),
              },
              padding: t.fn.size({ size: s, sizes: t.space }),
              outline: 0,
              display: "block",
              textDecoration: "none",
              color: t.colors.black.value,
              backgroundColor: t.colors.white.value,
              boxSizing: "border-box",
              borderRadius: `$${e}`,
              WebkitTapHighlightColor: "transparent",
              boxShadow: t.shadows[n].value || n || "none",
              border: void 0,
            },
            withBorder: {
              darkMode: { border: `1px solid ${t.fn.themeColor("dark", 4)}` },
              border: `1px solid ${t.fn.themeColor("gray", 3)}`,
            },
          }));
        function pi(t) {
          let e;
          const n = t[12].default,
            r = c(n, t, t[14], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 16384 & s) &&
                h(r, n, t, t[14], e ? d(n, t[14], s, null) : f(t[14]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function gi(t) {
          let e, r, s;
          const i = [
            {
              class: t[7](
                t[6].root,
                t[2],
                t[4] && t[6].withBorder,
                t[5]({ css: t[3] })
              ),
            },
            { use: t[1] },
            t[8],
          ];
          function o(e) {
            t[13](e);
          }
          let a = { $$slots: { default: [pi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  510 & n
                    ? Nt(i, [
                        252 & n && {
                          class: t[7](
                            t[6].root,
                            t[2],
                            t[4] && t[6].withBorder,
                            t[5]({ css: t[3] })
                          ),
                        },
                        2 & n && { use: t[1] },
                        256 & n && Bt(t[8]),
                      ])
                    : {};
                16384 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function mi(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "shadow",
            "radius",
            "withBorder",
            "padding",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              shadow: y = "xs",
              radius: b = "sm",
              withBorder: w = !1,
              padding: v = "md",
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(8, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "shadow" in t && r(9, (y = t.shadow)),
                "radius" in t && r(10, (b = t.radius)),
                "withBorder" in t && r(4, (w = t.withBorder)),
                "padding" in t && r(11, (v = t.padding)),
                "$$scope" in t && r(14, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              3600 & t.$$.dirty &&
                r(
                  7,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = fi(
                    { radius: b, shadow: y, withBorder: w, padding: v },
                    { name: "Paper" }
                  )),
                  s,
                  (r(6, i), r(10, b), r(9, y), r(4, w), r(11, v)),
                  (r(5, o), r(10, b), r(9, y), r(4, w), r(11, v))
                );
            }),
            [
              h,
              d,
              f,
              m,
              w,
              o,
              i,
              s,
              l,
              y,
              b,
              v,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var yi = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, mi, gi, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                shadow: 9,
                radius: 10,
                withBorder: 4,
                padding: 11,
              });
          }
        };
        function bi(t) {
          let e;
          const n = t[9].default,
            r = c(n, t, t[11], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2048 & s) &&
                h(r, n, t, t[11], e ? d(n, t[11], s, null) : f(t[11]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function wi(t) {
          let e, r, s;
          const i = [
            { class: t[7](t[2], t[6].root) },
            {
              override: {
                [`${t[5].dark} &`]: {
                  backgroundColor: t[5].fn.themeColor("dark", 6),
                },
                ...t[3],
              },
            },
            { padding: t[4] },
            { use: t[1] },
            t[8],
          ];
          function o(e) {
            t[10](e);
          }
          let a = { $$slots: { default: [bi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new yi({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  510 & n
                    ? Nt(i, [
                        196 & n && { class: t[7](t[2], t[6].root) },
                        40 & n && {
                          override: {
                            [`${t[5].dark} &`]: {
                              backgroundColor: t[5].fn.themeColor("dark", 6),
                            },
                            ...t[3],
                          },
                        },
                        16 & n && { padding: t[4] },
                        2 & n && { use: t[1] },
                        256 & n && Bt(t[8]),
                      ])
                    : {};
                2048 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function vi(t, e, r) {
          let s, i, o;
          const a = ["use", "element", "class", "override", "padding"];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              padding: y = "md",
            } = e;
          return (
            nt(() => {
              const t = h.children.length,
                e = h.children[0],
                n = h.children[t - 1];
              "svelteui_card_section" === e?.id &&
                (e.style.marginTop =
                  -1 * o.fn.size({ size: y, sizes: o.space }) + "px"),
                "svelteui_card_section" === n?.id &&
                  (n.style.marginBottom =
                    -1 * o.fn.size({ size: y, sizes: o.space }) + "px");
            }),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(8, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "padding" in t && r(4, (y = t.padding)),
                "$$scope" in t && r(11, (u = t.$$scope));
            }),
            r(
              7,
              ({ cx: s, classes: i, theme: o } = hi(null, { name: "Card" })),
              s,
              r(6, i),
              r(5, o)
            ),
            [
              h,
              d,
              f,
              m,
              y,
              o,
              i,
              s,
              l,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Ai = class extends Ft {
            constructor(t) {
              super(),
                zt(this, t, vi, wi, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 3,
                  padding: 4,
                });
            }
          },
          $i = Se((t, { padding: e }) => ({
            root: {
              display: "block",
              marginLeft: -1 * t.fn.size({ size: e, sizes: t.space }),
              marginRight: -1 * t.fn.size({ size: e, sizes: t.space }),
            },
          }));
        function xi(t) {
          let e;
          const n = t[9].default,
            r = c(n, t, t[11], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2048 & s) &&
                h(r, n, t, t[11], e ? d(n, t[11], s, null) : f(t[11]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function ki(t) {
          let e, r, s;
          const i = [
            { id: "svelteui_card_section" },
            { class: t[6](t[2], t[5].root, t[4]({ css: t[3] })) },
            { use: t[1] },
            t[7],
          ];
          function o(e) {
            t[10](e);
          }
          let a = { $$slots: { default: [xi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Nt(i, [
                        i[0],
                        124 & n && {
                          class: t[6](t[2], t[5].root, t[4]({ css: t[3] })),
                        },
                        2 & n && { use: t[1] },
                        128 & n && Bt(t[7]),
                      ])
                    : {};
                2048 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Ei(t, e, r) {
          let s, i, o;
          const a = ["use", "element", "class", "override", "padding"];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              padding: y = "md",
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "padding" in t && r(8, (y = t.padding)),
                "$$scope" in t && r(11, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              256 & t.$$.dirty &&
                r(
                  6,
                  ({ cx: s, classes: i, getStyles: o } = $i({ padding: y })),
                  s,
                  (r(5, i), r(8, y)),
                  (r(4, o), r(8, y))
                );
            }),
            [
              h,
              d,
              f,
              m,
              o,
              i,
              s,
              l,
              y,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Ci = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, Ei, ki, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                padding: 8,
              });
          }
        };
        Ai.Section = Ci;
        const Si = Ai;
        var Pi = Se((t, { inline: e }) => ({
          root: {
            display: e ? "inline-flex" : "flex",
            alignItems: "center",
            justifyContent: "center",
          },
        }));
        function Ii(t) {
          let e;
          const n = t[9].default,
            r = c(n, t, t[11], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2048 & s) &&
                h(r, n, t, t[11], e ? d(n, t[11], s, null) : f(t[11]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Ni(t) {
          let e, r, s;
          const i = [
            { use: t[1] },
            { class: t[6](t[2], t[5].root, t[4]({ css: t[3] })) },
            t[7],
          ];
          function o(e) {
            t[10](e);
          }
          let a = { $$slots: { default: [Ii] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Nt(i, [
                        2 & n && { use: t[1] },
                        124 & n && {
                          class: t[6](t[2], t[5].root, t[4]({ css: t[3] })),
                        },
                        128 & n && Bt(t[7]),
                      ])
                    : {};
                2048 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Bi(t, e, r) {
          let s, i, o;
          const a = ["use", "element", "class", "override", "inline"];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              inline: y = !1,
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "inline" in t && r(8, (y = t.inline)),
                "$$scope" in t && r(11, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              256 & t.$$.dirty &&
                r(
                  6,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = Pi({ inline: y }, { name: "Center" })),
                  s,
                  (r(5, i), r(8, y)),
                  (r(4, o), r(8, y))
                );
            }),
            [
              h,
              d,
              f,
              m,
              o,
              i,
              s,
              l,
              y,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Ti = class extends Ft {
            constructor(t) {
              super(),
                zt(this, t, Bi, Ni, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 3,
                  inline: 8,
                });
            }
          },
          Oi = Se((t, { fluid: e, size: n, sizes: r }) => ({
            root: {
              paddingLeft: t.fn.size({ size: n, sizes: t.space }),
              paddingRight: t.fn.size({ size: n, sizes: t.space }),
              maxWidth: e
                ? "100%"
                : "number" == typeof n
                ? `${n}px`
                : r[n] ?? r.md,
              marginLeft: "auto",
              marginRight: "auto",
            },
          }));
        function Ri(t) {
          let e;
          const n = t[11].default,
            r = c(n, t, t[13], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 8192 & s) &&
                h(r, n, t, t[13], e ? d(n, t[13], s, null) : f(t[13]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Li(t) {
          let e, r, s;
          const i = [
            { use: t[1] },
            { class: t[6](t[2], t[5].root, t[4]({ css: t[3] })) },
            t[7],
          ];
          function o(e) {
            t[12](e);
          }
          let a = { $$slots: { default: [Ri] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Nt(i, [
                        2 & n && { use: t[1] },
                        124 & n && {
                          class: t[6](t[2], t[5].root, t[4]({ css: t[3] })),
                        },
                        128 & n && Bt(t[7]),
                      ])
                    : {};
                8192 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function zi(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "size",
            "fluid",
            "sizes",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              size: y = "md",
              fluid: b = !1,
              sizes: w = { xs: 540, sm: 720, md: 960, lg: 1140, xl: 1320 },
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "size" in t && r(8, (y = t.size)),
                "fluid" in t && r(9, (b = t.fluid)),
                "sizes" in t && r(10, (w = t.sizes)),
                "$$scope" in t && r(13, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              1792 & t.$$.dirty &&
                r(
                  6,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = Oi(
                    { fluid: b, size: y, sizes: w },
                    { name: "Container" }
                  )),
                  s,
                  (r(5, i), r(9, b), r(8, y), r(10, w)),
                  (r(4, o), r(9, b), r(8, y), r(10, w))
                );
            }),
            [
              h,
              d,
              f,
              m,
              o,
              i,
              s,
              l,
              y,
              b,
              w,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Fi = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, zi, Li, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                size: 8,
                fluid: 9,
                sizes: 10,
              });
          }
        };
        const Ui = { app: 100, modal: 200, popover: 300, overlay: 400 };
        function Di(t) {
          return Ui[t];
        }
        function Mi(t) {
          let e, r, s;
          const i = [
            { use: [t[10], [Qt, t[1]]] },
            {
              css: {
                ...t[9],
                ...t[8],
                opacity: t[4],
                borderRadius: `${t[6]}`,
                ...t[3],
              },
            },
            t[11],
            { class: t[2] },
          ];
          function o(e) {
            t[17](e);
          }
          let a = { $$slots: { default: [Wi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  3934 & n
                    ? Nt(i, [
                        1026 & n && { use: [t[10], [Qt, t[1]]] },
                        856 & n && {
                          css: {
                            ...t[9],
                            ...t[8],
                            opacity: t[4],
                            borderRadius: `${t[6]}`,
                            ...t[3],
                          },
                        },
                        2048 & n && Bt(t[11]),
                        4 & n && { class: t[2] },
                      ])
                    : {};
                262272 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function ji(t) {
          let e, r, s;
          const i = [
            { use: [t[10], [Qt, t[1]]] },
            { css: { ...t[8], backdropFilter: `blur(${t[5]}px)` } },
            { class: t[2] },
            t[11],
          ];
          function o(e) {
            t[16](e);
          }
          let a = { $$slots: { default: [Qi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  3366 & n
                    ? Nt(i, [
                        1026 & n && { use: [t[10], [Qt, t[1]]] },
                        288 & n && {
                          css: { ...t[8], backdropFilter: `blur(${t[5]}px)` },
                        },
                        4 & n && { class: t[2] },
                        2048 & n && Bt(t[11]),
                      ])
                    : {};
                263e3 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Hi(t) {
          let e;
          const n = t[15].default,
            r = c(n, t, t[18], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 262144 & s) &&
                h(r, n, t, t[18], e ? d(n, t[18], s, null) : f(t[18]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Gi(t) {
          let e, n;
          return (
            (e = new Ti({
              props: { $$slots: { default: [Vi] }, $$scope: { ctx: t } },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                262144 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Vi(t) {
          let e;
          const n = t[15].default,
            r = c(n, t, t[18], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 262144 & s) &&
                h(r, n, t, t[18], e ? d(n, t[18], s, null) : f(t[18]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Wi(t) {
          let e, n, r, s;
          const i = [Gi, Hi],
            o = [];
          function a(t, e) {
            return t[7] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, s) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (kt(),
                      St(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      Et(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      Ct(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (Ct(n), (s = !0));
              },
              o(t) {
                St(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Qi(t) {
          let e, n;
          return (
            (e = new Gn({
              props: {
                css: {
                  ...t[9],
                  ...t[8],
                  opacity: t[4],
                  borderRadius: `${t[6]}`,
                  ...t[3],
                },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                856 & n &&
                  (r.css = {
                    ...t[9],
                    ...t[8],
                    opacity: t[4],
                    borderRadius: `${t[6]}`,
                    ...t[3],
                  }),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Ji(t) {
          let e, n, r, s;
          const i = [ji, Mi],
            o = [];
          function a(t, e) {
            return t[5] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, [s]) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (kt(),
                      St(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      Et(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      Ct(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (Ct(n), (s = !0));
              },
              o(t) {
                St(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function _i(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "override",
            "opacity",
            "color",
            "blur",
            "gradient",
            "zIndex",
            "radius",
            "center",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e,
            {
              use: u = [],
              element: d,
              class: h = "",
              override: f = {},
              opacity: m = 0.6,
              color: y = "#fff",
              blur: b = 0,
              gradient: w = "",
              zIndex: v = Di("modal"),
              radius: A = 0,
              center: $ = !1,
            } = e;
          const x = Kt(et());
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(11, (a = g(e, o))),
                "use" in t && r(1, (u = t.use)),
                "element" in t && r(0, (d = t.element)),
                "class" in t && r(2, (h = t.class)),
                "override" in t && r(3, (f = t.override)),
                "opacity" in t && r(4, (m = t.opacity)),
                "color" in t && r(12, (y = t.color)),
                "blur" in t && r(5, (b = t.blur)),
                "gradient" in t && r(13, (w = t.gradient)),
                "zIndex" in t && r(14, (v = t.zIndex)),
                "radius" in t && r(6, (A = t.radius)),
                "center" in t && r(7, ($ = t.center)),
                "$$scope" in t && r(18, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              12288 & t.$$.dirty &&
                r(9, (s = w ? { backgroundImage: w } : { backgroundColor: y })),
                16384 & t.$$.dirty &&
                  r(
                    8,
                    (i = {
                      position: "absolute",
                      top: 0,
                      bottom: 0,
                      left: 0,
                      right: 0,
                      zIndex: v,
                    })
                  );
            }),
            [
              d,
              u,
              h,
              f,
              m,
              b,
              A,
              $,
              i,
              s,
              x,
              a,
              y,
              w,
              v,
              l,
              function (t) {
                (d = t), r(0, d);
              },
              function (t) {
                (d = t), r(0, d);
              },
              c,
            ]
          );
        }
        var Ki = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, _i, Ji, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                opacity: 4,
                color: 12,
                blur: 5,
                gradient: 13,
                zIndex: 14,
                radius: 6,
                center: 7,
              });
          }
        };
        const qi = {
          xs: 320,
          sm: 380,
          md: 440,
          lg: 620,
          xl: 780,
          full: "100%",
        };
        var Yi = Se((t, { centered: e, overflow: n, size: r, zIndex: s }) => {
          const i = r in qi == !1;
          return {
            close: {},
            overlay: {},
            root: {
              position: "fixed",
              zIndex: s,
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
            },
            inner: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              overflowY: "auto",
              padding: `${2 * +t.space.xl.value}px ${+t.space.md.value}px`,
              display: "flex",
              justifyContent: "center",
              alignItems: e ? "center" : "flex-start",
            },
            title: {
              marginRight: +t.space.md.value,
              textOverflow: "ellipsis",
              display: "block",
              wordBreak: "break-word",
            },
            modal: {
              [`${t.dark} &`]: { backgroundColor: t.fn.themeColor("dark", 7) },
              position: "relative",
              width:
                "string" == typeof r && i
                  ? r
                  : t.fn.size({ sizes: qi, size: r }),
              outline: 0,
              backgroundColor: "white",
              marginTop: e ? "auto" : void 0,
              marginBottom: e ? "auto" : void 0,
              zIndex: 1,
              marginLeft: "calc(var(--removed-scroll-width, 0px) * -1)",
            },
            header: {
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              marginBottom: parseInt(t.space.md.value),
              marginRight: -9,
            },
            body: {
              maxHeight: "inside" === n ? "calc(100vh - 185px)" : null,
              overflowY: "inside" === n ? "auto" : null,
              wordBreak: "break-word",
            },
          };
        });
        function Zi(t) {
          let e, n;
          return (
            (e = new Es({
              props: {
                class: t[28](),
                withinPortal: t[17],
                target: t[16],
                $$slots: { default: [so] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                131072 & n[0] && (r.withinPortal = t[17]),
                  65536 & n[0] && (r.target = t[16]),
                  (540868591 & n[0]) | (512 & n[1]) &&
                    (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Xi(t) {
          let e, n, r, s, i;
          n = new Zs({
            props: {
              id: t[24],
              class: t[19].title,
              $$slots: { default: [to] },
              $$scope: { ctx: t },
            },
          });
          let o = t[6] && eo(t);
          return {
            c() {
              (e = N("div")),
                Ot(n.$$.fragment),
                (r = O()),
                o && o.c(),
                z(e, "class", (s = t[19].header));
            },
            m(t, s) {
              P(t, e, s), Rt(n, e, null), x(e, r), o && o.m(e, null), (i = !0);
            },
            p(t, r) {
              const a = {};
              524288 & r[0] && (a.class = t[19].title),
                (32 & r[0]) | (512 & r[1]) &&
                  (a.$$scope = { dirty: r, ctx: t }),
                n.$set(a),
                t[6]
                  ? o
                    ? (o.p(t, r), 64 & r[0] && Ct(o, 1))
                    : ((o = eo(t)), o.c(), Ct(o, 1), o.m(e, null))
                  : o &&
                    (kt(),
                    St(o, 1, 1, () => {
                      o = null;
                    }),
                    Et()),
                (!i || (524288 & r[0] && s !== (s = t[19].header))) &&
                  z(e, "class", s);
            },
            i(t) {
              i || (Ct(n.$$.fragment, t), Ct(o), (i = !0));
            },
            o(t) {
              St(n.$$.fragment, t), St(o), (i = !1);
            },
            d(t) {
              t && I(e), Lt(n), o && o.d();
            },
          };
        }
        function to(t) {
          let e;
          return {
            c() {
              e = T(t[5]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              32 & n[0] && H(e, t[5]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function eo(t) {
          let e, n;
          return (
            (e = new ns({
              props: { iconSize: 16, "aria-label": t[10], class: t[19].close },
            })),
            e.$on("click", t[27]),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                1024 & n[0] && (r["aria-label"] = t[10]),
                  524288 & n[0] && (r.class = t[19].close),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function no(t) {
          let e,
            n,
            r,
            s,
            i = (t[5] || t[6]) && Xi(t);
          const o = t[36].default,
            a = c(o, t, t[40], null),
            l =
              a ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("Place some content");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              i && i.c(),
                (e = O()),
                (n = N("div")),
                l && l.c(),
                z(n, "id", t[25]),
                z(n, "class", (r = t[19].body));
            },
            m(t, r) {
              i && i.m(t, r),
                P(t, e, r),
                P(t, n, r),
                l && l.m(n, null),
                (s = !0);
            },
            p(t, l) {
              t[5] || t[6]
                ? i
                  ? (i.p(t, l), 96 & l[0] && Ct(i, 1))
                  : ((i = Xi(t)), i.c(), Ct(i, 1), i.m(e.parentNode, e))
                : i &&
                  (kt(),
                  St(i, 1, 1, () => {
                    i = null;
                  }),
                  Et()),
                a &&
                  a.p &&
                  (!s || 512 & l[1]) &&
                  h(a, o, t, t[40], s ? d(o, t[40], l, null) : f(t[40]), null),
                (!s || (524288 & l[0] && r !== (r = t[19].body))) &&
                  z(n, "class", r);
            },
            i(t) {
              s || (Ct(i), Ct(l, t), (s = !0));
            },
            o(t) {
              St(i), St(l, t), (s = !1);
            },
            d(t) {
              i && i.d(t), t && I(e), t && I(n), l && l.d(t);
            },
          };
        }
        function ro(t) {
          let e, n, r, s, a, l, c, u, d, h, f, p, g;
          return (
            (r = new yi({
              props: {
                class: t[19].modal,
                shadow: t[11],
                padding: t[12],
                radius: t[9],
                role: "dialog",
                "aria-labelledby": t[24],
                "aria-describedby": t[25],
                "aria-modal": !0,
                tabindex: -1,
                use: [[us, t[15]]],
                $$slots: { default: [no] },
                $$scope: { ctx: t },
              },
            })),
            (c = new Ki({
              props: {
                class: t[19].overlay,
                override: { position: "fixed" },
                zIndex: 0,
                blur: t[8],
                color: t[7] || "black",
                opacity: t[26],
              },
            })),
            c.$on("mousedown", t[37]),
            {
              c() {
                (e = N("div")),
                  (n = N("div")),
                  Ot(r.$$.fragment),
                  (a = O()),
                  (l = N("div")),
                  Ot(c.$$.fragment),
                  z(e, "role", "presentation"),
                  z(e, "class", (d = t[19].inner));
              },
              m(s, i) {
                P(s, e, i),
                  x(e, n),
                  Rt(r, n, null),
                  x(e, a),
                  x(e, l),
                  Rt(c, l, null),
                  (f = !0),
                  p ||
                    ((g = [
                      y((h = gs.call(null, e, t[21]))),
                      L(e, "keydown", t[38], !0),
                    ]),
                    (p = !0));
              },
              p(n, s) {
                t = n;
                const i = {};
                524288 & s[0] && (i.class = t[19].modal),
                  2048 & s[0] && (i.shadow = t[11]),
                  4096 & s[0] && (i.padding = t[12]),
                  512 & s[0] && (i.radius = t[9]),
                  32768 & s[0] && (i.use = [[us, t[15]]]),
                  (525408 & s[0]) | (512 & s[1]) &&
                    (i.$$scope = { dirty: s, ctx: t }),
                  r.$set(i);
                const a = {};
                524288 & s[0] && (a.class = t[19].overlay),
                  256 & s[0] && (a.blur = t[8]),
                  128 & s[0] && (a.color = t[7] || "black"),
                  c.$set(a),
                  (!f || (524288 & s[0] && d !== (d = t[19].inner))) &&
                    z(e, "class", d),
                  h &&
                    o(h.update) &&
                    2097152 & s[0] &&
                    h.update.call(null, t[21]);
              },
              i(t) {
                f ||
                  (Ct(r.$$.fragment, t),
                  pt(() => {
                    f &&
                      (s || (s = It(n, Xt, { duration: 100, easing: Yt }, !0)),
                      s.run(1));
                  }),
                  Ct(c.$$.fragment, t),
                  pt(() => {
                    f &&
                      (u || (u = It(l, Zt, { duration: 200, easing: Yt }, !0)),
                      u.run(1));
                  }),
                  (f = !0));
              },
              o(t) {
                St(r.$$.fragment, t),
                  s || (s = It(n, Xt, { duration: 100, easing: Yt }, !1)),
                  s.run(0),
                  St(c.$$.fragment, t),
                  u || (u = It(l, Zt, { duration: 200, easing: Yt }, !1)),
                  u.run(0),
                  (f = !1);
              },
              d(t) {
                t && I(e),
                  Lt(r),
                  t && s && s.end(),
                  Lt(c),
                  t && u && u.end(),
                  (p = !1),
                  i(g);
              },
            }
          );
        }
        function so(t) {
          let e, r, s;
          const i = [
            { id: t[23] },
            { use: t[1] },
            t[29],
            { class: t[20](t[2], t[19].root, t[18]({ css: t[3] })) },
          ];
          function o(e) {
            t[39](e);
          }
          let a = { $$slots: { default: [ro] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  547094542 & n[0]
                    ? Nt(i, [
                        8388608 & n[0] && { id: t[23] },
                        2 & n[0] && { use: t[1] },
                        536870912 & n[0] && Bt(t[29]),
                        1835020 & n[0] && {
                          class: t[20](t[2], t[19].root, t[18]({ css: t[3] })),
                        },
                      ])
                    : {};
                (2686944 & n[0]) | (512 & n[1]) &&
                  (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n[0] &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function io(t) {
          let e,
            n,
            r = t[4] && Zi(t);
          return {
            c() {
              r && r.c(), (e = R());
            },
            m(t, s) {
              r && r.m(t, s), P(t, e, s), (n = !0);
            },
            p(t, n) {
              t[4]
                ? r
                  ? (r.p(t, n), 16 & n[0] && Ct(r, 1))
                  : ((r = Zi(t)), r.c(), Ct(r, 1), r.m(e.parentNode, e))
                : r &&
                  (kt(),
                  St(r, 1, 1, () => {
                    r = null;
                  }),
                  Et());
            },
            i(t) {
              n || (Ct(r), (n = !0));
            },
            o(t) {
              St(r), (n = !1);
            },
            d(t) {
              r && r.d(t), t && I(e);
            },
          };
        }
        function oo(t, e, r) {
          let s, i, o, a;
          const c = [
            "use",
            "element",
            "class",
            "override",
            "opened",
            "title",
            "zIndex",
            "overflow",
            "withCloseButton",
            "overlayOpacity",
            "overlayColor",
            "overlayBlur",
            "radius",
            "size",
            "closeButtonLabel",
            "id",
            "shadow",
            "padding",
            "closeOnClickOutside",
            "closeOnEscape",
            "trapFocus",
            "centered",
            "target",
            "withinPortal",
          ];
          let u,
            d = g(e, c);
          l(t, se, (t) => r(41, (u = t)));
          let { $$slots: h = {}, $$scope: f } = e,
            {
              use: m = [],
              element: y,
              class: b = "",
              override: w = {},
              opened: v = !1,
              title: A = "",
              zIndex: $ = 200,
              overflow: x = "outside",
              withCloseButton: k = !0,
              overlayOpacity: E = null,
              overlayColor: C = null,
              overlayBlur: S = 0,
              radius: P = "sm",
              size: I = "md",
              closeButtonLabel: N = "svelteui-close-button",
              id: B = "svelteui",
              shadow: T = "lg",
              padding: O = "lg",
              closeOnClickOutside: R = !0,
              closeOnEscape: L = !0,
              trapFocus: z = !0,
              centered: F = null,
              target: U = "#SVELTEUI_PROVIDER",
              withinPortal: D = !0,
            } = e;
          const M = rt(),
            j = (t) => t,
            H = (function (t = "svelteui") {
              return `${t}-${Math.random().toString(36).substring(2, 10)}`;
            })(B),
            G = `${H}-title`,
            V = `${H}-body`,
            W = "number" == typeof E ? E : "dark" === u ? 0.85 : 0.75,
            { handleFocusReturn: Q } = (function () {
              let t;
              const e = () => {
                t &&
                  "focus" in t &&
                  "function" == typeof t.focus &&
                  t.focus({ preventScroll: !0 });
              };
              return {
                handleFocusReturn(n, r = !0) {
                  n ? (t = document.activeElement) : r && e();
                },
                returnFocus: e,
              };
            })(),
            J = (t) => {
              !z && "Escape" === t.code && L && _();
            };
          function _() {
            M("close");
          }
          const K = $n({ zIndex: $ });
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(29, (d = g(e, c))),
                "use" in t && r(1, (m = t.use)),
                "element" in t && r(0, (y = t.element)),
                "class" in t && r(2, (b = t.class)),
                "override" in t && r(3, (w = t.override)),
                "opened" in t && r(4, (v = t.opened)),
                "title" in t && r(5, (A = t.title)),
                "zIndex" in t && r(30, ($ = t.zIndex)),
                "overflow" in t && r(31, (x = t.overflow)),
                "withCloseButton" in t && r(6, (k = t.withCloseButton)),
                "overlayOpacity" in t && r(32, (E = t.overlayOpacity)),
                "overlayColor" in t && r(7, (C = t.overlayColor)),
                "overlayBlur" in t && r(8, (S = t.overlayBlur)),
                "radius" in t && r(9, (P = t.radius)),
                "size" in t && r(33, (I = t.size)),
                "closeButtonLabel" in t && r(10, (N = t.closeButtonLabel)),
                "id" in t && r(34, (B = t.id)),
                "shadow" in t && r(11, (T = t.shadow)),
                "padding" in t && r(12, (O = t.padding)),
                "closeOnClickOutside" in t &&
                  r(13, (R = t.closeOnClickOutside)),
                "closeOnEscape" in t && r(14, (L = t.closeOnEscape)),
                "trapFocus" in t && r(15, (z = t.trapFocus)),
                "centered" in t && r(35, (F = t.centered)),
                "target" in t && r(16, (U = t.target)),
                "withinPortal" in t && r(17, (D = t.withinPortal)),
                "$$scope" in t && r(40, (f = t.$$scope));
            }),
            (t.$$.update = () => {
              if (
                (16 & t.$$.dirty[0] && Q(v),
                32768 & t.$$.dirty[0] &&
                  nt(() => {
                    z ||
                      ("undefined" != typeof window &&
                        window.addEventListener("keydown", J));
                  }),
                65552 & t.$$.dirty[0] &&
                  v &&
                  (("string" == typeof U && !document.querySelector(U)) || !U))
              )
                throw new Error(
                  "Wrap your app in the SvelteUIProvider, or provide a sufficent target throught the \"target={''}\" prop "
                );
              16 & t.$$.dirty[0] && r(21, (s = v)),
                (1073741824 & t.$$.dirty[0]) | (21 & t.$$.dirty[1]) &&
                  r(
                    20,
                    ({
                      cx: i,
                      classes: o,
                      getStyles: a,
                    } = Yi(
                      { centered: F, overflow: x, size: I, zIndex: $ },
                      { name: "Modal" }
                    )),
                    i,
                    (r(19, o), r(35, F), r(31, x), r(33, I), r(30, $)),
                    (r(18, a), r(35, F), r(31, x), r(33, I), r(30, $))
                  );
            }),
            [
              y,
              m,
              b,
              w,
              v,
              A,
              k,
              C,
              S,
              P,
              N,
              T,
              O,
              R,
              L,
              z,
              U,
              D,
              a,
              o,
              i,
              s,
              j,
              H,
              G,
              V,
              W,
              _,
              K,
              d,
              $,
              x,
              E,
              I,
              B,
              F,
              h,
              () => R && _(),
              (t) => {
                "true" !==
                  t.target?.getAttribute("data-svelteui-stop-propagation") &&
                  "Escape" === t.code &&
                  L &&
                  _();
              },
              function (t) {
                (y = t), r(0, y);
              },
              f,
            ]
          );
        }
        var ao = class extends Ft {
            constructor(t) {
              super(),
                zt(
                  this,
                  t,
                  oo,
                  io,
                  a,
                  {
                    use: 1,
                    element: 0,
                    class: 2,
                    override: 3,
                    opened: 4,
                    title: 5,
                    zIndex: 30,
                    overflow: 31,
                    withCloseButton: 6,
                    overlayOpacity: 32,
                    overlayColor: 7,
                    overlayBlur: 8,
                    radius: 9,
                    size: 33,
                    closeButtonLabel: 10,
                    id: 34,
                    shadow: 11,
                    padding: 12,
                    closeOnClickOutside: 13,
                    closeOnEscape: 14,
                    trapFocus: 15,
                    centered: 35,
                    target: 16,
                    withinPortal: 17,
                  },
                  null,
                  [-1, -1]
                );
            }
          },
          lo = Se((t, { align: e, bulletSize: n, lineWidth: r }) => ({
            root: {
              paddingLeft: "left" === e ? n / 2 + r / 2 : 0,
              paddingRight: "left" === e ? 0 : n / 2 + r / 2,
            },
          }));
        function co(t) {
          let e;
          const n = t[15].default,
            r = c(n, t, t[17], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 131072 & s) &&
                h(r, n, t, t[17], e ? d(n, t[17], s, null) : f(t[17]), null);
            },
            i(t) {
              e || (Ct(r, t), (e = !0));
            },
            o(t) {
              St(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function uo(t) {
          let e, r, s;
          const i = [{ use: t[1] }, { class: t[4](t[2], t[3].root) }, t[6]];
          function o(e) {
            t[16](e);
          }
          let a = { $$slots: { default: [co] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  94 & n
                    ? Nt(i, [
                        2 & n && { use: t[1] },
                        28 & n && { class: t[4](t[2], t[3].root) },
                        64 & n && Bt(t[6]),
                      ])
                    : {};
                131072 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        const ho = "Timeline";
        function fo(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "override",
            "active",
            "align",
            "bulletSize",
            "radius",
            "color",
            "lineWidth",
            "reverseActive",
          ];
          let a,
            c = g(e, o),
            { $$slots: u = {}, $$scope: d } = e,
            {
              use: h = [],
              element: f,
              class: m = "",
              override: y = {},
              active: b = -1,
              align: w = "left",
              bulletSize: v = 20,
              radius: A = "xl",
              color: $ = "blue",
              lineWidth: x = 4,
              reverseActive: k = !1,
            } = e;
          const E = re({
            active: b,
            reverseActive: k,
            align: w,
            bulletSize: v,
            radius: A,
            color: $,
            lineWidth: x,
          });
          return (
            l(t, E, (t) => r(18, (a = t))),
            st(ho, E),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(6, (c = g(e, o))),
                "use" in t && r(1, (h = t.use)),
                "element" in t && r(0, (f = t.element)),
                "class" in t && r(2, (m = t.class)),
                "override" in t && r(7, (y = t.override)),
                "active" in t && r(8, (b = t.active)),
                "align" in t && r(9, (w = t.align)),
                "bulletSize" in t && r(10, (v = t.bulletSize)),
                "radius" in t && r(11, (A = t.radius)),
                "color" in t && r(12, ($ = t.color)),
                "lineWidth" in t && r(13, (x = t.lineWidth)),
                "reverseActive" in t && r(14, (k = t.reverseActive)),
                "$$scope" in t && r(17, (d = t.$$scope));
            }),
            (t.$$.update = () => {
              var e;
              32512 & t.$$.dirty &&
                ((a = {
                  active: b,
                  reverseActive: k,
                  align: w,
                  bulletSize: v,
                  radius: A,
                  color: $,
                  lineWidth: x,
                }),
                (e = a),
                E.set(e)),
                9856 & t.$$.dirty &&
                  r(
                    4,
                    ({ cx: s, classes: i } = lo(
                      { align: w, bulletSize: v, lineWidth: x },
                      { override: y, name: "Timeline" }
                    )),
                    s,
                    (r(3, i), r(9, w), r(10, v), r(13, x), r(7, y))
                  );
            }),
            [
              f,
              h,
              m,
              i,
              s,
              E,
              c,
              y,
              b,
              w,
              v,
              A,
              $,
              x,
              k,
              u,
              function (t) {
                (f = t), r(0, f);
              },
              d,
            ]
          );
        }
        var po = class extends Ft {
            constructor(t) {
              super(),
                zt(this, t, fo, uo, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 7,
                  active: 8,
                  align: 9,
                  bulletSize: 10,
                  radius: 11,
                  color: 12,
                  lineWidth: 13,
                  reverseActive: 14,
                });
            }
          },
          go = Se(
            (
              t,
              {
                align: e,
                bulletSize: n,
                radius: r,
                color: s,
                lineVariant: i,
                lineWidth: o,
              },
              a
            ) => {
              const l = de(s).filled;
              return {
                root: {
                  position: "relative",
                  boxSizing: "border-box",
                  color: t.colors.black.value,
                  paddingLeft: "left" === e ? t.space.xlPX.value : 0,
                  paddingRight: "right" === e ? t.space.xlPX.value : 0,
                  textAlign: e,
                  darkMode: { color: t.fn.themeColor("dark", 0) },
                  "&:not(:last-of-type)::before": { display: "block" },
                  "&:not(:first-of-type)": { marginTop: t.space.xlPX.value },
                  "&::before": {
                    boxSizing: "border-box",
                    position: "absolute",
                    top: 0,
                    bottom: -t.space.xl.value + "px",
                    left: "left" === e ? -o : "auto",
                    right: "right" === e ? -o : "auto",
                    borderLeft: `${o}px ${i} ${t.fn.themeColor("gray", 3)}`,
                    content: '""',
                    display: "none",
                    darkMode: {
                      borderLeft: `${o}px ${i} ${t.fn.themeColor("dark", 4)}`,
                    },
                  },
                  "&.lineActive": {
                    "&::before": { borderLeftColor: l.backgroundColor },
                  },
                  [`&.active .${a("bulletContainer")}`]: {
                    borderColor: l.backgroundColor,
                    backgroundColor: t.colors.white.value,
                  },
                  [`&.active .${a("bulletContainerWithChild")}`]: {
                    backgroundColor: l.backgroundColor,
                    color: t.colors.white.value,
                  },
                },
                bulletContainer: {
                  ref: a("bulletContainer"),
                  boxSizing: "border-box",
                  width: n,
                  height: n,
                  borderRadius: t.fn.radius(r),
                  border: `${o}px solid ${t.fn.themeColor("gray", 3)}`,
                  backgroundColor: t.colors.white.value,
                  position: "absolute",
                  top: 0,
                  left: "left" === e ? -n / 2 - o / 2 : "auto",
                  right: "right" === e ? -n / 2 - o / 2 : "auto",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  color: t.colors.white.value,
                  darkMode: {
                    border: `${o}px solid ${t.fn.themeColor("dark", 4)}`,
                    backgroundColor: t.fn.themeColor("dark", 7),
                  },
                },
                bulletContainerWithChild: {
                  ref: a("bulletContainerWithChild"),
                  borderWidth: 1,
                  backgroundColor: t.fn.themeColor("gray", 3),
                  color: t.colors.black.value,
                  darkMode: {
                    backgroundColor: t.fn.themeColor("dark", 4),
                    color: t.fn.themeColor("dark", 0),
                  },
                },
                bullet: {},
                container: {},
                title: {
                  fontWeight: 500,
                  lineHeight: 1,
                  marginBottom: +t.space.xs.value / 2 + "px",
                  textAlign: e,
                },
                content: { textAlign: e },
              };
            }
          );
        const mo = (t) => ({}),
          yo = (t) => ({});
        function bo(t) {
          let e, n;
          return (
            (e = new Us({
              props: {
                icon: t[3],
                className: t[7].bullet,
                iconSize: t[4],
                color: t[5],
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                8 & n && (r.icon = t[3]),
                  128 & n && (r.className = t[7].bullet),
                  16 & n && (r.iconSize = t[4]),
                  32 & n && (r.color = t[5]),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function wo(t) {
          let e, n;
          return (
            (e = new Zs({
              props: {
                class: t[7].title,
                $$slots: { default: [vo] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                128 & n && (r.class = t[7].title),
                  268435520 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function vo(t) {
          let e;
          return {
            c() {
              e = T(t[6]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              64 & n && H(e, t[6]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Ao(t) {
          let e, n, r, s, i, o, a, l, u;
          const p = t[26].bullet,
            g = c(p, t, t[28], yo),
            m =
              g ||
              (function (t) {
                let e,
                  n,
                  r = t[3] && bo(t);
                return {
                  c() {
                    r && r.c(), (e = R());
                  },
                  m(t, s) {
                    r && r.m(t, s), P(t, e, s), (n = !0);
                  },
                  p(t, n) {
                    t[3]
                      ? r
                        ? (r.p(t, n), 8 & n && Ct(r, 1))
                        : ((r = bo(t)), r.c(), Ct(r, 1), r.m(e.parentNode, e))
                      : r &&
                        (kt(),
                        St(r, 1, 1, () => {
                          r = null;
                        }),
                        Et());
                  },
                  i(t) {
                    n || (Ct(r), (n = !0));
                  },
                  o(t) {
                    St(r), (n = !1);
                  },
                  d(t) {
                    r && r.d(t), t && I(e);
                  },
                };
              })(t);
          let y = t[6] && wo(t);
          const b = t[26].default,
            w = c(b, t, t[28], null);
          return {
            c() {
              (e = N("div")),
                m && m.c(),
                (r = O()),
                (s = N("div")),
                y && y.c(),
                (i = O()),
                (o = N("div")),
                w && w.c(),
                z(
                  e,
                  "class",
                  (n = t[8](
                    t[7].bulletContainer,
                    t[3] && t[7].bulletContainerWithChild
                  ))
                ),
                z(o, "class", (a = t[7].content)),
                z(s, "class", (l = t[7].container));
            },
            m(t, n) {
              P(t, e, n),
                m && m.m(e, null),
                P(t, r, n),
                P(t, s, n),
                y && y.m(s, null),
                x(s, i),
                x(s, o),
                w && w.m(o, null),
                (u = !0);
            },
            p(t, r) {
              g
                ? g.p &&
                  (!u || 268435456 & r) &&
                  h(g, p, t, t[28], u ? d(p, t[28], r, mo) : f(t[28]), yo)
                : m && m.p && (!u || 184 & r) && m.p(t, u ? r : -1),
                (!u ||
                  (392 & r &&
                    n !==
                      (n = t[8](
                        t[7].bulletContainer,
                        t[3] && t[7].bulletContainerWithChild
                      )))) &&
                  z(e, "class", n),
                t[6]
                  ? y
                    ? (y.p(t, r), 64 & r && Ct(y, 1))
                    : ((y = wo(t)), y.c(), Ct(y, 1), y.m(s, i))
                  : y &&
                    (kt(),
                    St(y, 1, 1, () => {
                      y = null;
                    }),
                    Et()),
                w &&
                  w.p &&
                  (!u || 268435456 & r) &&
                  h(w, b, t, t[28], u ? d(b, t[28], r, null) : f(t[28]), null),
                (!u || (128 & r && a !== (a = t[7].content))) &&
                  z(o, "class", a),
                (!u || (128 & r && l !== (l = t[7].container))) &&
                  z(s, "class", l);
            },
            i(t) {
              u || (Ct(m, t), Ct(y), Ct(w, t), (u = !0));
            },
            o(t) {
              St(m, t), St(y), St(w, t), (u = !1);
            },
            d(t) {
              t && I(e),
                m && m.d(t),
                t && I(r),
                t && I(s),
                y && y.d(),
                w && w.d(t);
            },
          };
        }
        function $o(t) {
          let e, r, s;
          const i = [
            { use: t[1] },
            {
              class: t[8](t[2], t[7].root, { lineActive: t[9], active: t[10] }),
            },
            t[12],
          ];
          function o(e) {
            t[27](e);
          }
          let a = { $$slots: { default: [Ao] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Gn({ props: a })),
            at.push(() => Tt(e, "element", o)),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, n) {
                Rt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  6022 & n
                    ? Nt(i, [
                        2 & n && { use: t[1] },
                        1924 & n && {
                          class: t[8](t[2], t[7].root, {
                            lineActive: t[9],
                            active: t[10],
                          }),
                        },
                        4096 & n && Bt(t[12]),
                      ])
                    : {};
                268435960 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), gt(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function xo(t, e, r) {
          let s, i, o, a, c, u, d, h, f;
          const m = [
            "use",
            "element",
            "class",
            "override",
            "active",
            "align",
            "bullet",
            "bulletSize",
            "radius",
            "color",
            "lineActive",
            "lineVariant",
            "lineWidth",
            "title",
          ];
          let y,
            b = g(e, m),
            { $$slots: w = {}, $$scope: v } = e,
            {
              use: A = [],
              element: $,
              class: x = "",
              override: k = {},
              active: E,
              align: C,
              bullet: S,
              bulletSize: P,
              radius: I,
              color: N,
              lineActive: B,
              lineVariant: T = "solid",
              lineWidth: O,
              title: R,
            } = e;
          const L = it(ho);
          function z() {
            if (!$) return;
            const t = $.parentNode.children,
              e = Array.prototype.indexOf.call(t, $);
            r(
              10,
              (s =
                void 0 !== E
                  ? E
                  : y.reverseActive
                  ? y.active >= t.length - e - 1
                  : y.active >= e)
            ),
              r(
                9,
                (i =
                  void 0 !== B
                    ? B
                    : y.reverseActive
                    ? y.active >= t.length - e - 1
                    : y.active - 1 >= e)
              );
          }
          return (
            l(t, L, (t) => r(25, (y = t))),
            nt(() => z()),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(12, (b = g(e, m))),
                "use" in t && r(1, (A = t.use)),
                "element" in t && r(0, ($ = t.element)),
                "class" in t && r(2, (x = t.class)),
                "override" in t && r(13, (k = t.override)),
                "active" in t && r(14, (E = t.active)),
                "align" in t && r(15, (C = t.align)),
                "bullet" in t && r(3, (S = t.bullet)),
                "bulletSize" in t && r(4, (P = t.bulletSize)),
                "radius" in t && r(16, (I = t.radius)),
                "color" in t && r(5, (N = t.color)),
                "lineActive" in t && r(17, (B = t.lineActive)),
                "lineVariant" in t && r(18, (T = t.lineVariant)),
                "lineWidth" in t && r(19, (O = t.lineWidth)),
                "title" in t && r(6, (R = t.title)),
                "$$scope" in t && r(28, (v = t.$$scope));
            }),
            (t.$$.update = () => {
              16384 & t.$$.dirty && r(10, (s = E)),
                131072 & t.$$.dirty && r(9, (i = B)),
                33587200 & t.$$.dirty &&
                  r(24, (o = void 0 !== C ? C : y.align)),
                33554464 & t.$$.dirty &&
                  r(21, (a = void 0 !== N ? N : y.color)),
                33619968 & t.$$.dirty &&
                  r(22, (c = void 0 !== I ? I : y.radius)),
                33554448 & t.$$.dirty &&
                  r(23, (u = void 0 !== P ? P : y.bulletSize)),
                34078720 & t.$$.dirty &&
                  r(20, (d = void 0 !== O ? O : y.lineWidth)),
                33554432 & t.$$.dirty && z(),
                32776192 & t.$$.dirty &&
                  r(
                    8,
                    ({ cx: h, classes: f } = go(
                      {
                        align: o,
                        bulletSize: u,
                        radius: c,
                        color: a,
                        lineVariant: T,
                        lineWidth: d,
                      },
                      { override: k, name: "TimelineItem" }
                    )),
                    h,
                    (r(7, f),
                    r(24, o),
                    r(23, u),
                    r(22, c),
                    r(21, a),
                    r(18, T),
                    r(20, d),
                    r(13, k),
                    r(15, C),
                    r(25, y),
                    r(4, P),
                    r(16, I),
                    r(5, N),
                    r(19, O))
                  );
            }),
            [
              $,
              A,
              x,
              S,
              P,
              N,
              R,
              f,
              h,
              i,
              s,
              L,
              b,
              k,
              E,
              C,
              I,
              B,
              T,
              O,
              d,
              a,
              c,
              u,
              o,
              y,
              w,
              function (t) {
                ($ = t), r(0, $);
              },
              v,
            ]
          );
        }
        var ko = class extends Ft {
          constructor(t) {
            super(),
              zt(this, t, xo, $o, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 13,
                active: 14,
                align: 15,
                bullet: 3,
                bulletSize: 4,
                radius: 16,
                color: 5,
                lineActive: 17,
                lineVariant: 18,
                lineWidth: 19,
                title: 6,
              });
          }
        };
        po.Item = ko;
        const Eo = po;
        function Co(t) {
          let e, n, r, s, i, o, a;
          return (
            (e = new di({
              props: {
                variant: "filled",
                $$slots: { default: [Po] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment),
                  (n = O()),
                  (r = N("p")),
                  (s = T("Balance: ")),
                  (i = N("strong")),
                  (o = T(t[1]));
              },
              m(t, l) {
                Rt(e, t, l),
                  P(t, n, l),
                  P(t, r, l),
                  x(r, s),
                  x(r, i),
                  x(i, o),
                  (a = !0);
              },
              p(t, n) {
                const r = {};
                17 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r),
                  (!a || 2 & n) && H(o, t[1]);
              },
              i(t) {
                a || (Ct(e.$$.fragment, t), (a = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (a = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), t && I(r);
              },
            }
          );
        }
        function So(t) {
          let e, n;
          return (
            (e = new di({
              props: {
                variant: "filled",
                color: "red",
                $$slots: { default: [Io] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                16 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Po(t) {
          let e;
          return {
            c() {
              e = T(t[0]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              1 & n && H(e, t[0]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Io(t) {
          let e;
          return {
            c() {
              e = T("not connected");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function No(t) {
          let e, n, r, s, i, o;
          const a = [So, Co],
            l = [];
          function c(t, e) {
            return t[0] && t[1] ? 1 : 0;
          }
          return (
            (r = c(t)),
            (s = l[r] = a[r](t)),
            {
              c() {
                (e = N("h3")),
                  (e.textContent = "Account Information"),
                  (n = O()),
                  s.c(),
                  (i = R());
              },
              m(t, s) {
                P(t, e, s), P(t, n, s), l[r].m(t, s), P(t, i, s), (o = !0);
              },
              p(t, e) {
                let n = r;
                (r = c(t)),
                  r === n
                    ? l[r].p(t, e)
                    : (kt(),
                      St(l[n], 1, 1, () => {
                        l[n] = null;
                      }),
                      Et(),
                      (s = l[r]),
                      s ? s.p(t, e) : ((s = l[r] = a[r](t)), s.c()),
                      Ct(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (Ct(s), (o = !0));
              },
              o(t) {
                St(s), (o = !1);
              },
              d(t) {
                t && I(e), t && I(n), l[r].d(t), t && I(i);
              },
            }
          );
        }
        function Bo(t) {
          let e, n;
          return (
            (e = new Si({
              props: {
                shadow: "sm",
                padding: "lg",
                $$slots: { default: [No] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                19 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function To(t, e, n) {
          let r, s;
          return (
            nt(() => {
              (async function () {
                const t = await window.ethereum
                  .request({ method: "eth_requestAccounts" })
                  .catch((t) => {
                    4001 === t.code
                      ? console.log("Please connect to MetaMask.")
                      : console.error(t);
                  });
                n(0, (r = t[0]));
              })().then(() => {
                !(async function () {
                  console.log("account", r);
                  const t = await window.ethereum
                      .request({
                        method: "eth_getBalance",
                        params: [r, "latest"],
                      })
                      .catch((t) =>
                        4001 === t.code
                          ? (console.log("Please connect to MetaMask."), null)
                          : (console.error(t), null)
                      ),
                    e = parseInt(t, 16);
                  console.log("balWei", e),
                    n(1, (s = (e / 10 ** 18).toString()));
                })();
              });
            }),
            n(0, (r = null)),
            n(1, (s = null)),
            [r, s]
          );
        }
        class Oo extends Ft {
          constructor(t) {
            super(), zt(this, t, To, Bo, a, {});
          }
        }
        const Ro = "6.6.5";
        function Lo(t, e, n) {
          const r = e.split("|").map((t) => t.trim());
          for (let n = 0; n < r.length; n++)
            switch (e) {
              case "any":
                return;
              case "bigint":
              case "boolean":
              case "number":
              case "string":
                if (typeof t === e) return;
            }
          const s = new Error(`invalid value for type ${e}`);
          throw (
            ((s.code = "INVALID_ARGUMENT"),
            (s.argument = `value.${n}`),
            (s.value = t),
            s)
          );
        }
        async function zo(t) {
          const e = Object.keys(t),
            n = await Promise.all(e.map((e) => Promise.resolve(t[e])));
          return n.reduce((t, n, r) => ((t[e[r]] = n), t), {});
        }
        function Fo(t, e, n) {
          for (let r in e) {
            let s = e[r];
            const i = n ? n[r] : null;
            i && Lo(s, i, r),
              Object.defineProperty(t, r, {
                enumerable: !0,
                value: s,
                writable: !1,
              });
          }
        }
        function Uo(t) {
          if (null == t) return "null";
          if (Array.isArray(t)) return "[ " + t.map(Uo).join(", ") + " ]";
          if (t instanceof Uint8Array) {
            const e = "0123456789abcdef";
            let n = "0x";
            for (let r = 0; r < t.length; r++)
              (n += e[t[r] >> 4]), (n += e[15 & t[r]]);
            return n;
          }
          if ("object" == typeof t && "function" == typeof t.toJSON)
            return Uo(t.toJSON());
          switch (typeof t) {
            case "boolean":
            case "symbol":
            case "number":
              return t.toString();
            case "bigint":
              return BigInt(t).toString();
            case "string":
              return JSON.stringify(t);
            case "object": {
              const e = Object.keys(t);
              return (
                e.sort(),
                "{ " + e.map((e) => `${Uo(e)}: ${Uo(t[e])}`).join(", ") + " }"
              );
            }
          }
          return "[ COULD NOT SERIALIZE ]";
        }
        function Do(t, e) {
          return t && t.code === e;
        }
        function Mo(t) {
          return Do(t, "CALL_EXCEPTION");
        }
        function jo(t, e, n) {
          {
            const r = [];
            if (n) {
              if ("message" in n || "code" in n || "name" in n)
                throw new Error(
                  `value will overwrite populated values: ${Uo(n)}`
                );
              for (const t in n) {
                const e = n[t];
                r.push(t + "=" + Uo(e));
              }
            }
            r.push(`code=${e}`),
              r.push(`version=${Ro}`),
              r.length && (t += " (" + r.join(", ") + ")");
          }
          let r;
          switch (e) {
            case "INVALID_ARGUMENT":
              r = new TypeError(t);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              r = new RangeError(t);
              break;
            default:
              r = new Error(t);
          }
          return Fo(r, { code: e }), n && Object.assign(r, n), r;
        }
        function Ho(t, e, n, r) {
          if (!t) throw jo(e, n, r);
        }
        function Go(t, e, n, r) {
          Ho(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
        }
        function Vo(t, e, n) {
          null == n && (n = ""),
            n && (n = ": " + n),
            Ho(t >= e, "missing arguemnt" + n, "MISSING_ARGUMENT", {
              count: t,
              expectedCount: e,
            }),
            Ho(t <= e, "too many arguemnts" + n, "UNEXPECTED_ARGUMENT", {
              count: t,
              expectedCount: e,
            });
        }
        const Wo = ["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
          try {
            if ("test" !== "test".normalize(e)) throw new Error("bad");
            if ("NFD" === e) {
              const t = String.fromCharCode(233).normalize("NFD");
              if (t !== String.fromCharCode(101, 769))
                throw new Error("broken");
            }
            t.push(e);
          } catch (t) {}
          return t;
        }, []);
        function Qo(t, e, n) {
          if ((null == n && (n = ""), t !== e)) {
            let t = n,
              e = "new";
            n && ((t += "."), (e += " " + n)),
              Ho(
                !1,
                `private constructor; use ${t}from* methods`,
                "UNSUPPORTED_OPERATION",
                { operation: e }
              );
          }
        }
        function Jo(t, e, n) {
          if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
          if ("string" == typeof t && t.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
            const e = new Uint8Array((t.length - 2) / 2);
            let n = 2;
            for (let r = 0; r < e.length; r++)
              (e[r] = parseInt(t.substring(n, n + 2), 16)), (n += 2);
            return e;
          }
          Go(!1, "invalid BytesLike value", e || "value", t);
        }
        function _o(t, e) {
          return Jo(t, e, !1);
        }
        function Ko(t, e) {
          return Jo(t, e, !0);
        }
        function qo(t, e) {
          return (
            !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/)) &&
            ("number" != typeof e || t.length === 2 + 2 * e) &&
            (!0 !== e || t.length % 2 == 0)
          );
        }
        const Yo = "0123456789abcdef";
        function Zo(t) {
          const e = _o(t);
          let n = "0x";
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            n += Yo[(240 & r) >> 4] + Yo[15 & r];
          }
          return n;
        }
        function Xo(t) {
          return "0x" + t.map((t) => Zo(t).substring(2)).join("");
        }
        function ta(t) {
          return qo(t, !0) ? (t.length - 2) / 2 : _o(t).length;
        }
        function ea(t, e, n) {
          const r = _o(t);
          return (
            null != n &&
              n > r.length &&
              Ho(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
                buffer: r,
                length: r.length,
                offset: n,
              }),
            Zo(r.slice(null == e ? 0 : e, null == n ? r.length : n))
          );
        }
        function na(t, e, n) {
          const r = _o(t);
          Ho(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
            buffer: new Uint8Array(r),
            length: e,
            offset: e + 1,
          });
          const s = new Uint8Array(e);
          return s.fill(0), n ? s.set(r, e - r.length) : s.set(r, 0), Zo(s);
        }
        function ra(t, e) {
          return na(t, e, !0);
        }
        const sa = BigInt(0),
          ia = BigInt(1),
          oa = 9007199254740991;
        function aa(t, e) {
          const n = da(t, "value"),
            r = BigInt(pa(e, "width"));
          if (
            (Ho(n >> r === sa, "overflow", "NUMERIC_FAULT", {
              operation: "fromTwos",
              fault: "overflow",
              value: t,
            }),
            n >> (r - ia))
          ) {
            return -((~n & ((ia << r) - ia)) + ia);
          }
          return n;
        }
        function la(t, e) {
          let n = ua(t, "value");
          const r = BigInt(pa(e, "width")),
            s = ia << (r - ia);
          if (n < sa) {
            (n = -n),
              Ho(n <= s, "too low", "NUMERIC_FAULT", {
                operation: "toTwos",
                fault: "overflow",
                value: t,
              });
            return (~n & ((ia << r) - ia)) + ia;
          }
          return (
            Ho(n < s, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: t,
            }),
            n
          );
        }
        function ca(t, e) {
          const n = da(t, "value"),
            r = BigInt(pa(e, "bits"));
          return n & ((ia << r) - ia);
        }
        function ua(t, e) {
          switch (typeof t) {
            case "bigint":
              return t;
            case "number":
              return (
                Go(Number.isInteger(t), "underflow", e || "value", t),
                Go(t >= -oa && t <= oa, "overflow", e || "value", t),
                BigInt(t)
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return "-" === t[0] && "-" !== t[1]
                  ? -BigInt(t.substring(1))
                  : BigInt(t);
              } catch (n) {
                Go(
                  !1,
                  `invalid BigNumberish string: ${n.message}`,
                  e || "value",
                  t
                );
              }
          }
          Go(!1, "invalid BigNumberish value", e || "value", t);
        }
        function da(t, e) {
          const n = ua(t, e);
          return (
            Ho(n >= sa, "unsigned value cannot be negative", "NUMERIC_FAULT", {
              fault: "overflow",
              operation: "getUint",
              value: t,
            }),
            n
          );
        }
        const ha = "0123456789abcdef";
        function fa(t) {
          if (t instanceof Uint8Array) {
            let e = "0x0";
            for (const n of t) (e += ha[n >> 4]), (e += ha[15 & n]);
            return BigInt(e);
          }
          return ua(t);
        }
        function pa(t, e) {
          switch (typeof t) {
            case "bigint":
              return (
                Go(t >= -oa && t <= oa, "overflow", e || "value", t), Number(t)
              );
            case "number":
              return (
                Go(Number.isInteger(t), "underflow", e || "value", t),
                Go(t >= -oa && t <= oa, "overflow", e || "value", t),
                t
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return pa(BigInt(t), e);
              } catch (n) {
                Go(!1, `invalid numeric string: ${n.message}`, e || "value", t);
              }
          }
          Go(!1, "invalid numeric value", e || "value", t);
        }
        function ga(t, e) {
          let n = da(t, "value").toString(16);
          if (null == e) n.length % 2 && (n = "0" + n);
          else {
            const r = pa(e, "width");
            for (
              Ho(
                2 * r >= n.length,
                `value exceeds width (${r} bits)`,
                "NUMERIC_FAULT",
                { operation: "toBeHex", fault: "overflow", value: t }
              );
              n.length < 2 * r;

            )
              n = "0" + n;
          }
          return "0x" + n;
        }
        function ma(t) {
          const e = da(t, "value");
          if (e === sa) return new Uint8Array([]);
          let n = e.toString(16);
          n.length % 2 && (n = "0" + n);
          const r = new Uint8Array(n.length / 2);
          for (let t = 0; t < r.length; t++) {
            const e = 2 * t;
            r[t] = parseInt(n.substring(e, e + 2), 16);
          }
          return r;
        }
        function ya(t) {
          let e = Zo(
            (function (t) {
              return qo(t, !0) || t instanceof Uint8Array;
            })(t)
              ? t
              : ma(t)
          ).substring(2);
          for (; e.startsWith("0"); ) e = e.substring(1);
          return "" === e && (e = "0"), "0x" + e;
        }
        BigInt(0);
        const ba = BigInt(58);
        class wa {
          filter;
          emitter;
          #t;
          constructor(t, e, n) {
            (this.#t = e), Fo(this, { emitter: t, filter: n });
          }
          async removeListener() {
            null != this.#t && (await this.emitter.off(this.filter, this.#t));
          }
        }
        function va(t, e, n, r, s) {
          if ("BAD_PREFIX" === t || "UNEXPECTED_CONTINUE" === t) {
            let t = 0;
            for (let r = e + 1; r < n.length && n[r] >> 6 == 2; r++) t++;
            return t;
          }
          return "OVERRUN" === t ? n.length - e - 1 : 0;
        }
        const Aa = Object.freeze({
          error: function (t, e, n, r, s) {
            Go(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
          },
          ignore: va,
          replace: function (t, e, n, r, s) {
            return "OVERLONG" === t
              ? (Go(
                  "number" == typeof s,
                  "invalid bad code point for replacement",
                  "badCodepoint",
                  s
                ),
                r.push(s),
                0)
              : (r.push(65533), va(t, e, n));
          },
        });
        function $a(t, e) {
          null != e &&
            (!(function (t) {
              Ho(
                Wo.indexOf(t) >= 0,
                "platform missing String.prototype.normalize",
                "UNSUPPORTED_OPERATION",
                { operation: "String.prototype.normalize", info: { form: t } }
              );
            })(e),
            (t = t.normalize(e)));
          let n = [];
          for (let e = 0; e < t.length; e++) {
            const r = t.charCodeAt(e);
            if (r < 128) n.push(r);
            else if (r < 2048) n.push((r >> 6) | 192), n.push((63 & r) | 128);
            else if (55296 == (64512 & r)) {
              e++;
              const s = t.charCodeAt(e);
              Go(
                e < t.length && 56320 == (64512 & s),
                "invalid surrogate pair",
                "str",
                t
              );
              const i = 65536 + ((1023 & r) << 10) + (1023 & s);
              n.push((i >> 18) | 240),
                n.push(((i >> 12) & 63) | 128),
                n.push(((i >> 6) & 63) | 128),
                n.push((63 & i) | 128);
            } else
              n.push((r >> 12) | 224),
                n.push(((r >> 6) & 63) | 128),
                n.push((63 & r) | 128);
          }
          return new Uint8Array(n);
        }
        function xa(t, e) {
          return (
            (n = (function (t, e) {
              null == e && (e = Aa.error);
              const n = _o(t, "bytes"),
                r = [];
              let s = 0;
              for (; s < n.length; ) {
                const t = n[s++];
                if (t >> 7 == 0) {
                  r.push(t);
                  continue;
                }
                let i = null,
                  o = null;
                if (192 == (224 & t)) (i = 1), (o = 127);
                else if (224 == (240 & t)) (i = 2), (o = 2047);
                else {
                  if (240 != (248 & t)) {
                    s += e(
                      128 == (192 & t) ? "UNEXPECTED_CONTINUE" : "BAD_PREFIX",
                      s - 1,
                      n,
                      r
                    );
                    continue;
                  }
                  (i = 3), (o = 65535);
                }
                if (s - 1 + i >= n.length) {
                  s += e("OVERRUN", s - 1, n, r);
                  continue;
                }
                let a = t & ((1 << (8 - i - 1)) - 1);
                for (let t = 0; t < i; t++) {
                  let t = n[s];
                  if (128 != (192 & t)) {
                    (s += e("MISSING_CONTINUE", s, n, r)), (a = null);
                    break;
                  }
                  (a = (a << 6) | (63 & t)), s++;
                }
                null !== a &&
                  (a > 1114111
                    ? (s += e("OUT_OF_RANGE", s - 1 - i, n, r, a))
                    : a >= 55296 && a <= 57343
                    ? (s += e("UTF16_SURROGATE", s - 1 - i, n, r, a))
                    : a <= o
                    ? (s += e("OVERLONG", s - 1 - i, n, r, a))
                    : r.push(a));
              }
              return r;
            })(t, e)),
            n
              .map((t) =>
                t <= 65535
                  ? String.fromCharCode(t)
                  : ((t -= 65536),
                    String.fromCharCode(
                      55296 + ((t >> 10) & 1023),
                      56320 + (1023 & t)
                    ))
              )
              .join("")
          );
          var n;
        }
        let ka = async function (t, e) {
          const n = t.url.split(":")[0].toLowerCase();
          let r;
          if (
            (Ho(
              "http" === n || "https" === n,
              `unsupported protocol ${n}`,
              "UNSUPPORTED_OPERATION",
              { info: { protocol: n }, operation: "request" }
            ),
            Ho(
              "https" === n || !t.credentials || t.allowInsecureAuthentication,
              "insecure authorized connections unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "request" }
            ),
            e)
          ) {
            const t = new AbortController();
            (r = t.signal),
              e.addListener(() => {
                t.abort();
              });
          }
          const s = {
              method: t.method,
              headers: new Headers(Array.from(t)),
              body: t.body || void 0,
              signal: r,
            },
            i = await fetch(t.url, s),
            o = {};
          i.headers.forEach((t, e) => {
            o[e.toLowerCase()] = t;
          });
          const a = await i.arrayBuffer(),
            l = null == a ? null : new Uint8Array(a);
          return {
            statusCode: i.status,
            statusMessage: i.statusText,
            headers: o,
            body: l,
          };
        };
        const Ea = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
          Ca = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
        let Sa = !1;
        async function Pa(t, e) {
          try {
            const e = t.match(Ea);
            if (!e) throw new Error("invalid data");
            return new La(
              200,
              "OK",
              { "content-type": e[1] || "text/plain" },
              e[2]
                ? (function (t) {
                    t = atob(t);
                    const e = new Uint8Array(t.length);
                    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
                    return _o(e);
                  })(e[3])
                : $a(
                    e[3].replace(/%([0-9a-f][0-9a-f])/gi, (t, e) =>
                      String.fromCharCode(parseInt(e, 16))
                    )
                  )
            );
          } catch (e) {
            return new La(
              599,
              "BAD REQUEST (invalid data: URI)",
              {},
              null,
              new Ra(t)
            );
          }
        }
        function Ia(t) {
          return async function (e, n) {
            try {
              const n = e.match(Ca);
              if (!n) throw new Error("invalid link");
              return new Ra(`${t}${n[2]}`);
            } catch (t) {
              return new La(
                599,
                "BAD REQUEST (invalid IPFS URI)",
                {},
                null,
                new Ra(e)
              );
            }
          };
        }
        const Na = { data: Pa, ipfs: Ia("https://gateway.ipfs.io/ipfs/") },
          Ba = new WeakMap();
        class Ta {
          #e;
          #n;
          constructor(t) {
            (this.#e = []),
              (this.#n = !1),
              Ba.set(t, () => {
                if (!this.#n) {
                  this.#n = !0;
                  for (const t of this.#e)
                    setTimeout(() => {
                      t();
                    }, 0);
                  this.#e = [];
                }
              });
          }
          addListener(t) {
            Ho(!this.#n, "singal already cancelled", "UNSUPPORTED_OPERATION", {
              operation: "fetchCancelSignal.addCancelListener",
            }),
              this.#e.push(t);
          }
          get cancelled() {
            return this.#n;
          }
          checkSignal() {
            Ho(!this.cancelled, "cancelled", "CANCELLED", {});
          }
        }
        function Oa(t) {
          if (null == t) throw new Error("missing signal; should not happen");
          return t.checkSignal(), t;
        }
        class Ra {
          #r;
          #s;
          #i;
          #o;
          #a;
          #l;
          #c;
          #u;
          #d;
          #h;
          #f;
          #p;
          #g;
          #m;
          get url() {
            return this.#l;
          }
          set url(t) {
            this.#l = String(t);
          }
          get body() {
            return null == this.#c ? null : new Uint8Array(this.#c);
          }
          set body(t) {
            if (null == t) (this.#c = void 0), (this.#u = void 0);
            else if ("string" == typeof t)
              (this.#c = $a(t)), (this.#u = "text/plain");
            else if (t instanceof Uint8Array)
              (this.#c = t), (this.#u = "application/octet-stream");
            else {
              if ("object" != typeof t) throw new Error("invalid body");
              (this.#c = $a(JSON.stringify(t))), (this.#u = "application/json");
            }
          }
          hasBody() {
            return null != this.#c;
          }
          get method() {
            return this.#o ? this.#o : this.hasBody() ? "POST" : "GET";
          }
          set method(t) {
            null == t && (t = ""), (this.#o = String(t).toUpperCase());
          }
          get headers() {
            const t = Object.assign({}, this.#i);
            return (
              this.#d &&
                (t.authorization = `Basic ${(function (t) {
                  const e = _o(t);
                  let n = "";
                  for (let t = 0; t < e.length; t++)
                    n += String.fromCharCode(e[t]);
                  return btoa(n);
                })($a(this.#d))}`),
              this.allowGzip && (t["accept-encoding"] = "gzip"),
              null == t["content-type"] &&
                this.#u &&
                (t["content-type"] = this.#u),
              this.body && (t["content-length"] = String(this.body.length)),
              t
            );
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          setHeader(t, e) {
            this.#i[String(t).toLowerCase()] = String(e);
          }
          clearHeaders() {
            this.#i = {};
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          get credentials() {
            return this.#d || null;
          }
          setCredentials(t, e) {
            Go(
              !t.match(/:/),
              "invalid basic authentication username",
              "username",
              "[REDACTED]"
            ),
              (this.#d = `${t}:${e}`);
          }
          get allowGzip() {
            return this.#s;
          }
          set allowGzip(t) {
            this.#s = !!t;
          }
          get allowInsecureAuthentication() {
            return !!this.#r;
          }
          set allowInsecureAuthentication(t) {
            this.#r = !!t;
          }
          get timeout() {
            return this.#a;
          }
          set timeout(t) {
            Go(t >= 0, "timeout must be non-zero", "timeout", t), (this.#a = t);
          }
          get preflightFunc() {
            return this.#h || null;
          }
          set preflightFunc(t) {
            this.#h = t;
          }
          get processFunc() {
            return this.#f || null;
          }
          set processFunc(t) {
            this.#f = t;
          }
          get retryFunc() {
            return this.#p || null;
          }
          set retryFunc(t) {
            this.#p = t;
          }
          constructor(t) {
            (this.#l = String(t)),
              (this.#r = !1),
              (this.#s = !0),
              (this.#i = {}),
              (this.#o = ""),
              (this.#a = 3e5),
              (this.#m = { slotInterval: 250, maxAttempts: 12 });
          }
          toString() {
            return `<FetchRequest method=${JSON.stringify(
              this.method
            )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
              this.headers
            )} body=${this.#c ? Zo(this.#c) : "null"}>`;
          }
          setThrottleParams(t) {
            null != t.slotInterval && (this.#m.slotInterval = t.slotInterval),
              null != t.maxAttempts && (this.#m.maxAttempts = t.maxAttempts);
          }
          async #y(t, e, n, r, s) {
            if (t >= this.#m.maxAttempts)
              return s.makeServerError("exceeded maximum retry limit");
            Ho(za() <= e, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: r,
            }),
              n > 0 &&
                (await (function (t) {
                  return new Promise((e) => setTimeout(e, t));
                })(n));
            let i = this.clone();
            const o = (i.url.split(":")[0] || "").toLowerCase();
            if (o in Na) {
              const t = await Na[o](i.url, Oa(r.#g));
              if (t instanceof La) {
                let e = t;
                if (this.processFunc) {
                  Oa(r.#g);
                  try {
                    e = await this.processFunc(i, e);
                  } catch (t) {
                    (null != t.throttle && "number" == typeof t.stall) ||
                      e
                        .makeServerError("error in post-processing function", t)
                        .assertOk();
                  }
                }
                return e;
              }
              i = t;
            }
            this.preflightFunc && (i = await this.preflightFunc(i));
            const a = await ka(i, Oa(r.#g));
            let l = new La(a.statusCode, a.statusMessage, a.headers, a.body, r);
            if (301 === l.statusCode || 302 === l.statusCode) {
              try {
                const n = l.headers.location || "";
                return i.redirect(n).#y(t + 1, e, 0, r, l);
              } catch (t) {}
              return l;
            }
            if (
              429 === l.statusCode &&
              (null == this.retryFunc || (await this.retryFunc(i, l, t)))
            ) {
              const n = l.headers["retry-after"];
              let s =
                this.#m.slotInterval *
                Math.trunc(Math.random() * Math.pow(2, t));
              return (
                "string" == typeof n &&
                  n.match(/^[1-9][0-9]*$/) &&
                  (s = parseInt(n)),
                i.clone().#y(t + 1, e, s, r, l)
              );
            }
            if (this.processFunc) {
              Oa(r.#g);
              try {
                l = await this.processFunc(i, l);
              } catch (n) {
                (null != n.throttle && "number" == typeof n.stall) ||
                  l
                    .makeServerError("error in post-processing function", n)
                    .assertOk();
                let s =
                  this.#m.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, t));
                return (
                  n.stall >= 0 && (s = n.stall), i.clone().#y(t + 1, e, s, r, l)
                );
              }
            }
            return l;
          }
          send() {
            return (
              Ho(
                null == this.#g,
                "request already sent",
                "UNSUPPORTED_OPERATION",
                { operation: "fetchRequest.send" }
              ),
              (this.#g = new Ta(this)),
              this.#y(
                0,
                za() + this.timeout,
                0,
                this,
                new La(0, "", {}, null, this)
              )
            );
          }
          cancel() {
            Ho(
              null != this.#g,
              "request has not been sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.cancel" }
            );
            const t = Ba.get(this);
            if (!t) throw new Error("missing signal; should not happen");
            t();
          }
          redirect(t) {
            const e = this.url.split(":")[0].toLowerCase(),
              n = t.split(":")[0].toLowerCase();
            Ho(
              "GET" === this.method &&
                ("https" !== e || "http" !== n) &&
                t.match(/^https?:/),
              "unsupported redirect",
              "UNSUPPORTED_OPERATION",
              {
                operation: `redirect(${this.method} ${JSON.stringify(
                  this.url
                )} => ${JSON.stringify(t)})`,
              }
            );
            const r = new Ra(t);
            return (
              (r.method = "GET"),
              (r.allowGzip = this.allowGzip),
              (r.timeout = this.timeout),
              (r.#i = Object.assign({}, this.#i)),
              this.#c && (r.#c = new Uint8Array(this.#c)),
              (r.#u = this.#u),
              r
            );
          }
          clone() {
            const t = new Ra(this.url);
            return (
              (t.#o = this.#o),
              this.#c && (t.#c = this.#c),
              (t.#u = this.#u),
              (t.#i = Object.assign({}, this.#i)),
              (t.#d = this.#d),
              this.allowGzip && (t.allowGzip = !0),
              (t.timeout = this.timeout),
              this.allowInsecureAuthentication &&
                (t.allowInsecureAuthentication = !0),
              (t.#h = this.#h),
              (t.#f = this.#f),
              (t.#p = this.#p),
              t
            );
          }
          static lockConfig() {
            Sa = !0;
          }
          static getGateway(t) {
            return Na[t.toLowerCase()] || null;
          }
          static registerGateway(t, e) {
            if ("http" === (t = t.toLowerCase()) || "https" === t)
              throw new Error(`cannot intercept ${t}; use registerGetUrl`);
            if (Sa) throw new Error("gateways locked");
            Na[t] = e;
          }
          static registerGetUrl(t) {
            if (Sa) throw new Error("gateways locked");
            ka = t;
          }
          static createDataGateway() {
            return Pa;
          }
          static createIpfsGatewayFunc(t) {
            return Ia(t);
          }
        }
        class La {
          #b;
          #w;
          #i;
          #c;
          #v;
          #A;
          toString() {
            return `<FetchResponse status=${this.statusCode} body=${
              this.#c ? Zo(this.#c) : "null"
            }>`;
          }
          get statusCode() {
            return this.#b;
          }
          get statusMessage() {
            return this.#w;
          }
          get headers() {
            return Object.assign({}, this.#i);
          }
          get body() {
            return null == this.#c ? null : new Uint8Array(this.#c);
          }
          get bodyText() {
            try {
              return null == this.#c ? "" : xa(this.#c);
            } catch (t) {
              Ho(
                !1,
                "response body is not valid UTF-8 data",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyText", info: { response: this } }
              );
            }
          }
          get bodyJson() {
            try {
              return JSON.parse(this.bodyText);
            } catch (t) {
              Ho(
                !1,
                "response body is not valid JSON",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyJson", info: { response: this } }
              );
            }
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          constructor(t, e, n, r, s) {
            (this.#b = t),
              (this.#w = e),
              (this.#i = Object.keys(n).reduce(
                (t, e) => ((t[e.toLowerCase()] = String(n[e])), t),
                {}
              )),
              (this.#c = null == r ? null : new Uint8Array(r)),
              (this.#v = s || null),
              (this.#A = { message: "" });
          }
          makeServerError(t, e) {
            let n;
            n = t
              ? `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})`
              : `CLIENT ESCALATED SERVER ERROR (${(t = `${this.statusCode} ${this.statusMessage}`)})`;
            const r = new La(
              599,
              n,
              this.headers,
              this.body,
              this.#v || void 0
            );
            return (r.#A = { message: t, error: e }), r;
          }
          throwThrottleError(t, e) {
            null == e
              ? (e = -1)
              : Go(
                  Number.isInteger(e) && e >= 0,
                  "invalid stall timeout",
                  "stall",
                  e
                );
            const n = new Error(t || "throttling requests");
            throw (Fo(n, { stall: e, throttle: !0 }), n);
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          hasBody() {
            return null != this.#c;
          }
          get request() {
            return this.#v;
          }
          ok() {
            return (
              "" === this.#A.message &&
              this.statusCode >= 200 &&
              this.statusCode < 300
            );
          }
          assertOk() {
            if (this.ok()) return;
            let { message: t, error: e } = this.#A;
            "" === t &&
              (t = `server response ${this.statusCode} ${this.statusMessage}`),
              Ho(!1, t, "SERVER_ERROR", {
                request: this.request || "unknown request",
                response: this,
                error: e,
              });
          }
        }
        function za() {
          return new Date().getTime();
        }
        const Fa = BigInt(-1),
          Ua = BigInt(0),
          Da = BigInt(1),
          Ma = BigInt(5),
          ja = {};
        let Ha = "0000";
        for (; Ha.length < 80; ) Ha += Ha;
        function Ga(t) {
          let e = Ha;
          for (; e.length < t; ) e += e;
          return BigInt("1" + e.substring(0, t));
        }
        function Va(t, e, n) {
          const r = BigInt(e.width);
          if (e.signed) {
            const e = Da << (r - Da);
            Ho(null == n || (t >= -e && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = t > Ua ? aa(ca(t, r), r) : -aa(ca(-t, r), r));
          } else {
            const e = Da << r;
            Ho(null == n || (t >= 0 && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = ((t % e) + e) % e & (e - Da));
          }
          return t;
        }
        function Wa(t) {
          "number" == typeof t && (t = `fixed128x${t}`);
          let e = !0,
            n = 128,
            r = 18;
          if ("string" == typeof t)
            if ("fixed" === t);
            else if ("ufixed" === t) e = !1;
            else {
              const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              Go(s, "invalid fixed format", "format", t),
                (e = "u" !== s[1]),
                (n = parseInt(s[2])),
                (r = parseInt(s[3]));
            }
          else if (t) {
            const s = t,
              i = (t, e, n) =>
                null == s[t]
                  ? n
                  : (Go(
                      typeof s[t] === e,
                      "invalid fixed format (" + t + " not " + e + ")",
                      "format." + t,
                      s[t]
                    ),
                    s[t]);
            (e = i("signed", "boolean", e)),
              (n = i("width", "number", n)),
              (r = i("decimals", "number", r));
          }
          Go(
            n % 8 == 0,
            "invalid FixedNumber width (not byte aligned)",
            "format.width",
            n
          ),
            Go(
              r <= 80,
              "invalid FixedNumber decimals (too large)",
              "format.decimals",
              r
            );
          return {
            signed: e,
            width: n,
            decimals: r,
            name: (e ? "" : "u") + "fixed" + String(n) + "x" + String(r),
          };
        }
        class Qa {
          format;
          #$;
          #x;
          #k;
          _value;
          constructor(t, e, n) {
            Qo(t, ja, "FixedNumber"), (this.#x = e), (this.#$ = n);
            const r = (function (t, e) {
              let n = "";
              t < Ua && ((n = "-"), (t *= Fa));
              let r = t.toString();
              if (0 === e) return n + r;
              for (; r.length <= e; ) r = Ha + r;
              const s = r.length - e;
              for (
                r = r.substring(0, s) + "." + r.substring(s);
                "0" === r[0] && "." !== r[1];

              )
                r = r.substring(1);
              for (; "0" === r[r.length - 1] && "." !== r[r.length - 2]; )
                r = r.substring(0, r.length - 1);
              return n + r;
            })(e, n.decimals);
            Fo(this, { format: n.name, _value: r }), (this.#k = Ga(n.decimals));
          }
          get signed() {
            return this.#$.signed;
          }
          get width() {
            return this.#$.width;
          }
          get decimals() {
            return this.#$.decimals;
          }
          get value() {
            return this.#x;
          }
          #E(t) {
            Go(
              this.format === t.format,
              "incompatible format; use fixedNumber.toFormat",
              "other",
              t
            );
          }
          #C(t, e) {
            return (t = Va(t, this.#$, e)), new Qa(ja, t, this.#$);
          }
          #S(t, e) {
            return this.#E(t), this.#C(this.#x + t.#x, e);
          }
          addUnsafe(t) {
            return this.#S(t);
          }
          add(t) {
            return this.#S(t, "add");
          }
          #P(t, e) {
            return this.#E(t), this.#C(this.#x - t.#x, e);
          }
          subUnsafe(t) {
            return this.#P(t);
          }
          sub(t) {
            return this.#P(t, "sub");
          }
          #I(t, e) {
            return this.#E(t), this.#C((this.#x * t.#x) / this.#k, e);
          }
          mulUnsafe(t) {
            return this.#I(t);
          }
          mul(t) {
            return this.#I(t, "mul");
          }
          mulSignal(t) {
            this.#E(t);
            const e = this.#x * t.#x;
            return (
              Ho(
                e % this.#k === Ua,
                "precision lost during signalling mul",
                "NUMERIC_FAULT",
                { operation: "mulSignal", fault: "underflow", value: this }
              ),
              this.#C(e / this.#k, "mulSignal")
            );
          }
          #N(t, e) {
            return (
              Ho(t.#x !== Ua, "division by zero", "NUMERIC_FAULT", {
                operation: "div",
                fault: "divide-by-zero",
                value: this,
              }),
              this.#E(t),
              this.#C((this.#x * this.#k) / t.#x, e)
            );
          }
          divUnsafe(t) {
            return this.#N(t);
          }
          div(t) {
            return this.#N(t, "div");
          }
          divSignal(t) {
            Ho(t.#x !== Ua, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            }),
              this.#E(t);
            const e = this.#x * this.#k;
            return (
              Ho(
                e % t.#x === Ua,
                "precision lost during signalling div",
                "NUMERIC_FAULT",
                { operation: "divSignal", fault: "underflow", value: this }
              ),
              this.#C(e / t.#x, "divSignal")
            );
          }
          cmp(t) {
            let e = this.value,
              n = t.value;
            const r = this.decimals - t.decimals;
            return (
              r > 0 ? (n *= Ga(r)) : r < 0 && (e *= Ga(-r)),
              e < n ? -1 : e > n ? 1 : 0
            );
          }
          eq(t) {
            return 0 === this.cmp(t);
          }
          lt(t) {
            return this.cmp(t) < 0;
          }
          lte(t) {
            return this.cmp(t) <= 0;
          }
          gt(t) {
            return this.cmp(t) > 0;
          }
          gte(t) {
            return this.cmp(t) >= 0;
          }
          floor() {
            let t = this.#x;
            return (
              this.#x < Ua && (t -= this.#k - Da),
              (t = (this.#x / this.#k) * this.#k),
              this.#C(t, "floor")
            );
          }
          ceiling() {
            let t = this.#x;
            return (
              this.#x > Ua && (t += this.#k - Da),
              (t = (this.#x / this.#k) * this.#k),
              this.#C(t, "ceiling")
            );
          }
          round(t) {
            if ((null == t && (t = 0), t >= this.decimals)) return this;
            const e = this.decimals - t,
              n = Ma * Ga(e - 1);
            let r = this.value + n;
            const s = Ga(e);
            return (
              (r = (r / s) * s), Va(r, this.#$, "round"), new Qa(ja, r, this.#$)
            );
          }
          isZero() {
            return this.#x === Ua;
          }
          isNegative() {
            return this.#x < Ua;
          }
          toString() {
            return this._value;
          }
          toUnsafeFloat() {
            return parseFloat(this.toString());
          }
          toFormat(t) {
            return Qa.fromString(this.toString(), t);
          }
          static fromValue(t, e, n) {
            const r = null == e ? 0 : pa(e),
              s = Wa(n);
            let i = ua(t, "value");
            const o = r - s.decimals;
            if (o > 0) {
              const e = Ga(o);
              Ho(
                i % e === Ua,
                "value loses precision for format",
                "NUMERIC_FAULT",
                { operation: "fromValue", fault: "underflow", value: t }
              ),
                (i /= e);
            } else o < 0 && (i *= Ga(-o));
            return Va(i, s, "fromValue"), new Qa(ja, i, s);
          }
          static fromString(t, e) {
            const n = t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            Go(
              n && n[2].length + n[3].length > 0,
              "invalid FixedNumber string value",
              "value",
              t
            );
            const r = Wa(e);
            let s = n[2] || "0",
              i = n[3] || "";
            for (; i.length < r.decimals; ) i += Ha;
            Ho(
              i.substring(r.decimals).match(/^0*$/),
              "too many decimals for format",
              "NUMERIC_FAULT",
              { operation: "fromString", fault: "underflow", value: t }
            ),
              (i = i.substring(0, r.decimals));
            const o = BigInt(n[1] + s + i);
            return Va(o, r, "fromString"), new Qa(ja, o, r);
          }
          static fromBytes(t, e) {
            let n = fa(_o(t, "value"));
            const r = Wa(e);
            return (
              r.signed && (n = aa(n, r.width)),
              Va(n, r, "fromBytes"),
              new Qa(ja, n, r)
            );
          }
        }
        function Ja(t) {
          let e = t.toString(16);
          for (; e.length < 2; ) e = "0" + e;
          return "0x" + e;
        }
        function _a(t, e, n) {
          let r = 0;
          for (let s = 0; s < n; s++) r = 256 * r + t[e + s];
          return r;
        }
        function Ka(t, e, n, r) {
          const s = [];
          for (; n < e + 1 + r; ) {
            const i = qa(t, n);
            s.push(i.result),
              Ho(
                (n += i.consumed) <= e + 1 + r,
                "child data too short",
                "BUFFER_OVERRUN",
                { buffer: t, length: r, offset: e }
              );
          }
          return { consumed: 1 + r, result: s };
        }
        function qa(t, e) {
          Ho(0 !== t.length, "data too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: 0,
            offset: 1,
          });
          const n = (e) => {
            Ho(
              e <= t.length,
              "data short segment too short",
              "BUFFER_OVERRUN",
              { buffer: t, length: t.length, offset: e }
            );
          };
          if (t[e] >= 248) {
            const r = t[e] - 247;
            n(e + 1 + r);
            const s = _a(t, e + 1, r);
            return n(e + 1 + r + s), Ka(t, e, e + 1 + r, r + s);
          }
          if (t[e] >= 192) {
            const r = t[e] - 192;
            return n(e + 1 + r), Ka(t, e, e + 1, r);
          }
          if (t[e] >= 184) {
            const r = t[e] - 183;
            n(e + 1 + r);
            const s = _a(t, e + 1, r);
            n(e + 1 + r + s);
            return {
              consumed: 1 + r + s,
              result: Zo(t.slice(e + 1 + r, e + 1 + r + s)),
            };
          }
          if (t[e] >= 128) {
            const r = t[e] - 128;
            n(e + 1 + r);
            return { consumed: 1 + r, result: Zo(t.slice(e + 1, e + 1 + r)) };
          }
          return { consumed: 1, result: Ja(t[e]) };
        }
        function Ya(t) {
          const e = _o(t, "data"),
            n = qa(e, 0);
          return (
            Go(
              n.consumed === e.length,
              "unexpected junk after rlp payload",
              "data",
              t
            ),
            n.result
          );
        }
        function Za(t) {
          const e = [];
          for (; t; ) e.unshift(255 & t), (t >>= 8);
          return e;
        }
        function Xa(t) {
          if (Array.isArray(t)) {
            let e = [];
            if (
              (t.forEach(function (t) {
                e = e.concat(Xa(t));
              }),
              e.length <= 55)
            )
              return e.unshift(192 + e.length), e;
            const n = Za(e.length);
            return n.unshift(247 + n.length), n.concat(e);
          }
          const e = Array.prototype.slice.call(_o(t, "object"));
          if (1 === e.length && e[0] <= 127) return e;
          if (e.length <= 55) return e.unshift(128 + e.length), e;
          const n = Za(e.length);
          return n.unshift(183 + n.length), n.concat(e);
        }
        const tl = "0123456789abcdef";
        function el(t) {
          let e = "0x";
          for (const n of Xa(t)) (e += tl[n >> 4]), (e += tl[15 & n]);
          return e;
        }
        const nl = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
        function rl(t) {
          return (function (t, e) {
            let n = 18;
            if ("string" == typeof e) {
              const t = nl.indexOf(e);
              Go(t >= 0, "invalid unit", "unit", e), (n = 3 * t);
            } else null != e && (n = pa(e, "unit"));
            return Qa.fromValue(t, n, { decimals: n, width: 512 }).toString();
          })(t, 18);
        }
        function sl(t) {
          return (function (t, e) {
            Go("string" == typeof t, "value must be a string", "value", t);
            let n = 18;
            if ("string" == typeof e) {
              const t = nl.indexOf(e);
              Go(t >= 0, "invalid unit", "unit", e), (n = 3 * t);
            } else null != e && (n = pa(e, "unit"));
            return Qa.fromString(t, { decimals: n, width: 512 }).value;
          })(t, 18);
        }
        const il = 32,
          ol = new Uint8Array(il),
          al = ["then"],
          ll = {};
        function cl(t, e) {
          const n = new Error(
            `deferred error during ABI decoding triggered accessing ${t}`
          );
          throw ((n.error = e), n);
        }
        class ul extends Array {
          #B;
          constructor(...t) {
            const e = t[0];
            let n = t[1],
              r = (t[2] || []).slice(),
              s = !0;
            e !== ll && ((n = t), (r = []), (s = !1)),
              super(n.length),
              n.forEach((t, e) => {
                this[e] = t;
              });
            const i = r.reduce(
              (t, e) => (
                "string" == typeof e && t.set(e, (t.get(e) || 0) + 1), t
              ),
              new Map()
            );
            if (
              ((this.#B = Object.freeze(
                n.map((t, e) => {
                  const n = r[e];
                  return null != n && 1 === i.get(n) ? n : null;
                })
              )),
              s)
            )
              return (
                Object.freeze(this),
                new Proxy(this, {
                  get: (t, e, n) => {
                    if ("string" == typeof e) {
                      if (e.match(/^[0-9]+$/)) {
                        const n = pa(e, "%index");
                        if (n < 0 || n >= this.length)
                          throw new RangeError("out of result range");
                        const r = t[n];
                        return r instanceof Error && cl(`index ${n}`, r), r;
                      }
                      if (al.indexOf(e) >= 0) return Reflect.get(t, e, n);
                      const r = t[e];
                      if (r instanceof Function)
                        return function (...e) {
                          return r.apply(this === n ? t : this, e);
                        };
                      if (!(e in t))
                        return t.getValue.apply(this === n ? t : this, [e]);
                    }
                    return Reflect.get(t, e, n);
                  },
                })
              );
          }
          toArray() {
            const t = [];
            return (
              this.forEach((e, n) => {
                e instanceof Error && cl(`index ${n}`, e), t.push(e);
              }),
              t
            );
          }
          toObject() {
            return this.#B.reduce(
              (t, e, n) => (
                Ho(
                  null != e,
                  "value at index ${ index } unnamed",
                  "UNSUPPORTED_OPERATION",
                  { operation: "toObject()" }
                ),
                e in t || (t[e] = this.getValue(e)),
                t
              ),
              {}
            );
          }
          slice(t, e) {
            null == t && (t = 0),
              t < 0 && (t += this.length) < 0 && (t = 0),
              null == e && (e = this.length),
              e < 0 && (e += this.length) < 0 && (e = 0),
              e > this.length && (e = this.length);
            const n = [],
              r = [];
            for (let s = t; s < e; s++) n.push(this[s]), r.push(this.#B[s]);
            return new ul(ll, n, r);
          }
          filter(t, e) {
            const n = [],
              r = [];
            for (let s = 0; s < this.length; s++) {
              const i = this[s];
              i instanceof Error && cl(`index ${s}`, i),
                t.call(e, i, s, this) && (n.push(i), r.push(this.#B[s]));
            }
            return new ul(ll, n, r);
          }
          map(t, e) {
            const n = [];
            for (let r = 0; r < this.length; r++) {
              const s = this[r];
              s instanceof Error && cl(`index ${r}`, s),
                n.push(t.call(e, s, r, this));
            }
            return n;
          }
          getValue(t) {
            const e = this.#B.indexOf(t);
            if (-1 === e) return;
            const n = this[e];
            return (
              n instanceof Error &&
                cl(`property ${JSON.stringify(t)}`, n.error),
              n
            );
          }
          static fromItems(t, e) {
            return new ul(ll, t, e);
          }
        }
        function dl(t) {
          let e = ma(t);
          return (
            Ho(e.length <= il, "value out-of-bounds", "BUFFER_OVERRUN", {
              buffer: e,
              length: il,
              offset: e.length,
            }),
            e.length !== il && (e = Ko(Xo([ol.slice(e.length % il), e]))),
            e
          );
        }
        class hl {
          name;
          type;
          localName;
          dynamic;
          constructor(t, e, n, r) {
            Fo(
              this,
              { name: t, type: e, localName: n, dynamic: r },
              {
                name: "string",
                type: "string",
                localName: "string",
                dynamic: "boolean",
              }
            );
          }
          _throwError(t, e) {
            Go(!1, t, this.localName, e);
          }
        }
        class fl {
          #T;
          #O;
          constructor() {
            (this.#T = []), (this.#O = 0);
          }
          get data() {
            return Xo(this.#T);
          }
          get length() {
            return this.#O;
          }
          #R(t) {
            return this.#T.push(t), (this.#O += t.length), t.length;
          }
          appendWriter(t) {
            return this.#R(Ko(t.data));
          }
          writeBytes(t) {
            let e = Ko(t);
            const n = e.length % il;
            return n && (e = Ko(Xo([e, ol.slice(n)]))), this.#R(e);
          }
          writeValue(t) {
            return this.#R(dl(t));
          }
          writeUpdatableValue() {
            const t = this.#T.length;
            return (
              this.#T.push(ol),
              (this.#O += il),
              (e) => {
                this.#T[t] = dl(e);
              }
            );
          }
        }
        class pl {
          allowLoose;
          #T;
          #L;
          constructor(t, e) {
            Fo(this, { allowLoose: !!e }), (this.#T = Ko(t)), (this.#L = 0);
          }
          get data() {
            return Zo(this.#T);
          }
          get dataLength() {
            return this.#T.length;
          }
          get consumed() {
            return this.#L;
          }
          get bytes() {
            return new Uint8Array(this.#T);
          }
          #z(t, e, n) {
            let r = Math.ceil(e / il) * il;
            return (
              this.#L + r > this.#T.length &&
                (this.allowLoose && n && this.#L + e <= this.#T.length
                  ? (r = e)
                  : Ho(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                      buffer: Ko(this.#T),
                      length: this.#T.length,
                      offset: this.#L + r,
                    })),
              this.#T.slice(this.#L, this.#L + r)
            );
          }
          subReader(t) {
            return new pl(this.#T.slice(this.#L + t), this.allowLoose);
          }
          readBytes(t, e) {
            let n = this.#z(0, t, !!e);
            return (this.#L += n.length), n.slice(0, t);
          }
          readValue() {
            return fa(this.readBytes(il));
          }
          readIndex() {
            return pa(fa(this.readBytes(il)));
          }
        }
        function gl(t) {
          if (!Number.isSafeInteger(t) || t < 0)
            throw new Error(`Wrong positive integer: ${t}`);
        }
        function ml(t, ...e) {
          if (!(t instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          if (e.length > 0 && !e.includes(t.length))
            throw new TypeError(
              `Expected Uint8Array of length ${e}, not of length=${t.length}`
            );
        }
        const yl = {
            number: gl,
            bool: function (t) {
              if ("boolean" != typeof t)
                throw new Error(`Expected boolean, not ${t}`);
            },
            bytes: ml,
            hash: function (t) {
              if ("function" != typeof t || "function" != typeof t.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              gl(t.outputLen), gl(t.blockLen);
            },
            exists: function (t, e = !0) {
              if (t.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (e && t.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (t, e) {
              ml(t);
              const n = e.outputLen;
              if (t.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          bl = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
          wl = (t, e) => (t << (32 - e)) | (t >>> e);
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ if (
          !(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])
        )
          throw new Error("Non little-endian hardware is not supported");
        function vl(t) {
          if (
            ("string" == typeof t &&
              (t = (function (t) {
                if ("string" != typeof t)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof t
                  );
                return new TextEncoder().encode(t);
              })(t)),
            !(t instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof t})`
            );
          return t;
        }
        Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
        class Al {
          clone() {
            return this._cloneInto();
          }
        }
        function $l(t) {
          const e = (e) => t().update(vl(e)).digest(),
            n = t();
          return (
            (e.outputLen = n.outputLen),
            (e.blockLen = n.blockLen),
            (e.create = () => t()),
            e
          );
        }
        class xl extends Al {
          constructor(t, e) {
            super(), (this.finished = !1), (this.destroyed = !1), yl.hash(t);
            const n = vl(e);
            if (((this.iHash = t.create()), !(this.iHash instanceof Al)))
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            const r = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const s = new Uint8Array(r);
            s.set(
              n.length > this.iHash.blockLen ? t.create().update(n).digest() : n
            );
            for (let t = 0; t < s.length; t++) s[t] ^= 54;
            this.iHash.update(s), (this.oHash = t.create());
            for (let t = 0; t < s.length; t++) s[t] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(t) {
            return yl.exists(this), this.iHash.update(t), this;
          }
          digestInto(t) {
            yl.exists(this),
              yl.bytes(t, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(t),
              this.oHash.update(t),
              this.oHash.digestInto(t),
              this.destroy();
          }
          digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t), t;
          }
          _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: e,
              iHash: n,
              finished: r,
              destroyed: s,
              blockLen: i,
              outputLen: o,
            } = this;
            return (
              (t.finished = r),
              (t.destroyed = s),
              (t.blockLen = i),
              (t.outputLen = o),
              (t.oHash = e._cloneInto(t.oHash)),
              (t.iHash = n._cloneInto(t.iHash)),
              t
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const kl = (t, e, n) => new xl(t, e).update(n).digest();
        kl.create = (t, e) => new xl(t, e);
        class El extends Al {
          constructor(t, e, n, r) {
            super(),
              (this.blockLen = t),
              (this.outputLen = e),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(t)),
              (this.view = bl(this.buffer));
          }
          update(t) {
            yl.exists(this);
            const { view: e, buffer: n, blockLen: r } = this,
              s = (t = vl(t)).length;
            for (let i = 0; i < s; ) {
              const o = Math.min(r - this.pos, s - i);
              if (o !== r)
                n.set(t.subarray(i, i + o), this.pos),
                  (this.pos += o),
                  (i += o),
                  this.pos === r && (this.process(e, 0), (this.pos = 0));
              else {
                const e = bl(t);
                for (; r <= s - i; i += r) this.process(e, i);
              }
            }
            return (this.length += t.length), this.roundClean(), this;
          }
          digestInto(t) {
            yl.exists(this), yl.output(t, this), (this.finished = !0);
            const { buffer: e, view: n, blockLen: r, isLE: s } = this;
            let { pos: i } = this;
            (e[i++] = 128),
              this.buffer.subarray(i).fill(0),
              this.padOffset > r - i && (this.process(n, 0), (i = 0));
            for (let t = i; t < r; t++) e[t] = 0;
            !(function (t, e, n, r) {
              if ("function" == typeof t.setBigUint64)
                return t.setBigUint64(e, n, r);
              const s = BigInt(32),
                i = BigInt(4294967295),
                o = Number((n >> s) & i),
                a = Number(n & i),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              t.setUint32(e + l, o, r), t.setUint32(e + c, a, r);
            })(n, r - 8, BigInt(8 * this.length), s),
              this.process(n, 0);
            const o = bl(t);
            this.get().forEach((t, e) => o.setUint32(4 * e, t, s));
          }
          digest() {
            const { buffer: t, outputLen: e } = this;
            this.digestInto(t);
            const n = t.slice(0, e);
            return this.destroy(), n;
          }
          _cloneInto(t) {
            t || (t = new this.constructor()), t.set(...this.get());
            const {
              blockLen: e,
              buffer: n,
              length: r,
              finished: s,
              destroyed: i,
              pos: o,
            } = this;
            return (
              (t.length = r),
              (t.pos = o),
              (t.finished = s),
              (t.destroyed = i),
              r % e && t.buffer.set(n),
              t
            );
          }
        }
        const Cl = (t, e, n) => (t & e) ^ (~t & n),
          Sl = (t, e, n) => (t & e) ^ (t & n) ^ (e & n),
          Pl = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          Il = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          Nl = new Uint32Array(64);
        class Bl extends El {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | Il[0]),
              (this.B = 0 | Il[1]),
              (this.C = 0 | Il[2]),
              (this.D = 0 | Il[3]),
              (this.E = 0 | Il[4]),
              (this.F = 0 | Il[5]),
              (this.G = 0 | Il[6]),
              (this.H = 0 | Il[7]);
          }
          get() {
            const { A: t, B: e, C: n, D: r, E: s, F: i, G: o, H: a } = this;
            return [t, e, n, r, s, i, o, a];
          }
          set(t, e, n, r, s, i, o, a) {
            (this.A = 0 | t),
              (this.B = 0 | e),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | s),
              (this.F = 0 | i),
              (this.G = 0 | o),
              (this.H = 0 | a);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4) Nl[n] = t.getUint32(e, !1);
            for (let t = 16; t < 64; t++) {
              const e = Nl[t - 15],
                n = Nl[t - 2],
                r = wl(e, 7) ^ wl(e, 18) ^ (e >>> 3),
                s = wl(n, 17) ^ wl(n, 19) ^ (n >>> 10);
              Nl[t] = (s + Nl[t - 7] + r + Nl[t - 16]) | 0;
            }
            let { A: n, B: r, C: s, D: i, E: o, F: a, G: l, H: c } = this;
            for (let t = 0; t < 64; t++) {
              const e =
                  (c +
                    (wl(o, 6) ^ wl(o, 11) ^ wl(o, 25)) +
                    Cl(o, a, l) +
                    Pl[t] +
                    Nl[t]) |
                  0,
                u = ((wl(n, 2) ^ wl(n, 13) ^ wl(n, 22)) + Sl(n, r, s)) | 0;
              (c = l),
                (l = a),
                (a = o),
                (o = (i + e) | 0),
                (i = s),
                (s = r),
                (r = n),
                (n = (e + u) | 0);
            }
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (s = (s + this.C) | 0),
              (i = (i + this.D) | 0),
              (o = (o + this.E) | 0),
              (a = (a + this.F) | 0),
              (l = (l + this.G) | 0),
              (c = (c + this.H) | 0),
              this.set(n, r, s, i, o, a, l, c);
          }
          roundClean() {
            Nl.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        const Tl = $l(() => new Bl()),
          Ol = BigInt(2 ** 32 - 1),
          Rl = BigInt(32);
        function Ll(t, e = !1) {
          return e
            ? { h: Number(t & Ol), l: Number((t >> Rl) & Ol) }
            : { h: 0 | Number((t >> Rl) & Ol), l: 0 | Number(t & Ol) };
        }
        const zl = {
            fromBig: Ll,
            split: function (t, e = !1) {
              let n = new Uint32Array(t.length),
                r = new Uint32Array(t.length);
              for (let s = 0; s < t.length; s++) {
                const { h: i, l: o } = Ll(t[s], e);
                [n[s], r[s]] = [i, o];
              }
              return [n, r];
            },
            toBig: (t, e) => (BigInt(t >>> 0) << Rl) | BigInt(e >>> 0),
            shrSH: (t, e, n) => t >>> n,
            shrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrSH: (t, e, n) => (t >>> n) | (e << (32 - n)),
            rotrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrBH: (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
            rotrBL: (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
            rotr32H: (t, e) => e,
            rotr32L: (t, e) => t,
            rotlSH: (t, e, n) => (t << n) | (e >>> (32 - n)),
            rotlSL: (t, e, n) => (e << n) | (t >>> (32 - n)),
            rotlBH: (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
            rotlBL: (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
            add: function (t, e, n, r) {
              const s = (e >>> 0) + (r >>> 0);
              return { h: (t + n + ((s / 2 ** 32) | 0)) | 0, l: 0 | s };
            },
            add3L: (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
            add3H: (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
            add4L: (t, e, n, r) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
            add4H: (t, e, n, r, s) => (e + n + r + s + ((t / 2 ** 32) | 0)) | 0,
            add5H: (t, e, n, r, s, i) =>
              (e + n + r + s + i + ((t / 2 ** 32) | 0)) | 0,
            add5L: (t, e, n, r, s) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0),
          },
          [Fl, Ul] = zl.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((t) => BigInt(t))
          ),
          Dl = new Uint32Array(80),
          Ml = new Uint32Array(80);
        class jl extends El {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: t,
              Al: e,
              Bh: n,
              Bl: r,
              Ch: s,
              Cl: i,
              Dh: o,
              Dl: a,
              Eh: l,
              El: c,
              Fh: u,
              Fl: d,
              Gh: h,
              Gl: f,
              Hh: p,
              Hl: g,
            } = this;
            return [t, e, n, r, s, i, o, a, l, c, u, d, h, f, p, g];
          }
          set(t, e, n, r, s, i, o, a, l, c, u, d, h, f, p, g) {
            (this.Ah = 0 | t),
              (this.Al = 0 | e),
              (this.Bh = 0 | n),
              (this.Bl = 0 | r),
              (this.Ch = 0 | s),
              (this.Cl = 0 | i),
              (this.Dh = 0 | o),
              (this.Dl = 0 | a),
              (this.Eh = 0 | l),
              (this.El = 0 | c),
              (this.Fh = 0 | u),
              (this.Fl = 0 | d),
              (this.Gh = 0 | h),
              (this.Gl = 0 | f),
              (this.Hh = 0 | p),
              (this.Hl = 0 | g);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4)
              (Dl[n] = t.getUint32(e)), (Ml[n] = t.getUint32((e += 4)));
            for (let t = 16; t < 80; t++) {
              const e = 0 | Dl[t - 15],
                n = 0 | Ml[t - 15],
                r = zl.rotrSH(e, n, 1) ^ zl.rotrSH(e, n, 8) ^ zl.shrSH(e, n, 7),
                s = zl.rotrSL(e, n, 1) ^ zl.rotrSL(e, n, 8) ^ zl.shrSL(e, n, 7),
                i = 0 | Dl[t - 2],
                o = 0 | Ml[t - 2],
                a =
                  zl.rotrSH(i, o, 19) ^ zl.rotrBH(i, o, 61) ^ zl.shrSH(i, o, 6),
                l =
                  zl.rotrSL(i, o, 19) ^ zl.rotrBL(i, o, 61) ^ zl.shrSL(i, o, 6),
                c = zl.add4L(s, l, Ml[t - 7], Ml[t - 16]),
                u = zl.add4H(c, r, a, Dl[t - 7], Dl[t - 16]);
              (Dl[t] = 0 | u), (Ml[t] = 0 | c);
            }
            let {
              Ah: n,
              Al: r,
              Bh: s,
              Bl: i,
              Ch: o,
              Cl: a,
              Dh: l,
              Dl: c,
              Eh: u,
              El: d,
              Fh: h,
              Fl: f,
              Gh: p,
              Gl: g,
              Hh: m,
              Hl: y,
            } = this;
            for (let t = 0; t < 80; t++) {
              const e =
                  zl.rotrSH(u, d, 14) ^
                  zl.rotrSH(u, d, 18) ^
                  zl.rotrBH(u, d, 41),
                b =
                  zl.rotrSL(u, d, 14) ^
                  zl.rotrSL(u, d, 18) ^
                  zl.rotrBL(u, d, 41),
                w = (u & h) ^ (~u & p),
                v = (d & f) ^ (~d & g),
                A = zl.add5L(y, b, v, Ul[t], Ml[t]),
                $ = zl.add5H(A, m, e, w, Fl[t], Dl[t]),
                x = 0 | A,
                k =
                  zl.rotrSH(n, r, 28) ^
                  zl.rotrBH(n, r, 34) ^
                  zl.rotrBH(n, r, 39),
                E =
                  zl.rotrSL(n, r, 28) ^
                  zl.rotrBL(n, r, 34) ^
                  zl.rotrBL(n, r, 39),
                C = (n & s) ^ (n & o) ^ (s & o),
                S = (r & i) ^ (r & a) ^ (i & a);
              (m = 0 | p),
                (y = 0 | g),
                (p = 0 | h),
                (g = 0 | f),
                (h = 0 | u),
                (f = 0 | d),
                ({ h: u, l: d } = zl.add(0 | l, 0 | c, 0 | $, 0 | x)),
                (l = 0 | o),
                (c = 0 | a),
                (o = 0 | s),
                (a = 0 | i),
                (s = 0 | n),
                (i = 0 | r);
              const P = zl.add3L(x, E, S);
              (n = zl.add3H(P, $, k, C)), (r = 0 | P);
            }
            ({ h: n, l: r } = zl.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
              ({ h: s, l: i } = zl.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | i)),
              ({ h: o, l: a } = zl.add(0 | this.Ch, 0 | this.Cl, 0 | o, 0 | a)),
              ({ h: l, l: c } = zl.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)),
              ({ h: u, l: d } = zl.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)),
              ({ h: h, l: f } = zl.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)),
              ({ h: p, l: g } = zl.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
              ({ h: m, l: y } = zl.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
              this.set(n, r, s, i, o, a, l, c, u, d, h, f, p, g, m, y);
          }
          roundClean() {
            Dl.fill(0), Ml.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class Hl extends jl {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class Gl extends jl {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        const Vl = $l(() => new jl());
        $l(() => new Hl()), $l(() => new Gl());
        const Wl = (function () {
          if ("undefined" != typeof self) return self;
          if ("undefined" != typeof window) return window;
          if ("undefined" != typeof global) return global;
          throw new Error("unable to locate global object");
        })();
        Wl.crypto || Wl.msCrypto;
        let Ql = !1;
        const Jl = function (t, e, n) {
          return (function (t, e) {
            const n = { sha256: Tl, sha512: Vl }[t];
            return (
              Go(null != n, "invalid hmac algorithm", "algorithm", t),
              kl.create(n, e)
            );
          })(t, e)
            .update(n)
            .digest();
        };
        let _l = Jl;
        function Kl(t, e, n) {
          const r = _o(e, "key"),
            s = _o(n, "data");
          return Zo(_l(t, r, s));
        }
        (Kl._ = Jl),
          (Kl.lock = function () {
            Ql = !0;
          }),
          (Kl.register = function (t) {
            if (Ql) throw new Error("computeHmac is locked");
            _l = t;
          }),
          Object.freeze(Kl);
        const [ql, Yl, Zl] = [[], [], []],
          Xl = BigInt(0),
          tc = BigInt(1),
          ec = BigInt(2),
          nc = BigInt(7),
          rc = BigInt(256),
          sc = BigInt(113);
        for (let t = 0, e = tc, n = 1, r = 0; t < 24; t++) {
          ([n, r] = [r, (2 * n + 3 * r) % 5]),
            ql.push(2 * (5 * r + n)),
            Yl.push((((t + 1) * (t + 2)) / 2) % 64);
          let s = Xl;
          for (let t = 0; t < 7; t++)
            (e = ((e << tc) ^ ((e >> nc) * sc)) % rc),
              e & ec && (s ^= tc << ((tc << BigInt(t)) - tc));
          Zl.push(s);
        }
        const [ic, oc] = zl.split(Zl, !0),
          ac = (t, e, n) => (n > 32 ? zl.rotlBH(t, e, n) : zl.rotlSH(t, e, n)),
          lc = (t, e, n) => (n > 32 ? zl.rotlBL(t, e, n) : zl.rotlSL(t, e, n));
        class cc extends Al {
          constructor(t, e, n, r = !1, s = 24) {
            if (
              (super(),
              (this.blockLen = t),
              (this.suffix = e),
              (this.outputLen = n),
              (this.enableXOF = r),
              (this.rounds = s),
              (this.pos = 0),
              (this.posOut = 0),
              (this.finished = !1),
              (this.destroyed = !1),
              yl.number(n),
              0 >= this.blockLen || this.blockLen >= 200)
            )
              throw new Error("Sha3 supports only keccak-f1600 function");
            var i;
            (this.state = new Uint8Array(200)),
              (this.state32 =
                ((i = this.state),
                new Uint32Array(
                  i.buffer,
                  i.byteOffset,
                  Math.floor(i.byteLength / 4)
                )));
          }
          keccak() {
            !(function (t, e = 24) {
              const n = new Uint32Array(10);
              for (let r = 24 - e; r < 24; r++) {
                for (let e = 0; e < 10; e++)
                  n[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
                for (let e = 0; e < 10; e += 2) {
                  const r = (e + 8) % 10,
                    s = (e + 2) % 10,
                    i = n[s],
                    o = n[s + 1],
                    a = ac(i, o, 1) ^ n[r],
                    l = lc(i, o, 1) ^ n[r + 1];
                  for (let n = 0; n < 50; n += 10)
                    (t[e + n] ^= a), (t[e + n + 1] ^= l);
                }
                let e = t[2],
                  s = t[3];
                for (let n = 0; n < 24; n++) {
                  const r = Yl[n],
                    i = ac(e, s, r),
                    o = lc(e, s, r),
                    a = ql[n];
                  (e = t[a]), (s = t[a + 1]), (t[a] = i), (t[a + 1] = o);
                }
                for (let e = 0; e < 50; e += 10) {
                  for (let r = 0; r < 10; r++) n[r] = t[e + r];
                  for (let r = 0; r < 10; r++)
                    t[e + r] ^= ~n[(r + 2) % 10] & n[(r + 4) % 10];
                }
                (t[0] ^= ic[r]), (t[1] ^= oc[r]);
              }
              n.fill(0);
            })(this.state32, this.rounds),
              (this.posOut = 0),
              (this.pos = 0);
          }
          update(t) {
            yl.exists(this);
            const { blockLen: e, state: n } = this,
              r = (t = vl(t)).length;
            for (let s = 0; s < r; ) {
              const i = Math.min(e - this.pos, r - s);
              for (let e = 0; e < i; e++) n[this.pos++] ^= t[s++];
              this.pos === e && this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            const { state: t, suffix: e, pos: n, blockLen: r } = this;
            (t[n] ^= e),
              0 != (128 & e) && n === r - 1 && this.keccak(),
              (t[r - 1] ^= 128),
              this.keccak();
          }
          writeInto(t) {
            yl.exists(this, !1), yl.bytes(t), this.finish();
            const e = this.state,
              { blockLen: n } = this;
            for (let r = 0, s = t.length; r < s; ) {
              this.posOut >= n && this.keccak();
              const i = Math.min(n - this.posOut, s - r);
              t.set(e.subarray(this.posOut, this.posOut + i), r),
                (this.posOut += i),
                (r += i);
            }
            return t;
          }
          xofInto(t) {
            if (!this.enableXOF)
              throw new Error("XOF is not possible for this instance");
            return this.writeInto(t);
          }
          xof(t) {
            return yl.number(t), this.xofInto(new Uint8Array(t));
          }
          digestInto(t) {
            if ((yl.output(t, this), this.finished))
              throw new Error("digest() was already called");
            return this.writeInto(t), this.destroy(), t;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            (this.destroyed = !0), this.state.fill(0);
          }
          _cloneInto(t) {
            const {
              blockLen: e,
              suffix: n,
              outputLen: r,
              rounds: s,
              enableXOF: i,
            } = this;
            return (
              t || (t = new cc(e, n, r, i, s)),
              t.state32.set(this.state32),
              (t.pos = this.pos),
              (t.posOut = this.posOut),
              (t.finished = this.finished),
              (t.rounds = s),
              (t.suffix = n),
              (t.outputLen = r),
              (t.enableXOF = i),
              (t.destroyed = this.destroyed),
              t
            );
          }
        }
        const uc = (t, e, n) => $l(() => new cc(e, t, n));
        uc(6, 144, 28),
          uc(6, 136, 32),
          uc(6, 104, 48),
          uc(6, 72, 64),
          uc(1, 144, 28);
        const dc = uc(1, 136, 32);
        uc(1, 104, 48), uc(1, 72, 64);
        const hc = (t, e, n) =>
          (function (t) {
            const e = (e, n) => t(n).update(vl(e)).digest(),
              n = t({});
            return (
              (e.outputLen = n.outputLen),
              (e.blockLen = n.blockLen),
              (e.create = (e) => t(e)),
              e
            );
          })((r = {}) => new cc(e, t, void 0 === r.dkLen ? n : r.dkLen, !0));
        hc(31, 168, 16), hc(31, 136, 32);
        let fc = !1;
        const pc = function (t) {
          return dc(t);
        };
        let gc = pc;
        function mc(t) {
          const e = _o(t, "data");
          return Zo(gc(e));
        }
        (mc._ = pc),
          (mc.lock = function () {
            fc = !0;
          }),
          (mc.register = function (t) {
            if (fc) throw new TypeError("keccak256 is locked");
            gc = t;
          }),
          Object.freeze(mc);
        var yc = Object.freeze({ __proto__: null, default: {} });
        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
        const bc = BigInt(0),
          wc = BigInt(1),
          vc = BigInt(2),
          Ac = BigInt(3),
          $c = BigInt(8),
          xc = Object.freeze({
            a: bc,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
            ),
            h: wc,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          }),
          kc = (t, e) => (t + e / vc) / e,
          Ec = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar(t) {
              const { n: e } = xc,
                n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -wc * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                i = n,
                o = BigInt("0x100000000000000000000000000000000"),
                a = kc(i * t, e),
                l = kc(-r * t, e);
              let c = Xc(t - a * n - l * s, e),
                u = Xc(-a * r - l * i, e);
              const d = c > o,
                h = u > o;
              if ((d && (c = e - c), h && (u = e - u), c > o || u > o))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
              return { k1neg: d, k1: c, k2neg: h, k2: u };
            },
          },
          Cc = 32,
          Sc = 32,
          Pc = Cc + 1,
          Ic = 2 * Cc + 1;
        function Nc(t) {
          const { a: e, b: n } = xc,
            r = Xc(t * t),
            s = Xc(r * t);
          return Xc(s + e * t + n);
        }
        const Bc = xc.a === bc;
        class Tc extends Error {
          constructor(t) {
            super(t);
          }
        }
        function Oc(t) {
          if (!(t instanceof Rc)) throw new TypeError("JacobianPoint expected");
        }
        class Rc {
          constructor(t, e, n) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          static fromAffine(t) {
            if (!(t instanceof Fc))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(Fc.ZERO) ? Rc.ZERO : new Rc(t.x, t.y, wc);
          }
          static toAffineBatch(t) {
            const e = (function (t, e = xc.P) {
              const n = new Array(t.length),
                r = t.reduce(
                  (t, r, s) => (r === bc ? t : ((n[s] = t), Xc(t * r, e))),
                  wc
                ),
                s = eu(r, e);
              return (
                t.reduceRight(
                  (t, r, s) =>
                    r === bc ? t : ((n[s] = Xc(t * n[s], e)), Xc(t * r, e)),
                  s
                ),
                n
              );
            })(t.map((t) => t.z));
            return t.map((t, n) => t.toAffine(e[n]));
          }
          static normalizeZ(t) {
            return Rc.toAffineBatch(t).map(Rc.fromAffine);
          }
          equals(t) {
            Oc(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: o } = t,
              a = Xc(r * r),
              l = Xc(o * o),
              c = Xc(e * l),
              u = Xc(s * a),
              d = Xc(Xc(n * o) * l),
              h = Xc(Xc(i * r) * a);
            return c === u && d === h;
          }
          negate() {
            return new Rc(this.x, Xc(-this.y), this.z);
          }
          double() {
            const { x: t, y: e, z: n } = this,
              r = Xc(t * t),
              s = Xc(e * e),
              i = Xc(s * s),
              o = t + s,
              a = Xc(vc * (Xc(o * o) - r - i)),
              l = Xc(Ac * r),
              c = Xc(l * l),
              u = Xc(c - vc * a),
              d = Xc(l * (a - u) - $c * i),
              h = Xc(vc * e * n);
            return new Rc(u, d, h);
          }
          add(t) {
            Oc(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: o } = t;
            if (s === bc || i === bc) return this;
            if (e === bc || n === bc) return t;
            const a = Xc(r * r),
              l = Xc(o * o),
              c = Xc(e * l),
              u = Xc(s * a),
              d = Xc(Xc(n * o) * l),
              h = Xc(Xc(i * r) * a),
              f = Xc(u - c),
              p = Xc(h - d);
            if (f === bc) return p === bc ? this.double() : Rc.ZERO;
            const g = Xc(f * f),
              m = Xc(f * g),
              y = Xc(c * g),
              b = Xc(p * p - m - vc * y),
              w = Xc(p * (y - b) - d * m),
              v = Xc(r * o * f);
            return new Rc(b, w, v);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiplyUnsafe(t) {
            const e = Rc.ZERO;
            if ("bigint" == typeof t && t === bc) return e;
            let n = Zc(t);
            if (n === wc) return this;
            if (!Bc) {
              let t = e,
                r = this;
              for (; n > bc; )
                n & wc && (t = t.add(r)), (r = r.double()), (n >>= wc);
              return t;
            }
            let { k1neg: r, k1: s, k2neg: i, k2: o } = Ec.splitScalar(n),
              a = e,
              l = e,
              c = this;
            for (; s > bc || o > bc; )
              s & wc && (a = a.add(c)),
                o & wc && (l = l.add(c)),
                (c = c.double()),
                (s >>= wc),
                (o >>= wc);
            return (
              r && (a = a.negate()),
              i && (l = l.negate()),
              (l = new Rc(Xc(l.x * Ec.beta), l.y, l.z)),
              a.add(l)
            );
          }
          precomputeWindow(t) {
            const e = Bc ? 128 / t + 1 : 256 / t + 1,
              n = [];
            let r = this,
              s = r;
            for (let i = 0; i < e; i++) {
              (s = r), n.push(s);
              for (let e = 1; e < 2 ** (t - 1); e++) (s = s.add(r)), n.push(s);
              r = s.double();
            }
            return n;
          }
          wNAF(t, e) {
            !e && this.equals(Rc.BASE) && (e = Fc.BASE);
            const n = (e && e._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = e && zc.get(e);
            r ||
              ((r = this.precomputeWindow(n)),
              e && 1 !== n && ((r = Rc.normalizeZ(r)), zc.set(e, r)));
            let s = Rc.ZERO,
              i = Rc.BASE;
            const o = 1 + (Bc ? 128 / n : 256 / n),
              a = 2 ** (n - 1),
              l = BigInt(2 ** n - 1),
              c = 2 ** n,
              u = BigInt(n);
            for (let e = 0; e < o; e++) {
              const n = e * a;
              let o = Number(t & l);
              (t >>= u), o > a && ((o -= c), (t += wc));
              const d = n,
                h = n + Math.abs(o) - 1,
                f = e % 2 != 0,
                p = o < 0;
              0 === o ? (i = i.add(Lc(f, r[d]))) : (s = s.add(Lc(p, r[h])));
            }
            return { p: s, f: i };
          }
          multiply(t, e) {
            let n,
              r,
              s = Zc(t);
            if (Bc) {
              const { k1neg: t, k1: i, k2neg: o, k2: a } = Ec.splitScalar(s);
              let { p: l, f: c } = this.wNAF(i, e),
                { p: u, f: d } = this.wNAF(a, e);
              (l = Lc(t, l)),
                (u = Lc(o, u)),
                (u = new Rc(Xc(u.x * Ec.beta), u.y, u.z)),
                (n = l.add(u)),
                (r = c.add(d));
            } else {
              const { p: t, f: i } = this.wNAF(s, e);
              (n = t), (r = i);
            }
            return Rc.normalizeZ([n, r])[0];
          }
          toAffine(t) {
            const { x: e, y: n, z: r } = this,
              s = this.equals(Rc.ZERO);
            null == t && (t = s ? $c : eu(r));
            const i = t,
              o = Xc(i * i),
              a = Xc(o * i),
              l = Xc(e * o),
              c = Xc(n * a),
              u = Xc(r * i);
            if (s) return Fc.ZERO;
            if (u !== wc) throw new Error("invZ was invalid");
            return new Fc(l, c);
          }
        }
        function Lc(t, e) {
          const n = e.negate();
          return t ? n : e;
        }
        (Rc.BASE = new Rc(xc.Gx, xc.Gy, wc)), (Rc.ZERO = new Rc(bc, wc, bc));
        const zc = new WeakMap();
        class Fc {
          constructor(t, e) {
            (this.x = t), (this.y = e);
          }
          _setWindowSize(t) {
            (this._WINDOW_SIZE = t), zc.delete(this);
          }
          hasEvenY() {
            return this.y % vc === bc;
          }
          static fromCompressedHex(t) {
            const e = 32 === t.length,
              n = qc(e ? t : t.subarray(1));
            if (!au(n)) throw new Error("Point is not on curve");
            let r = (function (t) {
              const { P: e } = xc,
                n = BigInt(6),
                r = BigInt(11),
                s = BigInt(22),
                i = BigInt(23),
                o = BigInt(44),
                a = BigInt(88),
                l = (t * t * t) % e,
                c = (l * l * t) % e,
                u = (tu(c, Ac) * c) % e,
                d = (tu(u, Ac) * c) % e,
                h = (tu(d, vc) * l) % e,
                f = (tu(h, r) * h) % e,
                p = (tu(f, s) * f) % e,
                g = (tu(p, o) * p) % e,
                m = (tu(g, a) * g) % e,
                y = (tu(m, o) * p) % e,
                b = (tu(y, Ac) * c) % e,
                w = (tu(b, i) * f) % e,
                v = (tu(w, n) * l) % e,
                A = tu(v, vc),
                $ = (A * A) % e;
              if ($ !== t) throw new Error("Cannot find square root");
              return A;
            })(Nc(n));
            const s = (r & wc) === wc;
            if (e) s && (r = Xc(-r));
            else {
              (1 == (1 & t[0])) !== s && (r = Xc(-r));
            }
            const i = new Fc(n, r);
            return i.assertValidity(), i;
          }
          static fromUncompressedHex(t) {
            const e = qc(t.subarray(1, Cc + 1)),
              n = qc(t.subarray(Cc + 1, 2 * Cc + 1)),
              r = new Fc(e, n);
            return r.assertValidity(), r;
          }
          static fromHex(t) {
            const e = Yc(t),
              n = e.length,
              r = e[0];
            if (n === Cc) return this.fromCompressedHex(e);
            if (n === Pc && (2 === r || 3 === r))
              return this.fromCompressedHex(e);
            if (n === Ic && 4 === r) return this.fromUncompressedHex(e);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${Pc} compressed bytes or ${Ic} uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(t) {
            return Fc.BASE.multiply(cu(t));
          }
          static fromSignature(t, e, n) {
            const { r: r, s: s } = (function (t) {
              if (t instanceof Mc) return t.assertValidity(), t;
              try {
                return Mc.fromDER(t);
              } catch (e) {
                return Mc.fromCompact(t);
              }
            })(e);
            if (![0, 1, 2, 3].includes(n))
              throw new Error("Cannot recover: invalid recovery bit");
            const i = nu(Yc(t)),
              { n: o } = xc,
              a = 2 === n || 3 === n ? r + o : r,
              l = eu(a, o),
              c = Xc(-i * l, o),
              u = Xc(s * l, o),
              d = 1 & n ? "03" : "02",
              h = Fc.fromHex(d + Wc(a)),
              f = Fc.BASE.multiplyAndAddUnsafe(h, c, u);
            if (!f)
              throw new Error("Cannot recover signature: point at infinify");
            return f.assertValidity(), f;
          }
          toRawBytes(t = !1) {
            return Kc(this.toHex(t));
          }
          toHex(t = !1) {
            const e = Wc(this.x);
            if (t) {
              return `${this.hasEvenY() ? "02" : "03"}${e}`;
            }
            return `04${e}${Wc(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const t = "Point is not on elliptic curve",
              { x: e, y: n } = this;
            if (!au(e) || !au(n)) throw new Error(t);
            const r = Xc(n * n);
            if (Xc(r - Nc(e)) !== bc) throw new Error(t);
          }
          equals(t) {
            return this.x === t.x && this.y === t.y;
          }
          negate() {
            return new Fc(this.x, Xc(-this.y));
          }
          double() {
            return Rc.fromAffine(this).double().toAffine();
          }
          add(t) {
            return Rc.fromAffine(this).add(Rc.fromAffine(t)).toAffine();
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            return Rc.fromAffine(this).multiply(t, this).toAffine();
          }
          multiplyAndAddUnsafe(t, e, n) {
            const r = Rc.fromAffine(this),
              s =
                e === bc || e === wc || this !== Fc.BASE
                  ? r.multiplyUnsafe(e)
                  : r.multiply(e),
              i = Rc.fromAffine(t).multiplyUnsafe(n),
              o = s.add(i);
            return o.equals(Rc.ZERO) ? void 0 : o.toAffine();
          }
        }
        function Uc(t) {
          return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t;
        }
        function Dc(t) {
          if (t.length < 2 || 2 !== t[0])
            throw new Error(`Invalid signature integer tag: ${Gc(t)}`);
          const e = t[1],
            n = t.subarray(2, e + 2);
          if (!e || n.length !== e)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: qc(n), left: t.subarray(e + 2) };
        }
        (Fc.BASE = new Fc(xc.Gx, xc.Gy)), (Fc.ZERO = new Fc(bc, bc));
        let Mc = class t {
          constructor(t, e) {
            (this.r = t), (this.s = e), this.assertValidity();
          }
          static fromCompact(e) {
            const n = e instanceof Uint8Array,
              r = "Signature.fromCompact";
            if ("string" != typeof e && !n)
              throw new TypeError(`${r}: Expected string or Uint8Array`);
            const s = n ? Gc(e) : e;
            if (128 !== s.length) throw new Error(`${r}: Expected 64-byte hex`);
            return new t(_c(s.slice(0, 64)), _c(s.slice(64, 128)));
          }
          static fromDER(e) {
            const n = e instanceof Uint8Array;
            if ("string" != typeof e && !n)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: r, s: s } = (function (t) {
              if (t.length < 2 || 48 != t[0])
                throw new Error(`Invalid signature tag: ${Gc(t)}`);
              if (t[1] !== t.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: e, left: n } = Dc(t.subarray(2)),
                { data: r, left: s } = Dc(n);
              if (s.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${Gc(s)}`
                );
              return { r: e, s: r };
            })(n ? e : Kc(e));
            return new t(r, s);
          }
          static fromHex(t) {
            return this.fromDER(t);
          }
          assertValidity() {
            const { r: t, s: e } = this;
            if (!ou(t))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!ou(e))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const t = xc.n >> wc;
            return this.s > t;
          }
          normalizeS() {
            return this.hasHighS() ? new t(this.r, Xc(-this.s, xc.n)) : this;
          }
          toDERRawBytes() {
            return Kc(this.toDERHex());
          }
          toDERHex() {
            const t = Uc(Jc(this.s)),
              e = Uc(Jc(this.r)),
              n = t.length / 2,
              r = e.length / 2,
              s = Jc(n),
              i = Jc(r);
            return `30${Jc(r + n + 4)}02${i}${e}02${s}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return Kc(this.toCompactHex());
          }
          toCompactHex() {
            return Wc(this.r) + Wc(this.s);
          }
        };
        function jc(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            n = new Uint8Array(e);
          for (let e = 0, r = 0; e < t.length; e++) {
            const s = t[e];
            n.set(s, r), (r += s.length);
          }
          return n;
        }
        const Hc = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0")
        );
        function Gc(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let e = "";
          for (let n = 0; n < t.length; n++) e += Hc[t[n]];
          return e;
        }
        const Vc = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000"
        );
        function Wc(t) {
          if ("bigint" != typeof t) throw new Error("Expected bigint");
          if (!(bc <= t && t < Vc))
            throw new Error("Expected number 0 <= n < 2^256");
          return t.toString(16).padStart(64, "0");
        }
        function Qc(t) {
          const e = Kc(Wc(t));
          if (32 !== e.length) throw new Error("Error: expected 32 bytes");
          return e;
        }
        function Jc(t) {
          const e = t.toString(16);
          return 1 & e.length ? `0${e}` : e;
        }
        function _c(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof t
            );
          return BigInt(`0x${t}`);
        }
        function Kc(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + t.length
            );
          const e = new Uint8Array(t.length / 2);
          for (let n = 0; n < e.length; n++) {
            const r = 2 * n,
              s = t.slice(r, r + 2),
              i = Number.parseInt(s, 16);
            if (Number.isNaN(i) || i < 0)
              throw new Error("Invalid byte sequence");
            e[n] = i;
          }
          return e;
        }
        function qc(t) {
          return _c(Gc(t));
        }
        function Yc(t) {
          return t instanceof Uint8Array ? Uint8Array.from(t) : Kc(t);
        }
        function Zc(t) {
          if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
          if ("bigint" == typeof t && ou(t)) return t;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function Xc(t, e = xc.P) {
          const n = t % e;
          return n >= bc ? n : e + n;
        }
        function tu(t, e) {
          const { P: n } = xc;
          let r = t;
          for (; e-- > bc; ) (r *= r), (r %= n);
          return r;
        }
        function eu(t, e = xc.P) {
          if (t === bc || e <= bc)
            throw new Error(
              `invert: expected positive integers, got n=${t} mod=${e}`
            );
          let n = Xc(t, e),
            r = e,
            s = bc,
            i = wc;
          for (; n !== bc; ) {
            const t = r % n,
              e = s - i * (r / n);
            (r = n), (n = t), (s = i), (i = e);
          }
          if (r !== wc) throw new Error("invert: does not exist");
          return Xc(s, e);
        }
        function nu(t, e = !1) {
          const n = (function (t) {
            const e = 8 * t.length - 8 * Sc,
              n = qc(t);
            return e > 0 ? n >> BigInt(e) : n;
          })(t);
          if (e) return n;
          const { n: r } = xc;
          return n >= r ? n - r : n;
        }
        let ru, su;
        class iu {
          constructor(t, e) {
            if (
              ((this.hashLen = t),
              (this.qByteLen = e),
              "number" != typeof t || t < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(t).fill(1)),
              (this.k = new Uint8Array(t).fill(0)),
              (this.counter = 0);
          }
          hmac(...t) {
            return bu.hmacSha256(this.k, ...t);
          }
          hmacSync(...t) {
            return su(this.k, ...t);
          }
          checkSync() {
            if ("function" != typeof su)
              throw new Tc("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed(t = new Uint8Array()) {
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), t)),
              (this.v = await this.hmac(this.v)),
              0 !== t.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), t)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync(t = new Uint8Array()) {
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), t)),
              (this.v = this.hmacSync(this.v)),
              0 !== t.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), t)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return jc(...e);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return jc(...e);
          }
        }
        function ou(t) {
          return bc < t && t < xc.n;
        }
        function au(t) {
          return bc < t && t < xc.P;
        }
        function lu(t, e, n, r = !0) {
          const { n: s } = xc,
            i = nu(t, !0);
          if (!ou(i)) return;
          const o = eu(i, s),
            a = Fc.BASE.multiply(i),
            l = Xc(a.x, s);
          if (l === bc) return;
          const c = Xc(o * Xc(e + n * l, s), s);
          if (c === bc) return;
          let u = new Mc(l, c),
            d = (a.x === u.r ? 0 : 2) | Number(a.y & wc);
          return (
            r && u.hasHighS() && ((u = u.normalizeS()), (d ^= 1)),
            { sig: u, recovery: d }
          );
        }
        function cu(t) {
          let e;
          if ("bigint" == typeof t) e = t;
          else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
          else if ("string" == typeof t) {
            if (t.length !== 2 * Sc)
              throw new Error("Expected 32 bytes of private key");
            e = _c(t);
          } else {
            if (!(t instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (t.length !== Sc)
              throw new Error("Expected 32 bytes of private key");
            e = qc(t);
          }
          if (!ou(e)) throw new Error("Expected private key: 0 < key < n");
          return e;
        }
        function uu(t) {
          const e = t instanceof Uint8Array,
            n = "string" == typeof t,
            r = (e || n) && t.length;
          return e
            ? r === Pc || r === Ic
            : n
            ? r === 2 * Pc || r === 2 * Ic
            : t instanceof Fc;
        }
        function du(t, e, n = !1) {
          if (uu(t))
            throw new TypeError(
              "getSharedSecret: first arg must be private key"
            );
          if (!uu(e))
            throw new TypeError(
              "getSharedSecret: second arg must be public key"
            );
          const r =
            (s = e) instanceof Fc ? (s.assertValidity(), s) : Fc.fromHex(s);
          var s;
          return r.assertValidity(), r.multiply(cu(t)).toRawBytes(n);
        }
        function hu(t) {
          return qc(t.length > Cc ? t.slice(0, Cc) : t);
        }
        function fu(t) {
          const e = hu(t),
            n = Xc(e, xc.n);
          return pu(n < bc ? e : n);
        }
        function pu(t) {
          return Qc(t);
        }
        function gu(t, e, n = {}) {
          const {
              seed: r,
              m: s,
              d: i,
            } = (function (t, e, n) {
              if (null == t)
                throw new Error(
                  `sign: expected valid message hash, not "${t}"`
                );
              const r = Yc(t),
                s = cu(e),
                i = [pu(s), fu(r)];
              if (null != n) {
                !0 === n && (n = bu.randomBytes(Cc));
                const t = Yc(n);
                if (t.length !== Cc)
                  throw new Error(`sign: Expected ${Cc} bytes of extra data`);
                i.push(t);
              }
              return { seed: jc(...i), m: hu(r), d: s };
            })(t, e, n.extraEntropy),
            o = new iu(32, Sc);
          let a;
          for (
            o.reseedSync(r);
            !(a = lu(o.generateSync(), s, i, n.canonical));

          )
            o.reseedSync();
          return (function (t, e) {
            const { sig: n, recovery: r } = t,
              { der: s, recovered: i } = Object.assign(
                { canonical: !0, der: !0 },
                e
              ),
              o = s ? n.toDERRawBytes() : n.toCompactRawBytes();
            return i ? [o, r] : o;
          })(a, n);
        }
        Fc.BASE._setWindowSize(8);
        const mu = {
            node: yc,
            web:
              "object" == typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          yu = {},
          bu = {
            bytesToHex: Gc,
            hexToBytes: Kc,
            concatBytes: jc,
            mod: Xc,
            invert: eu,
            isValidPrivateKey(t) {
              try {
                return cu(t), !0;
              } catch (t) {
                return !1;
              }
            },
            _bigintTo32Bytes: Qc,
            _normalizePrivateKey: cu,
            hashToPrivateKey: (t) => {
              t = Yc(t);
              const e = Sc + 8;
              if (t.length < e || t.length > 1024)
                throw new Error(
                  "Expected valid bytes of private key as per FIPS 186"
                );
              return Qc(Xc(qc(t), xc.n - wc) + wc);
            },
            randomBytes: (t = 32) => {
              if (mu.web) return mu.web.getRandomValues(new Uint8Array(t));
              if (mu.node) {
                const { randomBytes: e } = mu.node;
                return Uint8Array.from(e(t));
              }
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            },
            randomPrivateKey: () => bu.hashToPrivateKey(bu.randomBytes(Sc + 8)),
            precompute(t = 8, e = Fc.BASE) {
              const n = e === Fc.BASE ? e : new Fc(e.x, e.y);
              return n._setWindowSize(t), n.multiply(Ac), n;
            },
            sha256: async (...t) => {
              if (mu.web) {
                const e = await mu.web.subtle.digest("SHA-256", jc(...t));
                return new Uint8Array(e);
              }
              if (mu.node) {
                const { createHash: e } = mu.node,
                  n = e("sha256");
                return (
                  t.forEach((t) => n.update(t)), Uint8Array.from(n.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async (t, ...e) => {
              if (mu.web) {
                const n = await mu.web.subtle.importKey(
                    "raw",
                    t,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"]
                  ),
                  r = jc(...e),
                  s = await mu.web.subtle.sign("HMAC", n, r);
                return new Uint8Array(s);
              }
              if (mu.node) {
                const { createHmac: n } = mu.node,
                  r = n("sha256", t);
                return (
                  e.forEach((t) => r.update(t)), Uint8Array.from(r.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async (t, ...e) => {
              let n = yu[t];
              if (void 0 === n) {
                const e = await bu.sha256(
                  Uint8Array.from(t, (t) => t.charCodeAt(0))
                );
                (n = jc(e, e)), (yu[t] = n);
              }
              return bu.sha256(n, ...e);
            },
            taggedHashSync: (t, ...e) => {
              if ("function" != typeof ru)
                throw new Tc("sha256Sync is undefined, you need to set it");
              let n = yu[t];
              if (void 0 === n) {
                const e = ru(Uint8Array.from(t, (t) => t.charCodeAt(0)));
                (n = jc(e, e)), (yu[t] = n);
              }
              return ru(n, ...e);
            },
            _JacobianPoint: Rc,
          };
        Object.defineProperties(bu, {
          sha256Sync: {
            configurable: !1,
            get: () => ru,
            set(t) {
              ru || (ru = t);
            },
          },
          hmacSha256Sync: {
            configurable: !1,
            get: () => su,
            set(t) {
              su || (su = t);
            },
          },
        });
        const wu = "0x0000000000000000000000000000000000000000",
          vu =
            "0x0000000000000000000000000000000000000000000000000000000000000000",
          Au = BigInt(0),
          $u = BigInt(1),
          xu = BigInt(2),
          ku = BigInt(27),
          Eu = BigInt(28),
          Cu = BigInt(35),
          Su = {};
        function Pu(t) {
          return ra(ma(t), 32);
        }
        class Iu {
          #F;
          #U;
          #D;
          #M;
          get r() {
            return this.#F;
          }
          set r(t) {
            Go(32 === ta(t), "invalid r", "value", t), (this.#F = Zo(t));
          }
          get s() {
            return this.#U;
          }
          set s(t) {
            Go(32 === ta(t), "invalid s", "value", t);
            const e = Zo(t);
            Go(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e),
              (this.#U = e);
          }
          get v() {
            return this.#D;
          }
          set v(t) {
            const e = pa(t, "value");
            Go(27 === e || 28 === e, "invalid v", "v", t), (this.#D = e);
          }
          get networkV() {
            return this.#M;
          }
          get legacyChainId() {
            const t = this.networkV;
            return null == t ? null : Iu.getChainId(t);
          }
          get yParity() {
            return 27 === this.v ? 0 : 1;
          }
          get yParityAndS() {
            const t = _o(this.s);
            return this.yParity && (t[0] |= 128), Zo(t);
          }
          get compactSerialized() {
            return Xo([this.r, this.yParityAndS]);
          }
          get serialized() {
            return Xo([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
          }
          constructor(t, e, n, r) {
            Qo(t, Su, "Signature"),
              (this.#F = e),
              (this.#U = n),
              (this.#D = r),
              (this.#M = null);
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
          }
          clone() {
            const t = new Iu(Su, this.r, this.s, this.v);
            return this.networkV && (t.#M = this.networkV), t;
          }
          toJSON() {
            const t = this.networkV;
            return {
              _type: "signature",
              networkV: null != t ? t.toString() : null,
              r: this.r,
              s: this.s,
              v: this.v,
            };
          }
          static getChainId(t) {
            const e = ua(t, "v");
            return e == ku || e == Eu
              ? Au
              : (Go(e >= Cu, "invalid EIP-155 v", "v", t), (e - Cu) / xu);
          }
          static getChainIdV(t, e) {
            return ua(t) * xu + BigInt(35 + e - 27);
          }
          static getNormalizedV(t) {
            const e = ua(t);
            return e === Au || e === ku
              ? 27
              : e === $u || e === Eu
              ? 28
              : (Go(e >= Cu, "invalid v", "v", t), e & $u ? 27 : 28);
          }
          static from(t) {
            function e(e, n) {
              Go(e, n, "signature", t);
            }
            if (null == t) return new Iu(Su, vu, vu, 27);
            if ("string" == typeof t) {
              const n = _o(t, "signature");
              if (64 === n.length) {
                const t = Zo(n.slice(0, 32)),
                  e = n.slice(32, 64),
                  r = 128 & e[0] ? 28 : 27;
                return (e[0] &= 127), new Iu(Su, t, Zo(e), r);
              }
              if (65 === n.length) {
                const t = Zo(n.slice(0, 32)),
                  r = n.slice(32, 64);
                e(0 == (128 & r[0]), "non-canonical s");
                const s = Iu.getNormalizedV(n[64]);
                return new Iu(Su, t, Zo(r), s);
              }
              e(!1, "invalid raw signature length");
            }
            if (t instanceof Iu) return t.clone();
            const n = t.r;
            e(null != n, "missing r");
            const r = Pu(n),
              s = (function (t, n) {
                if (null != t) return Pu(t);
                if (null != n) {
                  e(qo(n, 32), "invalid yParityAndS");
                  const t = _o(n);
                  return (t[0] &= 127), Zo(t);
                }
                e(!1, "missing s");
              })(t.s, t.yParityAndS);
            e(0 == (128 & _o(s)[0]), "non-canonical s");
            const { networkV: i, v: o } = (function (t, n, r) {
                if (null != t) {
                  const e = ua(t);
                  return {
                    networkV: e >= Cu ? e : void 0,
                    v: Iu.getNormalizedV(e),
                  };
                }
                if (null != n)
                  return (
                    e(qo(n, 32), "invalid yParityAndS"),
                    { v: 128 & _o(n)[0] ? 28 : 27 }
                  );
                if (null != r) {
                  switch (pa(r, "sig.yParity")) {
                    case 0:
                      return { v: 27 };
                    case 1:
                      return { v: 28 };
                  }
                  e(!1, "invalid yParity");
                }
                e(!1, "missing v");
              })(t.v, t.yParityAndS, t.yParity),
              a = new Iu(Su, r, s, o);
            return (
              i && (a.#M = i),
              e(
                null == t.yParity || pa(t.yParity, "sig.yParity") === a.yParity,
                "yParity mismatch"
              ),
              e(
                null == t.yParityAndS || t.yParityAndS === a.yParityAndS,
                "yParityAndS mismatch"
              ),
              a
            );
          }
        }
        bu.hmacSha256Sync = function (t, ...e) {
          return _o(Kl("sha256", t, Xo(e)));
        };
        class Nu {
          #j;
          constructor(t) {
            Go(32 === ta(t), "invalid private key", "privateKey", "[REDACTED]"),
              (this.#j = Zo(t));
          }
          get privateKey() {
            return this.#j;
          }
          get publicKey() {
            return Nu.computePublicKey(this.#j);
          }
          get compressedPublicKey() {
            return Nu.computePublicKey(this.#j, !0);
          }
          sign(t) {
            Go(32 === ta(t), "invalid digest length", "digest", t);
            const [e, n] = gu(Ko(t), Ko(this.#j), {
                recovered: !0,
                canonical: !0,
              }),
              r = Mc.fromHex(e);
            return Iu.from({
              r: ga("0x" + r.r.toString(16), 32),
              s: ga("0x" + r.s.toString(16), 32),
              v: n ? 28 : 27,
            });
          }
          computeSharedSecret(t) {
            const e = Nu.computePublicKey(t);
            return Zo(du(Ko(this.#j), _o(e)));
          }
          static computePublicKey(t, e) {
            let n = _o(t, "key");
            if (32 === n.length) {
              return Zo(
                (function (t, e = !1) {
                  return Fc.fromPrivateKey(t).toRawBytes(e);
                })(n, !!e)
              );
            }
            if (64 === n.length) {
              const t = new Uint8Array(65);
              (t[0] = 4), t.set(n, 1), (n = t);
            }
            return Zo(Fc.fromHex(n).toRawBytes(e));
          }
          static recoverPublicKey(t, e) {
            Go(32 === ta(t), "invalid digest length", "digest", t);
            const n = Iu.from(e),
              r = Mc.fromCompact(Ko(Xo([n.r, n.s]))).toDERRawBytes(),
              s = (function (t, e, n, r = !1) {
                return Fc.fromSignature(t, e, n).toRawBytes(r);
              })(Ko(t), r, n.yParity);
            return (
              Go(null != s, "invalid signautre for digest", "signature", e),
              Zo(s)
            );
          }
          static addPoints(t, e, n) {
            const r = Fc.fromHex(Nu.computePublicKey(t).substring(2)),
              s = Fc.fromHex(Nu.computePublicKey(e).substring(2));
            return "0x" + r.add(s).toHex(!!n);
          }
        }
        const Bu = BigInt(0),
          Tu = BigInt(36);
        function Ou(t) {
          const e = (t = t.toLowerCase()).substring(2).split(""),
            n = new Uint8Array(40);
          for (let t = 0; t < 40; t++) n[t] = e[t].charCodeAt(0);
          const r = _o(mc(n));
          for (let t = 0; t < 40; t += 2)
            r[t >> 1] >> 4 >= 8 && (e[t] = e[t].toUpperCase()),
              (15 & r[t >> 1]) >= 8 && (e[t + 1] = e[t + 1].toUpperCase());
          return "0x" + e.join("");
        }
        const Ru = {};
        for (let t = 0; t < 10; t++) Ru[String(t)] = String(t);
        for (let t = 0; t < 26; t++)
          Ru[String.fromCharCode(65 + t)] = String(10 + t);
        const Lu = 15;
        const zu = (function () {
          const t = {};
          for (let e = 0; e < 36; e++) {
            t["0123456789abcdefghijklmnopqrstuvwxyz"[e]] = BigInt(e);
          }
          return t;
        })();
        function Fu(t) {
          if (
            (Go("string" == typeof t, "invalid address", "address", t),
            t.match(/^(0x)?[0-9a-fA-F]{40}$/))
          ) {
            t.startsWith("0x") || (t = "0x" + t);
            const e = Ou(t);
            return (
              Go(
                !t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t,
                "bad address checksum",
                "address",
                t
              ),
              e
            );
          }
          if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            Go(
              t.substring(2, 4) ===
                (function (t) {
                  let e = (t =
                    (t = t.toUpperCase()).substring(4) +
                    t.substring(0, 2) +
                    "00")
                    .split("")
                    .map((t) => Ru[t])
                    .join("");
                  for (; e.length >= Lu; ) {
                    let t = e.substring(0, Lu);
                    e = (parseInt(t, 10) % 97) + e.substring(t.length);
                  }
                  let n = String(98 - (parseInt(e, 10) % 97));
                  for (; n.length < 2; ) n = "0" + n;
                  return n;
                })(t),
              "bad icap checksum",
              "address",
              t
            );
            let e = (function (t) {
              t = t.toLowerCase();
              let e = Bu;
              for (let n = 0; n < t.length; n++) e = e * Tu + zu[t[n]];
              return e;
            })(t.substring(4)).toString(16);
            for (; e.length < 40; ) e = "0" + e;
            return Ou("0x" + e);
          }
          Go(!1, "invalid address", "address", t);
        }
        function Uu(t) {
          return t && "function" == typeof t.getAddress;
        }
        async function Du(t, e) {
          const n = await e;
          return (
            (null != n && "0x0000000000000000000000000000000000000000" !== n) ||
              (Ho(
                "string" != typeof t,
                "unconfigured name",
                "UNCONFIGURED_NAME",
                { value: t }
              ),
              Go(
                !1,
                "invalid AddressLike value; did not resolve to a value address",
                "target",
                t
              )),
            Fu(n)
          );
        }
        function Mu(t, e) {
          return "string" == typeof t
            ? t.match(/^0x[0-9a-f]{40}$/i)
              ? Fu(t)
              : (Ho(
                  null != e,
                  "ENS resolution requires a provider",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName" }
                ),
                Du(t, e.resolveName(t)))
            : Uu(t)
            ? Du(t, t.getAddress())
            : t && "function" == typeof t.then
            ? Du(t, t)
            : void Go(!1, "unsupported addressable value", "target", t);
        }
        const ju = {};
        function Hu(t, e) {
          let n = !1;
          return (
            e < 0 && ((n = !0), (e *= -1)),
            new Wu(ju, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e })
          );
        }
        function Gu(t, e) {
          return new Wu(ju, `bytes${e || ""}`, t, { size: e });
        }
        const Vu = Symbol.for("_ethers_typed");
        class Wu {
          type;
          value;
          #H;
          _typedSymbol;
          constructor(t, e, n, r) {
            null == r && (r = null),
              Qo(ju, t, "Typed"),
              Fo(this, { _typedSymbol: Vu, type: e, value: n }),
              (this.#H = r),
              this.format();
          }
          format() {
            if ("array" === this.type) throw new Error("");
            if ("dynamicArray" === this.type) throw new Error("");
            return "tuple" === this.type
              ? `tuple(${this.value.map((t) => t.format()).join(",")})`
              : this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return "string" === this.type;
          }
          get tupleName() {
            if ("tuple" !== this.type) throw TypeError("not a tuple");
            return this.#H;
          }
          get arrayLength() {
            if ("array" !== this.type) throw TypeError("not an array");
            return !0 === this.#H
              ? -1
              : !1 === this.#H
              ? this.value.length
              : null;
          }
          static from(t, e) {
            return new Wu(ju, t, e);
          }
          static uint8(t) {
            return Hu(t, 8);
          }
          static uint16(t) {
            return Hu(t, 16);
          }
          static uint24(t) {
            return Hu(t, 24);
          }
          static uint32(t) {
            return Hu(t, 32);
          }
          static uint40(t) {
            return Hu(t, 40);
          }
          static uint48(t) {
            return Hu(t, 48);
          }
          static uint56(t) {
            return Hu(t, 56);
          }
          static uint64(t) {
            return Hu(t, 64);
          }
          static uint72(t) {
            return Hu(t, 72);
          }
          static uint80(t) {
            return Hu(t, 80);
          }
          static uint88(t) {
            return Hu(t, 88);
          }
          static uint96(t) {
            return Hu(t, 96);
          }
          static uint104(t) {
            return Hu(t, 104);
          }
          static uint112(t) {
            return Hu(t, 112);
          }
          static uint120(t) {
            return Hu(t, 120);
          }
          static uint128(t) {
            return Hu(t, 128);
          }
          static uint136(t) {
            return Hu(t, 136);
          }
          static uint144(t) {
            return Hu(t, 144);
          }
          static uint152(t) {
            return Hu(t, 152);
          }
          static uint160(t) {
            return Hu(t, 160);
          }
          static uint168(t) {
            return Hu(t, 168);
          }
          static uint176(t) {
            return Hu(t, 176);
          }
          static uint184(t) {
            return Hu(t, 184);
          }
          static uint192(t) {
            return Hu(t, 192);
          }
          static uint200(t) {
            return Hu(t, 200);
          }
          static uint208(t) {
            return Hu(t, 208);
          }
          static uint216(t) {
            return Hu(t, 216);
          }
          static uint224(t) {
            return Hu(t, 224);
          }
          static uint232(t) {
            return Hu(t, 232);
          }
          static uint240(t) {
            return Hu(t, 240);
          }
          static uint248(t) {
            return Hu(t, 248);
          }
          static uint256(t) {
            return Hu(t, 256);
          }
          static uint(t) {
            return Hu(t, 256);
          }
          static int8(t) {
            return Hu(t, -8);
          }
          static int16(t) {
            return Hu(t, -16);
          }
          static int24(t) {
            return Hu(t, -24);
          }
          static int32(t) {
            return Hu(t, -32);
          }
          static int40(t) {
            return Hu(t, -40);
          }
          static int48(t) {
            return Hu(t, -48);
          }
          static int56(t) {
            return Hu(t, -56);
          }
          static int64(t) {
            return Hu(t, -64);
          }
          static int72(t) {
            return Hu(t, -72);
          }
          static int80(t) {
            return Hu(t, -80);
          }
          static int88(t) {
            return Hu(t, -88);
          }
          static int96(t) {
            return Hu(t, -96);
          }
          static int104(t) {
            return Hu(t, -104);
          }
          static int112(t) {
            return Hu(t, -112);
          }
          static int120(t) {
            return Hu(t, -120);
          }
          static int128(t) {
            return Hu(t, -128);
          }
          static int136(t) {
            return Hu(t, -136);
          }
          static int144(t) {
            return Hu(t, -144);
          }
          static int152(t) {
            return Hu(t, -152);
          }
          static int160(t) {
            return Hu(t, -160);
          }
          static int168(t) {
            return Hu(t, -168);
          }
          static int176(t) {
            return Hu(t, -176);
          }
          static int184(t) {
            return Hu(t, -184);
          }
          static int192(t) {
            return Hu(t, -192);
          }
          static int200(t) {
            return Hu(t, -200);
          }
          static int208(t) {
            return Hu(t, -208);
          }
          static int216(t) {
            return Hu(t, -216);
          }
          static int224(t) {
            return Hu(t, -224);
          }
          static int232(t) {
            return Hu(t, -232);
          }
          static int240(t) {
            return Hu(t, -240);
          }
          static int248(t) {
            return Hu(t, -248);
          }
          static int256(t) {
            return Hu(t, -256);
          }
          static int(t) {
            return Hu(t, -256);
          }
          static bytes1(t) {
            return Gu(t, 1);
          }
          static bytes2(t) {
            return Gu(t, 2);
          }
          static bytes3(t) {
            return Gu(t, 3);
          }
          static bytes4(t) {
            return Gu(t, 4);
          }
          static bytes5(t) {
            return Gu(t, 5);
          }
          static bytes6(t) {
            return Gu(t, 6);
          }
          static bytes7(t) {
            return Gu(t, 7);
          }
          static bytes8(t) {
            return Gu(t, 8);
          }
          static bytes9(t) {
            return Gu(t, 9);
          }
          static bytes10(t) {
            return Gu(t, 10);
          }
          static bytes11(t) {
            return Gu(t, 11);
          }
          static bytes12(t) {
            return Gu(t, 12);
          }
          static bytes13(t) {
            return Gu(t, 13);
          }
          static bytes14(t) {
            return Gu(t, 14);
          }
          static bytes15(t) {
            return Gu(t, 15);
          }
          static bytes16(t) {
            return Gu(t, 16);
          }
          static bytes17(t) {
            return Gu(t, 17);
          }
          static bytes18(t) {
            return Gu(t, 18);
          }
          static bytes19(t) {
            return Gu(t, 19);
          }
          static bytes20(t) {
            return Gu(t, 20);
          }
          static bytes21(t) {
            return Gu(t, 21);
          }
          static bytes22(t) {
            return Gu(t, 22);
          }
          static bytes23(t) {
            return Gu(t, 23);
          }
          static bytes24(t) {
            return Gu(t, 24);
          }
          static bytes25(t) {
            return Gu(t, 25);
          }
          static bytes26(t) {
            return Gu(t, 26);
          }
          static bytes27(t) {
            return Gu(t, 27);
          }
          static bytes28(t) {
            return Gu(t, 28);
          }
          static bytes29(t) {
            return Gu(t, 29);
          }
          static bytes30(t) {
            return Gu(t, 30);
          }
          static bytes31(t) {
            return Gu(t, 31);
          }
          static bytes32(t) {
            return Gu(t, 32);
          }
          static address(t) {
            return new Wu(ju, "address", t);
          }
          static bool(t) {
            return new Wu(ju, "bool", !!t);
          }
          static bytes(t) {
            return new Wu(ju, "bytes", t);
          }
          static string(t) {
            return new Wu(ju, "string", t);
          }
          static array(t, e) {
            throw new Error("not implemented yet");
          }
          static tuple(t, e) {
            throw new Error("not implemented yet");
          }
          static overrides(t) {
            return new Wu(ju, "overrides", Object.assign({}, t));
          }
          static isTyped(t) {
            return (
              t &&
              "object" == typeof t &&
              "_typedSymbol" in t &&
              t._typedSymbol === Vu
            );
          }
          static dereference(t, e) {
            if (Wu.isTyped(t)) {
              if (t.type !== e)
                throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
              return t.value;
            }
            return t;
          }
        }
        class Qu extends hl {
          constructor(t) {
            super("address", "address", t, !1);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(t, e) {
            let n = Wu.dereference(e, "string");
            try {
              n = Fu(n);
            } catch (t) {
              return this._throwError(t.message, e);
            }
            return t.writeValue(n);
          }
          decode(t) {
            return Fu(ga(t.readValue(), 20));
          }
        }
        class Ju extends hl {
          coder;
          constructor(t) {
            super(t.name, t.type, "_", t.dynamic), (this.coder = t);
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(t, e) {
            return this.coder.encode(t, e);
          }
          decode(t) {
            return this.coder.decode(t);
          }
        }
        function _u(t, e, n) {
          let r = [];
          if (Array.isArray(n)) r = n;
          else if (n && "object" == typeof n) {
            let t = {};
            r = e.map((e) => {
              const r = e.localName;
              return (
                Ho(
                  r,
                  "cannot encode object for signature with missing names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                Ho(
                  !t[r],
                  "cannot encode object for signature with duplicate names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                (t[r] = !0),
                n[r]
              );
            });
          } else Go(!1, "invalid tuple value", "tuple", n);
          Go(e.length === r.length, "types/value length mismatch", "tuple", n);
          let s = new fl(),
            i = new fl(),
            o = [];
          e.forEach((t, e) => {
            let n = r[e];
            if (t.dynamic) {
              let e = i.length;
              t.encode(i, n);
              let r = s.writeUpdatableValue();
              o.push((t) => {
                r(t + e);
              });
            } else t.encode(s, n);
          }),
            o.forEach((t) => {
              t(s.length);
            });
          let a = t.appendWriter(s);
          return (a += t.appendWriter(i)), a;
        }
        function Ku(t, e) {
          let n = [],
            r = [],
            s = t.subReader(0);
          return (
            e.forEach((e) => {
              let i = null;
              if (e.dynamic) {
                let n = t.readIndex(),
                  r = s.subReader(n);
                try {
                  i = e.decode(r);
                } catch (t) {
                  if (Do(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              } else
                try {
                  i = e.decode(t);
                } catch (t) {
                  if (Do(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              if (null == i) throw new Error("investigate");
              n.push(i), r.push(e.localName || null);
            }),
            ul.fromItems(n, r)
          );
        }
        class qu extends hl {
          coder;
          length;
          constructor(t, e, n) {
            super(
              "array",
              t.type + "[" + (e >= 0 ? e : "") + "]",
              n,
              -1 === e || t.dynamic
            ),
              Fo(this, { coder: t, length: e });
          }
          defaultValue() {
            const t = this.coder.defaultValue(),
              e = [];
            for (let n = 0; n < this.length; n++) e.push(t);
            return e;
          }
          encode(t, e) {
            const n = Wu.dereference(e, "array");
            Array.isArray(n) || this._throwError("expected array value", n);
            let r = this.length;
            -1 === r && ((r = n.length), t.writeValue(n.length)),
              Vo(
                n.length,
                r,
                "coder array" + (this.localName ? " " + this.localName : "")
              );
            let s = [];
            for (let t = 0; t < n.length; t++) s.push(this.coder);
            return _u(t, s, n);
          }
          decode(t) {
            let e = this.length;
            -1 === e &&
              ((e = t.readIndex()),
              Ho(
                e * il <= t.dataLength,
                "insufficient data length",
                "BUFFER_OVERRUN",
                { buffer: t.bytes, offset: e * il, length: t.dataLength }
              ));
            let n = [];
            for (let t = 0; t < e; t++) n.push(new Ju(this.coder));
            return Ku(t, n);
          }
        }
        class Yu extends hl {
          constructor(t) {
            super("bool", "bool", t, !1);
          }
          defaultValue() {
            return !1;
          }
          encode(t, e) {
            const n = Wu.dereference(e, "bool");
            return t.writeValue(n ? 1 : 0);
          }
          decode(t) {
            return !!t.readValue();
          }
        }
        class Zu extends hl {
          constructor(t, e) {
            super(t, t, e, !0);
          }
          defaultValue() {
            return "0x";
          }
          encode(t, e) {
            e = Ko(e);
            let n = t.writeValue(e.length);
            return (n += t.writeBytes(e)), n;
          }
          decode(t) {
            return t.readBytes(t.readIndex(), !0);
          }
        }
        class Xu extends Zu {
          constructor(t) {
            super("bytes", t);
          }
          decode(t) {
            return Zo(super.decode(t));
          }
        }
        class td extends hl {
          size;
          constructor(t, e) {
            let n = "bytes" + String(t);
            super(n, n, e, !1), Fo(this, { size: t }, { size: "number" });
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + 2 * this.size
            );
          }
          encode(t, e) {
            let n = Ko(Wu.dereference(e, this.type));
            return (
              n.length !== this.size &&
                this._throwError("incorrect data length", e),
              t.writeBytes(n)
            );
          }
          decode(t) {
            return Zo(t.readBytes(this.size));
          }
        }
        const ed = new Uint8Array([]);
        class nd extends hl {
          constructor(t) {
            super("null", "", t, !1);
          }
          defaultValue() {
            return null;
          }
          encode(t, e) {
            return (
              null != e && this._throwError("not null", e), t.writeBytes(ed)
            );
          }
          decode(t) {
            return t.readBytes(0), null;
          }
        }
        const rd = BigInt(0),
          sd = BigInt(1),
          id = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        class od extends hl {
          size;
          signed;
          constructor(t, e, n) {
            const r = (e ? "int" : "uint") + 8 * t;
            super(r, r, n, !1),
              Fo(
                this,
                { size: t, signed: e },
                { size: "number", signed: "boolean" }
              );
          }
          defaultValue() {
            return 0;
          }
          encode(t, e) {
            let n = ua(Wu.dereference(e, this.type)),
              r = ca(id, 256);
            if (this.signed) {
              let t = ca(r, 8 * this.size - 1);
              (n > t || n < -(t + sd)) &&
                this._throwError("value out-of-bounds", e),
                (n = la(n, 256));
            } else
              (n < rd || n > ca(r, 8 * this.size)) &&
                this._throwError("value out-of-bounds", e);
            return t.writeValue(n);
          }
          decode(t) {
            let e = ca(t.readValue(), 8 * this.size);
            return this.signed && (e = aa(e, 8 * this.size)), e;
          }
        }
        class ad extends Zu {
          constructor(t) {
            super("string", t);
          }
          defaultValue() {
            return "";
          }
          encode(t, e) {
            return super.encode(t, $a(Wu.dereference(e, "string")));
          }
          decode(t) {
            return xa(super.decode(t));
          }
        }
        class ld extends hl {
          coders;
          constructor(t, e) {
            let n = !1;
            const r = [];
            t.forEach((t) => {
              t.dynamic && (n = !0), r.push(t.type);
            });
            super("tuple", "tuple(" + r.join(",") + ")", e, n),
              Fo(this, { coders: Object.freeze(t.slice()) });
          }
          defaultValue() {
            const t = [];
            this.coders.forEach((e) => {
              t.push(e.defaultValue());
            });
            const e = this.coders.reduce((t, e) => {
              const n = e.localName;
              return n && (t[n] || (t[n] = 0), t[n]++), t;
            }, {});
            return (
              this.coders.forEach((n, r) => {
                let s = n.localName;
                s &&
                  1 === e[s] &&
                  ("length" === s && (s = "_length"),
                  null == t[s] && (t[s] = t[r]));
              }),
              Object.freeze(t)
            );
          }
          encode(t, e) {
            const n = Wu.dereference(e, "tuple");
            return _u(t, this.coders, n);
          }
          decode(t) {
            return Ku(t, this.coders);
          }
        }
        function cd(t) {
          return mc($a(t));
        }
        function ud(t) {
          return (function (t) {
            let e = 0;
            return () => t[e++];
          })(
            (function (t) {
              let e = 0;
              function n() {
                return (t[e++] << 8) | t[e++];
              }
              let r = n(),
                s = 1,
                i = [0, 1];
              for (let t = 1; t < r; t++) i.push((s += n()));
              let o = n(),
                a = e;
              e += o;
              let l = 0,
                c = 0;
              function u() {
                return (
                  0 == l && ((c = (c << 8) | t[e++]), (l = 8)), (c >> --l) & 1
                );
              }
              const d = 2 ** 31,
                h = d >>> 1,
                f = d - 1;
              let p = 0;
              for (let t = 0; t < 31; t++) p = (p << 1) | u();
              let g = [],
                m = 0,
                y = d;
              for (;;) {
                let t = Math.floor(((p - m + 1) * s - 1) / y),
                  e = 0,
                  n = r;
                for (; n - e > 1; ) {
                  let r = (e + n) >>> 1;
                  t < i[r] ? (n = r) : (e = r);
                }
                if (0 == e) break;
                g.push(e);
                let o = m + Math.floor((y * i[e]) / s),
                  a = m + Math.floor((y * i[e + 1]) / s) - 1;
                for (; 0 == ((o ^ a) & h); )
                  (p = ((p << 1) & f) | u()),
                    (o = (o << 1) & f),
                    (a = ((a << 1) & f) | 1);
                for (; o & ~a & 536870912; )
                  (p = (p & h) | ((p << 1) & (f >>> 1)) | u()),
                    (o = (o << 1) ^ h),
                    (a = ((a ^ h) << 1) | h | 1);
                (m = o), (y = 1 + a - o);
              }
              let b = r - 4;
              return g.map((e) => {
                switch (e - b) {
                  case 3:
                    return (
                      b + 65792 + ((t[a++] << 16) | (t[a++] << 8) | t[a++])
                    );
                  case 2:
                    return b + 256 + ((t[a++] << 8) | t[a++]);
                  case 1:
                    return b + t[a++];
                  default:
                    return e - 1;
                }
              });
            })(
              (function (t) {
                let e = [];
                [
                  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                ].forEach((t, n) => (e[t.charCodeAt(0)] = n));
                let n = t.length,
                  r = new Uint8Array((6 * n) >> 3);
                for (let s = 0, i = 0, o = 0, a = 0; s < n; s++)
                  (a = (a << 6) | e[t.charCodeAt(s)]),
                    (o += 6),
                    o >= 8 && (r[i++] = a >> (o -= 8));
                return r;
              })(t)
            )
          );
        }
        function dd(t) {
          return 1 & t ? ~t >> 1 : t >> 1;
        }
        function hd(t, e) {
          let n = Array(t);
          for (let r = 0, s = 0; r < t; r++) n[r] = s += dd(e());
          return n;
        }
        function fd(t, e = 0) {
          let n = [];
          for (;;) {
            let r = t(),
              s = t();
            if (!s) break;
            e += r;
            for (let t = 0; t < s; t++) n.push(e + t);
            e += s + 1;
          }
          return n;
        }
        function pd(t) {
          return md(() => {
            let e = fd(t);
            if (e.length) return e;
          });
        }
        function gd(t) {
          let e = [];
          for (;;) {
            let n = t();
            if (0 == n) break;
            e.push(bd(n, t));
          }
          for (;;) {
            let n = t() - 1;
            if (n < 0) break;
            e.push(wd(n, t));
          }
          return e.flat();
        }
        function md(t) {
          let e = [];
          for (;;) {
            let n = t(e.length);
            if (!n) break;
            e.push(n);
          }
          return e;
        }
        function yd(t, e, n) {
          let r = Array(t)
            .fill()
            .map(() => []);
          for (let s = 0; s < e; s++) hd(t, n).forEach((t, e) => r[e].push(t));
          return r;
        }
        function bd(t, e) {
          let n = 1 + e(),
            r = e(),
            s = md(e);
          return yd(s.length, 1 + t, e).flatMap((t, e) => {
            let [i, ...o] = t;
            return Array(s[e])
              .fill()
              .map((t, e) => {
                let s = e * r;
                return [i + e * n, o.map((t) => t + s)];
              });
          });
        }
        function wd(t, e) {
          return yd(1 + e(), 1 + t, e).map((t) => [t[0], t.slice(1)]);
        }
        var vd = ud(
          "AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE"
        );
        const Ad = new Map([
            [8217, "apostrophe"],
            [8260, "fraction slash"],
            [12539, "middle dot"],
          ]),
          $d = 4;
        function xd(t) {
          return `{${(function (t) {
            return t.toString(16).toUpperCase().padStart(2, "0");
          })(t)}}`;
        }
        function kd(t) {
          let e = t.length;
          if (e < 4096) return String.fromCodePoint(...t);
          let n = [];
          for (let r = 0; r < e; )
            n.push(String.fromCodePoint(...t.slice(r, (r += 4096))));
          return n.join("");
        }
        var Ed = ud(
          "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g"
        );
        function Cd(t) {
          return (t >> 24) & 255;
        }
        function Sd(t) {
          return 16777215 & t;
        }
        const Pd = new Map(
            pd(Ed).flatMap((t, e) => t.map((t) => [t, (e + 1) << 24]))
          ),
          Id = new Set(fd(Ed)),
          Nd = new Map(),
          Bd = new Map();
        for (let [t, e] of gd(Ed)) {
          if (!Id.has(t) && 2 == e.length) {
            let [n, r] = e,
              s = Bd.get(n);
            s || ((s = new Map()), Bd.set(n, s)), s.set(r, t);
          }
          Nd.set(t, e.reverse());
        }
        const Td = 44032,
          Od = 4352,
          Rd = 4449,
          Ld = 4519,
          zd = 28,
          Fd = 21 * zd,
          Ud = Td + 19 * Fd,
          Dd = Od + 19,
          Md = Rd + 21,
          jd = Ld + zd;
        function Hd(t) {
          return t >= Td && t < Ud;
        }
        function Gd(t, e) {
          if (t >= Od && t < Dd && e >= Rd && e < Md)
            return Td + (t - Od) * Fd + (e - Rd) * zd;
          if (Hd(t) && e > Ld && e < jd && (t - Td) % zd == 0)
            return t + (e - Ld);
          {
            let n = Bd.get(t);
            return n && ((n = n.get(e)), n) ? n : -1;
          }
        }
        function Vd(t) {
          let e = [],
            n = [],
            r = !1;
          function s(t) {
            let n = Pd.get(t);
            n && ((r = !0), (t |= n)), e.push(t);
          }
          for (let r of t)
            for (;;) {
              if (r < 128) e.push(r);
              else if (Hd(r)) {
                let t = r - Td,
                  e = ((t % Fd) / zd) | 0,
                  n = t % zd;
                s(Od + ((t / Fd) | 0)), s(Rd + e), n > 0 && s(Ld + n);
              } else {
                let t = Nd.get(r);
                t ? n.push(...t) : s(r);
              }
              if (!n.length) break;
              r = n.pop();
            }
          if (r && e.length > 1) {
            let t = Cd(e[0]);
            for (let n = 1; n < e.length; n++) {
              let r = Cd(e[n]);
              if (0 == r || t <= r) {
                t = r;
                continue;
              }
              let s = n - 1;
              for (;;) {
                let n = e[s + 1];
                if (((e[s + 1] = e[s]), (e[s] = n), !s)) break;
                if (((t = Cd(e[--s])), t <= r)) break;
              }
              t = Cd(e[n]);
            }
          }
          return e;
        }
        function Wd(t) {
          return Vd(t).map(Sd);
        }
        function Qd(t) {
          return (function (t) {
            let e = [],
              n = [],
              r = -1,
              s = 0;
            for (let i of t) {
              let t = Cd(i),
                o = Sd(i);
              if (-1 == r) 0 == t ? (r = o) : e.push(o);
              else if (s > 0 && s >= t)
                0 == t ? (e.push(r, ...n), (n.length = 0), (r = o)) : n.push(o),
                  (s = t);
              else {
                let i = Gd(r, o);
                i >= 0
                  ? (r = i)
                  : 0 == s && 0 == t
                  ? (e.push(r), (r = o))
                  : (n.push(o), (s = t));
              }
            }
            return r >= 0 && e.push(r, ...n), e;
          })(Vd(t));
        }
        const Jd = 65039,
          _d = ".",
          Kd = 1,
          qd = 45;
        function Yd() {
          return new Set(fd(vd));
        }
        const Zd = new Map(gd(vd)),
          Xd = Yd(),
          th = Yd(),
          eh = new Set(
            fd(vd).map(
              function (t) {
                return this[t];
              },
              [...th]
            )
          ),
          nh = Yd();
        Yd();
        const rh = pd(vd);
        function sh() {
          return new Set([fd(vd).map((t) => rh[t]), fd(vd)].flat(2));
        }
        const ih = vd(),
          oh = md((t) => {
            let e = md(vd).map((t) => t + 96);
            if (e.length) {
              let n = t >= ih;
              (e[0] -= 32), (e = kd(e)), n && (e = `Restricted[${e}]`);
              let r = sh(),
                s = sh(),
                i = [...r, ...s].sort((t, e) => t - e);
              return { N: e, P: r, M: !vd(), R: n, V: new Set(i) };
            }
          }),
          ah = Yd(),
          lh = new Map();
        [...ah, ...Yd()]
          .sort((t, e) => t - e)
          .map((t, e, n) => {
            let r = vd(),
              s = (n[e] = r ? n[e - r] : { V: [], M: new Map() });
            s.V.push(t), ah.has(t) || lh.set(t, s);
          });
        for (let { V: t, M: e } of new Set(lh.values())) {
          let n = [];
          for (let e of t) {
            let t = oh.filter((t) => t.V.has(e)),
              r = n.find(({ G: e }) => t.some((t) => e.has(t)));
            r || ((r = { G: new Set(), V: [] }), n.push(r)),
              r.V.push(e),
              t.forEach((t) => r.G.add(t));
          }
          let r = n.flatMap(({ G: t }) => [...t]);
          for (let { G: t, V: s } of n) {
            let n = new Set(r.filter((e) => !t.has(e)));
            for (let t of s) e.set(t, n);
          }
        }
        let ch = new Set(),
          uh = new Set();
        for (let t of oh) for (let e of t.V) (ch.has(e) ? uh : ch).add(e);
        for (let t of ch) lh.has(t) || uh.has(t) || lh.set(t, Kd);
        const dh = new Set([...ch, ...Wd(ch)]),
          hh = fd(vd),
          fh = (function t(e) {
            let n = md(() => {
                let e = fd(vd).map((t) => hh[t]);
                if (e.length) return t(e);
              }).sort((t, e) => e.Q.size - t.Q.size),
              r = vd(),
              s = r % 3;
            r = (r / 3) | 0;
            let i = 1 & r;
            r >>= 1;
            let o = 1 & r,
              a = 2 & r;
            return { B: n, V: s, F: i, S: o, C: a, Q: new Set(e) };
          })([]);
        class ph extends Array {
          get is_emoji() {
            return !0;
          }
        }
        function gh(t, e = xd) {
          let n = [];
          var r;
          (r = t[0]), th.has(r) && n.push("");
          let s = 0,
            i = t.length;
          for (let r = 0; r < i; r++) {
            let i = t[r];
            wh(i) && (n.push(kd(t.slice(s, r))), n.push(e(i)), (s = r + 1));
          }
          return n.push(kd(t.slice(s, i))), n.join("");
        }
        function mh(t) {
          return (wh(t) ? "" : `${yh(gh([t]))} `) + xd(t);
        }
        function yh(t) {
          return `"${t}"`;
        }
        function bh(t) {
          for (let e = t.lastIndexOf(95); e > 0; )
            if (95 !== t[--e])
              throw new Error("underscore allowed only at start");
        }
        function wh(t) {
          return nh.has(t);
        }
        function vh(t) {
          return (function (t) {
            return t
              .map(({ input: e, error: n, output: r }) => {
                if (n) {
                  let r = n.message;
                  throw new Error(
                    1 == t.length ? r : `Invalid label ${yh(gh(e))}: ${r}`
                  );
                }
                return kd(r);
              })
              .join(_d);
          })(
            (function (t, e) {
              let n = 0;
              return t.split(_d).map((t) => {
                let r,
                  s = (function (t) {
                    let e = [];
                    for (let n = 0, r = t.length; n < r; ) {
                      let r = t.codePointAt(n);
                      (n += r < 65536 ? 1 : 2), e.push(r);
                    }
                    return e;
                  })(t),
                  i = { input: s, offset: n };
                n += s.length + 1;
                try {
                  let t,
                    n = (i.tokens = (function (t, e) {
                      let n = [],
                        r = [];
                      t = t.slice().reverse();
                      for (; t.length; ) {
                        let s = kh(t);
                        if (s) r.length && (n.push(e(r)), (r = [])), n.push(s);
                        else {
                          let e = t.pop();
                          if (dh.has(e)) r.push(e);
                          else {
                            let t = Zd.get(e);
                            if (t) r.push(...t);
                            else if (!Xd.has(e)) throw Ah(e);
                          }
                        }
                      }
                      r.length && n.push(e(r));
                      return n;
                    })(s, Qd)),
                    o = n.length;
                  if (!o) throw new Error("empty label");
                  {
                    let s = n[0],
                      a = o > 1 || s.is_emoji;
                    if (!a && s.every((t) => t < 128))
                      (r = s),
                        bh(r),
                        (function (t) {
                          if (t.length >= 4 && t[2] == qd && t[3] == qd)
                            throw new Error("invalid label extension");
                        })(r),
                        (t = "ASCII");
                    else if (
                      (a &&
                        ((i.emoji = !0),
                        (s = n.flatMap((t) => (t.is_emoji ? [] : t)))),
                      (r = n.flatMap((t) =>
                        !e && t.is_emoji ? t.filter((t) => t != Jd) : t
                      )),
                      bh(r),
                      s.length)
                    ) {
                      if (th.has(r[0])) throw xh("leading combining mark");
                      for (let t = 1; t < o; t++) {
                        let e = n[t];
                        if (!e.is_emoji && th.has(e[0]))
                          throw xh(
                            `emoji + combining mark: "${kd(n[t - 1])} + ${gh([
                              e[0],
                            ])}"`
                          );
                      }
                      !(function (t) {
                        let e = t[0],
                          n = Ad.get(e);
                        if (n) throw xh(`leading ${n}`);
                        let r = t.length,
                          s = -1;
                        for (let i = 1; i < r; i++) {
                          e = t[i];
                          let r = Ad.get(e);
                          if (r) {
                            if (s == i) throw xh(`${n} + ${r}`);
                            (s = i + 1), (n = r);
                          }
                        }
                        if (s == r) throw xh(`trailing ${n}`);
                      })(r);
                      let e = [...new Set(s)],
                        [i] = (function (t) {
                          let e = oh;
                          for (let n of t) {
                            let t = e.filter((t) => t.V.has(n));
                            if (!t.length) throw e === oh ? Ah(n) : $h(e[0], n);
                            if (((e = t), 1 == t.length)) break;
                          }
                          return e;
                        })(e);
                      !(function (t, e) {
                        let { V: n, M: r } = t;
                        for (let r of e) if (!n.has(r)) throw $h(t, r);
                        if (r) {
                          let t = Wd(e);
                          for (let e = 1, n = t.length; e < n; e++)
                            if (eh.has(t[e])) {
                              let r = e + 1;
                              for (let s; r < n && eh.has((s = t[r])); r++)
                                for (let n = e; n < r; n++)
                                  if (t[n] == s)
                                    throw new Error(
                                      `non-spacing marks: repeated ${mh(s)}`
                                    );
                              if (r - e > $d)
                                throw new Error(
                                  `non-spacing marks: too many ${yh(
                                    gh(t.slice(e - 1, r))
                                  )} (${r - e}/${$d})`
                                );
                              e = r;
                            }
                        }
                      })(i, s),
                        (function (t, e) {
                          let n,
                            r = [];
                          for (let t of e) {
                            let e = lh.get(t);
                            if (e === Kd) return;
                            if (e) {
                              let r = e.M.get(t);
                              if (
                                ((n = n ? n.filter((t) => r.has(t)) : [...r]),
                                !n.length)
                              )
                                return;
                            } else r.push(t);
                          }
                          if (n)
                            for (let e of n)
                              if (r.every((t) => e.V.has(t)))
                                throw new Error(
                                  `whole-script confusable: ${t.N}/${e.N}`
                                );
                        })(i, e),
                        (t = i.N);
                    } else t = "Emoji";
                  }
                  i.type = t;
                } catch (t) {
                  i.error = t;
                }
                return (i.output = r), i;
              });
            })(t)
          );
        }
        function Ah(t) {
          return new Error(`disallowed character: ${mh(t)}`);
        }
        function $h(t, e) {
          let n = mh(e),
            r = oh.find((t) => t.P.has(e));
          return (
            r && (n = `${r.N} ${n}`),
            new Error(`illegal mixture: ${t.N} + ${n}`)
          );
        }
        function xh(t) {
          return new Error(`illegal placement: ${t}`);
        }
        function kh(t, e) {
          let n,
            r,
            s = fh,
            i = [],
            o = t.length;
          for (e && (e.length = 0); o; ) {
            let a = t[--o];
            if (((s = s.B.find((t) => t.Q.has(a))), !s)) break;
            if (s.S) r = a;
            else if (s.C && a === r) break;
            i.push(a),
              s.F && (i.push(Jd), o > 0 && t[o - 1] == Jd && o--),
              s.V &&
                ((n = Eh(i, s)),
                e && e.push(...t.slice(o).reverse()),
                (t.length = o));
          }
          return n;
        }
        function Eh(t, e) {
          let n = ph.from(t);
          return 2 == e.V && n.splice(1, 1), n;
        }
        const Ch = new Uint8Array(32);
        function Sh(t) {
          return (
            Go(0 !== t.length, "invalid ENS name; empty component", "comp", t),
            t
          );
        }
        function Ph(t) {
          const e = $a(
              (function (t) {
                try {
                  return vh(t);
                } catch (e) {
                  Go(!1, `invalid ENS name (${e.message})`, "name", t);
                }
              })(t)
            ),
            n = [];
          if (0 === t.length) return n;
          let r = 0;
          for (let t = 0; t < e.length; t++) {
            46 === e[t] && (n.push(Sh(e.slice(r, t))), (r = t + 1));
          }
          return (
            Go(r < e.length, "invalid ENS name; empty component", "name", t),
            n.push(Sh(e.slice(r))),
            n
          );
        }
        function Ih(t) {
          Go("string" == typeof t, "invalid ENS name; not a string", "name", t);
          let e = Ch;
          const n = Ph(t);
          for (; n.length; ) e = mc(Xo([e, mc(n.pop())]));
          return Zo(e);
        }
        function Nh(t, e) {
          return {
            address: Fu(t),
            storageKeys: e.map(
              (t, e) => (
                Go(qo(t, 32), "invalid slot", `storageKeys[${e}]`, t),
                t.toLowerCase()
              )
            ),
          };
        }
        function Bh(t) {
          if (Array.isArray(t))
            return t.map((e, n) =>
              Array.isArray(e)
                ? (Go(2 === e.length, "invalid slot set", `value[${n}]`, e),
                  Nh(e[0], e[1]))
                : (Go(
                    null != e && "object" == typeof e,
                    "invalid address-slot set",
                    "value",
                    t
                  ),
                  Nh(e.address, e.storageKeys))
            );
          Go(
            null != t && "object" == typeof t,
            "invalid access list",
            "value",
            t
          );
          const e = Object.keys(t).map((e) => {
            const n = t[e].reduce((t, e) => ((t[e] = !0), t), {});
            return Nh(e, Object.keys(n).sort());
          });
          return e.sort((t, e) => t.address.localeCompare(e.address)), e;
        }
        function Th(t, e) {
          return (function (t) {
            let e;
            return (
              (e =
                "string" == typeof t
                  ? Nu.computePublicKey(t, !1)
                  : t.publicKey),
              Fu(mc("0x" + e.substring(4)).substring(26))
            );
          })(Nu.recoverPublicKey(t, e));
        }
        Ch.fill(0);
        const Oh = BigInt(0),
          Rh = BigInt(2),
          Lh = BigInt(27),
          zh = BigInt(28),
          Fh = BigInt(35),
          Uh = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        function Dh(t) {
          return "0x" === t ? null : Fu(t);
        }
        function Mh(t, e) {
          try {
            return Bh(t);
          } catch (n) {
            Go(!1, n.message, e, t);
          }
        }
        function jh(t, e) {
          return "0x" === t ? 0 : pa(t, e);
        }
        function Hh(t, e) {
          if ("0x" === t) return Oh;
          const n = ua(t, e);
          return Go(n <= Uh, "value exceeds uint size", e, n), n;
        }
        function Gh(t, e) {
          const n = ua(t, "value"),
            r = ma(n);
          return Go(r.length <= 32, "value too large", `tx.${e}`, n), r;
        }
        function Vh(t) {
          return Bh(t).map((t) => [t.address, t.storageKeys]);
        }
        function Wh(t, e) {
          const n = [
            Gh(t.nonce || 0, "nonce"),
            Gh(t.gasPrice || 0, "gasPrice"),
            Gh(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Fu(t.to) : "0x",
            Gh(t.value || 0, "value"),
            t.data || "0x",
          ];
          let r = Oh;
          if (t.chainId != Oh)
            (r = ua(t.chainId, "tx.chainId")),
              Go(
                !e || null == e.networkV || e.legacyChainId === r,
                "tx.chainId/sig.v mismatch",
                "sig",
                e
              );
          else if (t.signature) {
            const e = t.signature.legacyChainId;
            null != e && (r = e);
          }
          if (!e)
            return (
              r !== Oh && (n.push(ma(r)), n.push("0x"), n.push("0x")), el(n)
            );
          let s = BigInt(27 + e.yParity);
          return (
            r !== Oh
              ? (s = Iu.getChainIdV(r, e.v))
              : BigInt(e.v) !== s &&
                Go(!1, "tx.chainId/sig.v mismatch", "sig", e),
            n.push(ma(s)),
            n.push(ma(e.r)),
            n.push(ma(e.s)),
            el(n)
          );
        }
        function Qh(t, e) {
          let n;
          try {
            if (((n = jh(e[0], "yParity")), 0 !== n && 1 !== n))
              throw new Error("bad yParity");
          } catch (t) {
            Go(!1, "invalid yParity", "yParity", e[0]);
          }
          const r = ra(e[1], 32),
            s = ra(e[2], 32),
            i = Iu.from({ r: r, s: s, yParity: n });
          t.signature = i;
        }
        function Jh(t, e) {
          const n = [
            Gh(t.chainId || 0, "chainId"),
            Gh(t.nonce || 0, "nonce"),
            Gh(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
            Gh(t.maxFeePerGas || 0, "maxFeePerGas"),
            Gh(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Fu(t.to) : "0x",
            Gh(t.value || 0, "value"),
            t.data || "0x",
            Vh(t.accessList || []),
          ];
          return (
            e &&
              (n.push(Gh(e.yParity, "yParity")),
              n.push(ma(e.r)),
              n.push(ma(e.s))),
            Xo(["0x02", el(n)])
          );
        }
        function _h(t, e) {
          const n = [
            Gh(t.chainId || 0, "chainId"),
            Gh(t.nonce || 0, "nonce"),
            Gh(t.gasPrice || 0, "gasPrice"),
            Gh(t.gasLimit || 0, "gasLimit"),
            null != t.to ? Fu(t.to) : "0x",
            Gh(t.value || 0, "value"),
            t.data || "0x",
            Vh(t.accessList || []),
          ];
          return (
            e &&
              (n.push(Gh(e.yParity, "recoveryParam")),
              n.push(ma(e.r)),
              n.push(ma(e.s))),
            Xo(["0x01", el(n)])
          );
        }
        class Kh {
          #G;
          #V;
          #T;
          #W;
          #Q;
          #J;
          #_;
          #K;
          #q;
          #Y;
          #Z;
          #X;
          get type() {
            return this.#G;
          }
          set type(t) {
            switch (t) {
              case null:
                this.#G = null;
                break;
              case 0:
              case "legacy":
                this.#G = 0;
                break;
              case 1:
              case "berlin":
              case "eip-2930":
                this.#G = 1;
                break;
              case 2:
              case "london":
              case "eip-1559":
                this.#G = 2;
                break;
              default:
                Go(!1, "unsupported transaction type", "type", t);
            }
          }
          get typeName() {
            switch (this.type) {
              case 0:
                return "legacy";
              case 1:
                return "eip-2930";
              case 2:
                return "eip-1559";
            }
            return null;
          }
          get to() {
            return this.#V;
          }
          set to(t) {
            this.#V = null == t ? null : Fu(t);
          }
          get nonce() {
            return this.#W;
          }
          set nonce(t) {
            this.#W = pa(t, "value");
          }
          get gasLimit() {
            return this.#Q;
          }
          set gasLimit(t) {
            this.#Q = ua(t);
          }
          get gasPrice() {
            const t = this.#J;
            return null != t || (0 !== this.type && 1 !== this.type) ? t : Oh;
          }
          set gasPrice(t) {
            this.#J = null == t ? null : ua(t, "gasPrice");
          }
          get maxPriorityFeePerGas() {
            const t = this.#_;
            return null == t ? (2 === this.type ? Oh : null) : t;
          }
          set maxPriorityFeePerGas(t) {
            this.#_ = null == t ? null : ua(t, "maxPriorityFeePerGas");
          }
          get maxFeePerGas() {
            const t = this.#K;
            return null == t ? (2 === this.type ? Oh : null) : t;
          }
          set maxFeePerGas(t) {
            this.#K = null == t ? null : ua(t, "maxFeePerGas");
          }
          get data() {
            return this.#T;
          }
          set data(t) {
            this.#T = Zo(t);
          }
          get value() {
            return this.#q;
          }
          set value(t) {
            this.#q = ua(t, "value");
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = ua(t);
          }
          get signature() {
            return this.#Z || null;
          }
          set signature(t) {
            this.#Z = null == t ? null : Iu.from(t);
          }
          get accessList() {
            const t = this.#X || null;
            return null == t
              ? 1 === this.type || 2 === this.type
                ? []
                : null
              : t;
          }
          set accessList(t) {
            this.#X = null == t ? null : Bh(t);
          }
          constructor() {
            (this.#G = null),
              (this.#V = null),
              (this.#W = 0),
              (this.#Q = BigInt(0)),
              (this.#J = null),
              (this.#_ = null),
              (this.#K = null),
              (this.#T = "0x"),
              (this.#q = BigInt(0)),
              (this.#Y = BigInt(0)),
              (this.#Z = null),
              (this.#X = null);
          }
          get hash() {
            return null == this.signature ? null : mc(this.serialized);
          }
          get unsignedHash() {
            return mc(this.unsignedSerialized);
          }
          get from() {
            return null == this.signature
              ? null
              : Th(this.unsignedHash, this.signature);
          }
          get fromPublicKey() {
            return null == this.signature
              ? null
              : Nu.recoverPublicKey(this.unsignedHash, this.signature);
          }
          isSigned() {
            return null != this.signature;
          }
          get serialized() {
            switch (
              (Ho(
                null != this.signature,
                "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
                "UNSUPPORTED_OPERATION",
                { operation: ".serialized" }
              ),
              this.inferType())
            ) {
              case 0:
                return Wh(this, this.signature);
              case 1:
                return _h(this, this.signature);
              case 2:
                return Jh(this, this.signature);
            }
            Ho(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".serialized",
            });
          }
          get unsignedSerialized() {
            switch (this.inferType()) {
              case 0:
                return Wh(this);
              case 1:
                return _h(this);
              case 2:
                return Jh(this);
            }
            Ho(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".unsignedSerialized",
            });
          }
          inferType() {
            return this.inferTypes().pop();
          }
          inferTypes() {
            const t = null != this.gasPrice,
              e =
                null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
              n = null != this.accessList;
            null != this.maxFeePerGas &&
              null != this.maxPriorityFeePerGas &&
              Ho(
                this.maxFeePerGas >= this.maxPriorityFeePerGas,
                "priorityFee cannot be more than maxFee",
                "BAD_DATA",
                { value: this }
              ),
              Ho(
                !e || (0 !== this.type && 1 !== this.type),
                "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
                "BAD_DATA",
                { value: this }
              ),
              Ho(
                0 !== this.type || !n,
                "legacy transaction cannot have accessList",
                "BAD_DATA",
                { value: this }
              );
            const r = [];
            return (
              null != this.type
                ? r.push(this.type)
                : e
                ? r.push(2)
                : t
                ? (r.push(1), n || r.push(0))
                : n
                ? (r.push(1), r.push(2))
                : (r.push(0), r.push(1), r.push(2)),
              r.sort(),
              r
            );
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          clone() {
            return Kh.from(this);
          }
          toJSON() {
            const t = (t) => (null == t ? null : t.toString());
            return {
              type: this.type,
              to: this.to,
              data: this.data,
              nonce: this.nonce,
              gasLimit: t(this.gasLimit),
              gasPrice: t(this.gasPrice),
              maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
              maxFeePerGas: t(this.maxFeePerGas),
              value: t(this.value),
              chainId: t(this.chainId),
              sig: this.signature ? this.signature.toJSON() : null,
              accessList: this.accessList,
            };
          }
          static from(t) {
            if (null == t) return new Kh();
            if ("string" == typeof t) {
              const e = _o(t);
              if (e[0] >= 127)
                return Kh.from(
                  (function (t) {
                    const e = Ya(t);
                    Go(
                      Array.isArray(e) && (9 === e.length || 6 === e.length),
                      "invalid field count for legacy transaction",
                      "data",
                      t
                    );
                    const n = {
                      type: 0,
                      nonce: jh(e[0], "nonce"),
                      gasPrice: Hh(e[1], "gasPrice"),
                      gasLimit: Hh(e[2], "gasLimit"),
                      to: Dh(e[3]),
                      value: Hh(e[4], "value"),
                      data: Zo(e[5]),
                      chainId: Oh,
                    };
                    if (6 === e.length) return n;
                    const r = Hh(e[6], "v"),
                      s = Hh(e[7], "r"),
                      i = Hh(e[8], "s");
                    if (s === Oh && i === Oh) n.chainId = r;
                    else {
                      let s = (r - Fh) / Rh;
                      s < Oh && (s = Oh),
                        (n.chainId = s),
                        Go(
                          s !== Oh || r === Lh || r === zh,
                          "non-canonical legacy v",
                          "v",
                          e[6]
                        ),
                        (n.signature = Iu.from({
                          r: ra(e[7], 32),
                          s: ra(e[8], 32),
                          v: r,
                        })),
                        (n.hash = mc(t));
                    }
                    return n;
                  })(e)
                );
              switch (e[0]) {
                case 1:
                  return Kh.from(
                    (function (t) {
                      const e = Ya(_o(t).slice(1));
                      Go(
                        Array.isArray(e) && (8 === e.length || 11 === e.length),
                        "invalid field count for transaction type: 1",
                        "data",
                        Zo(t)
                      );
                      const n = {
                        type: 1,
                        chainId: Hh(e[0], "chainId"),
                        nonce: jh(e[1], "nonce"),
                        gasPrice: Hh(e[2], "gasPrice"),
                        gasLimit: Hh(e[3], "gasLimit"),
                        to: Dh(e[4]),
                        value: Hh(e[5], "value"),
                        data: Zo(e[6]),
                        accessList: Mh(e[7], "accessList"),
                      };
                      return (
                        8 === e.length || ((n.hash = mc(t)), Qh(n, e.slice(8))),
                        n
                      );
                    })(e)
                  );
                case 2:
                  return Kh.from(
                    (function (t) {
                      const e = Ya(_o(t).slice(1));
                      Go(
                        Array.isArray(e) && (9 === e.length || 12 === e.length),
                        "invalid field count for transaction type: 2",
                        "data",
                        Zo(t)
                      );
                      const n = Hh(e[2], "maxPriorityFeePerGas"),
                        r = Hh(e[3], "maxFeePerGas"),
                        s = {
                          type: 2,
                          chainId: Hh(e[0], "chainId"),
                          nonce: jh(e[1], "nonce"),
                          maxPriorityFeePerGas: n,
                          maxFeePerGas: r,
                          gasPrice: null,
                          gasLimit: Hh(e[4], "gasLimit"),
                          to: Dh(e[5]),
                          value: Hh(e[6], "value"),
                          data: Zo(e[7]),
                          accessList: Mh(e[8], "accessList"),
                        };
                      return (
                        9 === e.length || ((s.hash = mc(t)), Qh(s, e.slice(9))),
                        s
                      );
                    })(e)
                  );
              }
              Ho(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from",
              });
            }
            const e = new Kh();
            return (
              null != t.type && (e.type = t.type),
              null != t.to && (e.to = t.to),
              null != t.nonce && (e.nonce = t.nonce),
              null != t.gasLimit && (e.gasLimit = t.gasLimit),
              null != t.gasPrice && (e.gasPrice = t.gasPrice),
              null != t.maxPriorityFeePerGas &&
                (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas),
              null != t.maxFeePerGas && (e.maxFeePerGas = t.maxFeePerGas),
              null != t.data && (e.data = t.data),
              null != t.value && (e.value = t.value),
              null != t.chainId && (e.chainId = t.chainId),
              null != t.signature && (e.signature = Iu.from(t.signature)),
              null != t.accessList && (e.accessList = t.accessList),
              null != t.hash &&
                (Go(
                  e.isSigned(),
                  "unsigned transaction cannot define hash",
                  "tx",
                  t
                ),
                Go(e.hash === t.hash, "hash mismatch", "tx", t)),
              null != t.from &&
                (Go(
                  e.isSigned(),
                  "unsigned transaction cannot define from",
                  "tx",
                  t
                ),
                Go(
                  e.from.toLowerCase() === (t.from || "").toLowerCase(),
                  "from mismatch",
                  "tx",
                  t
                )),
              e
            );
          }
        }
        const qh = new Uint8Array(32);
        qh.fill(0);
        const Yh = BigInt(-1),
          Zh = BigInt(0),
          Xh = BigInt(1),
          tf = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        const ef = ga(Xh, 32),
          nf = ga(Zh, 32),
          rf = {
            name: "string",
            version: "string",
            chainId: "uint256",
            verifyingContract: "address",
            salt: "bytes32",
          },
          sf = ["name", "version", "chainId", "verifyingContract", "salt"];
        function of(t) {
          return function (e) {
            return (
              Go(
                "string" == typeof e,
                `invalid domain value for ${JSON.stringify(t)}`,
                `domain.${t}`,
                e
              ),
              e
            );
          };
        }
        const af = {
          name: of("name"),
          version: of("version"),
          chainId: function (t) {
            const e = ua(t, "domain.chainId");
            return (
              Go(e >= 0, "invalid chain ID", "domain.chainId", t),
              Number.isSafeInteger(e) ? Number(e) : ya(e)
            );
          },
          verifyingContract: function (t) {
            try {
              return Fu(t).toLowerCase();
            } catch (t) {}
            Go(
              !1,
              'invalid domain value "verifyingContract"',
              "domain.verifyingContract",
              t
            );
          },
          salt: function (t) {
            const e = _o(t, "domain.salt");
            return (
              Go(
                32 === e.length,
                'invalid domain value "salt"',
                "domain.salt",
                t
              ),
              Zo(e)
            );
          },
        };
        function lf(t) {
          {
            const e = t.match(/^(u?)int(\d*)$/);
            if (e) {
              const n = "" === e[1],
                r = parseInt(e[2] || "256");
              Go(
                r % 8 == 0 &&
                  0 !== r &&
                  r <= 256 &&
                  (null == e[2] || e[2] === String(r)),
                "invalid numeric width",
                "type",
                t
              );
              const s = ca(tf, n ? r - 1 : r),
                i = n ? (s + Xh) * Yh : Zh;
              return function (e) {
                const r = ua(e, "value");
                return (
                  Go(
                    r >= i && r <= s,
                    `value out-of-bounds for ${t}`,
                    "value",
                    r
                  ),
                  ga(n ? la(r, 256) : r, 32)
                );
              };
            }
          }
          {
            const e = t.match(/^bytes(\d+)$/);
            if (e) {
              const n = parseInt(e[1]);
              return (
                Go(
                  0 !== n && n <= 32 && e[1] === String(n),
                  "invalid bytes width",
                  "type",
                  t
                ),
                function (e) {
                  return (
                    Go(
                      _o(e).length === n,
                      `invalid length for ${t}`,
                      "value",
                      e
                    ),
                    (function (t) {
                      const e = _o(t),
                        n = e.length % 32;
                      return n ? Xo([e, qh.slice(n)]) : Zo(e);
                    })(e)
                  );
                }
              );
            }
          }
          switch (t) {
            case "address":
              return function (t) {
                return ra(Fu(t), 32);
              };
            case "bool":
              return function (t) {
                return t ? ef : nf;
              };
            case "bytes":
              return function (t) {
                return mc(t);
              };
            case "string":
              return function (t) {
                return cd(t);
              };
          }
          return null;
        }
        function cf(t, e) {
          return `${t}(${e
            .map(({ name: t, type: e }) => e + " " + t)
            .join(",")})`;
        }
        class uf {
          primaryType;
          #tt;
          get types() {
            return JSON.parse(this.#tt);
          }
          #et;
          #nt;
          constructor(t) {
            (this.#tt = JSON.stringify(t)),
              (this.#et = new Map()),
              (this.#nt = new Map());
            const e = new Map(),
              n = new Map(),
              r = new Map();
            Object.keys(t).forEach((t) => {
              e.set(t, new Set()), n.set(t, []), r.set(t, new Set());
            });
            for (const r in t) {
              const s = new Set();
              for (const i of t[r]) {
                Go(
                  !s.has(i.name),
                  `duplicate variable name ${JSON.stringify(
                    i.name
                  )} in ${JSON.stringify(r)}`,
                  "types",
                  t
                ),
                  s.add(i.name);
                const o = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                Go(
                  o !== r,
                  `circular type reference to ${JSON.stringify(o)}`,
                  "types",
                  t
                );
                lf(o) ||
                  (Go(
                    n.has(o),
                    `unknown type ${JSON.stringify(o)}`,
                    "types",
                    t
                  ),
                  n.get(o).push(r),
                  e.get(r).add(o));
              }
            }
            const s = Array.from(n.keys()).filter((t) => 0 === n.get(t).length);
            Go(0 !== s.length, "missing primary type", "types", t),
              Go(
                1 === s.length,
                `ambiguous primary types or unused types: ${s
                  .map((t) => JSON.stringify(t))
                  .join(", ")}`,
                "types",
                t
              ),
              Fo(this, { primaryType: s[0] }),
              (function s(i, o) {
                Go(
                  !o.has(i),
                  `circular type reference to ${JSON.stringify(i)}`,
                  "types",
                  t
                ),
                  o.add(i);
                for (const t of e.get(i))
                  if (n.has(t)) {
                    s(t, o);
                    for (const e of o) r.get(e).add(t);
                  }
                o.delete(i);
              })(this.primaryType, new Set());
            for (const [e, n] of r) {
              const r = Array.from(n);
              r.sort(),
                this.#et.set(
                  e,
                  cf(e, t[e]) + r.map((e) => cf(e, t[e])).join("")
                );
            }
          }
          getEncoder(t) {
            let e = this.#nt.get(t);
            return e || ((e = this.#rt(t)), this.#nt.set(t, e)), e;
          }
          #rt(t) {
            {
              const e = lf(t);
              if (e) return e;
            }
            const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (e) {
              const t = e[1],
                n = this.getEncoder(t);
              return (r) => {
                Go(
                  !e[3] || parseInt(e[3]) === r.length,
                  `array length mismatch; expected length ${parseInt(e[3])}`,
                  "value",
                  r
                );
                let s = r.map(n);
                return this.#et.has(t) && (s = s.map(mc)), mc(Xo(s));
              };
            }
            const n = this.types[t];
            if (n) {
              const e = cd(this.#et.get(t));
              return (t) => {
                const r = n.map(({ name: e, type: n }) => {
                  const r = this.getEncoder(n)(t[e]);
                  return this.#et.has(n) ? mc(r) : r;
                });
                return r.unshift(e), Xo(r);
              };
            }
            Go(!1, `unknown type: ${t}`, "type", t);
          }
          encodeType(t) {
            const e = this.#et.get(t);
            return Go(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
          }
          encodeData(t, e) {
            return this.getEncoder(t)(e);
          }
          hashStruct(t, e) {
            return mc(this.encodeData(t, e));
          }
          encode(t) {
            return this.encodeData(this.primaryType, t);
          }
          hash(t) {
            return this.hashStruct(this.primaryType, t);
          }
          _visit(t, e, n) {
            if (lf(t)) return n(t, e);
            const r = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (r)
              return (
                Go(
                  !r[3] || parseInt(r[3]) === e.length,
                  `array length mismatch; expected length ${parseInt(r[3])}`,
                  "value",
                  e
                ),
                e.map((t) => this._visit(r[1], t, n))
              );
            const s = this.types[t];
            if (s)
              return s.reduce(
                (t, { name: r, type: s }) => (
                  (t[r] = this._visit(s, e[r], n)), t
                ),
                {}
              );
            Go(!1, `unknown type: ${t}`, "type", t);
          }
          visit(t, e) {
            return this._visit(this.primaryType, t, e);
          }
          static from(t) {
            return new uf(t);
          }
          static getPrimaryType(t) {
            return uf.from(t).primaryType;
          }
          static hashStruct(t, e, n) {
            return uf.from(e).hashStruct(t, n);
          }
          static hashDomain(t) {
            const e = [];
            for (const n in t) {
              if (null == t[n]) continue;
              const r = rf[n];
              Go(
                r,
                `invalid typed-data domain key: ${JSON.stringify(n)}`,
                "domain",
                t
              ),
                e.push({ name: n, type: r });
            }
            return (
              e.sort((t, e) => sf.indexOf(t.name) - sf.indexOf(e.name)),
              uf.hashStruct("EIP712Domain", { EIP712Domain: e }, t)
            );
          }
          static encode(t, e, n) {
            return Xo(["0x1901", uf.hashDomain(t), uf.from(e).hash(n)]);
          }
          static hash(t, e, n) {
            return mc(uf.encode(t, e, n));
          }
          static async resolveNames(t, e, n, r) {
            t = Object.assign({}, t);
            for (const e in t) null == t[e] && delete t[e];
            const s = {};
            t.verifyingContract &&
              !qo(t.verifyingContract, 20) &&
              (s[t.verifyingContract] = "0x");
            const i = uf.from(e);
            i.visit(
              n,
              (t, e) => ("address" !== t || qo(e, 20) || (s[e] = "0x"), e)
            );
            for (const t in s) s[t] = await r(t);
            return (
              t.verifyingContract &&
                s[t.verifyingContract] &&
                (t.verifyingContract = s[t.verifyingContract]),
              {
                domain: t,
                value: (n = i.visit(n, (t, e) =>
                  "address" === t && s[e] ? s[e] : e
                )),
              }
            );
          }
          static getPayload(t, e, n) {
            uf.hashDomain(t);
            const r = {},
              s = [];
            sf.forEach((e) => {
              const n = t[e];
              null != n &&
                ((r[e] = af[e](n)), s.push({ name: e, type: rf[e] }));
            });
            const i = uf.from(e),
              o = Object.assign({}, e);
            return (
              Go(
                null == o.EIP712Domain,
                "types must not contain EIP712Domain type",
                "types.EIP712Domain",
                e
              ),
              (o.EIP712Domain = s),
              i.encode(n),
              {
                types: o,
                domain: r,
                primaryType: i.primaryType,
                message: i.visit(n, (t, e) => {
                  if (t.match(/^bytes(\d*)/)) return Zo(_o(e));
                  if (t.match(/^u?int/)) return ua(e).toString();
                  switch (t) {
                    case "address":
                      return e.toLowerCase();
                    case "bool":
                      return !!e;
                    case "string":
                      return (
                        Go("string" == typeof e, "invalid string", "value", e),
                        e
                      );
                  }
                  Go(!1, "unsupported type", "type", t);
                }),
              }
            );
          }
        }
        function df(t) {
          const e = new Set();
          return t.forEach((t) => e.add(t)), Object.freeze(e);
        }
        const hf =
            "constant external internal payable private public pure view",
          ff = df(hf.split(" ")),
          pf = "constructor error event fallback function receive struct",
          gf = df(pf.split(" ")),
          mf = "calldata memory storage payable indexed",
          yf = df(mf.split(" ")),
          bf = df([pf, mf, "tuple returns", hf].join(" ").split(" ")),
          wf = {
            "(": "OPEN_PAREN",
            ")": "CLOSE_PAREN",
            "[": "OPEN_BRACKET",
            "]": "CLOSE_BRACKET",
            ",": "COMMA",
            "@": "AT",
          },
          vf = new RegExp("^(\\s*)"),
          Af = new RegExp("^([0-9]+)"),
          $f = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
          xf = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
          kf = new RegExp(
            "^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"
          );
        class Ef {
          #L;
          #st;
          get offset() {
            return this.#L;
          }
          get length() {
            return this.#st.length - this.#L;
          }
          constructor(t) {
            (this.#L = 0), (this.#st = t.slice());
          }
          clone() {
            return new Ef(this.#st);
          }
          reset() {
            this.#L = 0;
          }
          #it(t = 0, e = 0) {
            return new Ef(
              this.#st
                .slice(t, e)
                .map((e) =>
                  Object.freeze(
                    Object.assign({}, e, {
                      match: e.match - t,
                      linkBack: e.linkBack - t,
                      linkNext: e.linkNext - t,
                    })
                  )
                )
            );
          }
          popKeyword(t) {
            const e = this.peek();
            if ("KEYWORD" !== e.type || !t.has(e.text))
              throw new Error(`expected keyword ${e.text}`);
            return this.pop().text;
          }
          popType(t) {
            if (this.peek().type !== t)
              throw new Error(
                `expected ${t}; got ${JSON.stringify(this.peek())}`
              );
            return this.pop().text;
          }
          popParen() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = this.#it(this.#L + 1, t.match + 1);
            return (this.#L = t.match + 1), e;
          }
          popParams() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = [];
            for (; this.#L < t.match - 1; ) {
              const t = this.peek().linkNext;
              e.push(this.#it(this.#L + 1, t)), (this.#L = t);
            }
            return (this.#L = t.match + 1), e;
          }
          peek() {
            if (this.#L >= this.#st.length) throw new Error("out-of-bounds");
            return this.#st[this.#L];
          }
          peekKeyword(t) {
            const e = this.peekType("KEYWORD");
            return null != e && t.has(e) ? e : null;
          }
          peekType(t) {
            if (0 === this.length) return null;
            const e = this.peek();
            return e.type === t ? e.text : null;
          }
          pop() {
            const t = this.peek();
            return this.#L++, t;
          }
          toString() {
            const t = [];
            for (let e = this.#L; e < this.#st.length; e++) {
              const n = this.#st[e];
              t.push(`${n.type}:${n.text}`);
            }
            return `<TokenString ${t.join(" ")}>`;
          }
        }
        function Cf(t) {
          const e = [],
            n = (e) => {
              const n = i < t.length ? JSON.stringify(t[i]) : "$EOI";
              throw new Error(`invalid token ${n} at ${i}: ${e}`);
            };
          let r = [],
            s = [],
            i = 0;
          for (; i < t.length; ) {
            let o = t.substring(i),
              a = o.match(vf);
            a && ((i += a[1].length), (o = t.substring(i)));
            const l = {
              depth: r.length,
              linkBack: -1,
              linkNext: -1,
              match: -1,
              type: "",
              text: "",
              offset: i,
              value: -1,
            };
            e.push(l);
            let c = wf[o[0]] || "";
            if (c) {
              if (((l.type = c), (l.text = o[0]), i++, "OPEN_PAREN" === c))
                r.push(e.length - 1), s.push(e.length - 1);
              else if ("CLOSE_PAREN" == c)
                0 === r.length && n("no matching open bracket"),
                  (l.match = r.pop()),
                  (e[l.match].match = e.length - 1),
                  l.depth--,
                  (l.linkBack = s.pop()),
                  (e[l.linkBack].linkNext = e.length - 1);
              else if ("COMMA" === c)
                (l.linkBack = s.pop()),
                  (e[l.linkBack].linkNext = e.length - 1),
                  s.push(e.length - 1);
              else if ("OPEN_BRACKET" === c) l.type = "BRACKET";
              else if ("CLOSE_BRACKET" === c) {
                let t = e.pop().text;
                if (e.length > 0 && "NUMBER" === e[e.length - 1].type) {
                  const n = e.pop().text;
                  (t = n + t), (e[e.length - 1].value = pa(n));
                }
                if (0 === e.length || "BRACKET" !== e[e.length - 1].type)
                  throw new Error("missing opening bracket");
                e[e.length - 1].text += t;
              }
            } else if (((a = o.match($f)), a)) {
              if (((l.text = a[1]), (i += l.text.length), bf.has(l.text))) {
                l.type = "KEYWORD";
                continue;
              }
              if (l.text.match(kf)) {
                l.type = "TYPE";
                continue;
              }
              l.type = "ID";
            } else {
              if (((a = o.match(Af)), !a))
                throw new Error(
                  `unexpected token ${JSON.stringify(o[0])} at position ${i}`
                );
              (l.text = a[1]), (l.type = "NUMBER"), (i += l.text.length);
            }
          }
          return new Ef(e.map((t) => Object.freeze(t)));
        }
        function Sf(t, e) {
          let n = [];
          for (const r in e.keys()) t.has(r) && n.push(r);
          if (n.length > 1)
            throw new Error(`conflicting types: ${n.join(", ")}`);
        }
        function Pf(t, e) {
          if (e.peekKeyword(gf)) {
            const n = e.pop().text;
            if (n !== t) throw new Error(`expected ${t}, got ${n}`);
          }
          return e.popType("ID");
        }
        function If(t, e) {
          const n = new Set();
          for (;;) {
            const r = t.peekType("KEYWORD");
            if (null == r || (e && !e.has(r))) break;
            if ((t.pop(), n.has(r)))
              throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
            n.add(r);
          }
          return Object.freeze(n);
        }
        function Nf(t) {
          let e = If(t, ff);
          return (
            Sf(e, df("constant payable nonpayable".split(" "))),
            Sf(e, df("pure view payable nonpayable".split(" "))),
            e.has("view")
              ? "view"
              : e.has("pure")
              ? "pure"
              : e.has("payable")
              ? "payable"
              : e.has("nonpayable")
              ? "nonpayable"
              : e.has("constant")
              ? "view"
              : "nonpayable"
          );
        }
        function Bf(t, e) {
          return t.popParams().map((t) => Wf.from(t, e));
        }
        function Tf(t) {
          if (t.peekType("AT")) {
            if ((t.pop(), t.peekType("NUMBER"))) return ua(t.pop().text);
            throw new Error("invalid gas");
          }
          return null;
        }
        function Of(t) {
          if (t.length) throw new Error(`unexpected tokens: ${t.toString()}`);
        }
        const Rf = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function Lf(t) {
          const e = t.match(kf);
          if ((Go(e, "invalid type", "type", t), "uint" === t))
            return "uint256";
          if ("int" === t) return "int256";
          if (e[2]) {
            const n = parseInt(e[2]);
            Go(0 !== n && n <= 32, "invalid bytes length", "type", t);
          } else if (e[3]) {
            const n = parseInt(e[3]);
            Go(
              0 !== n && n <= 256 && n % 8 == 0,
              "invalid numeric width",
              "type",
              t
            );
          }
          return t;
        }
        const zf = {},
          Ff = Symbol.for("_ethers_internal"),
          Uf = "_ParamTypeInternal",
          Df = "_ErrorInternal",
          Mf = "_EventInternal",
          jf = "_ConstructorInternal",
          Hf = "_FallbackInternal",
          Gf = "_FunctionInternal",
          Vf = "_StructInternal";
        class Wf {
          name;
          type;
          baseType;
          indexed;
          components;
          arrayLength;
          arrayChildren;
          constructor(t, e, n, r, s, i, o, a) {
            if (
              (Qo(t, zf, "ParamType"),
              Object.defineProperty(this, Ff, { value: Uf }),
              i && (i = Object.freeze(i.slice())),
              "array" === r)
            ) {
              if (null == o || null == a) throw new Error("");
            } else if (null != o || null != a) throw new Error("");
            if ("tuple" === r) {
              if (null == i) throw new Error("");
            } else if (null != i) throw new Error("");
            Fo(this, {
              name: e,
              type: n,
              baseType: r,
              indexed: s,
              components: i,
              arrayLength: o,
              arrayChildren: a,
            });
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t)) {
              const e = this.name || void 0;
              if (this.isArray()) {
                const t = JSON.parse(this.arrayChildren.format("json"));
                return (
                  (t.name = e),
                  (t.type += `[${
                    this.arrayLength < 0 ? "" : String(this.arrayLength)
                  }]`),
                  JSON.stringify(t)
                );
              }
              const n = {
                type: "tuple" === this.baseType ? "tuple" : this.type,
                name: e,
              };
              return (
                "boolean" == typeof this.indexed && (n.indexed = this.indexed),
                this.isTuple() &&
                  (n.components = this.components.map((e) =>
                    JSON.parse(e.format(t))
                  )),
                JSON.stringify(n)
              );
            }
            let e = "";
            return (
              this.isArray()
                ? ((e += this.arrayChildren.format(t)),
                  (e += `[${
                    this.arrayLength < 0 ? "" : String(this.arrayLength)
                  }]`))
                : this.isTuple()
                ? ("sighash" !== t && (e += this.type),
                  (e +=
                    "(" +
                    this.components
                      .map((e) => e.format(t))
                      .join("full" === t ? ", " : ",") +
                    ")"))
                : (e += this.type),
              "sighash" !== t &&
                (!0 === this.indexed && (e += " indexed"),
                "full" === t && this.name && (e += " " + this.name)),
              e
            );
          }
          isArray() {
            return "array" === this.baseType;
          }
          isTuple() {
            return "tuple" === this.baseType;
          }
          isIndexable() {
            return null != this.indexed;
          }
          walk(t, e) {
            if (this.isArray()) {
              if (!Array.isArray(t)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && t.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t) => n.arrayChildren.walk(t, e));
            }
            if (this.isTuple()) {
              if (!Array.isArray(t)) throw new Error("invalid tuple value");
              if (t.length !== this.components.length)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t, r) => n.components[r].walk(t, e));
            }
            return e(this.type, t);
          }
          #ot(t, e, n, r) {
            if (this.isArray()) {
              if (!Array.isArray(e)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && e.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const s = this.arrayChildren,
                i = e.slice();
              return (
                i.forEach((e, r) => {
                  s.#ot(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            if (this.isTuple()) {
              const s = this.components;
              let i;
              if (Array.isArray(e)) i = e.slice();
              else {
                if (null == e || "object" != typeof e)
                  throw new Error("invalid tuple value");
                i = s.map((t) => {
                  if (!t.name)
                    throw new Error(
                      "cannot use object value with unnamed components"
                    );
                  if (!(t.name in e))
                    throw new Error(`missing value for component ${t.name}`);
                  return e[t.name];
                });
              }
              if (i.length !== this.components.length)
                throw new Error("array is wrong length");
              return (
                i.forEach((e, r) => {
                  s[r].#ot(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            const s = n(this.type, e);
            s.then
              ? t.push(
                  (async function () {
                    r(await s);
                  })()
                )
              : r(s);
          }
          async walkAsync(t, e) {
            const n = [],
              r = [t];
            return (
              this.#ot(n, t, e, (t) => {
                r[0] = t;
              }),
              n.length && (await Promise.all(n)),
              r[0]
            );
          }
          static from(t, e) {
            if (Wf.isParamType(t)) return t;
            if ("string" == typeof t)
              try {
                return Wf.from(Cf(t), e);
              } catch (e) {
                Go(!1, "invalid param type", "obj", t);
              }
            else if (t instanceof Ef) {
              let n = "",
                r = "",
                s = null;
              If(t, df(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN")
                ? ((r = "tuple"),
                  (s = t.popParams().map((t) => Wf.from(t))),
                  (n = `tuple(${s.map((t) => t.format()).join(",")})`))
                : ((n = Lf(t.popType("TYPE"))), (r = n));
              let i = null,
                o = null;
              for (; t.length && t.peekType("BRACKET"); ) {
                const e = t.pop();
                (i = new Wf(zf, "", n, r, null, s, o, i)),
                  (o = e.value),
                  (n += e.text),
                  (r = "array"),
                  (s = null);
              }
              let a = null;
              if (If(t, yf).has("indexed")) {
                if (!e) throw new Error("");
                a = !0;
              }
              const l = t.peekType("ID") ? t.pop().text : "";
              if (t.length) throw new Error("leftover tokens");
              return new Wf(zf, l, n, r, a, s, o, i);
            }
            const n = t.name;
            Go(
              !n || ("string" == typeof n && n.match(xf)),
              "invalid name",
              "obj.name",
              n
            );
            let r = t.indexed;
            null != r &&
              (Go(e, "parameter cannot be indexed", "obj.indexed", t.indexed),
              (r = !!r));
            let s = t.type,
              i = s.match(Rf);
            if (i) {
              const e = parseInt(i[2] || "-1"),
                o = Wf.from({ type: i[1], components: t.components });
              return new Wf(zf, n || "", s, "array", r, null, e, o);
            }
            if ("tuple" === s || s.startsWith("tuple(") || s.startsWith("(")) {
              const e =
                null != t.components
                  ? t.components.map((t) => Wf.from(t))
                  : null;
              return new Wf(zf, n || "", s, "tuple", r, e, null, null);
            }
            return (
              (s = Lf(t.type)), new Wf(zf, n || "", s, s, r, null, null, null)
            );
          }
          static isParamType(t) {
            return t && t[Ff] === Uf;
          }
        }
        class Qf {
          type;
          inputs;
          constructor(t, e, n) {
            Qo(t, zf, "Fragment"),
              Fo(this, { type: e, inputs: (n = Object.freeze(n.slice())) });
          }
          static from(t) {
            if ("string" == typeof t) {
              try {
                Qf.from(JSON.parse(t));
              } catch (t) {}
              return Qf.from(Cf(t));
            }
            if (t instanceof Ef) {
              switch (t.peekKeyword(gf)) {
                case "constructor":
                  return Yf.from(t);
                case "error":
                  return Kf.from(t);
                case "event":
                  return qf.from(t);
                case "fallback":
                case "receive":
                  return Zf.from(t);
                case "function":
                  return Xf.from(t);
                case "struct":
                  return tp.from(t);
              }
            } else if ("object" == typeof t) {
              switch (t.type) {
                case "constructor":
                  return Yf.from(t);
                case "error":
                  return Kf.from(t);
                case "event":
                  return qf.from(t);
                case "fallback":
                case "receive":
                  return Zf.from(t);
                case "function":
                  return Xf.from(t);
                case "struct":
                  return tp.from(t);
              }
              Ho(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from",
              });
            }
            Go(!1, "unsupported frgament object", "obj", t);
          }
          static isConstructor(t) {
            return Yf.isFragment(t);
          }
          static isError(t) {
            return Kf.isFragment(t);
          }
          static isEvent(t) {
            return qf.isFragment(t);
          }
          static isFunction(t) {
            return Xf.isFragment(t);
          }
          static isStruct(t) {
            return tp.isFragment(t);
          }
        }
        class Jf extends Qf {
          name;
          constructor(t, e, n, r) {
            super(t, e, r),
              Go(
                "string" == typeof n && n.match(xf),
                "invalid identifier",
                "name",
                n
              ),
              (r = Object.freeze(r.slice())),
              Fo(this, { name: n });
          }
        }
        function _f(t, e) {
          return (
            "(" +
            e.map((e) => e.format(t)).join("full" === t ? ", " : ",") +
            ")"
          );
        }
        class Kf extends Jf {
          constructor(t, e, n) {
            super(t, "error", e, n),
              Object.defineProperty(this, Ff, { value: Df });
          }
          get selector() {
            return cd(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("error"),
              e.push(this.name + _f(t, this.inputs)),
              e.join(" ")
            );
          }
          static from(t) {
            if (Kf.isFragment(t)) return t;
            if ("string" == typeof t) return Kf.from(Cf(t));
            if (t instanceof Ef) {
              const e = Pf("error", t),
                n = Bf(t);
              return Of(t), new Kf(zf, e, n);
            }
            return new Kf(zf, t.name, t.inputs ? t.inputs.map(Wf.from) : []);
          }
          static isFragment(t) {
            return t && t[Ff] === Df;
          }
        }
        class qf extends Jf {
          anonymous;
          constructor(t, e, n, r) {
            super(t, "event", e, n),
              Object.defineProperty(this, Ff, { value: Mf }),
              Fo(this, { anonymous: r });
          }
          get topicHash() {
            return cd(this.format("sighash"));
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("event"),
              e.push(this.name + _f(t, this.inputs)),
              "sighash" !== t && this.anonymous && e.push("anonymous"),
              e.join(" ")
            );
          }
          static getTopicHash(t, e) {
            e = (e || []).map((t) => Wf.from(t));
            return new qf(zf, t, e, !1).topicHash;
          }
          static from(t) {
            if (qf.isFragment(t)) return t;
            if ("string" == typeof t)
              try {
                return qf.from(Cf(t));
              } catch (e) {
                Go(!1, "invalid event fragment", "obj", t);
              }
            else if (t instanceof Ef) {
              const e = Pf("event", t),
                n = Bf(t, !0),
                r = !!If(t, df(["anonymous"])).has("anonymous");
              return Of(t), new qf(zf, e, n, r);
            }
            return new qf(
              zf,
              t.name,
              t.inputs ? t.inputs.map((t) => Wf.from(t, !0)) : [],
              !!t.anonymous
            );
          }
          static isFragment(t) {
            return t && t[Ff] === Mf;
          }
        }
        class Yf extends Qf {
          payable;
          gas;
          constructor(t, e, n, r, s) {
            super(t, e, n),
              Object.defineProperty(this, Ff, { value: jf }),
              Fo(this, { payable: r, gas: s });
          }
          format(t) {
            if (
              (Ho(
                null != t && "sighash" !== t,
                "cannot format a constructor for sighash",
                "UNSUPPORTED_OPERATION",
                { operation: "format(sighash)" }
              ),
              "json" === t)
            )
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [`constructor${_f(t, this.inputs)}`];
            return (
              e.push(this.payable ? "payable" : "nonpayable"),
              null != this.gas && e.push(`@${this.gas.toString()}`),
              e.join(" ")
            );
          }
          static from(t) {
            if (Yf.isFragment(t)) return t;
            if ("string" == typeof t)
              try {
                return Yf.from(Cf(t));
              } catch (e) {
                Go(!1, "invalid constuctor fragment", "obj", t);
              }
            else if (t instanceof Ef) {
              If(t, df(["constructor"]));
              const e = Bf(t),
                n = !!If(t, df(["payable"])).has("payable"),
                r = Tf(t);
              return Of(t), new Yf(zf, "constructor", e, n, r);
            }
            return new Yf(
              zf,
              "constructor",
              t.inputs ? t.inputs.map(Wf.from) : [],
              !!t.payable,
              null != t.gas ? t.gas : null
            );
          }
          static isFragment(t) {
            return t && t[Ff] === jf;
          }
        }
        class Zf extends Qf {
          payable;
          constructor(t, e, n) {
            super(t, "fallback", e),
              Object.defineProperty(this, Ff, { value: Hf }),
              Fo(this, { payable: n });
          }
          format(t) {
            const e = 0 === this.inputs.length ? "receive" : "fallback";
            if ("json" === t) {
              const t = this.payable ? "payable" : "nonpayable";
              return JSON.stringify({ type: e, stateMutability: t });
            }
            return `${e}()${this.payable ? " payable" : ""}`;
          }
          static from(t) {
            if (Zf.isFragment(t)) return t;
            if ("string" == typeof t)
              try {
                return Zf.from(Cf(t));
              } catch (e) {
                Go(!1, "invalid fallback fragment", "obj", t);
              }
            else if (t instanceof Ef) {
              const e = t.toString();
              Go(
                t.peekKeyword(df(["fallback", "receive"])),
                "type must be fallback or receive",
                "obj",
                e
              );
              if ("receive" === t.popKeyword(df(["fallback", "receive"]))) {
                const e = Bf(t);
                return (
                  Go(
                    0 === e.length,
                    "receive cannot have arguments",
                    "obj.inputs",
                    e
                  ),
                  If(t, df(["payable"])),
                  Of(t),
                  new Zf(zf, [], !0)
                );
              }
              let n = Bf(t);
              n.length
                ? Go(
                    1 === n.length && "bytes" === n[0].type,
                    "invalid fallback inputs",
                    "obj.inputs",
                    n.map((t) => t.format("minimal")).join(", ")
                  )
                : (n = [Wf.from("bytes")]);
              const r = Nf(t);
              if (
                (Go(
                  "nonpayable" === r || "payable" === r,
                  "fallback cannot be constants",
                  "obj.stateMutability",
                  r
                ),
                If(t, df(["returns"])).has("returns"))
              ) {
                const e = Bf(t);
                Go(
                  1 === e.length && "bytes" === e[0].type,
                  "invalid fallback outputs",
                  "obj.outputs",
                  e.map((t) => t.format("minimal")).join(", ")
                );
              }
              return Of(t), new Zf(zf, n, "payable" === r);
            }
            if ("receive" === t.type) return new Zf(zf, [], !0);
            if ("fallback" === t.type) {
              const e = [Wf.from("bytes")],
                n = "payable" === t.stateMutability;
              return new Zf(zf, e, n);
            }
            Go(!1, "invalid fallback description", "obj", t);
          }
          static isFragment(t) {
            return t && t[Ff] === Hf;
          }
        }
        class Xf extends Jf {
          constant;
          outputs;
          stateMutability;
          payable;
          gas;
          constructor(t, e, n, r, s, i) {
            super(t, "function", e, r),
              Object.defineProperty(this, Ff, { value: Gf });
            Fo(this, {
              constant: "view" === n || "pure" === n,
              gas: i,
              outputs: (s = Object.freeze(s.slice())),
              payable: "payable" === n,
              stateMutability: n,
            });
          }
          get selector() {
            return cd(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  "nonpayable" !== this.stateMutability
                    ? this.stateMutability
                    : void 0,
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
                outputs: this.outputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("function"),
              e.push(this.name + _f(t, this.inputs)),
              "sighash" !== t &&
                ("nonpayable" !== this.stateMutability &&
                  e.push(this.stateMutability),
                this.outputs &&
                  this.outputs.length &&
                  (e.push("returns"), e.push(_f(t, this.outputs))),
                null != this.gas && e.push(`@${this.gas.toString()}`)),
              e.join(" ")
            );
          }
          static getSelector(t, e) {
            e = (e || []).map((t) => Wf.from(t));
            return new Xf(zf, t, "view", e, [], null).selector;
          }
          static from(t) {
            if (Xf.isFragment(t)) return t;
            if ("string" == typeof t)
              try {
                return Xf.from(Cf(t));
              } catch (e) {
                Go(!1, "invalid function fragment", "obj", t);
              }
            else if (t instanceof Ef) {
              const e = Pf("function", t),
                n = Bf(t),
                r = Nf(t);
              let s = [];
              If(t, df(["returns"])).has("returns") && (s = Bf(t));
              const i = Tf(t);
              return Of(t), new Xf(zf, e, r, n, s, i);
            }
            let e = t.stateMutability;
            return (
              null == e &&
                ((e = "payable"),
                "boolean" == typeof t.constant
                  ? ((e = "view"),
                    t.constant ||
                      ((e = "payable"),
                      "boolean" != typeof t.payable ||
                        t.payable ||
                        (e = "nonpayable")))
                  : "boolean" != typeof t.payable ||
                    t.payable ||
                    (e = "nonpayable")),
              new Xf(
                zf,
                t.name,
                e,
                t.inputs ? t.inputs.map(Wf.from) : [],
                t.outputs ? t.outputs.map(Wf.from) : [],
                null != t.gas ? t.gas : null
              )
            );
          }
          static isFragment(t) {
            return t && t[Ff] === Gf;
          }
        }
        class tp extends Jf {
          constructor(t, e, n) {
            super(t, "struct", e, n),
              Object.defineProperty(this, Ff, { value: Vf });
          }
          format() {
            throw new Error("@TODO");
          }
          static from(t) {
            if ("string" == typeof t)
              try {
                return tp.from(Cf(t));
              } catch (e) {
                Go(!1, "invalid struct fragment", "obj", t);
              }
            else if (t instanceof Ef) {
              const e = Pf("struct", t),
                n = Bf(t);
              return Of(t), new tp(zf, e, n);
            }
            return new tp(zf, t.name, t.inputs ? t.inputs.map(Wf.from) : []);
          }
          static isFragment(t) {
            return t && t[Ff] === Vf;
          }
        }
        const ep = new Map();
        ep.set(0, "GENERIC_PANIC"),
          ep.set(1, "ASSERT_FALSE"),
          ep.set(17, "OVERFLOW"),
          ep.set(18, "DIVIDE_BY_ZERO"),
          ep.set(33, "ENUM_RANGE_ERROR"),
          ep.set(34, "BAD_STORAGE_DATA"),
          ep.set(49, "STACK_UNDERFLOW"),
          ep.set(50, "ARRAY_RANGE_ERROR"),
          ep.set(65, "OUT_OF_MEMORY"),
          ep.set(81, "UNINITIALIZED_FUNCTION_CALL");
        const np = new RegExp(/^bytes([0-9]*)$/),
          rp = new RegExp(/^(u?int)([0-9]*)$/);
        let sp = null;
        class ip {
          #at(t) {
            if (t.isArray())
              return new qu(this.#at(t.arrayChildren), t.arrayLength, t.name);
            if (t.isTuple())
              return new ld(
                t.components.map((t) => this.#at(t)),
                t.name
              );
            switch (t.baseType) {
              case "address":
                return new Qu(t.name);
              case "bool":
                return new Yu(t.name);
              case "string":
                return new ad(t.name);
              case "bytes":
                return new Xu(t.name);
              case "":
                return new nd(t.name);
            }
            let e = t.type.match(rp);
            if (e) {
              let n = parseInt(e[2] || "256");
              return (
                Go(
                  0 !== n && n <= 256 && n % 8 == 0,
                  "invalid " + e[1] + " bit length",
                  "param",
                  t
                ),
                new od(n / 8, "int" === e[1], t.name)
              );
            }
            if (((e = t.type.match(np)), e)) {
              let n = parseInt(e[1]);
              return (
                Go(0 !== n && n <= 32, "invalid bytes length", "param", t),
                new td(n, t.name)
              );
            }
            Go(!1, "invalid type", "type", t.type);
          }
          getDefaultValue(t) {
            const e = t.map((t) => this.#at(Wf.from(t)));
            return new ld(e, "_").defaultValue();
          }
          encode(t, e) {
            Vo(e.length, t.length, "types/values length mismatch");
            const n = t.map((t) => this.#at(Wf.from(t))),
              r = new ld(n, "_"),
              s = new fl();
            return r.encode(s, e), s.data;
          }
          decode(t, e, n) {
            const r = t.map((t) => this.#at(Wf.from(t)));
            return new ld(r, "_").decode(new pl(e, n));
          }
          static defaultAbiCoder() {
            return null == sp && (sp = new ip()), sp;
          }
          static getBuiltinCallException(t, e, n) {
            return (function (t, e, n, r) {
              let s = "missing revert data",
                i = null,
                o = null;
              if (n) {
                s = "execution reverted";
                const t = _o(n);
                if (((n = Zo(n)), 0 === t.length))
                  (s += " (no data present; likely require(false) occurred"),
                    (i = "require(false)");
                else if (t.length % 32 != 4)
                  s += " (could not decode reason; invalid data length)";
                else if ("0x08c379a0" === Zo(t.slice(0, 4)))
                  try {
                    (i = r.decode(["string"], t.slice(4))[0]),
                      (o = {
                        signature: "Error(string)",
                        name: "Error",
                        args: [i],
                      }),
                      (s += `: ${JSON.stringify(i)}`);
                  } catch (t) {
                    s += " (could not decode reason; invalid string data)";
                  }
                else if ("0x4e487b71" === Zo(t.slice(0, 4)))
                  try {
                    const e = Number(r.decode(["uint256"], t.slice(4))[0]);
                    (o = {
                      signature: "Panic(uint256)",
                      name: "Panic",
                      args: [e],
                    }),
                      (i = `Panic due to ${ep.get(e) || "UNKNOWN"}(${e})`),
                      (s += `: ${i}`);
                  } catch (t) {
                    s += " (could not decode panic code)";
                  }
                else s += " (unknown custom error)";
              }
              const a = { to: e.to ? Fu(e.to) : null, data: e.data || "0x" };
              return (
                e.from && (a.from = Fu(e.from)),
                jo(s, "CALL_EXCEPTION", {
                  action: t,
                  data: n,
                  reason: i,
                  transaction: a,
                  invocation: null,
                  revert: o,
                })
              );
            })(t, e, n, ip.defaultAbiCoder());
          }
        }
        class op {
          fragment;
          name;
          signature;
          topic;
          args;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            Fo(this, { fragment: t, name: r, signature: s, topic: e, args: n });
          }
        }
        class ap {
          fragment;
          name;
          args;
          signature;
          selector;
          value;
          constructor(t, e, n, r) {
            const s = t.name,
              i = t.format();
            Fo(this, {
              fragment: t,
              name: s,
              args: n,
              signature: i,
              selector: e,
              value: r,
            });
          }
        }
        class lp {
          fragment;
          name;
          args;
          signature;
          selector;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            Fo(this, {
              fragment: t,
              name: r,
              args: n,
              signature: s,
              selector: e,
            });
          }
        }
        class cp {
          hash;
          _isIndexed;
          static isIndexed(t) {
            return !(!t || !t._isIndexed);
          }
          constructor(t) {
            Fo(this, { hash: t, _isIndexed: !0 });
          }
        }
        const up = {
            0: "generic panic",
            1: "assert(false)",
            17: "arithmetic overflow",
            18: "division or modulo by zero",
            33: "enum overflow",
            34: "invalid encoded storage byte array accessed",
            49: "out-of-bounds array access; popping on an empty array",
            50: "out-of-bounds access of an array or bytesN",
            65: "out of memory",
            81: "uninitialized function",
          },
          dp = {
            "0x08c379a0": {
              signature: "Error(string)",
              name: "Error",
              inputs: ["string"],
              reason: (t) => `reverted with reason string ${JSON.stringify(t)}`,
            },
            "0x4e487b71": {
              signature: "Panic(uint256)",
              name: "Panic",
              inputs: ["uint256"],
              reason: (t) => {
                let e = "unknown panic code";
                return (
                  t >= 0 &&
                    t <= 255 &&
                    up[t.toString()] &&
                    (e = up[t.toString()]),
                  `reverted with panic code 0x${t.toString(16)} (${e})`
                );
              },
            },
          };
        class hp {
          fragments;
          deploy;
          fallback;
          receive;
          #lt;
          #ct;
          #ut;
          #dt;
          constructor(t) {
            let e = [];
            (e = "string" == typeof t ? JSON.parse(t) : t),
              (this.#ut = new Map()),
              (this.#lt = new Map()),
              (this.#ct = new Map());
            const n = [];
            for (const t of e)
              try {
                n.push(Qf.from(t));
              } catch (t) {
                console.log("EE", t);
              }
            Fo(this, { fragments: Object.freeze(n) });
            let r = null,
              s = !1;
            (this.#dt = this.getAbiCoder()),
              this.fragments.forEach((t, e) => {
                let n;
                switch (t.type) {
                  case "constructor":
                    return this.deploy
                      ? void console.log("duplicate definition - constructor")
                      : void Fo(this, { deploy: t });
                  case "fallback":
                    return void (0 === t.inputs.length
                      ? (s = !0)
                      : (Go(
                          !r || t.payable !== r.payable,
                          "conflicting fallback fragments",
                          `fragments[${e}]`,
                          t
                        ),
                        (r = t),
                        (s = r.payable)));
                  case "function":
                    n = this.#ut;
                    break;
                  case "event":
                    n = this.#ct;
                    break;
                  case "error":
                    n = this.#lt;
                    break;
                  default:
                    return;
                }
                const i = t.format();
                n.has(i) || n.set(i, t);
              }),
              this.deploy || Fo(this, { deploy: Yf.from("constructor()") }),
              Fo(this, { fallback: r, receive: s });
          }
          format(t) {
            const e = t ? "minimal" : "full",
              n = this.fragments.map((t) => t.format(e));
            return n;
          }
          formatJson() {
            const t = this.fragments.map((t) => t.format("json"));
            return JSON.stringify(t.map((t) => JSON.parse(t)));
          }
          getAbiCoder() {
            return ip.defaultAbiCoder();
          }
          #ht(t, e, n) {
            if (qo(t)) {
              const e = t.toLowerCase();
              for (const t of this.#ut.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#ut) e.split("(")[0] === t && r.push(n);
              if (e) {
                const t = e.length > 0 ? e[e.length - 1] : null;
                let n = e.length,
                  s = !0;
                Wu.isTyped(t) && "overrides" === t.type && ((s = !1), n--);
                for (let t = r.length - 1; t >= 0; t--) {
                  const e = r[t].inputs.length;
                  e === n || (s && e === n - 1) || r.splice(t, 1);
                }
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if (Wu.isTyped(e[s])) {
                      if (s >= n.length) {
                        if ("overrides" === e[s].type) continue;
                        r.splice(t, 1);
                        break;
                      }
                      if (e[s].type !== n[s].baseType) {
                        r.splice(t, 1);
                        break;
                      }
                    }
                }
              }
              if (1 === r.length && e && e.length !== r[0].inputs.length) {
                const t = e[e.length - 1];
                (null == t || Array.isArray(t) || "object" != typeof t) &&
                  r.splice(0, 1);
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                const e = r.map((t) => JSON.stringify(t.format())).join(", ");
                Go(
                  !1,
                  `ambiguous function description (i.e. matches ${e})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#ut.get(Xf.from(t).format());
            return r || null;
          }
          getFunctionName(t) {
            const e = this.#ht(t, null, !1);
            return Go(e, "no matching function", "key", t), e.name;
          }
          hasFunction(t) {
            return !!this.#ht(t, null, !1);
          }
          getFunction(t, e) {
            return this.#ht(t, e || null, !0);
          }
          forEachFunction(t) {
            const e = Array.from(this.#ut.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ut.get(r), n);
            }
          }
          #ft(t, e, n) {
            if (qo(t)) {
              const e = t.toLowerCase();
              for (const t of this.#ct.values())
                if (e === t.topicHash) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#ct) e.split("(")[0] === t && r.push(n);
              if (e) {
                for (let t = r.length - 1; t >= 0; t--)
                  r[t].inputs.length < e.length && r.splice(t, 1);
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if (Wu.isTyped(e[s]) && e[s].type !== n[s].baseType) {
                      r.splice(t, 1);
                      break;
                    }
                }
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                const e = r.map((t) => JSON.stringify(t.format())).join(", ");
                Go(
                  !1,
                  `ambiguous event description (i.e. matches ${e})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#ct.get(qf.from(t).format());
            return r || null;
          }
          getEventName(t) {
            const e = this.#ft(t, null, !1);
            return Go(e, "no matching event", "key", t), e.name;
          }
          hasEvent(t) {
            return !!this.#ft(t, null, !1);
          }
          getEvent(t, e) {
            return this.#ft(t, e || null, !0);
          }
          forEachEvent(t) {
            const e = Array.from(this.#ct.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ct.get(r), n);
            }
          }
          getError(t, e) {
            if (qo(t)) {
              const e = t.toLowerCase();
              if (dp[e]) return Kf.from(dp[e].signature);
              for (const t of this.#lt.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const e = [];
              for (const [n, r] of this.#lt) n.split("(")[0] === t && e.push(r);
              if (0 === e.length)
                return "Error" === t
                  ? Kf.from("error Error(string)")
                  : "Panic" === t
                  ? Kf.from("error Panic(uint256)")
                  : null;
              if (e.length > 1) {
                const n = e.map((t) => JSON.stringify(t.format())).join(", ");
                Go(!1, `ambiguous error description (i.e. ${n})`, "name", t);
              }
              return e[0];
            }
            if ("Error(string)" === (t = Kf.from(t).format()))
              return Kf.from("error Error(string)");
            if ("Panic(uint256)" === t) return Kf.from("error Panic(uint256)");
            const n = this.#lt.get(t);
            return n || null;
          }
          forEachError(t) {
            const e = Array.from(this.#lt.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#lt.get(r), n);
            }
          }
          _decodeParams(t, e) {
            return this.#dt.decode(t, e);
          }
          _encodeParams(t, e) {
            return this.#dt.encode(t, e);
          }
          encodeDeploy(t) {
            return this._encodeParams(this.deploy.inputs, t || []);
          }
          decodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              Go(e, "unknown error", "fragment", t), (t = e);
            }
            return (
              Go(
                ea(e, 0, 4) === t.selector,
                `data signature does not match error ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, ea(e, 4))
            );
          }
          encodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              Go(e, "unknown error", "fragment", t), (t = e);
            }
            return Xo([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              Go(e, "unknown function", "fragment", t), (t = e);
            }
            return (
              Go(
                ea(e, 0, 4) === t.selector,
                `data signature does not match function ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, ea(e, 4))
            );
          }
          encodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              Go(e, "unknown function", "fragment", t), (t = e);
            }
            return Xo([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              Go(e, "unknown function", "fragment", t), (t = e);
            }
            let n = "invalid length for result data";
            const r = Ko(e);
            if (r.length % 32 == 0)
              try {
                return this.#dt.decode(t.outputs, r);
              } catch (t) {
                n = "could not decode result data";
              }
            Ho(!1, n, "BAD_DATA", {
              value: Zo(r),
              info: { method: t.name, signature: t.format() },
            });
          }
          makeError(t, e) {
            const n = _o(t, "data"),
              r = ip.getBuiltinCallException("call", e, n);
            if (
              r.message.startsWith("execution reverted (unknown custom error)")
            ) {
              const t = Zo(n.slice(0, 4)),
                e = this.getError(t);
              if (e)
                try {
                  const t = this.#dt.decode(e.inputs, n.slice(4));
                  (r.revert = { name: e.name, signature: e.format(), args: t }),
                    (r.reason = r.revert.signature),
                    (r.message = `execution reverted: ${r.reason}`);
                } catch (t) {
                  r.message =
                    "execution reverted (coult not decode custom error)";
                }
            }
            const s = this.parseTransaction(e);
            return (
              s &&
                (r.invocation = {
                  method: s.name,
                  signature: s.signature,
                  args: s.args,
                }),
              r
            );
          }
          encodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              Go(e, "unknown function", "fragment", t), (t = e);
            }
            return Zo(this.#dt.encode(t.outputs, e || []));
          }
          encodeFilterTopics(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              Go(e, "unknown event", "eventFragment", t), (t = e);
            }
            Ho(
              e.length <= t.inputs.length,
              `too many arguments for ${t.format()}`,
              "UNEXPECTED_ARGUMENT",
              { count: e.length, expectedCount: t.inputs.length }
            );
            const n = [];
            t.anonymous || n.push(t.topicHash);
            const r = (t, e) =>
              "string" === t.type
                ? cd(e)
                : "bytes" === t.type
                ? mc(Zo(e))
                : ("bool" === t.type && "boolean" == typeof e
                    ? (e = e ? "0x01" : "0x00")
                    : t.type.match(/^u?int/)
                    ? (e = ga(e))
                    : t.type.match(/^bytes/)
                    ? (e = na(e, 32, !1))
                    : "address" === t.type && this.#dt.encode(["address"], [e]),
                  ra(Zo(e), 32));
            for (
              e.forEach((e, s) => {
                const i = t.inputs[s];
                i.indexed
                  ? null == e
                    ? n.push(null)
                    : "array" === i.baseType || "tuple" === i.baseType
                    ? Go(
                        !1,
                        "filtering with tuples or arrays not supported",
                        "contract." + i.name,
                        e
                      )
                    : Array.isArray(e)
                    ? n.push(e.map((t) => r(i, t)))
                    : n.push(r(i, e))
                  : Go(
                      null == e,
                      "cannot filter non-indexed parameters; must be null",
                      "contract." + i.name,
                      e
                    );
              });
              n.length && null === n[n.length - 1];

            )
              n.pop();
            return n;
          }
          encodeEventLog(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              Go(e, "unknown event", "eventFragment", t), (t = e);
            }
            const n = [],
              r = [],
              s = [];
            return (
              t.anonymous || n.push(t.topicHash),
              Go(
                e.length === t.inputs.length,
                "event arguments/values mismatch",
                "values",
                e
              ),
              t.inputs.forEach((t, i) => {
                const o = e[i];
                if (t.indexed)
                  if ("string" === t.type) n.push(cd(o));
                  else if ("bytes" === t.type) n.push(mc(o));
                  else {
                    if ("tuple" === t.baseType || "array" === t.baseType)
                      throw new Error("not implemented");
                    n.push(this.#dt.encode([t.type], [o]));
                  }
                else r.push(t), s.push(o);
              }),
              { data: this.#dt.encode(r, s), topics: n }
            );
          }
          decodeEventLog(t, e, n) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              Go(e, "unknown event", "eventFragment", t), (t = e);
            }
            if (null != n && !t.anonymous) {
              const e = t.topicHash;
              Go(
                qo(n[0], 32) && n[0].toLowerCase() === e,
                "fragment/topic mismatch",
                "topics[0]",
                n[0]
              ),
                (n = n.slice(1));
            }
            const r = [],
              s = [],
              i = [];
            t.inputs.forEach((t, e) => {
              t.indexed
                ? "string" === t.type ||
                  "bytes" === t.type ||
                  "tuple" === t.baseType ||
                  "array" === t.baseType
                  ? (r.push(Wf.from({ type: "bytes32", name: t.name })),
                    i.push(!0))
                  : (r.push(t), i.push(!1))
                : (s.push(t), i.push(!1));
            });
            const o = null != n ? this.#dt.decode(r, Xo(n)) : null,
              a = this.#dt.decode(s, e, !0),
              l = [],
              c = [];
            let u = 0,
              d = 0;
            return (
              t.inputs.forEach((t, e) => {
                let n = null;
                if (t.indexed)
                  if (null == o) n = new cp(null);
                  else if (i[e]) n = new cp(o[d++]);
                  else
                    try {
                      n = o[d++];
                    } catch (t) {
                      n = t;
                    }
                else
                  try {
                    n = a[u++];
                  } catch (t) {
                    n = t;
                  }
                l.push(n), c.push(t.name || null);
              }),
              ul.fromItems(l, c)
            );
          }
          parseTransaction(t) {
            const e = _o(t.data, "tx.data"),
              n = ua(null != t.value ? t.value : 0, "tx.value"),
              r = this.getFunction(Zo(e.slice(0, 4)));
            if (!r) return null;
            const s = this.#dt.decode(r.inputs, e.slice(4));
            return new ap(r, r.selector, s, n);
          }
          parseCallResult(t) {
            throw new Error("@TODO");
          }
          parseLog(t) {
            const e = this.getEvent(t.topics[0]);
            return !e || e.anonymous
              ? null
              : new op(
                  e,
                  e.topicHash,
                  this.decodeEventLog(e, t.data, t.topics)
                );
          }
          parseError(t) {
            const e = Zo(t),
              n = this.getError(ea(e, 0, 4));
            if (!n) return null;
            const r = this.#dt.decode(n.inputs, ea(e, 4));
            return new lp(n, n.selector, r);
          }
          static from(t) {
            return t instanceof hp
              ? t
              : "string" == typeof t
              ? new hp(JSON.parse(t))
              : "function" == typeof t.format
              ? new hp(t.format("json"))
              : new hp(t);
          }
        }
        const fp = BigInt(0);
        function pp(t) {
          return null == t ? null : t;
        }
        function gp(t) {
          return null == t ? null : t.toString();
        }
        class mp {
          gasPrice;
          maxFeePerGas;
          maxPriorityFeePerGas;
          constructor(t, e, n) {
            Fo(this, {
              gasPrice: pp(t),
              maxFeePerGas: pp(e),
              maxPriorityFeePerGas: pp(n),
            });
          }
          toJSON() {
            const {
              gasPrice: t,
              maxFeePerGas: e,
              maxPriorityFeePerGas: n,
            } = this;
            return {
              _type: "FeeData",
              gasPrice: gp(t),
              maxFeePerGas: gp(e),
              maxPriorityFeePerGas: gp(n),
            };
          }
        }
        function yp(t) {
          const e = {};
          t.to && (e.to = t.to),
            t.from && (e.from = t.from),
            t.data && (e.data = Zo(t.data));
          const n =
            "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
              /,/
            );
          for (const r of n)
            r in t && null != t[r] && (e[r] = ua(t[r], `request.${r}`));
          const r = "type,nonce".split(/,/);
          for (const n of r)
            n in t && null != t[n] && (e[n] = pa(t[n], `request.${n}`));
          return (
            t.accessList && (e.accessList = Bh(t.accessList)),
            "blockTag" in t && (e.blockTag = t.blockTag),
            "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead),
            "customData" in t && (e.customData = t.customData),
            e
          );
        }
        class bp {
          provider;
          number;
          hash;
          timestamp;
          parentHash;
          nonce;
          difficulty;
          gasLimit;
          gasUsed;
          miner;
          extraData;
          baseFeePerGas;
          #pt;
          constructor(t, e) {
            (this.#pt = t.transactions.map((t) =>
              "string" != typeof t ? new Ap(t, e) : t
            )),
              Fo(this, {
                provider: e,
                hash: pp(t.hash),
                number: t.number,
                timestamp: t.timestamp,
                parentHash: t.parentHash,
                nonce: t.nonce,
                difficulty: t.difficulty,
                gasLimit: t.gasLimit,
                gasUsed: t.gasUsed,
                miner: t.miner,
                extraData: t.extraData,
                baseFeePerGas: pp(t.baseFeePerGas),
              });
          }
          get transactions() {
            return this.#pt.map((t) => ("string" == typeof t ? t : t.hash));
          }
          get prefetchedTransactions() {
            const t = this.#pt.slice();
            return 0 === t.length
              ? []
              : (Ho(
                  "object" == typeof t[0],
                  "transactions were not prefetched with block request",
                  "UNSUPPORTED_OPERATION",
                  { operation: "transactionResponses()" }
                ),
                t);
          }
          toJSON() {
            const {
              baseFeePerGas: t,
              difficulty: e,
              extraData: n,
              gasLimit: r,
              gasUsed: s,
              hash: i,
              miner: o,
              nonce: a,
              number: l,
              parentHash: c,
              timestamp: u,
              transactions: d,
            } = this;
            return {
              _type: "Block",
              baseFeePerGas: gp(t),
              difficulty: gp(e),
              extraData: n,
              gasLimit: gp(r),
              gasUsed: gp(s),
              hash: i,
              miner: o,
              nonce: a,
              number: l,
              parentHash: c,
              timestamp: u,
              transactions: d,
            };
          }
          [Symbol.iterator]() {
            let t = 0;
            const e = this.transactions;
            return {
              next: () =>
                t < this.length
                  ? { value: e[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get length() {
            return this.#pt.length;
          }
          get date() {
            return null == this.timestamp
              ? null
              : new Date(1e3 * this.timestamp);
          }
          async getTransaction(t) {
            let e;
            if ("number" == typeof t) e = this.#pt[t];
            else {
              const n = t.toLowerCase();
              for (const t of this.#pt) {
                if ("string" == typeof t) {
                  if (t !== n) continue;
                  e = t;
                  break;
                }
                if (t.hash !== n) {
                  e = t;
                  break;
                }
              }
            }
            if (null == e) throw new Error("no such tx");
            return "string" == typeof e
              ? await this.provider.getTransaction(e)
              : e;
          }
          getPrefetchedTransaction(t) {
            const e = this.prefetchedTransactions;
            if ("number" == typeof t) return e[t];
            t = t.toLowerCase();
            for (const n of e) if (n.hash === t) return n;
            Go(!1, "no matching transaction", "indexOrHash", t);
          }
          isMined() {
            return !!this.hash;
          }
          isLondon() {
            return !!this.baseFeePerGas;
          }
          orphanedEvent() {
            if (!this.isMined()) throw new Error("");
            return {
              orphan: "drop-block",
              hash: (t = this).hash,
              number: t.number,
            };
            var t;
          }
        }
        class wp {
          provider;
          transactionHash;
          blockHash;
          blockNumber;
          removed;
          address;
          data;
          topics;
          index;
          transactionIndex;
          constructor(t, e) {
            this.provider = e;
            const n = Object.freeze(t.topics.slice());
            Fo(this, {
              transactionHash: t.transactionHash,
              blockHash: t.blockHash,
              blockNumber: t.blockNumber,
              removed: t.removed,
              address: t.address,
              data: t.data,
              topics: n,
              index: t.index,
              transactionIndex: t.transactionIndex,
            });
          }
          toJSON() {
            const {
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: o,
              transactionHash: a,
              transactionIndex: l,
            } = this;
            return {
              _type: "log",
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: o,
              transactionHash: a,
              transactionIndex: l,
            };
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            return (
              Ho(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t
            );
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.transactionHash);
            return (
              Ho(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t
            );
          }
          async getTransactionReceipt() {
            const t = await this.provider.getTransactionReceipt(
              this.transactionHash
            );
            return (
              Ho(
                !!t,
                "failed to find transaction receipt",
                "UNKNOWN_ERROR",
                {}
              ),
              t
            );
          }
          removedEvent() {
            return {
              orphan: "drop-log",
              log: {
                transactionHash: (t = this).transactionHash,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                address: t.address,
                data: t.data,
                topics: Object.freeze(t.topics.slice()),
                index: t.index,
              },
            };
            var t;
          }
        }
        class vp {
          provider;
          to;
          from;
          contractAddress;
          hash;
          index;
          blockHash;
          blockNumber;
          logsBloom;
          gasUsed;
          cumulativeGasUsed;
          gasPrice;
          type;
          status;
          root;
          #gt;
          constructor(t, e) {
            this.#gt = Object.freeze(t.logs.map((t) => new wp(t, e)));
            let n = fp;
            null != t.effectiveGasPrice
              ? (n = t.effectiveGasPrice)
              : null != t.gasPrice && (n = t.gasPrice),
              Fo(this, {
                provider: e,
                to: t.to,
                from: t.from,
                contractAddress: t.contractAddress,
                hash: t.hash,
                index: t.index,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                logsBloom: t.logsBloom,
                gasUsed: t.gasUsed,
                cumulativeGasUsed: t.cumulativeGasUsed,
                gasPrice: n,
                type: t.type,
                status: t.status,
                root: t.root,
              });
          }
          get logs() {
            return this.#gt;
          }
          toJSON() {
            const {
              to: t,
              from: e,
              contractAddress: n,
              hash: r,
              index: s,
              blockHash: i,
              blockNumber: o,
              logsBloom: a,
              logs: l,
              status: c,
              root: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              blockHash: i,
              blockNumber: o,
              contractAddress: n,
              cumulativeGasUsed: gp(this.cumulativeGasUsed),
              from: e,
              gasPrice: gp(this.gasPrice),
              gasUsed: gp(this.gasUsed),
              hash: r,
              index: s,
              logs: l,
              logsBloom: a,
              root: u,
              status: c,
              to: t,
            };
          }
          get length() {
            return this.logs.length;
          }
          [Symbol.iterator]() {
            let t = 0;
            return {
              next: () =>
                t < this.length
                  ? { value: this.logs[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get fee() {
            return this.gasUsed * this.gasPrice;
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.hash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getResult() {
            return await this.provider.getTransactionResult(this.hash);
          }
          async confirmations() {
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          removedEvent() {
            return xp(this);
          }
          reorderedEvent(t) {
            return (
              Ho(
                !t || t.isMined(),
                "unmined 'other' transction cannot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "reorderedEvent(other)" }
              ),
              $p(this, t)
            );
          }
        }
        class Ap {
          provider;
          blockNumber;
          blockHash;
          index;
          hash;
          type;
          to;
          from;
          nonce;
          gasLimit;
          gasPrice;
          maxPriorityFeePerGas;
          maxFeePerGas;
          data;
          value;
          chainId;
          signature;
          accessList;
          #mt;
          constructor(t, e) {
            (this.provider = e),
              (this.blockNumber = null != t.blockNumber ? t.blockNumber : null),
              (this.blockHash = null != t.blockHash ? t.blockHash : null),
              (this.hash = t.hash),
              (this.index = t.index),
              (this.type = t.type),
              (this.from = t.from),
              (this.to = t.to || null),
              (this.gasLimit = t.gasLimit),
              (this.nonce = t.nonce),
              (this.data = t.data),
              (this.value = t.value),
              (this.gasPrice = t.gasPrice),
              (this.maxPriorityFeePerGas =
                null != t.maxPriorityFeePerGas ? t.maxPriorityFeePerGas : null),
              (this.maxFeePerGas =
                null != t.maxFeePerGas ? t.maxFeePerGas : null),
              (this.chainId = t.chainId),
              (this.signature = t.signature),
              (this.accessList = null != t.accessList ? t.accessList : null),
              (this.#mt = -1);
          }
          toJSON() {
            const {
              blockNumber: t,
              blockHash: e,
              index: n,
              hash: r,
              type: s,
              to: i,
              from: o,
              nonce: a,
              data: l,
              signature: c,
              accessList: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              accessList: u,
              blockNumber: t,
              blockHash: e,
              chainId: gp(this.chainId),
              data: l,
              from: o,
              gasLimit: gp(this.gasLimit),
              gasPrice: gp(this.gasPrice),
              hash: r,
              maxFeePerGas: gp(this.maxFeePerGas),
              maxPriorityFeePerGas: gp(this.maxPriorityFeePerGas),
              nonce: a,
              signature: c,
              to: i,
              index: n,
              type: s,
              value: gp(this.value),
            };
          }
          async getBlock() {
            let t = this.blockNumber;
            if (null == t) {
              const e = await this.getTransaction();
              e && (t = e.blockNumber);
            }
            if (null == t) return null;
            const e = this.provider.getBlock(t);
            if (null == e) throw new Error("TODO");
            return e;
          }
          async getTransaction() {
            return this.provider.getTransaction(this.hash);
          }
          async confirmations() {
            if (null == this.blockNumber) {
              const { tx: t, blockNumber: e } = await zo({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(),
              });
              return null == t || null == t.blockNumber
                ? 0
                : e - t.blockNumber + 1;
            }
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          async wait(t, e) {
            const n = null == t ? 1 : t,
              r = null == e ? 0 : e;
            let s = this.#mt,
              i = -1,
              o = -1 === s;
            const a = async () => {
                if (o) return null;
                const { blockNumber: t, nonce: e } = await zo({
                  blockNumber: this.provider.getBlockNumber(),
                  nonce: this.provider.getTransactionCount(this.from),
                });
                if (e < this.nonce) return void (s = t);
                if (o) return null;
                const r = await this.getTransaction();
                if (!r || null == r.blockNumber)
                  for (
                    -1 === i && ((i = s - 3), i < this.#mt && (i = this.#mt));
                    i <= t;

                  ) {
                    if (o) return null;
                    const e = await this.provider.getBlock(i, !0);
                    if (null == e) return;
                    for (const t of e) if (t === this.hash) return;
                    for (let r = 0; r < e.length; r++) {
                      const i = await e.getTransaction(r);
                      if (i.from === this.from && i.nonce === this.nonce) {
                        if (o) return null;
                        const e = await this.provider.getTransactionReceipt(
                          i.hash
                        );
                        if (null == e) return;
                        if (t - e.blockNumber + 1 < n) return;
                        let r = "replaced";
                        i.data === this.data &&
                        i.to === this.to &&
                        i.value === this.value
                          ? (r = "repriced")
                          : "0x" === i.data &&
                            i.from === i.to &&
                            i.value === fp &&
                            (r = "cancelled"),
                          Ho(
                            !1,
                            "transaction was replaced",
                            "TRANSACTION_REPLACED",
                            {
                              cancelled: "replaced" === r || "cancelled" === r,
                              reason: r,
                              replacement: i.replaceableTransaction(s),
                              hash: i.hash,
                              receipt: e,
                            }
                          );
                      }
                    }
                    i++;
                  }
              },
              l = await this.provider.getTransactionReceipt(this.hash);
            if (0 === n) return l;
            if (l) {
              if ((await l.confirmations()) >= n) return l;
            } else if ((await a(), 0 === n)) return null;
            const c = new Promise((t, e) => {
              const i = [],
                l = () => {
                  i.forEach((t) => t());
                };
              if (
                (i.push(() => {
                  o = !0;
                }),
                r > 0)
              ) {
                const t = setTimeout(() => {
                  l(), e(jo("wait for transaction timeout", "TIMEOUT"));
                }, r);
                i.push(() => {
                  clearTimeout(t);
                });
              }
              const c = async (e) => {
                (await e.confirmations()) >= n && (l(), t(e));
              };
              if (
                (i.push(() => {
                  this.provider.off(this.hash, c);
                }),
                this.provider.on(this.hash, c),
                s >= 0)
              ) {
                const t = async () => {
                  try {
                    await a();
                  } catch (t) {
                    if (Do(t, "TRANSACTION_REPLACED")) return l(), void e(t);
                  }
                  o || this.provider.once("block", t);
                };
                i.push(() => {
                  this.provider.off("block", t);
                }),
                  this.provider.once("block", t);
              }
            });
            return await c;
          }
          isMined() {
            return null != this.blockHash;
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          removedEvent() {
            return (
              Ho(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              xp(this)
            );
          }
          reorderedEvent(t) {
            return (
              Ho(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              Ho(
                !t || t.isMined(),
                "unmined 'other' transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              $p(this, t)
            );
          }
          replaceableTransaction(t) {
            Go(
              Number.isInteger(t) && t >= 0,
              "invalid startBlock",
              "startBlock",
              t
            );
            const e = new Ap(this, this.provider);
            return (e.#mt = t), e;
          }
        }
        function $p(t, e) {
          return { orphan: "reorder-transaction", tx: t, other: e };
        }
        function xp(t) {
          return { orphan: "drop-transaction", tx: t };
        }
        class kp extends wp {
          interface;
          fragment;
          args;
          constructor(t, e, n) {
            super(t, t.provider);
            Fo(this, {
              args: e.decodeEventLog(n, t.data, t.topics),
              fragment: n,
              interface: e,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        class Ep extends vp {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          get logs() {
            return super.logs.map((t) => {
              const e = t.topics.length ? this.#yt.getEvent(t.topics[0]) : null;
              return e ? new kp(t, this.#yt, e) : t;
            });
          }
        }
        class Cp extends Ap {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          async wait(t) {
            const e = await super.wait(t);
            return null == e ? null : new Ep(this.#yt, this.provider, e);
          }
        }
        class Sp extends wa {
          log;
          constructor(t, e, n, r) {
            super(t, e, n), Fo(this, { log: r });
          }
          async getBlock() {
            return await this.log.getBlock();
          }
          async getTransaction() {
            return await this.log.getTransaction();
          }
          async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
          }
        }
        class Pp extends Sp {
          constructor(t, e, n, r, s) {
            super(t, e, n, new kp(s, t.interface, r));
            Fo(this, {
              args: t.interface.decodeEventLog(
                r,
                this.log.data,
                this.log.topics
              ),
              fragment: r,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        const Ip = BigInt(0);
        function Np(t) {
          return t && "function" == typeof t.call;
        }
        function Bp(t) {
          return t && "function" == typeof t.estimateGas;
        }
        function Tp(t) {
          return t && "function" == typeof t.resolveName;
        }
        function Op(t) {
          return t && "function" == typeof t.sendTransaction;
        }
        class Rp {
          #bt;
          fragment;
          constructor(t, e, n) {
            if ((Fo(this, { fragment: e }), e.inputs.length < n.length))
              throw new Error("too many arguments");
            const r = Lp(t.runner, "resolveName"),
              s = Tp(r) ? r : null;
            this.#bt = (async function () {
              const r = await Promise.all(
                e.inputs.map((t, e) =>
                  null == n[e]
                    ? null
                    : t.walkAsync(n[e], (t, e) =>
                        "address" === t
                          ? Array.isArray(e)
                            ? Promise.all(e.map((t) => Mu(t, s)))
                            : Mu(e, s)
                          : e
                      )
                )
              );
              return t.interface.encodeFilterTopics(e, r);
            })();
          }
          getTopicFilter() {
            return this.#bt;
          }
        }
        function Lp(t, e) {
          return null == t
            ? null
            : "function" == typeof t[e]
            ? t
            : t.provider && "function" == typeof t.provider[e]
            ? t.provider
            : null;
        }
        function zp(t) {
          return null == t ? null : t.provider || null;
        }
        async function Fp(t, e) {
          const n = yp(Wu.dereference(t, "overrides"));
          return (
            Go(
              null == n.to || (e || []).indexOf("to") >= 0,
              "cannot override to",
              "overrides.to",
              n.to
            ),
            Go(
              null == n.data || (e || []).indexOf("data") >= 0,
              "cannot override data",
              "overrides.data",
              n.data
            ),
            n.from && (n.from = await Mu(n.from)),
            n
          );
        }
        function Up(t) {
          const e = async function (e) {
              const n = await Fp(e, ["data"]);
              n.to = await t.getAddress();
              const r = t.interface,
                s = ua(n.value || Ip, "overrides.value") === Ip,
                i = "0x" === (n.data || "0x");
              !r.fallback ||
                r.fallback.payable ||
                !r.receive ||
                i ||
                s ||
                Go(
                  !1,
                  "cannot send data to receive or send value to non-payable fallback",
                  "overrides",
                  e
                ),
                Go(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                );
              return (
                Go(
                  r.receive || (r.fallback && r.fallback.payable) || s,
                  "cannot send value to non-payable fallback",
                  "overrides.value",
                  n.value
                ),
                Go(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                ),
                n
              );
            },
            n = async function (n) {
              const r = t.runner;
              Ho(
                Op(r),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await r.sendTransaction(await e(n)),
                i = zp(t.runner);
              return new Cp(t.interface, i, s);
            },
            r = async (t) => await n(t);
          return (
            Fo(r, {
              _contract: t,
              estimateGas: async function (n) {
                const r = Lp(t.runner, "estimateGas");
                return (
                  Ho(
                    Bp(r),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await r.estimateGas(await e(n))
                );
              },
              populateTransaction: e,
              send: n,
              staticCall: async function (n) {
                const r = Lp(t.runner, "call");
                Ho(
                  Np(r),
                  "contract runner does not support calling",
                  "UNSUPPORTED_OPERATION",
                  { operation: "call" }
                );
                const s = await e(n);
                try {
                  return await r.call(s);
                } catch (e) {
                  if (Mo(e) && e.data) throw t.interface.makeError(e.data, s);
                  throw e;
                }
              },
            }),
            r
          );
        }
        function Dp(t, e) {
          const n = function (...n) {
              const r = t.interface.getFunction(e, n);
              return (
                Ho(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                  operation: "fragment",
                  info: { key: e, args: n },
                }),
                r
              );
            },
            r = async function (...e) {
              const r = n(...e);
              let s = {};
              if (
                (r.inputs.length + 1 === e.length && (s = await Fp(e.pop())),
                r.inputs.length !== e.length)
              )
                throw new Error(
                  "internal error: fragment inputs doesn't match arguments; should not happen"
                );
              const i = await (async function (t, e, n) {
                const r = Lp(t, "resolveName"),
                  s = Tp(r) ? r : null;
                return await Promise.all(
                  e.map((t, e) =>
                    t.walkAsync(
                      n[e],
                      (t, e) => (
                        (e = Wu.dereference(e, t)),
                        "address" === t ? Mu(e, s) : e
                      )
                    )
                  )
                );
              })(t.runner, r.inputs, e);
              return Object.assign(
                {},
                s,
                await zo({
                  to: t.getAddress(),
                  data: t.interface.encodeFunctionData(r, i),
                })
              );
            },
            s = async function (...t) {
              const e = await o(...t);
              return 1 === e.length ? e[0] : e;
            },
            i = async function (...e) {
              const n = t.runner;
              Ho(
                Op(n),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await n.sendTransaction(await r(...e)),
                i = zp(t.runner);
              return new Cp(t.interface, i, s);
            },
            o = async function (...e) {
              const s = Lp(t.runner, "call");
              Ho(
                Np(s),
                "contract runner does not support calling",
                "UNSUPPORTED_OPERATION",
                { operation: "call" }
              );
              const i = await r(...e);
              let o = "0x";
              try {
                o = await s.call(i);
              } catch (e) {
                if (Mo(e) && e.data) throw t.interface.makeError(e.data, i);
                throw e;
              }
              const a = n(...e);
              return t.interface.decodeFunctionResult(a, o);
            },
            a = async (...t) =>
              n(...t).constant ? await s(...t) : await i(...t);
          return (
            Fo(a, {
              name: t.interface.getFunctionName(e),
              _contract: t,
              _key: e,
              getFragment: n,
              estimateGas: async function (...e) {
                const n = Lp(t.runner, "estimateGas");
                return (
                  Ho(
                    Bp(n),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await n.estimateGas(await r(...e))
                );
              },
              populateTransaction: r,
              send: i,
              staticCall: s,
              staticCallResult: o,
            }),
            Object.defineProperty(a, "fragment", {
              configurable: !1,
              enumerable: !0,
              get: () => {
                const n = t.interface.getFunction(e);
                return (
                  Ho(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                    operation: "fragment",
                    info: { key: e },
                  }),
                  n
                );
              },
            }),
            a
          );
        }
        const Mp = Symbol.for("_ethersInternal_contract"),
          jp = new WeakMap();
        function Hp(t) {
          return jp.get(t[Mp]);
        }
        async function Gp(t, e) {
          let n,
            r = null;
          if (Array.isArray(e)) {
            const r = function (e) {
              if (qo(e, 32)) return e;
              const n = t.interface.getEvent(e);
              return Go(n, "unknown fragment", "name", e), n.topicHash;
            };
            n = e.map((t) =>
              null == t ? null : Array.isArray(t) ? t.map(r) : r(t)
            );
          } else
            "*" === e
              ? (n = [null])
              : "string" == typeof e
              ? qo(e, 32)
                ? (n = [e])
                : ((r = t.interface.getEvent(e)),
                  Go(r, "unknown fragment", "event", e),
                  (n = [r.topicHash]))
              : (s = e) &&
                "object" == typeof s &&
                "getTopicFilter" in s &&
                "function" == typeof s.getTopicFilter &&
                s.fragment
              ? (n = await e.getTopicFilter())
              : "fragment" in e
              ? ((r = e.fragment), (n = [r.topicHash]))
              : Go(!1, "unknown event name", "event", e);
          var s;
          n = n.map((t) => {
            if (null == t) return null;
            if (Array.isArray(t)) {
              const e = Array.from(
                new Set(t.map((t) => t.toLowerCase())).values()
              );
              return 1 === e.length ? e[0] : (e.sort(), e);
            }
            return t.toLowerCase();
          });
          const i = n
            .map((t) =>
              null == t ? "null" : Array.isArray(t) ? t.join("|") : t
            )
            .join("&");
          return { fragment: r, tag: i, topics: n };
        }
        async function Vp(t, e) {
          const { subs: n } = Hp(t);
          return n.get((await Gp(t, e)).tag) || null;
        }
        async function Wp(t, e, n) {
          const r = zp(t.runner);
          Ho(
            r,
            "contract runner does not support subscribing",
            "UNSUPPORTED_OPERATION",
            { operation: e }
          );
          const { fragment: s, tag: i, topics: o } = await Gp(t, n),
            { addr: a, subs: l } = Hp(t);
          let c = l.get(i);
          if (!c) {
            const e = { address: a || t, topics: o },
              u = (e) => {
                let r = s;
                if (null == r)
                  try {
                    r = t.interface.getEvent(e.topics[0]);
                  } catch (t) {}
                if (r) {
                  const i = r,
                    o = s
                      ? t.interface.decodeEventLog(s, e.data, e.topics)
                      : [];
                  Jp(t, n, o, (r) => new Pp(t, r, n, i, e));
                } else Jp(t, n, [], (r) => new Sp(t, r, n, e));
              };
            let d = [];
            (c = {
              tag: i,
              listeners: [],
              start: () => {
                d.length || d.push(r.on(e, u));
              },
              stop: async () => {
                if (0 == d.length) return;
                let t = d;
                (d = []), await Promise.all(t), r.off(e, u);
              },
            }),
              l.set(i, c);
          }
          return c;
        }
        let Qp = Promise.resolve();
        async function Jp(t, e, n, r) {
          try {
            await Qp;
          } catch (t) {}
          const s = (async function (t, e, n, r) {
            await Qp;
            const s = await Vp(t, e);
            if (!s) return !1;
            const i = s.listeners.length;
            return (
              (s.listeners = s.listeners.filter(({ listener: e, once: s }) => {
                const i = Array.from(n);
                r && i.push(r(s ? null : e));
                try {
                  e.call(t, ...i);
                } catch (t) {}
                return !s;
              })),
              0 === s.listeners.length && (s.stop(), Hp(t).subs.delete(s.tag)),
              i > 0
            );
          })(t, e, n, r);
          return (Qp = s), await s;
        }
        const _p = ["then"];
        class Kp {
          target;
          interface;
          runner;
          filters;
          [Mp];
          fallback;
          constructor(t, e, n, r) {
            Go(
              "string" == typeof t || Uu(t),
              "invalid value for Contract target",
              "target",
              t
            ),
              null == n && (n = null);
            const s = hp.from(e);
            let i;
            Fo(this, { target: t, runner: n, interface: s }),
              Object.defineProperty(this, Mp, { value: {} });
            let o = null,
              a = null;
            if (r) {
              const t = zp(n);
              a = new Cp(this.interface, t, r);
            }
            let l = new Map();
            if ("string" == typeof t)
              if (qo(t)) (o = t), (i = Promise.resolve(t));
              else {
                const e = Lp(n, "resolveName");
                if (!Tp(e))
                  throw jo(
                    "contract runner does not support name resolution",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  );
                i = e.resolveName(t).then((e) => {
                  if (null == e)
                    throw jo(
                      "an ENS name used for a contract target must be correctly configured",
                      "UNCONFIGURED_NAME",
                      { value: t }
                    );
                  return (Hp(this).addr = e), e;
                });
              }
            else
              i = t.getAddress().then((t) => {
                if (null == t) throw new Error("TODO");
                return (Hp(this).addr = t), t;
              });
            var c, u;
            (c = this),
              (u = { addrPromise: i, addr: o, deployTx: a, subs: l }),
              jp.set(c[Mp], u);
            const d = new Proxy(
              {},
              {
                get: (t, e, n) => {
                  if (_p.indexOf(e) >= 0) return Reflect.get(t, e, n);
                  const r = String(e),
                    s = this.getEvent(r);
                  if (s) return s;
                  throw new Error(`unknown contract event: ${r}`);
                },
                has: (t, e) =>
                  _p.indexOf(e) >= 0
                    ? Reflect.has(t, e)
                    : Reflect.has(t, e) || this.interface.hasEvent(String(e)),
              }
            );
            return (
              Fo(this, { filters: d }),
              Fo(this, { fallback: s.receive || s.fallback ? Up(this) : null }),
              new Proxy(this, {
                get: (t, e, n) => {
                  if (e in t || _p.indexOf(e) >= 0 || "symbol" == typeof e)
                    return Reflect.get(t, e, n);
                  const r = String(e),
                    s = t.getFunction(r);
                  if (s) return s;
                  throw new Error(`unknown contract method: ${r}`);
                },
                has: (t, e) =>
                  e in t || _p.indexOf(e) >= 0 || "symbol" == typeof e
                    ? Reflect.has(t, e)
                    : t.interface.hasFunction(String(e)),
              })
            );
          }
          connect(t) {
            return new Kp(this.target, this.interface, t);
          }
          attach(t) {
            return new Kp(t, this.interface, this.runner);
          }
          async getAddress() {
            return await Hp(this).addrPromise;
          }
          async getDeployedCode() {
            const t = zp(this.runner);
            Ho(
              t,
              "runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "getDeployedCode" }
            );
            const e = await t.getCode(await this.getAddress());
            return "0x" === e ? null : e;
          }
          async waitForDeployment() {
            const t = this.deploymentTransaction();
            if (t) return await t.wait(), this;
            if (null != (await this.getDeployedCode())) return this;
            const e = zp(this.runner);
            return (
              Ho(
                null != e,
                "contract runner does not support .provider",
                "UNSUPPORTED_OPERATION",
                { operation: "waitForDeployment" }
              ),
              new Promise((t, n) => {
                const r = async () => {
                  try {
                    if (null != (await this.getDeployedCode())) return t(this);
                    e.once("block", r);
                  } catch (t) {
                    n(t);
                  }
                };
                r();
              })
            );
          }
          deploymentTransaction() {
            return Hp(this).deployTx;
          }
          getFunction(t) {
            "string" != typeof t && (t = t.format());
            return Dp(this, t);
          }
          getEvent(t) {
            return (
              "string" != typeof t && (t = t.format()),
              (function (t, e) {
                const n = function (...n) {
                    const r = t.interface.getEvent(e, n);
                    return (
                      Ho(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                        operation: "fragment",
                        info: { key: e, args: n },
                      }),
                      r
                    );
                  },
                  r = function (...e) {
                    return new Rp(t, n(...e), e);
                  };
                return (
                  Fo(r, {
                    name: t.interface.getEventName(e),
                    _contract: t,
                    _key: e,
                    getFragment: n,
                  }),
                  Object.defineProperty(r, "fragment", {
                    configurable: !1,
                    enumerable: !0,
                    get: () => {
                      const n = t.interface.getEvent(e);
                      return (
                        Ho(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                          operation: "fragment",
                          info: { key: e },
                        }),
                        n
                      );
                    },
                  }),
                  r
                );
              })(this, t)
            );
          }
          async queryTransaction(t) {
            throw new Error("@TODO");
          }
          async queryFilter(t, e, n) {
            null == e && (e = 0), null == n && (n = "latest");
            const { addr: r, addrPromise: s } = Hp(this),
              i = r || (await s),
              { fragment: o, topics: a } = await Gp(this, t),
              l = { address: i, topics: a, fromBlock: e, toBlock: n },
              c = zp(this.runner);
            return (
              Ho(
                c,
                "contract runner does not have a provider",
                "UNSUPPORTED_OPERATION",
                { operation: "queryFilter" }
              ),
              (await c.getLogs(l)).map((t) => {
                let e = o;
                if (null == e)
                  try {
                    e = this.interface.getEvent(t.topics[0]);
                  } catch (t) {}
                if (e)
                  try {
                    return new kp(t, this.interface, e);
                  } catch (t) {}
                return new wp(t, c);
              })
            );
          }
          async on(t, e) {
            const n = await Wp(this, "on", t);
            return n.listeners.push({ listener: e, once: !1 }), n.start(), this;
          }
          async once(t, e) {
            const n = await Wp(this, "once", t);
            return n.listeners.push({ listener: e, once: !0 }), n.start(), this;
          }
          async emit(t, ...e) {
            return await Jp(this, t, e, null);
          }
          async listenerCount(t) {
            if (t) {
              const e = await Vp(this, t);
              return e ? e.listeners.length : 0;
            }
            const { subs: e } = Hp(this);
            let n = 0;
            for (const { listeners: t } of e.values()) n += t.length;
            return n;
          }
          async listeners(t) {
            if (t) {
              const e = await Vp(this, t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            const { subs: e } = Hp(this);
            let n = [];
            for (const { listeners: t } of e.values())
              n = n.concat(t.map(({ listener: t }) => t));
            return n;
          }
          async off(t, e) {
            const n = await Vp(this, t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (null != e && 0 !== n.listeners.length) ||
                (n.stop(), Hp(this).subs.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const e = await Vp(this, t);
              if (!e) return this;
              e.stop(), Hp(this).subs.delete(e.tag);
            } else {
              const { subs: t } = Hp(this);
              for (const { tag: e, stop: n } of t.values()) n(), t.delete(e);
            }
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return await this.off(t, e);
          }
          static buildClass(t) {
            return class extends Kp {
              constructor(e, n = null) {
                super(e, t, n);
              }
            };
          }
          static from(t, e, n) {
            null == n && (n = null);
            return new this(t, e, n);
          }
        }
        class qp extends (function () {
          return Kp;
        })() {}
        function Yp(t) {
          return (
            t.match(/^ipfs:\/\/ipfs\//i)
              ? (t = t.substring(12))
              : t.match(/^ipfs:\/\//i)
              ? (t = t.substring(7))
              : Go(!1, "unsupported IPFS format", "link", t),
            `https://gateway.ipfs.io/ipfs/${t}`
          );
        }
        class Zp {
          name;
          constructor(t) {
            Fo(this, { name: t });
          }
          connect(t) {
            return this;
          }
          supportsCoinType(t) {
            return !1;
          }
          async encodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
          async decodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
        }
        const Xp = new RegExp("^(ipfs)://(.*)$", "i"),
          tg = [
            new RegExp("^(https)://(.*)$", "i"),
            new RegExp("^(data):(.*)$", "i"),
            Xp,
            new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
          ];
        class eg {
          provider;
          address;
          name;
          #wt;
          #vt;
          constructor(t, e, n) {
            Fo(this, { provider: t, address: e, name: n }),
              (this.#wt = null),
              (this.#vt = new qp(
                e,
                [
                  "function supportsInterface(bytes4) view returns (bool)",
                  "function resolve(bytes, bytes) view returns (bytes)",
                  "function addr(bytes32) view returns (address)",
                  "function addr(bytes32, uint) view returns (bytes)",
                  "function text(bytes32, string) view returns (string)",
                  "function contenthash(bytes32) view returns (bytes)",
                ],
                t
              ));
          }
          async supportsWildcard() {
            return (
              null == this.#wt &&
                (this.#wt = (async () => {
                  try {
                    return await this.#vt.supportsInterface("0x9061b923");
                  } catch (t) {
                    if (Do(t, "CALL_EXCEPTION")) return !1;
                    throw ((this.#wt = null), t);
                  }
                })()),
              await this.#wt
            );
          }
          async #At(t, e) {
            e = (e || []).slice();
            const n = this.#vt.interface;
            e.unshift(Ih(this.name));
            let r = null;
            var s;
            (await this.supportsWildcard()) &&
              ((r = n.getFunction(t)),
              Ho(r, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName: t },
              }),
              (e = [
                ((s = this.name),
                Zo(
                  Xo(
                    Ph(s).map((t) => {
                      if (t.length > 63)
                        throw new Error(
                          "invalid DNS encoded entry; length exceeds 63 bytes"
                        );
                      const e = new Uint8Array(t.length + 1);
                      return e.set(t, 1), (e[0] = e.length - 1), e;
                    })
                  )
                ) + "00"),
                n.encodeFunctionData(r, e),
              ]),
              (t = "resolve(bytes,bytes)")),
              e.push({ enableCcipRead: !0 });
            try {
              const s = await this.#vt[t](...e);
              return r ? n.decodeFunctionResult(r, s)[0] : s;
            } catch (t) {
              if (!Do(t, "CALL_EXCEPTION")) throw t;
            }
            return null;
          }
          async getAddress(t) {
            if ((null == t && (t = 60), 60 === t))
              try {
                const t = await this.#At("addr(bytes32)");
                return null == t || t === wu ? null : t;
              } catch (t) {
                if (Do(t, "CALL_EXCEPTION")) return null;
                throw t;
              }
            if (t >= 0 && t < 2147483648) {
              let e = t + 2147483648;
              const n = await this.#At("addr(bytes32,uint)", [e]);
              if (qo(n, 20)) return Fu(n);
            }
            let e = null;
            for (const n of this.provider.plugins)
              if (n instanceof Zp && n.supportsCoinType(t)) {
                e = n;
                break;
              }
            if (null == e) return null;
            const n = await this.#At("addr(bytes32,uint)", [t]);
            if (null == n || "0x" === n) return null;
            const r = await e.decodeAddress(t, n);
            if (null != r) return r;
            Ho(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${t})`,
              info: { coinType: t, data: n },
            });
          }
          async getText(t) {
            const e = await this.#At("text(bytes32,string)", [t]);
            return null == e || "0x" === e ? null : e;
          }
          async getContentHash() {
            const t = await this.#At("contenthash(bytes32)");
            if (null == t || "0x" === t) return null;
            const e = t.match(
              /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
            );
            if (e) {
              const t = "e3010170" === e[1] ? "ipfs" : "ipns",
                n = parseInt(e[4], 16);
              if (e[5].length === 2 * n)
                return `${t}://${(function (t) {
                  let e = fa(_o(t)),
                    n = "";
                  for (; e; )
                    (n =
                      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"[
                        Number(e % ba)
                      ] + n),
                      (e /= ba);
                  return n;
                })("0x" + e[2])}`;
            }
            const n = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (n && 64 === n[1].length) return `bzz://${n[1]}`;
            Ho(
              !1,
              "invalid or unsupported content hash data",
              "UNSUPPORTED_OPERATION",
              { operation: "getContentHash()", info: { data: t } }
            );
          }
          async getAvatar() {
            return (await this._getAvatar()).url;
          }
          async _getAvatar() {
            const t = [{ type: "name", value: this.name }];
            try {
              const e = await this.getText("avatar");
              if (null == e)
                return (
                  t.push({ type: "!avatar", value: "" }),
                  { url: null, linkage: t }
                );
              t.push({ type: "avatar", value: e });
              for (let n = 0; n < tg.length; n++) {
                const r = e.match(tg[n]);
                if (null == r) continue;
                const s = r[1].toLowerCase();
                switch (s) {
                  case "https":
                  case "data":
                    return (
                      t.push({ type: "url", value: e }), { linkage: t, url: e }
                    );
                  case "ipfs": {
                    const n = Yp(e);
                    return (
                      t.push({ type: "ipfs", value: e }),
                      t.push({ type: "url", value: n }),
                      { linkage: t, url: n }
                    );
                  }
                  case "erc721":
                  case "erc1155": {
                    const n =
                      "erc721" === s ? "tokenURI(uint256)" : "uri(uint256)";
                    t.push({ type: s, value: e });
                    const i = await this.getAddress();
                    if (null == i)
                      return (
                        t.push({ type: "!owner", value: "" }),
                        { url: null, linkage: t }
                      );
                    const o = (r[2] || "").split("/");
                    if (2 !== o.length)
                      return (
                        t.push({ type: `!${s}caip`, value: r[2] || "" }),
                        { url: null, linkage: t }
                      );
                    const a = o[1],
                      l = new qp(
                        o[0],
                        [
                          "function tokenURI(uint) view returns (string)",
                          "function ownerOf(uint) view returns (address)",
                          "function uri(uint) view returns (string)",
                          "function balanceOf(address, uint256) view returns (uint)",
                        ],
                        this.provider
                      );
                    if ("erc721" === s) {
                      const e = await l.ownerOf(a);
                      if (i !== e)
                        return (
                          t.push({ type: "!owner", value: e }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "owner", value: e });
                    } else if ("erc1155" === s) {
                      const e = await l.balanceOf(i, a);
                      if (!e)
                        return (
                          t.push({ type: "!balance", value: "0" }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "balance", value: e.toString() });
                    }
                    let c = await l[n](a);
                    if (null == c || "0x" === c)
                      return (
                        t.push({ type: "!metadata-url", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata-url-base", value: c }),
                      "erc1155" === s &&
                        ((c = c.replace("{id}", ga(a, 32).substring(2))),
                        t.push({ type: "metadata-url-expanded", value: c })),
                      c.match(/^ipfs:/i) && (c = Yp(c)),
                      t.push({ type: "metadata-url", value: c });
                    let u = {};
                    const d = await new Ra(c).send();
                    d.assertOk();
                    try {
                      u = d.bodyJson;
                    } catch (e) {
                      try {
                        t.push({ type: "!metadata", value: d.bodyText });
                      } catch (e) {
                        const n = d.body;
                        return (
                          n && t.push({ type: "!metadata", value: Zo(n) }),
                          { url: null, linkage: t }
                        );
                      }
                      return { url: null, linkage: t };
                    }
                    if (!u)
                      return (
                        t.push({ type: "!metadata", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata", value: JSON.stringify(u) });
                    let h = u.image;
                    if ("string" != typeof h)
                      return (
                        t.push({ type: "!imageUrl", value: "" }),
                        { url: null, linkage: t }
                      );
                    if (h.match(/^(https:\/\/|data:)/i));
                    else {
                      if (null == h.match(Xp))
                        return (
                          t.push({ type: "!imageUrl-ipfs", value: h }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "imageUrl-ipfs", value: h }), (h = Yp(h));
                    }
                    return (
                      t.push({ type: "url", value: h }), { linkage: t, url: h }
                    );
                  }
                }
              }
            } catch (t) {}
            return { linkage: t, url: null };
          }
          static async getEnsAddress(t) {
            const e = await t.getNetwork(),
              n = e.getPlugin("org.ethers.plugins.network.Ens");
            return (
              Ho(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                operation: "getEnsAddress",
                info: { network: e },
              }),
              n.address
            );
          }
          static async #$t(t, e) {
            const n = await eg.getEnsAddress(t);
            try {
              const r = new qp(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  t
                ),
                s = await r.resolver(Ih(e), { enableCcipRead: !0 });
              return s === wu ? null : s;
            } catch (t) {
              throw t;
            }
            return null;
          }
          static async fromName(t, e) {
            let n = e;
            for (;;) {
              if ("" === n || "." === n) return null;
              if ("eth" !== e && "eth" === n) return null;
              const r = await eg.#$t(t, n);
              if (null != r) {
                const s = new eg(t, r, e);
                return n === e || (await s.supportsWildcard()) ? s : null;
              }
              n = n.split(".").slice(1).join(".");
            }
          }
        }
        const ng = BigInt(0);
        function rg(t, e) {
          return function (n) {
            return null == n ? e : t(n);
          };
        }
        function sg(t) {
          return (e) => {
            if (!Array.isArray(e)) throw new Error("not an array");
            return e.map((e) => t(e));
          };
        }
        function ig(t, e) {
          return (n) => {
            const r = {};
            for (const s in t) {
              let i = s;
              if (e && s in e && !(i in n))
                for (const t of e[s])
                  if (t in n) {
                    i = t;
                    break;
                  }
              try {
                const e = t[s](n[i]);
                void 0 !== e && (r[s] = e);
              } catch (t) {
                Ho(
                  !1,
                  `invalid value for value.${s} (${
                    t instanceof Error ? t.message : "not-an-error"
                  })`,
                  "BAD_DATA",
                  { value: n }
                );
              }
            }
            return r;
          };
        }
        function og(t) {
          return Go(qo(t, !0), "invalid data", "value", t), t;
        }
        function ag(t) {
          return Go(qo(t, 32), "invalid hash", "value", t), t;
        }
        const lg = ig(
          {
            address: Fu,
            blockHash: ag,
            blockNumber: pa,
            data: og,
            index: pa,
            removed: rg(function (t) {
              switch (t) {
                case !0:
                case "true":
                  return !0;
                case !1:
                case "false":
                  return !1;
              }
              Go(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
            }, !1),
            topics: sg(ag),
            transactionHash: ag,
            transactionIndex: pa,
          },
          { index: ["logIndex"] }
        );
        const cg = ig({
          hash: rg(ag),
          parentHash: ag,
          number: pa,
          timestamp: pa,
          nonce: rg(og),
          difficulty: ua,
          gasLimit: ua,
          gasUsed: ua,
          miner: rg(Fu),
          extraData: og,
          baseFeePerGas: rg(ua),
        });
        const ug = ig(
          {
            transactionIndex: pa,
            blockNumber: pa,
            transactionHash: ag,
            address: Fu,
            topics: sg(ag),
            data: og,
            index: pa,
            blockHash: ag,
          },
          { index: ["logIndex"] }
        );
        const dg = ig(
          {
            to: rg(Fu, null),
            from: rg(Fu, null),
            contractAddress: rg(Fu, null),
            index: pa,
            root: rg(Zo),
            gasUsed: ua,
            logsBloom: rg(og),
            blockHash: ag,
            hash: ag,
            logs: sg(function (t) {
              return ug(t);
            }),
            blockNumber: pa,
            cumulativeGasUsed: ua,
            effectiveGasPrice: rg(ua),
            status: rg(pa),
            type: rg(pa, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
        function hg(t) {
          t.to &&
            ua(t.to) === ng &&
            (t.to = "0x0000000000000000000000000000000000000000");
          const e = ig(
            {
              hash: ag,
              type: (t) => ("0x" === t || null == t ? 0 : pa(t)),
              accessList: rg(Bh, null),
              blockHash: rg(ag, null),
              blockNumber: rg(pa, null),
              transactionIndex: rg(pa, null),
              from: Fu,
              gasPrice: rg(ua),
              maxPriorityFeePerGas: rg(ua),
              maxFeePerGas: rg(ua),
              gasLimit: ua,
              to: rg(Fu, null),
              value: ua,
              nonce: pa,
              data: og,
              creates: rg(Fu, null),
              chainId: rg(ua, null),
            },
            { data: ["input"], gasLimit: ["gas"] }
          )(t);
          if (
            (null == e.to &&
              null == e.creates &&
              (e.creates = (function (t) {
                const e = Fu(t.from);
                let n = ua(t.nonce, "tx.nonce").toString(16);
                return (
                  (n = "0" === n ? "0x" : n.length % 2 ? "0x0" + n : "0x" + n),
                  Fu(ea(mc(el([e, n])), 12))
                );
              })(e)),
            (1 !== t.type && 2 !== t.type) ||
              null != t.accessList ||
              (e.accessList = []),
            t.signature
              ? (e.signature = Iu.from(t.signature))
              : (e.signature = Iu.from(t)),
            null == e.chainId)
          ) {
            const t = e.signature.legacyChainId;
            null != t && (e.chainId = t);
          }
          return (
            e.blockHash && ua(e.blockHash) === ng && (e.blockHash = null), e
          );
        }
        class fg {
          name;
          constructor(t) {
            Fo(this, { name: t });
          }
          clone() {
            return new fg(this.name);
          }
        }
        class pg extends fg {
          effectiveBlock;
          txBase;
          txCreate;
          txDataZero;
          txDataNonzero;
          txAccessListStorageKey;
          txAccessListAddress;
          constructor(t, e) {
            null == t && (t = 0),
              super(`org.ethers.network.plugins.GasCost#${t || 0}`);
            const n = { effectiveBlock: t };
            function r(t, r) {
              let s = (e || {})[t];
              null == s && (s = r),
                Go("number" == typeof s, `invalud value for ${t}`, "costs", e),
                (n[t] = s);
            }
            r("txBase", 21e3),
              r("txCreate", 32e3),
              r("txDataZero", 4),
              r("txDataNonzero", 16),
              r("txAccessListStorageKey", 1900),
              r("txAccessListAddress", 2400),
              Fo(this, n);
          }
          clone() {
            return new pg(this.effectiveBlock, this);
          }
        }
        class gg extends fg {
          address;
          targetNetwork;
          constructor(t, e) {
            super("org.ethers.plugins.network.Ens"),
              Fo(this, {
                address: t || "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                targetNetwork: null == e ? 1 : e,
              });
          }
          clone() {
            return new gg(this.address, this.targetNetwork);
          }
        }
        const mg = new Map();
        class yg {
          #xt;
          #Y;
          #kt;
          constructor(t, e) {
            (this.#xt = t), (this.#Y = ua(e)), (this.#kt = new Map());
          }
          toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
          }
          get name() {
            return this.#xt;
          }
          set name(t) {
            this.#xt = t;
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = ua(t, "chainId");
          }
          matches(t) {
            if (null == t) return !1;
            if ("string" == typeof t) {
              try {
                return this.chainId === ua(t);
              } catch (t) {}
              return this.name === t;
            }
            if ("number" == typeof t || "bigint" == typeof t) {
              try {
                return this.chainId === ua(t);
              } catch (t) {}
              return !1;
            }
            if ("object" == typeof t) {
              if (null != t.chainId) {
                try {
                  return this.chainId === ua(t.chainId);
                } catch (t) {}
                return !1;
              }
              return null != t.name && this.name === t.name;
            }
            return !1;
          }
          get plugins() {
            return Array.from(this.#kt.values());
          }
          attachPlugin(t) {
            if (this.#kt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#kt.set(t.name, t.clone()), this;
          }
          getPlugin(t) {
            return this.#kt.get(t) || null;
          }
          getPlugins(t) {
            return this.plugins.filter((e) => e.name.split("#")[0] === t);
          }
          clone() {
            const t = new yg(this.name, this.chainId);
            return (
              this.plugins.forEach((e) => {
                t.attachPlugin(e.clone());
              }),
              t
            );
          }
          computeIntrinsicGas(t) {
            const e =
              this.getPlugin("org.ethers.plugins.network.GasCost") || new pg();
            let n = e.txBase;
            if ((null == t.to && (n += e.txCreate), t.data))
              for (let r = 2; r < t.data.length; r += 2)
                "00" === t.data.substring(r, r + 2)
                  ? (n += e.txDataZero)
                  : (n += e.txDataNonzero);
            if (t.accessList) {
              const r = Bh(t.accessList);
              for (const t in r)
                n +=
                  e.txAccessListAddress +
                  e.txAccessListStorageKey * r[t].storageKeys.length;
            }
            return n;
          }
          static from(t) {
            if (
              ((function () {
                if (bg) return;
                function t(t, e, n) {
                  const r = function () {
                    const r = new yg(t, e);
                    return (
                      null != n.ensNetwork &&
                        r.attachPlugin(new gg(null, n.ensNetwork)),
                      n.priorityFee,
                      r.attachPlugin(new pg()),
                      r
                    );
                  };
                  yg.register(t, r),
                    yg.register(e, r),
                    n.altNames &&
                      n.altNames.forEach((t) => {
                        yg.register(t, r);
                      });
                }
                (bg = !0),
                  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
                  t("ropsten", 3, { ensNetwork: 3 }),
                  t("rinkeby", 4, { ensNetwork: 4 }),
                  t("goerli", 5, { ensNetwork: 5 }),
                  t("kovan", 42, { ensNetwork: 42 }),
                  t("sepolia", 11155111, {}),
                  t("classic", 61, {}),
                  t("classicKotti", 6, {}),
                  t("xdai", 100, { ensNetwork: 1 }),
                  t("optimism", 10, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api-optimistic.etherscan.io/" },
                  }),
                  t("optimism-goerli", 420, {
                    etherscan: {
                      url: "https://api-goerli-optimistic.etherscan.io/",
                    },
                  }),
                  t("arbitrum", 42161, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.arbiscan.io/" },
                  }),
                  t("arbitrum-goerli", 421613, {
                    etherscan: { url: "https://api-goerli.arbiscan.io/" },
                  }),
                  t("matic", 137, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.polygonscan.com/" },
                  }),
                  t("matic-mumbai", 80001, {
                    altNames: ["maticMumbai", "maticmum"],
                    etherscan: { url: "https://api-testnet.polygonscan.com/" },
                  }),
                  t("bnb", 56, {
                    ensNetwork: 1,
                    etherscan: { url: "http://api.bscscan.com" },
                  }),
                  t("bnbt", 97, {
                    etherscan: { url: "http://api-testnet.bscscan.com" },
                  });
              })(),
              null == t)
            )
              return yg.from("mainnet");
            if (
              ("number" == typeof t && (t = BigInt(t)),
              "string" == typeof t || "bigint" == typeof t)
            ) {
              const e = mg.get(t);
              if (e) return e();
              if ("bigint" == typeof t) return new yg("unknown", t);
              Go(!1, "unknown network", "network", t);
            }
            if ("function" == typeof t.clone) {
              return t.clone();
            }
            if ("object" == typeof t) {
              Go(
                "string" == typeof t.name && "number" == typeof t.chainId,
                "invalid network object name or chainId",
                "network",
                t
              );
              const e = new yg(t.name, t.chainId);
              return (
                (t.ensAddress || null != t.ensNetwork) &&
                  e.attachPlugin(new gg(t.ensAddress, t.ensNetwork)),
                e
              );
            }
            Go(!1, "invalid network", "network", t);
          }
          static register(t, e) {
            "number" == typeof t && (t = BigInt(t));
            const n = mg.get(t);
            n &&
              Go(
                !1,
                `conflicting network for ${JSON.stringify(n.name)}`,
                "nameOrChainId",
                t
              ),
              mg.set(t, e);
          }
        }
        let bg = !1;
        function wg(t) {
          return JSON.parse(JSON.stringify(t));
        }
        class vg {
          #Et;
          #Ct;
          #St;
          #Pt;
          constructor(t) {
            (this.#Et = t),
              (this.#Ct = null),
              (this.#St = 4e3),
              (this.#Pt = -2);
          }
          get pollingInterval() {
            return this.#St;
          }
          set pollingInterval(t) {
            this.#St = t;
          }
          async #It() {
            try {
              const t = await this.#Et.getBlockNumber();
              if (-2 === this.#Pt) return void (this.#Pt = t);
              if (t !== this.#Pt) {
                for (let e = this.#Pt + 1; e <= t; e++) {
                  if (null == this.#Ct) return;
                  await this.#Et.emit("block", e);
                }
                this.#Pt = t;
              }
            } catch (t) {}
            null != this.#Ct &&
              (this.#Ct = this.#Et._setTimeout(this.#It.bind(this), this.#St));
          }
          start() {
            this.#Ct ||
              ((this.#Ct = this.#Et._setTimeout(this.#It.bind(this), this.#St)),
              this.#It());
          }
          stop() {
            this.#Ct && (this.#Et._clearTimeout(this.#Ct), (this.#Ct = null));
          }
          pause(t) {
            this.stop(), t && (this.#Pt = -2);
          }
          resume() {
            this.start();
          }
        }
        class Ag {
          #Et;
          #It;
          #Nt;
          constructor(t) {
            (this.#Et = t),
              (this.#Nt = !1),
              (this.#It = (t) => {
                this._poll(t, this.#Et);
              });
          }
          async _poll(t, e) {
            throw new Error("sub-classes must override this");
          }
          start() {
            this.#Nt ||
              ((this.#Nt = !0), this.#It(-2), this.#Et.on("block", this.#It));
          }
          stop() {
            this.#Nt && ((this.#Nt = !1), this.#Et.off("block", this.#It));
          }
          pause(t) {
            this.stop();
          }
          resume() {
            this.start();
          }
        }
        class $g extends Ag {
          #bt;
          constructor(t, e) {
            super(t), (this.#bt = wg(e));
          }
          async _poll(t, e) {
            throw new Error("@TODO");
          }
        }
        class xg extends Ag {
          #Bt;
          constructor(t, e) {
            super(t), (this.#Bt = e);
          }
          async _poll(t, e) {
            const n = await e.getTransactionReceipt(this.#Bt);
            n && e.emit(this.#Bt, n);
          }
        }
        class kg {
          #Et;
          #bt;
          #Ct;
          #Nt;
          #Pt;
          constructor(t, e) {
            (this.#Et = t),
              (this.#bt = wg(e)),
              (this.#Ct = this.#It.bind(this)),
              (this.#Nt = !1),
              (this.#Pt = -2);
          }
          async #It(t) {
            if (-2 === this.#Pt) return;
            const e = wg(this.#bt);
            (e.fromBlock = this.#Pt + 1), (e.toBlock = t);
            const n = await this.#Et.getLogs(e);
            if (0 !== n.length)
              for (const t of n)
                this.#Et.emit(this.#bt, t), (this.#Pt = t.blockNumber);
            else this.#Pt < t - 60 && (this.#Pt = t - 60);
          }
          start() {
            this.#Nt ||
              ((this.#Nt = !0),
              -2 === this.#Pt &&
                this.#Et.getBlockNumber().then((t) => {
                  this.#Pt = t;
                }),
              this.#Et.on("block", this.#Ct));
          }
          stop() {
            this.#Nt && ((this.#Nt = !1), this.#Et.off("block", this.#Ct));
          }
          pause(t) {
            this.stop(), t && (this.#Pt = -2);
          }
          resume() {
            this.start();
          }
        }
        const Eg = BigInt(2);
        function Cg(t) {
          return t && "function" == typeof t.then;
        }
        function Sg(t, e) {
          return (
            t +
            ":" +
            JSON.stringify(e, (t, e) => {
              if (null == e) return "null";
              if ("bigint" == typeof e) return `bigint:${e.toString()}`;
              if ("string" == typeof e) return e.toLowerCase();
              if ("object" == typeof e && !Array.isArray(e)) {
                const t = Object.keys(e);
                return t.sort(), t.reduce((t, n) => ((t[n] = e[n]), t), {});
              }
              return e;
            })
          );
        }
        class Pg {
          name;
          constructor(t) {
            Fo(this, { name: t });
          }
          start() {}
          stop() {}
          pause(t) {}
          resume() {}
        }
        function Ig(t) {
          return (t = Array.from(new Set(t).values())).sort(), t;
        }
        async function Ng(t, e) {
          if (null == t) throw new Error("invalid event");
          if ((Array.isArray(t) && (t = { topics: t }), "string" == typeof t))
            switch (t) {
              case "block":
              case "pending":
              case "debug":
              case "error":
              case "network":
                return { type: t, tag: t };
            }
          if (qo(t, 32)) {
            const e = t.toLowerCase();
            return { type: "transaction", tag: Sg("tx", { hash: e }), hash: e };
          }
          if (t.orphan) {
            const e = t;
            return {
              type: "orphan",
              tag: Sg("orphan", e),
              filter: ((n = e), JSON.parse(JSON.stringify(n))),
            };
          }
          var n;
          if (t.address || t.topics) {
            const n = t,
              r = {
                topics: (n.topics || []).map((t) =>
                  null == t
                    ? null
                    : Array.isArray(t)
                    ? Ig(t.map((t) => t.toLowerCase()))
                    : t.toLowerCase()
                ),
              };
            if (n.address) {
              const t = [],
                s = [],
                i = (n) => {
                  qo(n)
                    ? t.push(n)
                    : s.push(
                        (async () => {
                          t.push(await Mu(n, e));
                        })()
                      );
                };
              Array.isArray(n.address) ? n.address.forEach(i) : i(n.address),
                s.length && (await Promise.all(s)),
                (r.address = Ig(t.map((t) => t.toLowerCase())));
            }
            return { filter: r, tag: Sg("event", r), type: "event" };
          }
          Go(!1, "unknown ProviderEvent", "event", t);
        }
        function Bg() {
          return new Date().getTime();
        }
        const Tg = { cacheTimeout: 250 };
        class Og {
          #Tt;
          #kt;
          #Ot;
          #Rt;
          #Lt;
          #zt;
          #Ft;
          #Ut;
          #Dt;
          #Mt;
          #jt;
          #H;
          constructor(t, e) {
            if (((this.#H = Object.assign({}, Tg, e || {})), "any" === t))
              (this.#zt = !0), (this.#Lt = null);
            else if (t) {
              const e = yg.from(t);
              (this.#zt = !1),
                (this.#Lt = Promise.resolve(e)),
                setTimeout(() => {
                  this.emit("network", e, null);
                }, 0);
            } else (this.#zt = !1), (this.#Lt = null);
            (this.#Ut = -1),
              (this.#Ft = new Map()),
              (this.#Tt = new Map()),
              (this.#kt = new Map()),
              (this.#Ot = null),
              (this.#Rt = !1),
              (this.#Dt = 1),
              (this.#Mt = new Map()),
              (this.#jt = !1);
          }
          get provider() {
            return this;
          }
          get plugins() {
            return Array.from(this.#kt.values());
          }
          attachPlugin(t) {
            if (this.#kt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#kt.set(t.name, t.connect(this)), this;
          }
          getPlugin(t) {
            return this.#kt.get(t) || null;
          }
          get disableCcipRead() {
            return this.#jt;
          }
          set disableCcipRead(t) {
            this.#jt = !!t;
          }
          async #Ht(t) {
            const e = this.#H.cacheTimeout;
            if (e < 0) return await this._perform(t);
            const n = Sg(t.method, t);
            let r = this.#Ft.get(n);
            return (
              r ||
                ((r = this._perform(t)),
                this.#Ft.set(n, r),
                setTimeout(() => {
                  this.#Ft.get(n) === r && this.#Ft.delete(n);
                }, e)),
              await r
            );
          }
          async ccipReadFetch(t, e, n) {
            if (this.disableCcipRead || 0 === n.length || null == t.to)
              return null;
            const r = t.to.toLowerCase(),
              s = e.toLowerCase(),
              i = [];
            for (let e = 0; e < n.length; e++) {
              const o = n[e],
                a = o.replace("{sender}", r).replace("{data}", s),
                l = new Ra(a);
              -1 === o.indexOf("{data}") && (l.body = { data: s, sender: r }),
                this.emit("debug", {
                  action: "sendCcipReadFetchRequest",
                  request: l,
                  index: e,
                  urls: n,
                });
              let c = "unknown error";
              const u = await l.send();
              try {
                const t = u.bodyJson;
                if (t.data)
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadFetchResult",
                      request: l,
                      result: t,
                    }),
                    t.data
                  );
                t.message && (c = t.message),
                  this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: l,
                    result: t,
                  });
              } catch (t) {}
              Ho(
                u.statusCode < 400 || u.statusCode >= 500,
                `response not found during CCIP fetch: ${c}`,
                "OFFCHAIN_FAULT",
                {
                  reason: "404_MISSING_RESOURCE",
                  transaction: t,
                  info: { url: o, errorMessage: c },
                }
              ),
                i.push(c);
            }
            Ho(
              !1,
              `error encountered during CCIP fetch: ${i
                .map((t) => JSON.stringify(t))
                .join(", ")}`,
              "OFFCHAIN_FAULT",
              {
                reason: "500_SERVER_ERROR",
                transaction: t,
                info: { urls: n, errorMessages: i },
              }
            );
          }
          _wrapBlock(t, e) {
            return new bp(
              (function (t) {
                const e = cg(t);
                return (
                  (e.transactions = t.transactions.map((t) =>
                    "string" == typeof t ? t : hg(t)
                  )),
                  e
                );
              })(t),
              this
            );
          }
          _wrapLog(t, e) {
            return new wp(
              (function (t) {
                return lg(t);
              })(t),
              this
            );
          }
          _wrapTransactionReceipt(t, e) {
            return new vp(
              (function (t) {
                return dg(t);
              })(t),
              this
            );
          }
          _wrapTransactionResponse(t, e) {
            return new Ap(hg(t), this);
          }
          _detectNetwork() {
            Ho(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
              operation: "_detectNetwork",
            });
          }
          async _perform(t) {
            Ho(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
              operation: t.method,
              info: t,
            });
          }
          async getBlockNumber() {
            const t = pa(
              await this.#Ht({ method: "getBlockNumber" }),
              "%response"
            );
            return this.#Ut >= 0 && (this.#Ut = t), t;
          }
          _getAddress(t) {
            return Mu(t, this);
          }
          _getBlockTag(t) {
            if (null == t) return "latest";
            switch (t) {
              case "earliest":
                return "0x0";
              case "latest":
              case "pending":
              case "safe":
              case "finalized":
                return t;
            }
            return qo(t)
              ? qo(t, 32)
                ? t
                : ya(t)
              : ("bigint" == typeof t && (t = pa(t, "blockTag")),
                "number" == typeof t
                  ? t >= 0
                    ? ya(t)
                    : this.#Ut >= 0
                    ? ya(this.#Ut + t)
                    : this.getBlockNumber().then((e) => ya(e + t))
                  : void Go(!1, "invalid blockTag", "blockTag", t));
          }
          _getFilter(t) {
            const e = (t.topics || []).map((t) =>
                null == t
                  ? null
                  : Array.isArray(t)
                  ? Ig(t.map((t) => t.toLowerCase()))
                  : t.toLowerCase()
              ),
              n = "blockHash" in t ? t.blockHash : void 0,
              r = (t, r, s) => {
                let i;
                switch (t.length) {
                  case 0:
                    break;
                  case 1:
                    i = t[0];
                    break;
                  default:
                    t.sort(), (i = t);
                }
                if (n && (null != r || null != s))
                  throw new Error("invalid filter");
                const o = {};
                return (
                  i && (o.address = i),
                  e.length && (o.topics = e),
                  r && (o.fromBlock = r),
                  s && (o.toBlock = s),
                  n && (o.blockHash = n),
                  o
                );
              };
            let s,
              i,
              o = [];
            if (t.address)
              if (Array.isArray(t.address))
                for (const e of t.address) o.push(this._getAddress(e));
              else o.push(this._getAddress(t.address));
            return (
              "fromBlock" in t && (s = this._getBlockTag(t.fromBlock)),
              "toBlock" in t && (i = this._getBlockTag(t.toBlock)),
              o.filter((t) => "string" != typeof t).length ||
              (null != s && "string" != typeof s) ||
              (null != i && "string" != typeof i)
                ? Promise.all([Promise.all(o), s, i]).then((t) =>
                    r(t[0], t[1], t[2])
                  )
                : r(o, s, i)
            );
          }
          _getTransactionRequest(t) {
            const e = yp(t),
              n = [];
            if (
              (["to", "from"].forEach((t) => {
                if (null == e[t]) return;
                const r = Mu(e[t]);
                Cg(r)
                  ? n.push(
                      (async function () {
                        e[t] = await r;
                      })()
                    )
                  : (e[t] = r);
              }),
              null != e.blockTag)
            ) {
              const t = this._getBlockTag(e.blockTag);
              Cg(t)
                ? n.push(
                    (async function () {
                      e.blockTag = await t;
                    })()
                  )
                : (e.blockTag = t);
            }
            return n.length
              ? (async function () {
                  return await Promise.all(n), e;
                })()
              : e;
          }
          async getNetwork() {
            if (null == this.#Lt) {
              const t = this._detectNetwork().then(
                (t) => (this.emit("network", t, null), t),
                (e) => {
                  throw (this.#Lt === t && (this.#Lt = null), e);
                }
              );
              return (this.#Lt = t), (await t).clone();
            }
            const t = this.#Lt,
              [e, n] = await Promise.all([t, this._detectNetwork()]);
            return (
              e.chainId !== n.chainId &&
                (this.#zt
                  ? (this.emit("network", n, e),
                    this.#Lt === t && (this.#Lt = Promise.resolve(n)))
                  : Ho(
                      !1,
                      `network changed: ${e.chainId} => ${n.chainId} `,
                      "NETWORK_ERROR",
                      { event: "changed" }
                    )),
              e.clone()
            );
          }
          async getFeeData() {
            const { block: t, gasPrice: e } = await zo({
              block: this.getBlock("latest"),
              gasPrice: (async () => {
                try {
                  return ua(
                    await this.#Ht({ method: "getGasPrice" }),
                    "%response"
                  );
                } catch (t) {}
                return null;
              })(),
            });
            let n = null,
              r = null;
            return (
              t &&
                t.baseFeePerGas &&
                ((r = BigInt("1000000000")), (n = t.baseFeePerGas * Eg + r)),
              new mp(e, n, r)
            );
          }
          async estimateGas(t) {
            let e = this._getTransactionRequest(t);
            return (
              Cg(e) && (e = await e),
              ua(
                await this.#Ht({ method: "estimateGas", transaction: e }),
                "%response"
              )
            );
          }
          async #Gt(t, e, n) {
            Ho(
              n < 10,
              "CCIP read exceeded maximum redirections",
              "OFFCHAIN_FAULT",
              {
                reason: "TOO_MANY_REDIRECTS",
                transaction: Object.assign({}, t, {
                  blockTag: e,
                  enableCcipRead: !0,
                }),
              }
            );
            const r = yp(t);
            try {
              return Zo(
                await this._perform({
                  method: "call",
                  transaction: r,
                  blockTag: e,
                })
              );
            } catch (t) {
              if (
                !this.disableCcipRead &&
                Mo(t) &&
                t.data &&
                n >= 0 &&
                "latest" === e &&
                null != r.to &&
                "0x556f1830" === ea(t.data, 0, 4)
              ) {
                const s = t.data,
                  i = await Mu(r.to, this);
                let o;
                try {
                  o = (function (t) {
                    const e = {
                      sender: "",
                      urls: [],
                      calldata: "",
                      selector: "",
                      extraData: "",
                      errorArgs: [],
                    };
                    Ho(
                      ta(t) >= 160,
                      "insufficient OffchainLookup data",
                      "OFFCHAIN_FAULT",
                      { reason: "insufficient OffchainLookup data" }
                    );
                    const n = ea(t, 0, 32);
                    Ho(
                      ea(n, 0, 12) === ea(Mg, 0, 12),
                      "corrupt OffchainLookup sender",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup sender" }
                    ),
                      (e.sender = ea(n, 12));
                    try {
                      const n = [],
                        r = pa(ea(t, 32, 64)),
                        s = pa(ea(t, r, r + 32)),
                        i = ea(t, r + 32);
                      for (let t = 0; t < s; t++) {
                        const e = Rg(i, 32 * t);
                        if (null == e) throw new Error("abort");
                        n.push(e);
                      }
                      e.urls = n;
                    } catch (t) {
                      Ho(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
                        reason: "corrupt OffchainLookup urls",
                      });
                    }
                    try {
                      const n = Lg(t, 64);
                      if (null == n) throw new Error("abort");
                      e.calldata = n;
                    } catch (t) {
                      Ho(
                        !1,
                        "corrupt OffchainLookup calldata",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup calldata" }
                      );
                    }
                    Ho(
                      ea(t, 100, 128) === ea(Mg, 0, 28),
                      "corrupt OffchainLookup callbaackSelector",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup callbaackSelector" }
                    ),
                      (e.selector = ea(t, 96, 100));
                    try {
                      const n = Lg(t, 128);
                      if (null == n) throw new Error("abort");
                      e.extraData = n;
                    } catch (t) {
                      Ho(
                        !1,
                        "corrupt OffchainLookup extraData",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup extraData" }
                      );
                    }
                    return (
                      (e.errorArgs = "sender,urls,calldata,selector,extraData"
                        .split(/,/)
                        .map((t) => e[t])),
                      e
                    );
                  })(ea(t.data, 4));
                } catch (t) {
                  Ho(!1, t.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: r,
                    info: { data: s },
                  });
                }
                Ho(
                  o.sender.toLowerCase() === i.toLowerCase(),
                  "CCIP Read sender mismatch",
                  "CALL_EXCEPTION",
                  {
                    action: "call",
                    data: s,
                    reason: "OffchainLookup",
                    transaction: r,
                    invocation: null,
                    revert: {
                      signature:
                        "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      name: "OffchainLookup",
                      args: o.errorArgs,
                    },
                  }
                );
                const a = await this.ccipReadFetch(r, o.calldata, o.urls);
                Ho(
                  null != a,
                  "CCIP Read failed to fetch data",
                  "OFFCHAIN_FAULT",
                  {
                    reason: "FETCH_FAILED",
                    transaction: r,
                    info: { data: t.data, errorArgs: o.errorArgs },
                  }
                );
                const l = {
                  to: i,
                  data: Xo([o.selector, Dg([a, o.extraData])]),
                };
                this.emit("debug", {
                  action: "sendCcipReadCall",
                  transaction: l,
                });
                try {
                  const t = await this.#Gt(l, e, n + 1);
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadCallResult",
                      transaction: Object.assign({}, l),
                      result: t,
                    }),
                    t
                  );
                } catch (t) {
                  throw (
                    (this.emit("debug", {
                      action: "receiveCcipReadCallError",
                      transaction: Object.assign({}, l),
                      error: t,
                    }),
                    t)
                  );
                }
              }
              throw t;
            }
          }
          async #Vt(t) {
            const { value: e } = await zo({
              network: this.getNetwork(),
              value: t,
            });
            return e;
          }
          async call(t) {
            const { tx: e, blockTag: n } = await zo({
              tx: this._getTransactionRequest(t),
              blockTag: this._getBlockTag(t.blockTag),
            });
            return await this.#Vt(this.#Gt(e, n, t.enableCcipRead ? 0 : -1));
          }
          async #Wt(t, e, n) {
            let r = this._getAddress(e),
              s = this._getBlockTag(n);
            return (
              ("string" == typeof r && "string" == typeof s) ||
                ([r, s] = await Promise.all([r, s])),
              await this.#Vt(
                this.#Ht(Object.assign(t, { address: r, blockTag: s }))
              )
            );
          }
          async getBalance(t, e) {
            return ua(
              await this.#Wt({ method: "getBalance" }, t, e),
              "%response"
            );
          }
          async getTransactionCount(t, e) {
            return pa(
              await this.#Wt({ method: "getTransactionCount" }, t, e),
              "%response"
            );
          }
          async getCode(t, e) {
            return Zo(await this.#Wt({ method: "getCode" }, t, e));
          }
          async getStorage(t, e, n) {
            const r = ua(e, "position");
            return Zo(
              await this.#Wt({ method: "getStorage", position: r }, t, n)
            );
          }
          async broadcastTransaction(t) {
            const {
                blockNumber: e,
                hash: n,
                network: r,
              } = await zo({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                  method: "broadcastTransaction",
                  signedTransaction: t,
                }),
                network: this.getNetwork(),
              }),
              s = Kh.from(t);
            if (s.hash !== n)
              throw new Error("@TODO: the returned hash did not match");
            return this._wrapTransactionResponse(s, r).replaceableTransaction(
              e
            );
          }
          async #Qt(t, e) {
            if (qo(t, 32))
              return await this.#Ht({
                method: "getBlock",
                blockHash: t,
                includeTransactions: e,
              });
            let n = this._getBlockTag(t);
            return (
              "string" != typeof n && (n = await n),
              await this.#Ht({
                method: "getBlock",
                blockTag: n,
                includeTransactions: e,
              })
            );
          }
          async getBlock(t, e) {
            const { network: n, params: r } = await zo({
              network: this.getNetwork(),
              params: this.#Qt(t, !!e),
            });
            return null == r ? null : this._wrapBlock(r, n);
          }
          async getTransaction(t) {
            const { network: e, params: n } = await zo({
              network: this.getNetwork(),
              params: this.#Ht({ method: "getTransaction", hash: t }),
            });
            return null == n ? null : this._wrapTransactionResponse(n, e);
          }
          async getTransactionReceipt(t) {
            const { network: e, params: n } = await zo({
              network: this.getNetwork(),
              params: this.#Ht({ method: "getTransactionReceipt", hash: t }),
            });
            if (null == n) return null;
            if (null == n.gasPrice && null == n.effectiveGasPrice) {
              const e = await this.#Ht({ method: "getTransaction", hash: t });
              if (null == e)
                throw new Error(
                  "report this; could not find tx or effectiveGasPrice"
                );
              n.effectiveGasPrice = e.gasPrice;
            }
            return this._wrapTransactionReceipt(n, e);
          }
          async getTransactionResult(t) {
            const { result: e } = await zo({
              network: this.getNetwork(),
              result: this.#Ht({ method: "getTransactionResult", hash: t }),
            });
            return null == e ? null : Zo(e);
          }
          async getLogs(t) {
            let e = this._getFilter(t);
            Cg(e) && (e = await e);
            const { network: n, params: r } = await zo({
              network: this.getNetwork(),
              params: this.#Ht({ method: "getLogs", filter: e }),
            });
            return r.map((t) => this._wrapLog(t, n));
          }
          _getProvider(t) {
            Ho(
              !1,
              "provider cannot connect to target network",
              "UNSUPPORTED_OPERATION",
              { operation: "_getProvider()" }
            );
          }
          async getResolver(t) {
            return await eg.fromName(this, t);
          }
          async getAvatar(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAvatar() : null;
          }
          async resolveName(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAddress() : null;
          }
          async lookupAddress(t) {
            const e = Ih(
              (t = Fu(t)).substring(2).toLowerCase() + ".addr.reverse"
            );
            try {
              const n = await eg.getEnsAddress(this),
                r = new qp(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  this
                ),
                s = await r.resolver(e);
              if (null == s || s === wu) return null;
              const i = new qp(
                  s,
                  ["function name(bytes32) view returns (string)"],
                  this
                ),
                o = await i.name(e);
              return (await this.resolveName(o)) !== t ? null : o;
            } catch (t) {
              if (Do(t, "BAD_DATA") && "0x" === t.value) return null;
              if (Do(t, "CALL_EXCEPTION")) return null;
              throw t;
            }
            return null;
          }
          async waitForTransaction(t, e, n) {
            const r = null != e ? e : 1;
            return 0 === r
              ? this.getTransactionReceipt(t)
              : new Promise(async (e, s) => {
                  let i = null;
                  const o = async (n) => {
                    try {
                      const s = await this.getTransactionReceipt(t);
                      if (null != s && n - s.blockNumber + 1 >= r)
                        return e(s), void (i && (clearTimeout(i), (i = null)));
                    } catch (t) {
                      console.log("EEE", t);
                    }
                    this.once("block", o);
                  };
                  null != n &&
                    (i = setTimeout(() => {
                      null != i &&
                        ((i = null),
                        this.off("block", o),
                        s(jo("timeout", "TIMEOUT", { reason: "timeout" })));
                    }, n)),
                    o(await this.getBlockNumber());
                });
          }
          async waitForBlock(t) {
            Ho(!1, "not implemented yet", "NOT_IMPLEMENTED", {
              operation: "waitForBlock",
            });
          }
          _clearTimeout(t) {
            const e = this.#Mt.get(t);
            e && (e.timer && clearTimeout(e.timer), this.#Mt.delete(t));
          }
          _setTimeout(t, e) {
            null == e && (e = 0);
            const n = this.#Dt++,
              r = () => {
                this.#Mt.delete(n), t();
              };
            if (this.paused) this.#Mt.set(n, { timer: null, func: r, time: e });
            else {
              const t = setTimeout(r, e);
              this.#Mt.set(n, { timer: t, func: r, time: Bg() });
            }
            return n;
          }
          _forEachSubscriber(t) {
            for (const e of this.#Tt.values()) t(e.subscriber);
          }
          _getSubscriber(t) {
            switch (t.type) {
              case "debug":
              case "error":
              case "network":
                return new Pg(t.type);
              case "block":
                return new vg(this);
              case "event":
                return new kg(this, t.filter);
              case "transaction":
                return new xg(this, t.hash);
              case "orphan":
                return new $g(this, t.filter);
            }
            throw new Error(`unsupported event: ${t.type}`);
          }
          _recoverSubscriber(t, e) {
            for (const n of this.#Tt.values())
              if (n.subscriber === t) {
                n.started && n.subscriber.stop(),
                  (n.subscriber = e),
                  n.started && e.start(),
                  null != this.#Ot && e.pause(this.#Ot);
                break;
              }
          }
          async #Jt(t, e) {
            let n = await Ng(t, this);
            return (
              "event" === n.type &&
                e &&
                e.length > 0 &&
                !0 === e[0].removed &&
                (n = await Ng({ orphan: "drop-log", log: e[0] }, this)),
              this.#Tt.get(n.tag) || null
            );
          }
          async #_t(t) {
            const e = await Ng(t, this),
              n = e.tag;
            let r = this.#Tt.get(n);
            if (!r) {
              (r = {
                subscriber: this._getSubscriber(e),
                tag: n,
                addressableMap: new WeakMap(),
                nameMap: new Map(),
                started: !1,
                listeners: [],
              }),
                this.#Tt.set(n, r);
            }
            return r;
          }
          async on(t, e) {
            const n = await this.#_t(t);
            return (
              n.listeners.push({ listener: e, once: !1 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Ot && n.subscriber.pause(this.#Ot)),
              this
            );
          }
          async once(t, e) {
            const n = await this.#_t(t);
            return (
              n.listeners.push({ listener: e, once: !0 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Ot && n.subscriber.pause(this.#Ot)),
              this
            );
          }
          async emit(t, ...e) {
            const n = await this.#Jt(t, e);
            if (!n || 0 === n.listeners.length) return !1;
            const r = n.listeners.length;
            return (
              (n.listeners = n.listeners.filter(({ listener: n, once: r }) => {
                const s = new wa(this, r ? null : n, t);
                try {
                  n.call(this, ...e, s);
                } catch (t) {}
                return !r;
              })),
              0 === n.listeners.length &&
                (n.started && n.subscriber.stop(), this.#Tt.delete(n.tag)),
              r > 0
            );
          }
          async listenerCount(t) {
            if (t) {
              const e = await this.#Jt(t);
              return e ? e.listeners.length : 0;
            }
            let e = 0;
            for (const { listeners: t } of this.#Tt.values()) e += t.length;
            return e;
          }
          async listeners(t) {
            if (t) {
              const e = await this.#Jt(t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            let e = [];
            for (const { listeners: t } of this.#Tt.values())
              e = e.concat(t.map(({ listener: t }) => t));
            return e;
          }
          async off(t, e) {
            const n = await this.#Jt(t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (e && 0 !== n.listeners.length) ||
                (n.started && n.subscriber.stop(), this.#Tt.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const { tag: e, started: n, subscriber: r } = await this.#_t(t);
              n && r.stop(), this.#Tt.delete(e);
            } else
              for (const [t, { started: e, subscriber: n }] of this.#Tt)
                e && n.stop(), this.#Tt.delete(t);
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return this.off(t, e);
          }
          get destroyed() {
            return this.#Rt;
          }
          destroy() {
            this.removeAllListeners();
            for (const t of this.#Mt.keys()) this._clearTimeout(t);
            this.#Rt = !0;
          }
          get paused() {
            return null != this.#Ot;
          }
          set paused(t) {
            !!t !== this.paused &&
              (this.paused ? this.resume() : this.pause(!1));
          }
          pause(t) {
            if (((this.#Ut = -1), null != this.#Ot)) {
              if (this.#Ot == !!t) return;
              Ho(
                !1,
                "cannot change pause type; resume first",
                "UNSUPPORTED_OPERATION",
                { operation: "pause" }
              );
            }
            this._forEachSubscriber((e) => e.pause(t)), (this.#Ot = !!t);
            for (const t of this.#Mt.values())
              t.timer && clearTimeout(t.timer), (t.time = Bg() - t.time);
          }
          resume() {
            if (null != this.#Ot) {
              this._forEachSubscriber((t) => t.resume()), (this.#Ot = null);
              for (const t of this.#Mt.values()) {
                let e = t.time;
                e < 0 && (e = 0), (t.time = Bg()), setTimeout(t.func, e);
              }
            }
          }
        }
        function Rg(t, e) {
          try {
            const n = Lg(t, e);
            if (n) return xa(n);
          } catch (t) {}
          return null;
        }
        function Lg(t, e) {
          if ("0x" === t) return null;
          try {
            const n = pa(ea(t, e, e + 32)),
              r = pa(ea(t, n, n + 32));
            return ea(t, n + 32, n + 32 + r);
          } catch (t) {}
          return null;
        }
        function zg(t) {
          const e = ma(t);
          if (e.length > 32) throw new Error("internal; should not happen");
          const n = new Uint8Array(32);
          return n.set(e, 32 - e.length), n;
        }
        function Fg(t) {
          if (t.length % 32 == 0) return t;
          const e = new Uint8Array(32 * Math.ceil(t.length / 32));
          return e.set(t), e;
        }
        const Ug = new Uint8Array([]);
        function Dg(t) {
          const e = [];
          let n = 0;
          for (let r = 0; r < t.length; r++) e.push(Ug), (n += 32);
          for (let r = 0; r < t.length; r++) {
            const s = _o(t[r]);
            (e[r] = zg(n)),
              e.push(zg(s.length)),
              e.push(Fg(s)),
              (n += 32 + 32 * Math.ceil(s.length / 32));
          }
          return Xo(e);
        }
        const Mg =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        function jg(t, e) {
          if (t.provider) return t.provider;
          Ho(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
        }
        async function Hg(t, e) {
          let n = yp(e);
          if ((null != n.to && (n.to = Mu(n.to, t)), null != n.from)) {
            const e = n.from;
            n.from = Promise.all([t.getAddress(), Mu(e, t)]).then(
              ([t, e]) => (
                Go(
                  t.toLowerCase() === e.toLowerCase(),
                  "transaction from mismatch",
                  "tx.from",
                  e
                ),
                t
              )
            );
          } else n.from = t.getAddress();
          return await zo(n);
        }
        class Gg {
          provider;
          constructor(t) {
            Fo(this, { provider: t || null });
          }
          async getNonce(t) {
            return jg(this, "getTransactionCount").getTransactionCount(
              await this.getAddress(),
              t
            );
          }
          async populateCall(t) {
            return await Hg(this, t);
          }
          async populateTransaction(t) {
            const e = jg(this, "populateTransaction"),
              n = await Hg(this, t);
            null == n.nonce && (n.nonce = await this.getNonce("pending")),
              null == n.gasLimit && (n.gasLimit = await this.estimateGas(n));
            const r = await this.provider.getNetwork();
            if (null != n.chainId) {
              Go(
                ua(n.chainId) === r.chainId,
                "transaction chainId mismatch",
                "tx.chainId",
                t.chainId
              );
            } else n.chainId = r.chainId;
            const s = null != n.maxFeePerGas || null != n.maxPriorityFeePerGas;
            if (
              (null == n.gasPrice || (2 !== n.type && !s)
                ? (0 !== n.type && 1 !== n.type) ||
                  !s ||
                  Go(
                    !1,
                    "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                    "tx",
                    t
                  )
                : Go(
                    !1,
                    "eip-1559 transaction do not support gasPrice",
                    "tx",
                    t
                  ),
              (2 !== n.type && null != n.type) ||
                null == n.maxFeePerGas ||
                null == n.maxPriorityFeePerGas)
            )
              if (0 === n.type || 1 === n.type) {
                const t = await e.getFeeData();
                Ho(
                  null != t.gasPrice,
                  "network does not support gasPrice",
                  "UNSUPPORTED_OPERATION",
                  { operation: "getGasPrice" }
                ),
                  null == n.gasPrice && (n.gasPrice = t.gasPrice);
              } else {
                const t = await e.getFeeData();
                if (null == n.type)
                  if (null != t.maxFeePerGas && null != t.maxPriorityFeePerGas)
                    if (((n.type = 2), null != n.gasPrice)) {
                      const t = n.gasPrice;
                      delete n.gasPrice,
                        (n.maxFeePerGas = t),
                        (n.maxPriorityFeePerGas = t);
                    } else
                      null == n.maxFeePerGas &&
                        (n.maxFeePerGas = t.maxFeePerGas),
                        null == n.maxPriorityFeePerGas &&
                          (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas);
                  else
                    null != t.gasPrice
                      ? (Ho(
                          !s,
                          "network does not support EIP-1559",
                          "UNSUPPORTED_OPERATION",
                          { operation: "populateTransaction" }
                        ),
                        null == n.gasPrice && (n.gasPrice = t.gasPrice),
                        (n.type = 0))
                      : Ho(
                          !1,
                          "failed to get consistent fee data",
                          "UNSUPPORTED_OPERATION",
                          { operation: "signer.getFeeData" }
                        );
                else
                  2 === n.type &&
                    (null == n.maxFeePerGas &&
                      (n.maxFeePerGas = t.maxFeePerGas),
                    null == n.maxPriorityFeePerGas &&
                      (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas));
              }
            else n.type = 2;
            return await zo(n);
          }
          async estimateGas(t) {
            return jg(this, "estimateGas").estimateGas(
              await this.populateCall(t)
            );
          }
          async call(t) {
            return jg(this, "call").call(await this.populateCall(t));
          }
          async resolveName(t) {
            const e = jg(this, "resolveName");
            return await e.resolveName(t);
          }
          async sendTransaction(t) {
            const e = jg(this, "sendTransaction"),
              n = await this.populateTransaction(t);
            delete n.from;
            const r = Kh.from(n);
            return await e.broadcastTransaction(await this.signTransaction(r));
          }
        }
        class Vg {
          #Et;
          #Kt;
          #Ct;
          #Nt;
          #qt;
          #Yt;
          constructor(t) {
            (this.#Et = t),
              (this.#Kt = null),
              (this.#Ct = this.#It.bind(this)),
              (this.#Nt = !1),
              (this.#qt = null),
              (this.#Yt = !1);
          }
          _subscribe(t) {
            throw new Error("subclasses must override this");
          }
          _emitResults(t, e) {
            throw new Error("subclasses must override this");
          }
          _recover(t) {
            throw new Error("subclasses must override this");
          }
          async #It(t) {
            try {
              null == this.#Kt && (this.#Kt = this._subscribe(this.#Et));
              let t = null;
              try {
                t = await this.#Kt;
              } catch (t) {
                if (
                  !Do(t, "UNSUPPORTED_OPERATION") ||
                  "eth_newFilter" !== t.operation
                )
                  throw t;
              }
              if (null == t)
                return (
                  (this.#Kt = null),
                  void this.#Et._recoverSubscriber(
                    this,
                    this._recover(this.#Et)
                  )
                );
              const e = await this.#Et.getNetwork();
              if ((this.#qt || (this.#qt = e), this.#qt.chainId !== e.chainId))
                throw new Error("chaid changed");
              if (this.#Yt) return;
              const n = await this.#Et.send("eth_getFilterChanges", [t]);
              await this._emitResults(this.#Et, n);
            } catch (t) {
              console.log("@TODO", t);
            }
            this.#Et.once("block", this.#Ct);
          }
          #Zt() {
            const t = this.#Kt;
            t &&
              ((this.#Kt = null),
              t.then((t) => {
                this.#Et.send("eth_uninstallFilter", [t]);
              }));
          }
          start() {
            this.#Nt || ((this.#Nt = !0), this.#It(-2));
          }
          stop() {
            this.#Nt &&
              ((this.#Nt = !1),
              (this.#Yt = !0),
              this.#Zt(),
              this.#Et.off("block", this.#Ct));
          }
          pause(t) {
            t && this.#Zt(), this.#Et.off("block", this.#Ct);
          }
          resume() {
            this.start();
          }
        }
        class Wg extends Vg {
          #Xt;
          constructor(t, e) {
            var n;
            super(t), (this.#Xt = ((n = e), JSON.parse(JSON.stringify(n))));
          }
          _recover(t) {
            return new kg(t, this.#Xt);
          }
          async _subscribe(t) {
            return await t.send("eth_newFilter", [this.#Xt]);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit(this.#Xt, t._wrapLog(n, t._network));
          }
        }
        class Qg extends Vg {
          async _subscribe(t) {
            return await t.send("eth_newPendingTransactionFilter", []);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit("pending", n);
          }
        }
        const Jg = "bigint,boolean,function,number,string,symbol".split(/,/g);
        function _g(t) {
          if (null == t || Jg.indexOf(typeof t) >= 0) return t;
          if ("function" == typeof t.getAddress) return t;
          if (Array.isArray(t)) return t.map(_g);
          if ("object" == typeof t)
            return Object.keys(t).reduce((e, n) => ((e[n] = t[n]), e), {});
          throw new Error(`should not happen: ${t} (${typeof t})`);
        }
        function Kg(t) {
          return new Promise((e) => {
            setTimeout(e, t);
          });
        }
        function qg(t) {
          return t ? t.toLowerCase() : t;
        }
        function Yg(t) {
          return t && "number" == typeof t.pollingInterval;
        }
        const Zg = {
          polling: !1,
          staticNetwork: null,
          batchStallTime: 10,
          batchMaxSize: 1 << 20,
          batchMaxCount: 100,
          cacheTimeout: 250,
        };
        class Xg extends Gg {
          address;
          constructor(t, e) {
            super(t), Fo(this, { address: (e = Fu(e)) });
          }
          connect(t) {
            Ho(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
              operation: "signer.connect",
            });
          }
          async getAddress() {
            return this.address;
          }
          async populateTransaction(t) {
            return await this.populateCall(t);
          }
          async sendUncheckedTransaction(t) {
            const e = _g(t),
              n = [];
            if (e.from) {
              const r = e.from;
              n.push(
                (async () => {
                  const n = await Mu(r, this.provider);
                  Go(
                    null != n && n.toLowerCase() === this.address.toLowerCase(),
                    "from address mismatch",
                    "transaction",
                    t
                  ),
                    (e.from = n);
                })()
              );
            } else e.from = this.address;
            if (
              (null == e.gasLimit &&
                n.push(
                  (async () => {
                    e.gasLimit = await this.provider.estimateGas({
                      ...e,
                      from: this.address,
                    });
                  })()
                ),
              null != e.to)
            ) {
              const t = e.to;
              n.push(
                (async () => {
                  e.to = await Mu(t, this.provider);
                })()
              );
            }
            n.length && (await Promise.all(n));
            const r = this.provider.getRpcTransaction(e);
            return this.provider.send("eth_sendTransaction", [r]);
          }
          async sendTransaction(t) {
            const e = await this.provider.getBlockNumber(),
              n = await this.sendUncheckedTransaction(t);
            return await new Promise((t, r) => {
              const s = [1e3, 100],
                i = async () => {
                  const r = await this.provider.getTransaction(n);
                  null == r
                    ? this.provider._setTimeout(() => {
                        i();
                      }, s.pop() || 4e3)
                    : t(r.replaceableTransaction(e));
                };
              i();
            });
          }
          async signTransaction(t) {
            const e = _g(t);
            if (e.from) {
              const n = await Mu(e.from, this.provider);
              Go(
                null != n && n.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                t
              ),
                (e.from = n);
            } else e.from = this.address;
            const n = this.provider.getRpcTransaction(e);
            return await this.provider.send("eth_signTransaction", [n]);
          }
          async signMessage(t) {
            const e = "string" == typeof t ? $a(t) : t;
            return await this.provider.send("personal_sign", [
              Zo(e),
              this.address.toLowerCase(),
            ]);
          }
          async signTypedData(t, e, n) {
            const r = _g(n),
              s = await uf.resolveNames(t, e, r, async (t) => {
                const e = await Mu(t);
                return (
                  Go(
                    null != e,
                    "TypedData does not support null address",
                    "value",
                    t
                  ),
                  e
                );
              });
            return await this.provider.send("eth_signTypedData_v4", [
              this.address.toLowerCase(),
              JSON.stringify(uf.getPayload(s.domain, e, s.value)),
            ]);
          }
          async unlock(t) {
            return this.provider.send("personal_unlockAccount", [
              this.address.toLowerCase(),
              t,
              null,
            ]);
          }
          async _legacySignMessage(t) {
            const e = "string" == typeof t ? $a(t) : t;
            return await this.provider.send("eth_sign", [
              this.address.toLowerCase(),
              Zo(e),
            ]);
          }
        }
        class tm extends Og {
          #H;
          #te;
          #ee;
          #ne;
          #re;
          #qt;
          #se() {
            if (this.#ne) return;
            const t =
              1 === this._getOption("batchMaxCount")
                ? 0
                : this._getOption("batchStallTime");
            this.#ne = setTimeout(() => {
              this.#ne = null;
              const t = this.#ee;
              for (this.#ee = []; t.length; ) {
                const e = [t.shift()];
                for (; t.length && e.length !== this.#H.batchMaxCount; ) {
                  e.push(t.shift());
                  const n = JSON.stringify(e.map((t) => t.payload));
                  if (n.length > this.#H.batchMaxSize) {
                    t.unshift(e.pop());
                    break;
                  }
                }
                (async () => {
                  const t =
                    1 === e.length ? e[0].payload : e.map((t) => t.payload);
                  this.emit("debug", { action: "sendRpcPayload", payload: t });
                  try {
                    const n = await this._send(t);
                    this.emit("debug", {
                      action: "receiveRpcResult",
                      result: n,
                    });
                    for (const { resolve: t, reject: r, payload: s } of e) {
                      if (this.destroyed) {
                        r(
                          jo(
                            "provider destroyed; cancelled request",
                            "UNSUPPORTED_OPERATION",
                            { operation: s.method }
                          )
                        );
                        continue;
                      }
                      const e = n.filter((t) => t.id === s.id)[0];
                      if (null != e)
                        "error" in e ? r(this.getRpcError(s, e)) : t(e.result);
                      else {
                        const t = jo(
                          "missing response for request",
                          "BAD_DATA",
                          { value: n, info: { payload: s } }
                        );
                        this.emit("error", t), r(t);
                      }
                    }
                  } catch (t) {
                    this.emit("debug", { action: "receiveRpcError", error: t });
                    for (const { reject: n } of e) n(t);
                  }
                })();
              }
            }, t);
          }
          constructor(t, e) {
            const n = {};
            e && null != e.cacheTimeout && (n.cacheTimeout = e.cacheTimeout),
              super(t, n),
              (this.#te = 1),
              (this.#H = Object.assign({}, Zg, e || {})),
              (this.#ee = []),
              (this.#ne = null),
              (this.#qt = null);
            {
              let t = null;
              const e = new Promise((e) => {
                t = e;
              });
              this.#re = { promise: e, resolve: t };
            }
            const r = this._getOption("staticNetwork");
            r &&
              (Go(
                null == t || r.matches(t),
                "staticNetwork MUST match network object",
                "options",
                e
              ),
              (this.#qt = r));
          }
          _getOption(t) {
            return this.#H[t];
          }
          get _network() {
            return (
              Ho(this.#qt, "network is not available yet", "NETWORK_ERROR"),
              this.#qt
            );
          }
          async _perform(t) {
            if ("call" === t.method || "estimateGas" === t.method) {
              let e = t.transaction;
              if (
                e &&
                null != e.type &&
                ua(e.type) &&
                null == e.maxFeePerGas &&
                null == e.maxPriorityFeePerGas
              ) {
                const n = await this.getFeeData();
                null == n.maxFeePerGas &&
                  null == n.maxPriorityFeePerGas &&
                  (t = Object.assign({}, t, {
                    transaction: Object.assign({}, e, { type: void 0 }),
                  }));
              }
            }
            const e = this.getRpcRequest(t);
            return null != e
              ? await this.send(e.method, e.args)
              : super._perform(t);
          }
          async _detectNetwork() {
            const t = this._getOption("staticNetwork");
            if (t) return t;
            if (this.ready)
              return yg.from(ua(await this.send("eth_chainId", [])));
            const e = {
              id: this.#te++,
              method: "eth_chainId",
              params: [],
              jsonrpc: "2.0",
            };
            let n;
            this.emit("debug", { action: "sendRpcPayload", payload: e });
            try {
              n = (await this._send(e))[0];
            } catch (t) {
              throw (
                (this.emit("debug", { action: "receiveRpcError", error: t }), t)
              );
            }
            if (
              (this.emit("debug", { action: "receiveRpcResult", result: n }),
              "result" in n)
            )
              return yg.from(ua(n.result));
            throw this.getRpcError(e, n);
          }
          _start() {
            null != this.#re &&
              null != this.#re.resolve &&
              (this.#re.resolve(),
              (this.#re = null),
              (async () => {
                for (; null == this.#qt && !this.destroyed; )
                  try {
                    this.#qt = await this._detectNetwork();
                  } catch (t) {
                    console.log(
                      "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                    ),
                      this.emit(
                        "error",
                        jo(
                          "failed to bootstrap network detection",
                          "NETWORK_ERROR",
                          {
                            event: "initial-network-discovery",
                            info: { error: t },
                          }
                        )
                      ),
                      await Kg(1e3);
                  }
                this.#se();
              })());
          }
          async _waitUntilReady() {
            if (null != this.#re) return await this.#re.promise;
          }
          _getSubscriber(t) {
            return "pending" === t.type
              ? new Qg(this)
              : "event" === t.type
              ? this._getOption("polling")
                ? new kg(this, t.filter)
                : new Wg(this, t.filter)
              : "orphan" === t.type && "drop-log" === t.filter.orphan
              ? new Pg("orphan")
              : super._getSubscriber(t);
          }
          get ready() {
            return null == this.#re;
          }
          getRpcTransaction(t) {
            const e = {};
            return (
              [
                "chainId",
                "gasLimit",
                "gasPrice",
                "type",
                "maxFeePerGas",
                "maxPriorityFeePerGas",
                "nonce",
                "value",
              ].forEach((n) => {
                if (null == t[n]) return;
                let r = n;
                "gasLimit" === n && (r = "gas"),
                  (e[r] = ya(ua(t[n], `tx.${n}`)));
              }),
              ["from", "to", "data"].forEach((n) => {
                null != t[n] && (e[n] = Zo(t[n]));
              }),
              t.accessList && (e.accessList = Bh(t.accessList)),
              e
            );
          }
          getRpcRequest(t) {
            switch (t.method) {
              case "chainId":
                return { method: "eth_chainId", args: [] };
              case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
              case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
              case "getBalance":
                return {
                  method: "eth_getBalance",
                  args: [qg(t.address), t.blockTag],
                };
              case "getTransactionCount":
                return {
                  method: "eth_getTransactionCount",
                  args: [qg(t.address), t.blockTag],
                };
              case "getCode":
                return {
                  method: "eth_getCode",
                  args: [qg(t.address), t.blockTag],
                };
              case "getStorage":
                return {
                  method: "eth_getStorageAt",
                  args: [
                    qg(t.address),
                    "0x" + t.position.toString(16),
                    t.blockTag,
                  ],
                };
              case "broadcastTransaction":
                return {
                  method: "eth_sendRawTransaction",
                  args: [t.signedTransaction],
                };
              case "getBlock":
                if ("blockTag" in t)
                  return {
                    method: "eth_getBlockByNumber",
                    args: [t.blockTag, !!t.includeTransactions],
                  };
                if ("blockHash" in t)
                  return {
                    method: "eth_getBlockByHash",
                    args: [t.blockHash, !!t.includeTransactions],
                  };
                break;
              case "getTransaction":
                return { method: "eth_getTransactionByHash", args: [t.hash] };
              case "getTransactionReceipt":
                return { method: "eth_getTransactionReceipt", args: [t.hash] };
              case "call":
                return {
                  method: "eth_call",
                  args: [this.getRpcTransaction(t.transaction), t.blockTag],
                };
              case "estimateGas":
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(t.transaction)],
                };
              case "getLogs":
                return (
                  t.filter &&
                    null != t.filter.address &&
                    (Array.isArray(t.filter.address)
                      ? (t.filter.address = t.filter.address.map(qg))
                      : (t.filter.address = qg(t.filter.address))),
                  { method: "eth_getLogs", args: [t.filter] }
                );
            }
            return null;
          }
          getRpcError(t, e) {
            const { method: n } = t,
              { error: r } = e;
            if ("eth_estimateGas" === n && r.message) {
              const e = r.message;
              if (!e.match(/revert/i) && e.match(/insufficient funds/i))
                return jo("insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: t.params[0],
                  info: { payload: t, error: r },
                });
            }
            if ("eth_call" === n || "eth_estimateGas" === n) {
              const e = nm(r),
                s = ip.getBuiltinCallException(
                  "eth_call" === n ? "call" : "estimateGas",
                  t.params[0],
                  e ? e.data : null
                );
              return (s.info = { error: r, payload: t }), s;
            }
            const s = JSON.stringify(
              (function (t) {
                const e = [];
                return rm(t, e), e;
              })(r)
            );
            if (
              "string" == typeof r.message &&
              r.message.match(/user denied|ethers-user-denied/i)
            ) {
              return jo("user rejected action", "ACTION_REJECTED", {
                action:
                  {
                    eth_sign: "signMessage",
                    personal_sign: "signMessage",
                    eth_signTypedData_v4: "signTypedData",
                    eth_signTransaction: "signTransaction",
                    eth_sendTransaction: "sendTransaction",
                    eth_requestAccounts: "requestAccess",
                    wallet_requestAccounts: "requestAccess",
                  }[n] || "unknown",
                reason: "rejected",
                info: { payload: t, error: r },
              });
            }
            if ("eth_sendRawTransaction" === n || "eth_sendTransaction" === n) {
              const e = t.params[0];
              if (s.match(/insufficient funds|base fee exceeds gas limit/i))
                return jo(
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: e, info: { error: r } }
                );
              if (s.match(/nonce/i) && s.match(/too low/i))
                return jo("nonce has already been used", "NONCE_EXPIRED", {
                  transaction: e,
                  info: { error: r },
                });
              if (
                s.match(/replacement transaction/i) &&
                s.match(/underpriced/i)
              )
                return jo(
                  "replacement fee too low",
                  "REPLACEMENT_UNDERPRICED",
                  { transaction: e, info: { error: r } }
                );
              if (s.match(/only replay-protected/i))
                return jo(
                  "legacy pre-eip-155 transactions not supported",
                  "UNSUPPORTED_OPERATION",
                  { operation: n, info: { transaction: e, info: { error: r } } }
                );
            }
            let i = !!s.match(/the method .* does not exist/i);
            return (
              i ||
                (r &&
                  r.details &&
                  r.details.startsWith("Unauthorized method:") &&
                  (i = !0)),
              i
                ? jo("unsupported operation", "UNSUPPORTED_OPERATION", {
                    operation: t.method,
                    info: { error: r, payload: t },
                  })
                : jo("could not coalesce error", "UNKNOWN_ERROR", {
                    error: r,
                    payload: t,
                  })
            );
          }
          send(t, e) {
            if (this.destroyed)
              return Promise.reject(
                jo(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t }
                )
              );
            const n = this.#te++,
              r = new Promise((r, s) => {
                this.#ee.push({
                  resolve: r,
                  reject: s,
                  payload: { method: t, params: e, id: n, jsonrpc: "2.0" },
                });
              });
            return this.#se(), r;
          }
          async getSigner(t) {
            null == t && (t = 0);
            const e = this.send("eth_accounts", []);
            if ("number" == typeof t) {
              const n = await e;
              if (t >= n.length) throw new Error("no such account");
              return new Xg(this, n[t]);
            }
            const { accounts: n } = await zo({
              network: this.getNetwork(),
              accounts: e,
            });
            t = Fu(t);
            for (const e of n) if (Fu(e) === t) return new Xg(this, t);
            throw new Error("invalid account");
          }
          async listAccounts() {
            return (await this.send("eth_accounts", [])).map(
              (t) => new Xg(this, t)
            );
          }
          destroy() {
            this.#ne && (clearTimeout(this.#ne), (this.#ne = null));
            for (const { payload: t, reject: e } of this.#ee)
              e(
                jo(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t.method }
                )
              );
            (this.#ee = []), super.destroy();
          }
        }
        class em extends tm {
          #ie;
          constructor(t, e) {
            super(t, e), (this.#ie = 4e3);
          }
          _getSubscriber(t) {
            const e = super._getSubscriber(t);
            return Yg(e) && (e.pollingInterval = this.#ie), e;
          }
          get pollingInterval() {
            return this.#ie;
          }
          set pollingInterval(t) {
            if (!Number.isInteger(t) || t < 0)
              throw new Error("invalid interval");
            (this.#ie = t),
              this._forEachSubscriber((t) => {
                Yg(t) && (t.pollingInterval = this.#ie);
              });
          }
        }
        function nm(t) {
          if (null == t) return null;
          if (
            "string" == typeof t.message &&
            t.message.match(/revert/i) &&
            qo(t.data)
          )
            return { message: t.message, data: t.data };
          if ("object" == typeof t) {
            for (const e in t) {
              const n = nm(t[e]);
              if (n) return n;
            }
            return null;
          }
          if ("string" == typeof t)
            try {
              return nm(JSON.parse(t));
            } catch (t) {}
          return null;
        }
        function rm(t, e) {
          if (null != t) {
            if (
              ("string" == typeof t.message && e.push(t.message),
              "object" == typeof t)
            )
              for (const n in t) rm(t[n], e);
            if ("string" == typeof t)
              try {
                return rm(JSON.parse(t), e);
              } catch (t) {}
          }
        }
        class sm extends em {
          #v;
          constructor(t, e) {
            super(e, { batchMaxCount: 1 }),
              (this.#v = async (e, n) => {
                const r = { method: e, params: n };
                this.emit("debug", {
                  action: "sendEip1193Request",
                  payload: r,
                });
                try {
                  const e = await t.request(r);
                  return (
                    this.emit("debug", {
                      action: "receiveEip1193Result",
                      result: e,
                    }),
                    e
                  );
                } catch (t) {
                  const e = new Error(t.message);
                  throw (
                    ((e.code = t.code),
                    (e.data = t.data),
                    (e.payload = r),
                    this.emit("debug", {
                      action: "receiveEip1193Error",
                      error: e,
                    }),
                    e)
                  );
                }
              });
          }
          async send(t, e) {
            return await this._start(), await super.send(t, e);
          }
          async _send(t) {
            Go(
              !Array.isArray(t),
              "EIP-1193 does not support batch request",
              "payload",
              t
            );
            try {
              const e = await this.#v(t.method, t.params || []);
              return [{ id: t.id, result: e }];
            } catch (e) {
              return [
                {
                  id: t.id,
                  error: { code: e.code, data: e.data, message: e.message },
                },
              ];
            }
          }
          getRpcError(t, e) {
            switch ((e = JSON.parse(JSON.stringify(e))).error.code || -1) {
              case 4001:
                e.error.message = `ethers-user-denied: ${e.error.message}`;
                break;
              case 4200:
                e.error.message = `ethers-unsupported: ${e.error.message}`;
            }
            return super.getRpcError(t, e);
          }
          async hasSigner(t) {
            null == t && (t = 0);
            const e = await this.send("eth_accounts", []);
            return "number" == typeof t
              ? e.length > t
              : ((t = t.toLowerCase()),
                0 !== e.filter((e) => e.toLowerCase() === t).length);
          }
          async getSigner(t) {
            if ((null == t && (t = 0), !(await this.hasSigner(t))))
              try {
                await this.#v("eth_requestAccounts", []);
              } catch (t) {
                const e = t.payload;
                throw this.getRpcError(e, { id: e.id, error: t });
              }
            return await super.getSigner(t);
          }
        }
        const im = "0x8276EF08D33D4D805f1d19F00851023660c0ae13",
          om = "0x0000000000000000000000000000000000000000",
          am = [
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "Deposit",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
              ],
              name: "EscrowCancelled",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_merchant",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "EscrowCreated",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
              ],
              name: "TradeCompleted",
              type: "event",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "cancelEscrow",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "completeTrade",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "string", name: "_details", type: "string" },
              ],
              name: "createEscrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "deposit",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "escrows",
              outputs: [
                { internalType: "address", name: "buyer", type: "address" },
                { internalType: "address", name: "merchant", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
                { internalType: "string", name: "details", type: "string" },
                { internalType: "bool", name: "isDead", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "nextEscrowId",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          ],
          lm = re([]),
          cm = "accountEscrowLists";
        function um() {
          const t = localStorage.getItem(cm);
          if (t) {
            const e = JSON.parse(t),
              n = Object.keys(e).reduce(
                (t, n) => ((t[n.toLowerCase()] = e[n]), t),
                {}
              );
            return new Map(Object.entries(n));
          }
          return new Map();
        }
        function dm(t) {
          let e, n, r, s, o, a, l, c, u, d;
          const h = [pm, fm],
            f = [];
          function p(t, e) {
            return null !== t[3] ? 0 : 1;
          }
          return (
            (o = p(t)),
            (a = f[o] = h[o](t)),
            {
              c() {
                (e = N("input")),
                  (n = O()),
                  (r = N("input")),
                  (s = O()),
                  a.c(),
                  (l = R()),
                  z(e, "placeholder", "Escrow details"),
                  z(r, "type", "Amount"),
                  z(r, "placeholder", "Escrow amount");
              },
              m(i, a) {
                P(i, e, a),
                  G(e, t[0]),
                  P(i, n, a),
                  P(i, r, a),
                  G(r, t[1]),
                  P(i, s, a),
                  f[o].m(i, a),
                  P(i, l, a),
                  (c = !0),
                  u ||
                    ((d = [L(e, "input", t[6]), L(r, "input", t[7])]),
                    (u = !0));
              },
              p(t, n) {
                1 & n && e.value !== t[0] && G(e, t[0]), 2 & n && G(r, t[1]);
                let s = o;
                (o = p(t)),
                  o === s
                    ? f[o].p(t, n)
                    : (kt(),
                      St(f[s], 1, 1, () => {
                        f[s] = null;
                      }),
                      Et(),
                      (a = f[o]),
                      a ? a.p(t, n) : ((a = f[o] = h[o](t)), a.c()),
                      Ct(a, 1),
                      a.m(l.parentNode, l));
              },
              i(t) {
                c || (Ct(a), (c = !0));
              },
              o(t) {
                St(a), (c = !1);
              },
              d(t) {
                t && I(e),
                  t && I(n),
                  t && I(r),
                  t && I(s),
                  f[o].d(t),
                  t && I(l),
                  (u = !1),
                  i(d);
              },
            }
          );
        }
        function hm(t) {
          let e, n, r, s;
          return (
            (r = new Dr({
              props: {
                href: `${window.location.href}?escrowID=${t[4]}`,
                target: "_blank",
                $$slots: { default: [bm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = N("h3")),
                  (e.textContent = "Escrow created!"),
                  (n = O()),
                  Ot(r.$$.fragment);
              },
              m(t, i) {
                P(t, e, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, e) {
                const n = {};
                16 & e && (n.href = `${window.location.href}?escrowID=${t[4]}`),
                  528 & e && (n.$$scope = { dirty: e, ctx: t }),
                  r.$set(n);
              },
              i(t) {
                s || (Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                t && I(e), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function fm(t) {
          let e, n;
          return (
            (e = new Dr({
              props: { $$slots: { default: [gm] }, $$scope: { ctx: t } },
            })),
            e.$on("click", t[5]),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                512 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function pm(t) {
          let e, n, r, s;
          return (
            (e = new Dr({
              props: {
                loading: !0,
                $$slots: { default: [mm] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Ws({
              props: {
                title: "Status",
                color: "blue",
                $$slots: { default: [ym] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), Ot(r.$$.fragment);
              },
              m(t, i) {
                Rt(e, t, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                512 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const i = {};
                520 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function gm(t) {
          let e;
          return {
            c() {
              e = T("Create Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function mm(t) {
          let e;
          return {
            c() {
              e = T("Create Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function ym(t) {
          let e;
          return {
            c() {
              e = T(t[3]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              8 & n && H(e, t[3]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function bm(t) {
          let e, n;
          return {
            c() {
              (e = T("View Escrow ")), (n = T(t[4]));
            },
            m(t, r) {
              P(t, e, r), P(t, n, r);
            },
            p(t, e) {
              16 & e && H(n, t[4]);
            },
            d(t) {
              t && I(e), t && I(n);
            },
          };
        }
        function wm(t) {
          let e, n;
          return (
            (e = new Ws({
              props: {
                title: "Error!",
                color: "red",
                $$slots: { default: [vm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                516 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function vm(t) {
          let e;
          return {
            c() {
              e = T(t[2]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              4 & n && H(e, t[2]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Am(t) {
          let e, n, r, s, i;
          const o = [hm, dm],
            a = [];
          function l(t, e) {
            return t[4] ? 0 : 1;
          }
          (e = l(t)), (n = a[e] = o[e](t));
          let c = t[2] && wm(t);
          return {
            c() {
              n.c(), (r = O()), c && c.c(), (s = R());
            },
            m(t, n) {
              a[e].m(t, n), P(t, r, n), c && c.m(t, n), P(t, s, n), (i = !0);
            },
            p(t, i) {
              let u = e;
              (e = l(t)),
                e === u
                  ? a[e].p(t, i)
                  : (kt(),
                    St(a[u], 1, 1, () => {
                      a[u] = null;
                    }),
                    Et(),
                    (n = a[e]),
                    n ? n.p(t, i) : ((n = a[e] = o[e](t)), n.c()),
                    Ct(n, 1),
                    n.m(r.parentNode, r)),
                t[2]
                  ? c
                    ? (c.p(t, i), 4 & i && Ct(c, 1))
                    : ((c = wm(t)), c.c(), Ct(c, 1), c.m(s.parentNode, s))
                  : c &&
                    (kt(),
                    St(c, 1, 1, () => {
                      c = null;
                    }),
                    Et());
            },
            i(t) {
              i || (Ct(n), Ct(c), (i = !0));
            },
            o(t) {
              St(n), St(c), (i = !1);
            },
            d(t) {
              a[e].d(t), t && I(r), c && c.d(t), t && I(s);
            },
          };
        }
        function $m(t) {
          let e, n;
          return (
            (e = new Fi({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [Am] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                543 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function xm(t, e, n) {
          const r = new sm(window.ethereum);
          let s = null,
            i = null,
            o = null,
            a = null,
            l = null;
          return [
            s,
            i,
            o,
            a,
            l,
            async function () {
              var t;
              if (
                (n(2, (o = null)), n(3, (a = "Creating escrow...")), !s || !i)
              )
                return (
                  console.log("Please enter details and amount"),
                  n(2, (o = "Please enter details and amount")),
                  void n(3, (a = null))
                );
              const e = sl(i.toString()),
                c = await r.getSigner(),
                u = new qp(im, am, c);
              console.log("ethers.parseEther((escrowAmount / 4).toString())"),
                console.log(sl((i / 4).toString()));
              const d = await u.createEscrow(e, s, {
                value: sl((i / 4).toString()),
              });
              n(
                3,
                (a =
                  "Escrow request signed and sent. Waiting for confirmation...")
              );
              const h = await d.wait();
              console.log("receipt", h),
                n(3, (a = `Escrow created in block ${h.blockNumber}`));
              const f = u.filters["EscrowCreated(uint256,address,uint256)"],
                p = await u.queryFilter(f, h.blockNumber);
              console.log("events", p);
              const g =
                null === (t = p[0].args) || void 0 === t ? void 0 : t._escrowId;
              console.log("escrowID", g),
                n(4, (l = Number(g))),
                n(3, (a = null)),
                (function (t, e) {
                  const n = um(),
                    r = n.get(e.toLowerCase()) || [];
                  r.push(t), lm.set(r), n.set(e.toLowerCase(), r);
                  const s = Object.fromEntries(n.entries());
                  localStorage.setItem(cm, JSON.stringify(s));
                })(
                  { escrowId: g.toString(), details: s, amount: i },
                  c.address
                );
            },
            function () {
              (s = this.value), n(0, s);
            },
            function () {
              (i = this.value), n(1, i);
            },
          ];
        }
        class km extends Ft {
          constructor(t) {
            super(), zt(this, t, xm, $m, a, {});
          }
        }
        async function Em() {
          return (
            await window.ethereum
              .request({ method: "eth_requestAccounts" })
              .catch((t) => {
                4001 === t.code
                  ? console.log("Please connect to MetaMask.")
                  : console.error(t);
              })
          )[0];
        }
        function Cm(t) {
          let e, n, r, s, i, o, a, l, c;
          e = new Si({
            props: {
              shadow: "sm",
              padding: "lg",
              $$slots: { default: [Nm] },
              $$scope: { ctx: t },
            },
          });
          let u = t[3] && !t[1].isDead && Bm(t),
            d = !t[3] && !t[5] && !t[1].isDead && Fm(t),
            h = !t[3] && t[5] && !t[1].isDead && Gm(t);
          return (
            (l = new Ti({
              props: { $$slots: { default: [oy] }, $$scope: { ctx: t } },
            })),
            {
              c() {
                Ot(e.$$.fragment),
                  (n = O()),
                  u && u.c(),
                  (r = O()),
                  d && d.c(),
                  (s = O()),
                  h && h.c(),
                  (i = O()),
                  (o = N("br")),
                  (a = O()),
                  Ot(l.$$.fragment);
              },
              m(t, f) {
                Rt(e, t, f),
                  P(t, n, f),
                  u && u.m(t, f),
                  P(t, r, f),
                  d && d.m(t, f),
                  P(t, s, f),
                  h && h.m(t, f),
                  P(t, i, f),
                  P(t, o, f),
                  P(t, a, f),
                  Rt(l, t, f),
                  (c = !0);
              },
              p(t, n) {
                const o = {};
                262166 & n && (o.$$scope = { dirty: n, ctx: t }),
                  e.$set(o),
                  t[3] && !t[1].isDead
                    ? u
                      ? (u.p(t, n), 10 & n && Ct(u, 1))
                      : ((u = Bm(t)), u.c(), Ct(u, 1), u.m(r.parentNode, r))
                    : u &&
                      (kt(),
                      St(u, 1, 1, () => {
                        u = null;
                      }),
                      Et()),
                  t[3] || t[5] || t[1].isDead
                    ? d &&
                      (kt(),
                      St(d, 1, 1, () => {
                        d = null;
                      }),
                      Et())
                    : d
                    ? (d.p(t, n), 42 & n && Ct(d, 1))
                    : ((d = Fm(t)), d.c(), Ct(d, 1), d.m(s.parentNode, s)),
                  t[3] || !t[5] || t[1].isDead
                    ? h &&
                      (kt(),
                      St(h, 1, 1, () => {
                        h = null;
                      }),
                      Et())
                    : h
                    ? (h.p(t, n), 42 & n && Ct(h, 1))
                    : ((h = Gm(t)), h.c(), Ct(h, 1), h.m(i.parentNode, i));
                const a = {};
                262596 & n && (a.$$scope = { dirty: n, ctx: t }), l.$set(a);
              },
              i(t) {
                c ||
                  (Ct(e.$$.fragment, t),
                  Ct(u),
                  Ct(d),
                  Ct(h),
                  Ct(l.$$.fragment, t),
                  (c = !0));
              },
              o(t) {
                St(e.$$.fragment, t),
                  St(u),
                  St(d),
                  St(h),
                  St(l.$$.fragment, t),
                  (c = !1);
              },
              d(t) {
                Lt(e, t),
                  t && I(n),
                  u && u.d(t),
                  t && I(r),
                  d && d.d(t),
                  t && I(s),
                  h && h.d(t),
                  t && I(i),
                  t && I(o),
                  t && I(a),
                  Lt(l, t);
              },
            }
          );
        }
        function Sm(t) {
          let e,
            n = t[1].isDead ? "dead" : "active";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              2 & r && n !== (n = t[1].isDead ? "dead" : "active") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Pm(t) {
          let e,
            n = t[1].merchant + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              2 & r && n !== (n = t[1].merchant + "") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Im(t) {
          let e,
            n = (t[4] ? t[1].buyer : "waiting for buyer") + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              18 & r &&
                n !== (n = (t[4] ? t[1].buyer : "waiting for buyer") + "") &&
                H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Nm(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l,
            c,
            u,
            d,
            h,
            f,
            p,
            g,
            m,
            y,
            b,
            w,
            v,
            A,
            $ = t[1].details + "";
          return (
            (r = new di({
              props: {
                variant: "filled",
                color: t[1].isDead ? "red" : "green",
                $$slots: { default: [Sm] },
                $$scope: { ctx: t },
              },
            })),
            (a = new di({
              props: {
                variant: "filled",
                color: "blue",
                $$slots: { default: [Pm] },
                $$scope: { ctx: t },
              },
            })),
            (d = new di({
              props: {
                variant: "filled",
                color: t[4] ? "purple" : "red",
                $$slots: { default: [Im] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = N("p")),
                  (n = T("Status: ")),
                  Ot(r.$$.fragment),
                  (s = O()),
                  (i = N("p")),
                  (o = T("merchant: ")),
                  Ot(a.$$.fragment),
                  (l = O()),
                  (c = N("p")),
                  (u = T("buyer: ")),
                  Ot(d.$$.fragment),
                  (h = O()),
                  (f = N("p")),
                  (p = T("amount: ")),
                  (g = N("strong")),
                  (m = T(t[2])),
                  (y = O()),
                  (b = N("p")),
                  (w = T("details: ")),
                  (v = T($));
              },
              m(t, $) {
                P(t, e, $),
                  x(e, n),
                  Rt(r, e, null),
                  P(t, s, $),
                  P(t, i, $),
                  x(i, o),
                  Rt(a, i, null),
                  P(t, l, $),
                  P(t, c, $),
                  x(c, u),
                  Rt(d, c, null),
                  P(t, h, $),
                  P(t, f, $),
                  x(f, p),
                  x(f, g),
                  x(g, m),
                  P(t, y, $),
                  P(t, b, $),
                  x(b, w),
                  x(b, v),
                  (A = !0);
              },
              p(t, e) {
                const n = {};
                2 & e && (n.color = t[1].isDead ? "red" : "green"),
                  262146 & e && (n.$$scope = { dirty: e, ctx: t }),
                  r.$set(n);
                const s = {};
                262146 & e && (s.$$scope = { dirty: e, ctx: t }), a.$set(s);
                const i = {};
                16 & e && (i.color = t[4] ? "purple" : "red"),
                  262162 & e && (i.$$scope = { dirty: e, ctx: t }),
                  d.$set(i),
                  (!A || 4 & e) && H(m, t[2]),
                  (!A || 2 & e) && $ !== ($ = t[1].details + "") && H(v, $);
              },
              i(t) {
                A ||
                  (Ct(r.$$.fragment, t),
                  Ct(a.$$.fragment, t),
                  Ct(d.$$.fragment, t),
                  (A = !0));
              },
              o(t) {
                St(r.$$.fragment, t),
                  St(a.$$.fragment, t),
                  St(d.$$.fragment, t),
                  (A = !1);
              },
              d(t) {
                t && I(e),
                  Lt(r),
                  t && I(s),
                  t && I(i),
                  Lt(a),
                  t && I(l),
                  t && I(c),
                  Lt(d),
                  t && I(h),
                  t && I(f),
                  t && I(y),
                  t && I(b);
              },
            }
          );
        }
        function Bm(t) {
          let e, n, r, s, i, o;
          const a = [Om, Tm],
            l = [];
          function c(t, e) {
            return null !== t[9] ? 0 : 1;
          }
          return (
            (r = c(t)),
            (s = l[r] = a[r](t)),
            {
              c() {
                (e = N("br")), (n = O()), s.c(), (i = R());
              },
              m(t, s) {
                P(t, e, s), P(t, n, s), l[r].m(t, s), P(t, i, s), (o = !0);
              },
              p(t, e) {
                let n = r;
                (r = c(t)),
                  r === n
                    ? l[r].p(t, e)
                    : (kt(),
                      St(l[n], 1, 1, () => {
                        l[n] = null;
                      }),
                      Et(),
                      (s = l[r]),
                      s ? s.p(t, e) : ((s = l[r] = a[r](t)), s.c()),
                      Ct(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (Ct(s), (o = !0));
              },
              o(t) {
                St(s), (o = !1);
              },
              d(t) {
                t && I(e), t && I(n), l[r].d(t), t && I(i);
              },
            }
          );
        }
        function Tm(t) {
          let e, n;
          return (
            (e = new Dr({
              props: {
                color: "red",
                $$slots: { default: [Rm] },
                $$scope: { ctx: t },
              },
            })),
            e.$on("click", t[12]),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                262144 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Om(t) {
          let e, n, r, s;
          return (
            (e = new Dr({
              props: {
                loading: !0,
                color: "red",
                $$slots: { default: [Lm] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Ws({
              props: {
                title: "Status",
                color: "blue",
                $$slots: { default: [zm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), Ot(r.$$.fragment);
              },
              m(t, i) {
                Rt(e, t, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                262144 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const i = {};
                262656 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function Rm(t) {
          let e;
          return {
            c() {
              e = T("Cancel Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Lm(t) {
          let e;
          return {
            c() {
              e = T("Cancel Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function zm(t) {
          let e;
          return {
            c() {
              e = T(t[9]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              512 & n && H(e, t[9]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Fm(t) {
          let e, n, r, s, i, o;
          const a = [Dm, Um],
            l = [];
          function c(t, e) {
            return null !== t[10] ? 0 : 1;
          }
          return (
            (r = c(t)),
            (s = l[r] = a[r](t)),
            {
              c() {
                (e = N("br")), (n = O()), s.c(), (i = R());
              },
              m(t, s) {
                P(t, e, s), P(t, n, s), l[r].m(t, s), P(t, i, s), (o = !0);
              },
              p(t, e) {
                let n = r;
                (r = c(t)),
                  r === n
                    ? l[r].p(t, e)
                    : (kt(),
                      St(l[n], 1, 1, () => {
                        l[n] = null;
                      }),
                      Et(),
                      (s = l[r]),
                      s ? s.p(t, e) : ((s = l[r] = a[r](t)), s.c()),
                      Ct(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (Ct(s), (o = !0));
              },
              o(t) {
                St(s), (o = !1);
              },
              d(t) {
                t && I(e), t && I(n), l[r].d(t), t && I(i);
              },
            }
          );
        }
        function Um(t) {
          let e, n;
          return (
            (e = new Dr({
              props: {
                color: "green",
                $$slots: { default: [Mm] },
                $$scope: { ctx: t },
              },
            })),
            e.$on("click", t[13]),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                262144 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Dm(t) {
          let e, n, r, s;
          return (
            (e = new Dr({
              props: {
                loading: !0,
                color: "green",
                $$slots: { default: [jm] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Ws({
              props: {
                title: "Status",
                color: "blue",
                $$slots: { default: [Hm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), Ot(r.$$.fragment);
              },
              m(t, i) {
                Rt(e, t, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                262144 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const i = {};
                263168 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function Mm(t) {
          let e;
          return {
            c() {
              e = T("Enter Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function jm(t) {
          let e;
          return {
            c() {
              e = T("Enter Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Hm(t) {
          let e;
          return {
            c() {
              e = T(t[10]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              1024 & n && H(e, t[10]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Gm(t) {
          let e, n, r, s, i, o;
          const a = [Wm, Vm],
            l = [];
          function c(t, e) {
            return null !== t[11] ? 0 : 1;
          }
          return (
            (r = c(t)),
            (s = l[r] = a[r](t)),
            {
              c() {
                (e = N("br")), (n = O()), s.c(), (i = R());
              },
              m(t, s) {
                P(t, e, s), P(t, n, s), l[r].m(t, s), P(t, i, s), (o = !0);
              },
              p(t, e) {
                let n = r;
                (r = c(t)),
                  r === n
                    ? l[r].p(t, e)
                    : (kt(),
                      St(l[n], 1, 1, () => {
                        l[n] = null;
                      }),
                      Et(),
                      (s = l[r]),
                      s ? s.p(t, e) : ((s = l[r] = a[r](t)), s.c()),
                      Ct(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (Ct(s), (o = !0));
              },
              o(t) {
                St(s), (o = !1);
              },
              d(t) {
                t && I(e), t && I(n), l[r].d(t), t && I(i);
              },
            }
          );
        }
        function Vm(t) {
          let e, n;
          return (
            (e = new Dr({
              props: {
                color: "green",
                $$slots: { default: [Qm] },
                $$scope: { ctx: t },
              },
            })),
            e.$on("click", t[14]),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                262144 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function Wm(t) {
          let e, n, r, s;
          return (
            (e = new Dr({
              props: {
                loading: !0,
                color: "green",
                $$slots: { default: [Jm] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Ws({
              props: {
                title: "Status",
                color: "blue",
                $$slots: { default: [_m] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), Ot(r.$$.fragment);
              },
              m(t, i) {
                Rt(e, t, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                262144 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const i = {};
                264192 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function Qm(t) {
          let e;
          return {
            c() {
              e = T("Release Payment to Merchant");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Jm(t) {
          let e;
          return {
            c() {
              e = T("Release Payment to Merchant");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function _m(t) {
          let e;
          return {
            c() {
              e = T(t[11]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              2048 & n && H(e, t[11]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Km(t) {
          let e;
          return {
            c() {
              e = T("fix-notifications");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function qm(t) {
          let e, n, r, s;
          return (
            (n = new Zs({
              props: {
                variant: "link",
                root: "span",
                href: "#",
                inherit: !0,
                $$slots: { default: [Km] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = T("You've created new branch")),
                  Ot(n.$$.fragment),
                  (r = T(" from master"));
              },
              m(t, i) {
                P(t, e, i), Rt(n, t, i), P(t, r, i), (s = !0);
              },
              p(t, e) {
                const r = {};
                262144 & e && (r.$$scope = { dirty: e, ctx: t }), n.$set(r);
              },
              i(t) {
                s || (Ct(n.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(n.$$.fragment, t), (s = !1);
              },
              d(t) {
                t && I(e), Lt(n, t), t && I(r);
              },
            }
          );
        }
        function Ym(t) {
          let e,
            n,
            r = t[2] / 4 + "";
          return {
            c() {
              (e = T("Merchant Deposited ")), (n = T(r));
            },
            m(t, r) {
              P(t, e, r), P(t, n, r);
            },
            p(t, e) {
              4 & e && r !== (r = t[2] / 4 + "") && H(n, r);
            },
            d(t) {
              t && I(e), t && I(n);
            },
          };
        }
        function Zm(t) {
          let e, n, r, s;
          return (
            (e = new Zs({
              props: {
                color: "dimmed",
                size: "sm",
                $$slots: { default: [qm] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Zs({
              props: {
                size: "xs",
                $$slots: { default: [Ym] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), Ot(r.$$.fragment);
              },
              m(t, i) {
                Rt(e, t, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                262144 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const i = {};
                262148 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function Xm(t) {
          let e,
            n = t[7].description + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              128 & r && n !== (n = t[7].description + "") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function ty(t) {
          let e,
            n = t[7].extra + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              128 & r && n !== (n = t[7].extra + "") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function ey(t) {
          let e, n, r, s;
          return (
            (e = new Zs({
              props: {
                size: "sm",
                color: t[7].color,
                $$slots: { default: [Xm] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Zs({
              props: {
                size: "xs",
                $$slots: { default: [ty] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), Ot(r.$$.fragment);
              },
              m(t, i) {
                Rt(e, t, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                128 & n && (s.color = t[7].color),
                  262272 & n && (s.$$scope = { dirty: n, ctx: t }),
                  e.$set(s);
                const i = {};
                262272 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function ny(t) {
          let e,
            n = t[8].description + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              256 & r && n !== (n = t[8].description + "") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function ry(t) {
          let e,
            n = t[8].extra + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              256 & r && n !== (n = t[8].extra + "") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function sy(t) {
          let e, n, r, s;
          return (
            (e = new Zs({
              props: {
                size: "sm",
                color: t[8].color,
                $$slots: { default: [ny] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Zs({
              props: {
                size: "xs",
                $$slots: { default: [ry] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment), (n = O()), Ot(r.$$.fragment);
              },
              m(t, i) {
                Rt(e, t, i), P(t, n, i), Rt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                256 & n && (s.color = t[8].color),
                  262400 & n && (s.$$scope = { dirty: n, ctx: t }),
                  e.$set(s);
                const i = {};
                262400 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (Ct(e.$$.fragment, t), Ct(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t);
              },
            }
          );
        }
        function iy(t) {
          let e, n, r, s, i, o;
          return (
            (e = new Eo.Item({
              props: {
                title: "New Escrow",
                $$slots: { default: [Zm] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Eo.Item({
              props: {
                title: t[7].title,
                color: t[7].color,
                $$slots: { default: [ey] },
                $$scope: { ctx: t },
              },
            })),
            (i = new Eo.Item({
              props: {
                title: t[8].title,
                color: t[8].color,
                $$slots: { default: [sy] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment),
                  (n = O()),
                  Ot(r.$$.fragment),
                  (s = O()),
                  Ot(i.$$.fragment);
              },
              m(t, a) {
                Rt(e, t, a),
                  P(t, n, a),
                  Rt(r, t, a),
                  P(t, s, a),
                  Rt(i, t, a),
                  (o = !0);
              },
              p(t, n) {
                const s = {};
                262148 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const o = {};
                128 & n && (o.title = t[7].title),
                  128 & n && (o.color = t[7].color),
                  262272 & n && (o.$$scope = { dirty: n, ctx: t }),
                  r.$set(o);
                const a = {};
                256 & n && (a.title = t[8].title),
                  256 & n && (a.color = t[8].color),
                  262400 & n && (a.$$scope = { dirty: n, ctx: t }),
                  i.$set(a);
              },
              i(t) {
                o ||
                  (Ct(e.$$.fragment, t),
                  Ct(r.$$.fragment, t),
                  Ct(i.$$.fragment, t),
                  (o = !0));
              },
              o(t) {
                St(e.$$.fragment, t),
                  St(r.$$.fragment, t),
                  St(i.$$.fragment, t),
                  (o = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t), t && I(s), Lt(i, t);
              },
            }
          );
        }
        function oy(t) {
          let e, n;
          return (
            (e = new Eo({
              props: {
                active: t[6],
                lineWidth: 4,
                bulletSize: 20,
                $$slots: { default: [iy] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                64 & n && (r.active = t[6]),
                  262532 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function ay(t) {
          let e, n;
          return (
            (e = new Ws({
              props: {
                title: "Error!",
                color: "red",
                $$slots: { default: [ly] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                262145 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function ly(t) {
          let e;
          return {
            c() {
              e = T(t[0]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              1 & n && H(e, t[0]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function cy(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l = t[3] ? "Merchant" : "Buyer",
            c = t[1] && Cm(t),
            u = t[0] && ay(t);
          return {
            c() {
              (e = N("h2")),
                (n = T(l)),
                (r = T(" Portal")),
                (s = O()),
                c && c.c(),
                (i = O()),
                u && u.c(),
                (o = R());
            },
            m(t, l) {
              P(t, e, l),
                x(e, n),
                x(e, r),
                P(t, s, l),
                c && c.m(t, l),
                P(t, i, l),
                u && u.m(t, l),
                P(t, o, l),
                (a = !0);
            },
            p(t, e) {
              (!a || 8 & e) &&
                l !== (l = t[3] ? "Merchant" : "Buyer") &&
                H(n, l),
                t[1]
                  ? c
                    ? (c.p(t, e), 2 & e && Ct(c, 1))
                    : ((c = Cm(t)), c.c(), Ct(c, 1), c.m(i.parentNode, i))
                  : c &&
                    (kt(),
                    St(c, 1, 1, () => {
                      c = null;
                    }),
                    Et()),
                t[0]
                  ? u
                    ? (u.p(t, e), 1 & e && Ct(u, 1))
                    : ((u = ay(t)), u.c(), Ct(u, 1), u.m(o.parentNode, o))
                  : u &&
                    (kt(),
                    St(u, 1, 1, () => {
                      u = null;
                    }),
                    Et());
            },
            i(t) {
              a || (Ct(c), Ct(u), (a = !0));
            },
            o(t) {
              St(c), St(u), (a = !1);
            },
            d(t) {
              t && I(e),
                t && I(s),
                c && c.d(t),
                t && I(i),
                u && u.d(t),
                t && I(o);
            },
          };
        }
        function uy(t) {
          let e, n;
          return (
            (e = new Fi({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [cy] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                266239 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function dy(t, e, n) {
          let { escrowID: r } = e;
          const s = new sm(window.ethereum);
          nt(() => {
            r &&
              (async function () {
                n(0, (i = null));
                let t = null;
                try {
                  t = Number(r);
                } catch (t) {
                  return (
                    console.log("Please enter a valid escrow number"),
                    void n(0, (i = "Please enter a valid escrow number"))
                  );
                }
                if (!t)
                  return (
                    console.log("Please enter escrow number"),
                    void n(0, (i = "Please enter escrow number"))
                  );
                const e = await s.getSigner(),
                  p = new qp(im, am, e),
                  g = await p.escrows(t);
                if (g.merchant === om)
                  return (
                    console.log("Escrow does not exist"),
                    void n(0, (i = "Escrow does not exist"))
                  );
                n(1, (o = g)), n(2, (a = Number(rl(g.amount))));
                const m = await Em();
                m.toLowerCase() === g.merchant.toLowerCase() && n(3, (l = !0));
                m.toLowerCase() === g.buyer.toLowerCase() && n(5, (u = !0));
                g.buyer !== om && n(4, (c = !0));
                c
                  ? (n(6, (d = 1)),
                    n(
                      7,
                      (h = {
                        title: "Buyer Entered",
                        description: `The buyer ${g.buyer} has entered the escrow and paid ${a} ETH`,
                        extra: "Buyer has also deposited " + a / 4,
                        color: "blue",
                      })
                    ))
                  : g.isDead &&
                    (n(6, (d = 1)),
                    n(
                      7,
                      (h = {
                        title: "Escrow Cancelled",
                        description: "The escrow was cancelled by the merchant",
                        extra: "No staked was deposited by a buyer",
                        color: "red",
                      })
                    ));
                c &&
                  g.isDead &&
                  (n(6, (d = 2)),
                  n(
                    8,
                    (f = {
                      title: "Ended",
                      description: "The escrow has ended",
                      extra:
                        "The buyer received the goods or the merchant refunded",
                      color: "black",
                    })
                  ));
              })();
          });
          let i = null,
            o = null,
            a = null,
            l = !1,
            c = !1,
            u = !1,
            d = 0,
            h = {
              title: "Buyer Entered",
              description: "",
              extra: "",
              color: "dimmed",
            },
            f = {
              title: "Complete",
              description: "",
              extra: "",
              color: "dimmed",
            };
          let p = null;
          let g = null;
          let m = null;
          return (
            (t.$$set = (t) => {
              "escrowID" in t && n(15, (r = t.escrowID));
            }),
            [
              i,
              o,
              a,
              l,
              c,
              u,
              d,
              h,
              f,
              p,
              g,
              m,
              async function () {
                n(9, (p = "Canceling escrow..."));
                const t = await s.getSigner(),
                  e = new qp(im, am, t),
                  i = await e.cancelEscrow(Number(r));
                n(
                  9,
                  (p =
                    "Cancel request signed and sent. Waiting for confirmation...")
                );
                const o = await i.wait();
                console.log("receipt", o),
                  n(9, (p = `Escrow cancelled in block ${o.blockNumber}`));
                const a = e.filters["EscrowCancelled(uint256)"],
                  l = await e.queryFilter(a, o.blockNumber);
                console.log("events", l),
                  n(9, (p = null)),
                  window.location.reload();
              },
              async function () {
                n(10, (g = "Depositing... " + a / 4 + " ETH"));
                const t = await s.getSigner(),
                  e = new qp(im, am, t),
                  i = await e.deposit(Number(r), {
                    value: sl((1.25 * a).toString()),
                  });
                n(
                  10,
                  (g =
                    "Deposit request signed and sent. Waiting for confirmation...")
                );
                const o = await i.wait();
                console.log("receipt", o),
                  n(10, (g = `Escrow cancelled in block ${o.blockNumber}`));
                const l = e.filters["Deposit(uint256,address,uint256)"],
                  c = await e.queryFilter(l, o.blockNumber);
                console.log("events", c),
                  n(10, (g = null)),
                  window.location.reload();
              },
              async function () {
                n(
                  11,
                  (m =
                    "Completing Trade, sending " +
                    a / 4 +
                    " ETH to the merchant")
                );
                const t = await s.getSigner(),
                  e = new qp(im, am, t),
                  i = await e.completeTrade(Number(r));
                n(
                  11,
                  (m =
                    "Complete Escrow request signed and sent. Waiting for confirmation...")
                );
                const o = await i.wait();
                console.log("receipt", o),
                  n(11, (m = `Escrow cancelled in block ${o.blockNumber}`));
                const l = e.filters["TradeCompleted(uint256,address)"],
                  c = await e.queryFilter(l, o.blockNumber);
                console.log("events", c),
                  n(11, (m = null)),
                  window.location.reload();
              },
              r,
            ]
          );
        }
        class hy extends Ft {
          constructor(t) {
            super(), zt(this, t, dy, uy, a, { escrowID: 15 });
          }
        }
        function fy(t, e, n) {
          const r = t.slice();
          return (
            (r[2] = e[n].escrowId),
            (r[3] = e[n].amount),
            (r[4] = e[n].details),
            (r[6] = n),
            r
          );
        }
        function py(t) {
          let e,
            n = t[3] + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              1 & r && n !== (n = t[3] + "") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function gy(t) {
          let e;
          return {
            c() {
              e = T("View");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function my(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l,
            c,
            u,
            d,
            h,
            f = t[2] + "",
            p = t[4] + "";
          return (
            (i = new di({
              props: {
                variant: "filled",
                $$slots: { default: [py] },
                $$scope: { ctx: t },
              },
            })),
            (d = new Dr({
              props: {
                href: `${window.location.href}?escrowID=${t[2]}`,
                $$slots: { default: [gy] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = N("h3")),
                  (n = T("Escrow ")),
                  (r = T(f)),
                  (s = O()),
                  Ot(i.$$.fragment),
                  (o = O()),
                  (a = N("p")),
                  (l = N("strong")),
                  (c = T(p)),
                  (u = O()),
                  Ot(d.$$.fragment);
              },
              m(t, f) {
                P(t, e, f),
                  x(e, n),
                  x(e, r),
                  P(t, s, f),
                  Rt(i, t, f),
                  P(t, o, f),
                  P(t, a, f),
                  x(a, l),
                  x(l, c),
                  P(t, u, f),
                  Rt(d, t, f),
                  (h = !0);
              },
              p(t, e) {
                (!h || 1 & e) && f !== (f = t[2] + "") && H(r, f);
                const n = {};
                129 & e && (n.$$scope = { dirty: e, ctx: t }),
                  i.$set(n),
                  (!h || 1 & e) && p !== (p = t[4] + "") && H(c, p);
                const s = {};
                1 & e && (s.href = `${window.location.href}?escrowID=${t[2]}`),
                  128 & e && (s.$$scope = { dirty: e, ctx: t }),
                  d.$set(s);
              },
              i(t) {
                h || (Ct(i.$$.fragment, t), Ct(d.$$.fragment, t), (h = !0));
              },
              o(t) {
                St(i.$$.fragment, t), St(d.$$.fragment, t), (h = !1);
              },
              d(t) {
                t && I(e),
                  t && I(s),
                  Lt(i, t),
                  t && I(o),
                  t && I(a),
                  t && I(u),
                  Lt(d, t);
              },
            }
          );
        }
        function yy(t) {
          let e, n, r, s, i, o;
          return (
            (n = new Si({
              props: {
                shadow: "sm",
                padding: "lg",
                $$slots: { default: [my] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = N("li")),
                  Ot(n.$$.fragment),
                  (r = O()),
                  (s = N("br")),
                  (i = O());
              },
              m(t, a) {
                P(t, e, a), Rt(n, e, null), x(e, r), x(e, s), x(e, i), (o = !0);
              },
              p(t, e) {
                const r = {};
                129 & e && (r.$$scope = { dirty: e, ctx: t }), n.$set(r);
              },
              i(t) {
                o || (Ct(n.$$.fragment, t), (o = !0));
              },
              o(t) {
                St(n.$$.fragment, t), (o = !1);
              },
              d(t) {
                t && I(e), Lt(n);
              },
            }
          );
        }
        function by(t) {
          let e,
            n,
            r = t[0],
            s = [];
          for (let e = 0; e < r.length; e += 1) s[e] = yy(fy(t, r, e));
          const i = (t) =>
            St(s[t], 1, 1, () => {
              s[t] = null;
            });
          return {
            c() {
              for (let t = 0; t < s.length; t += 1) s[t].c();
              e = R();
            },
            m(t, r) {
              for (let e = 0; e < s.length; e += 1) s[e] && s[e].m(t, r);
              P(t, e, r), (n = !0);
            },
            p(t, n) {
              if (1 & n) {
                let o;
                for (r = t[0], o = 0; o < r.length; o += 1) {
                  const i = fy(t, r, o);
                  s[o]
                    ? (s[o].p(i, n), Ct(s[o], 1))
                    : ((s[o] = yy(i)),
                      s[o].c(),
                      Ct(s[o], 1),
                      s[o].m(e.parentNode, e));
                }
                for (kt(), o = r.length; o < s.length; o += 1) i(o);
                Et();
              }
            },
            i(t) {
              if (!n) {
                for (let t = 0; t < r.length; t += 1) Ct(s[t]);
                n = !0;
              }
            },
            o(t) {
              s = s.filter(Boolean);
              for (let t = 0; t < s.length; t += 1) St(s[t]);
              n = !1;
            },
            d(t) {
              !(function (t, e) {
                for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e);
              })(s, t),
                t && I(e);
            },
          };
        }
        function wy(t) {
          let e, n;
          return (
            (e = new Fi({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [by] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                129 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function vy(t, e, n) {
          let r;
          return (
            l(t, lm, (t) => n(0, (r = t))),
            nt(() => {
              Em().then((t) => {
                !(function (t) {
                  const e = um().get(t.toLowerCase()) || [];
                  lm.set(e);
                })(t);
              });
            }),
            [r]
          );
        }
        class Ay extends Ft {
          constructor(t) {
            super(), zt(this, t, vy, wy, a, {});
          }
        }
        function $y(t) {
          let e, n;
          return (
            (e = new Oo({})),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function xy(t) {
          let e, n;
          return (
            (e = new km({})),
            {
              c() {
                Ot(e.$$.fragment);
              },
              m(t, r) {
                Rt(e, t, r), (n = !0);
              },
              i(t) {
                n || (Ct(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                St(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Lt(e, t);
              },
            }
          );
        }
        function ky(e) {
          let n;
          return {
            c() {
              (n = N("h1")), (n.textContent = "Trading app");
            },
            m(t, e) {
              P(t, n, e);
            },
            p: t,
            d(t) {
              t && I(n);
            },
          };
        }
        function Ey(t) {
          let e, n, r, s, i, o;
          return (
            (e = new Dr({
              props: {
                color: "green",
                $$slots: { default: [Sy] },
                $$scope: { ctx: t },
              },
            })),
            e.$on("click", t[4]),
            (i = new Ay({})),
            {
              c() {
                Ot(e.$$.fragment),
                  (n = O()),
                  (r = N("br")),
                  (s = O()),
                  Ot(i.$$.fragment);
              },
              m(t, a) {
                Rt(e, t, a),
                  P(t, n, a),
                  P(t, r, a),
                  P(t, s, a),
                  Rt(i, t, a),
                  (o = !0);
              },
              p(t, n) {
                const r = {};
                64 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                o || (Ct(e.$$.fragment, t), Ct(i.$$.fragment, t), (o = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(i.$$.fragment, t), (o = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), t && I(r), t && I(s), Lt(i, t);
              },
            }
          );
        }
        function Cy(e) {
          let n, r;
          return (
            (n = new hy({ props: { escrowID: e[2] } })),
            {
              c() {
                Ot(n.$$.fragment);
              },
              m(t, e) {
                Rt(n, t, e), (r = !0);
              },
              p: t,
              i(t) {
                r || (Ct(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                St(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                Lt(n, t);
              },
            }
          );
        }
        function Sy(t) {
          let e;
          return {
            c() {
              e = T("New escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Py(t) {
          let e, n, r, s, i, o, a, l;
          e = new Dr({
            props: {
              href: window.location.href.split("?")[0],
              $$slots: { default: [ky] },
              $$scope: { ctx: t },
            },
          });
          const c = [Cy, Ey],
            u = [];
          return (
            (i = (function (t, e) {
              return t[2] ? 0 : 1;
            })(t)),
            (o = u[i] = c[i](t)),
            {
              c() {
                Ot(e.$$.fragment),
                  (n = O()),
                  (r = N("br")),
                  (s = O()),
                  o.c(),
                  (a = R());
              },
              m(t, o) {
                Rt(e, t, o),
                  P(t, n, o),
                  P(t, r, o),
                  P(t, s, o),
                  u[i].m(t, o),
                  P(t, a, o),
                  (l = !0);
              },
              p(t, n) {
                const r = {};
                64 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r),
                  o.p(t, n);
              },
              i(t) {
                l || (Ct(e.$$.fragment, t), Ct(o), (l = !0));
              },
              o(t) {
                St(e.$$.fragment, t), St(o), (l = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), t && I(r), t && I(s), u[i].d(t), t && I(a);
              },
            }
          );
        }
        function Iy(t) {
          let e, n, r, s, i, o;
          return (
            (e = new Ns({
              props: {
                position: { top: 20, right: 20 },
                $$slots: { default: [$y] },
                $$scope: { ctx: t },
              },
            })),
            (r = new ao({
              props: {
                opened: t[1],
                title: "Create Escrow",
                $$slots: { default: [xy] },
                $$scope: { ctx: t },
              },
            })),
            r.$on("close", t[3]),
            (i = new Fi({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [Py] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Ot(e.$$.fragment),
                  (n = O()),
                  Ot(r.$$.fragment),
                  (s = O()),
                  Ot(i.$$.fragment);
              },
              m(t, a) {
                Rt(e, t, a),
                  P(t, n, a),
                  Rt(r, t, a),
                  P(t, s, a),
                  Rt(i, t, a),
                  (o = !0);
              },
              p(t, n) {
                const s = {};
                64 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const o = {};
                2 & n && (o.opened = t[1]),
                  64 & n && (o.$$scope = { dirty: n, ctx: t }),
                  r.$set(o);
                const a = {};
                66 & n && (a.$$scope = { dirty: n, ctx: t }), i.$set(a);
              },
              i(t) {
                o ||
                  (Ct(e.$$.fragment, t),
                  Ct(r.$$.fragment, t),
                  Ct(i.$$.fragment, t),
                  (o = !0));
              },
              o(t) {
                St(e.$$.fragment, t),
                  St(r.$$.fragment, t),
                  St(i.$$.fragment, t),
                  (o = !1);
              },
              d(t) {
                Lt(e, t), t && I(n), Lt(r, t), t && I(s), Lt(i, t);
              },
            }
          );
        }
        function Ny(t) {
          let e, n, r, s, i;
          return (
            (document.title = e = t[0]),
            (s = new le({
              props: { $$slots: { default: [Iy] }, $$scope: { ctx: t } },
            })),
            {
              c() {
                (n = N("meta")),
                  (r = O()),
                  Ot(s.$$.fragment),
                  z(n, "name", "description"),
                  z(n, "content", "Trading App");
              },
              m(t, e) {
                x(document.head, n), P(t, r, e), Rt(s, t, e), (i = !0);
              },
              p(t, [n]) {
                (!i || 1 & n) && e !== (e = t[0]) && (document.title = e);
                const r = {};
                66 & n && (r.$$scope = { dirty: n, ctx: t }), s.$set(r);
              },
              i(t) {
                i || (Ct(s.$$.fragment, t), (i = !0));
              },
              o(t) {
                St(s.$$.fragment, t), (i = !1);
              },
              d(t) {
                I(n), t && I(r), Lt(s, t);
              },
            }
          );
        }
        function By(t, e, n) {
          let { title: r } = e;
          const s =
            new URLSearchParams(window.location.search).get("escrowID") || null;
          let i = !1;
          return (
            (t.$$set = (t) => {
              "title" in t && n(0, (r = t.title));
            }),
            [
              r,
              i,
              s,
              function () {
                n(1, (i = !1));
              },
              () => n(1, (i = !0)),
            ]
          );
        }
        return new (class extends Ft {
          constructor(t) {
            super(), zt(this, t, By, Ny, a, { title: 0 });
          }
        })({ target: document.body, props: { title: "Trading App" } });
      })();
      //# sourceMappingURL=bundle.js.map
    </script>
  </body>
</html>
