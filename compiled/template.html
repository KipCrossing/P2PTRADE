<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trading App</title>
  </head>
  <body>
    <div id="app"></div>
    <script>
      var app = (function () {
        "use strict";
        function t() {}
        const e = (t) => t;
        function n(t, e) {
          for (const n in e) t[n] = e[n];
          return t;
        }
        function r(t) {
          return t();
        }
        function s() {
          return Object.create(null);
        }
        function i(t) {
          t.forEach(r);
        }
        function o(t) {
          return "function" == typeof t;
        }
        function a(t, e) {
          return t != t
            ? e == e
            : t !== e || (t && "object" == typeof t) || "function" == typeof t;
        }
        function l(e, n, r) {
          e.$$.on_destroy.push(
            (function (e, ...n) {
              if (null == e) return t;
              const r = e.subscribe(...n);
              return r.unsubscribe ? () => r.unsubscribe() : r;
            })(n, r)
          );
        }
        function c(t, e, n, r) {
          if (t) {
            const s = u(t, e, n, r);
            return t[0](s);
          }
        }
        function u(t, e, r, s) {
          return t[1] && s ? n(r.ctx.slice(), t[1](s(e))) : r.ctx;
        }
        function d(t, e, n, r) {
          if (t[2] && r) {
            const s = t[2](r(n));
            if (void 0 === e.dirty) return s;
            if ("object" == typeof s) {
              const t = [],
                n = Math.max(e.dirty.length, s.length);
              for (let r = 0; r < n; r += 1) t[r] = e.dirty[r] | s[r];
              return t;
            }
            return e.dirty | s;
          }
          return e.dirty;
        }
        function h(t, e, n, r, s, i) {
          if (s) {
            const o = u(e, n, r, i);
            t.p(o, s);
          }
        }
        function f(t) {
          if (t.ctx.length > 32) {
            const e = [],
              n = t.ctx.length / 32;
            for (let t = 0; t < n; t++) e[t] = -1;
            return e;
          }
          return -1;
        }
        function p(t) {
          const e = {};
          for (const n in t) "$" !== n[0] && (e[n] = t[n]);
          return e;
        }
        function g(t, e) {
          const n = {};
          e = new Set(e);
          for (const r in t) e.has(r) || "$" === r[0] || (n[r] = t[r]);
          return n;
        }
        function m(t) {
          const e = {};
          for (const n in t) e[n] = !0;
          return e;
        }
        function y(e) {
          return e && o(e.destroy) ? e.destroy : t;
        }
        const b = "undefined" != typeof window;
        let w = b ? () => window.performance.now() : () => Date.now(),
          v = b ? (t) => requestAnimationFrame(t) : t;
        const A = new Set();
        function x(t) {
          A.forEach((e) => {
            e.c(t) || (A.delete(e), e.f());
          }),
            0 !== A.size && v(x);
        }
        function $(t, e) {
          t.appendChild(e);
        }
        function k(t, e, n) {
          const r = E(t);
          if (!r.getElementById(e)) {
            const t = B("style");
            (t.id = e), (t.textContent = n), S(r, t);
          }
        }
        function E(t) {
          if (!t) return document;
          const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;
          return e && e.host ? e : t.ownerDocument;
        }
        function C(t) {
          const e = B("style");
          return S(E(t), e), e.sheet;
        }
        function S(t, e) {
          return $(t.head || t, e), e.sheet;
        }
        function P(t, e, n) {
          t.insertBefore(e, n || null);
        }
        function I(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
        function B(t) {
          return document.createElement(t);
        }
        function N(t) {
          return document.createElementNS("http://www.w3.org/2000/svg", t);
        }
        function T(t) {
          return document.createTextNode(t);
        }
        function O() {
          return T(" ");
        }
        function R() {
          return T("");
        }
        function L(t, e, n, r) {
          return (
            t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r)
          );
        }
        function z(t, e, n) {
          null == n
            ? t.removeAttribute(e)
            : t.getAttribute(e) !== n && t.setAttribute(e, n);
        }
        const U = ["width", "height"];
        function F(t, e) {
          const n = Object.getOwnPropertyDescriptors(t.__proto__);
          for (const r in e)
            null == e[r]
              ? t.removeAttribute(r)
              : "style" === r
              ? (t.style.cssText = e[r])
              : "__value" === r
              ? (t.value = t[r] = e[r])
              : n[r] && n[r].set && -1 === U.indexOf(r)
              ? (t[r] = e[r])
              : z(t, r, e[r]);
        }
        function D(t, e) {
          for (const n in e) z(t, n, e[n]);
        }
        function M(t, e) {
          Object.keys(e).forEach((n) => {
            !(function (t, e, n) {
              e in t
                ? (t[e] = ("boolean" == typeof t[e] && "" === n) || n)
                : z(t, e, n);
            })(t, n, e[n]);
          });
        }
        function j(t) {
          return /-/.test(t) ? M : F;
        }
        function H(t, e) {
          (e = "" + e), t.data !== e && (t.data = e);
        }
        function G(t, e) {
          t.value = null == e ? "" : e;
        }
        function V(t, e, n, r) {
          null == n
            ? t.style.removeProperty(e)
            : t.style.setProperty(e, n, r ? "important" : "");
        }
        function Q(t, e, n) {
          t.classList[n ? "add" : "remove"](e);
        }
        function W(t, e, { bubbles: n = !1, cancelable: r = !1 } = {}) {
          const s = document.createEvent("CustomEvent");
          return s.initCustomEvent(t, n, r, e), s;
        }
        class J {
          constructor(t = !1) {
            (this.is_svg = !1), (this.is_svg = t), (this.e = this.n = null);
          }
          c(t) {
            this.h(t);
          }
          m(t, e, n = null) {
            this.e ||
              (this.is_svg
                ? (this.e = N(e.nodeName))
                : (this.e = B(11 === e.nodeType ? "TEMPLATE" : e.nodeName)),
              (this.t = "TEMPLATE" !== e.tagName ? e : e.content),
              this.c(t)),
              this.i(n);
          }
          h(t) {
            (this.e.innerHTML = t),
              (this.n = Array.from(
                "TEMPLATE" === this.e.nodeName
                  ? this.e.content.childNodes
                  : this.e.childNodes
              ));
          }
          i(t) {
            for (let e = 0; e < this.n.length; e += 1) P(this.t, this.n[e], t);
          }
          p(t) {
            this.d(), this.h(t), this.i(this.a);
          }
          d() {
            this.n.forEach(I);
          }
        }
        function _(t, e) {
          return new t(e);
        }
        const K = new Map();
        let q,
          Y = 0;
        function Z(t, e, n, r, s, i, o, a = 0) {
          const l = 16.666 / r;
          let c = "{\n";
          for (let t = 0; t <= 1; t += l) {
            const r = e + (n - e) * i(t);
            c += 100 * t + `%{${o(r, 1 - r)}}\n`;
          }
          const u = c + `100% {${o(n, 1 - n)}}\n}`,
            d = `__svelte_${(function (t) {
              let e = 5381,
                n = t.length;
              for (; n--; ) e = ((e << 5) - e) ^ t.charCodeAt(n);
              return e >>> 0;
            })(u)}_${a}`,
            h = E(t),
            { stylesheet: f, rules: p } =
              K.get(h) ||
              (function (t, e) {
                const n = { stylesheet: C(e), rules: {} };
                return K.set(t, n), n;
              })(h, t);
          p[d] ||
            ((p[d] = !0),
            f.insertRule(`@keyframes ${d} ${u}`, f.cssRules.length));
          const g = t.style.animation || "";
          return (
            (t.style.animation = `${
              g ? `${g}, ` : ""
            }${d} ${r}ms linear ${s}ms 1 both`),
            (Y += 1),
            d
          );
        }
        function X(t, e) {
          const n = (t.style.animation || "").split(", "),
            r = n.filter(
              e ? (t) => t.indexOf(e) < 0 : (t) => -1 === t.indexOf("__svelte")
            ),
            s = n.length - r.length;
          s &&
            ((t.style.animation = r.join(", ")),
            (Y -= s),
            Y ||
              v(() => {
                Y ||
                  (K.forEach((t) => {
                    const { ownerNode: e } = t.stylesheet;
                    e && I(e);
                  }),
                  K.clear());
              }));
        }
        function tt(t) {
          q = t;
        }
        function et() {
          if (!q)
            throw new Error("Function called outside component initialization");
          return q;
        }
        function nt(t) {
          et().$$.on_mount.push(t);
        }
        function rt() {
          const t = et();
          return (e, n, { cancelable: r = !1 } = {}) => {
            const s = t.$$.callbacks[e];
            if (s) {
              const i = W(e, n, { cancelable: r });
              return (
                s.slice().forEach((e) => {
                  e.call(t, i);
                }),
                !i.defaultPrevented
              );
            }
            return !0;
          };
        }
        const st = [],
          it = [];
        let ot = [];
        const at = [],
          lt = Promise.resolve();
        let ct = !1;
        function ut() {
          ct || ((ct = !0), lt.then(yt));
        }
        function dt() {
          return ut(), lt;
        }
        function ht(t) {
          ot.push(t);
        }
        function ft(t) {
          at.push(t);
        }
        const pt = new Set();
        let gt,
          mt = 0;
        function yt() {
          if (0 !== mt) return;
          const t = q;
          do {
            try {
              for (; mt < st.length; ) {
                const t = st[mt];
                mt++, tt(t), bt(t.$$);
              }
            } catch (t) {
              throw ((st.length = 0), (mt = 0), t);
            }
            for (tt(null), st.length = 0, mt = 0; it.length; ) it.pop()();
            for (let t = 0; t < ot.length; t += 1) {
              const e = ot[t];
              pt.has(e) || (pt.add(e), e());
            }
            ot.length = 0;
          } while (st.length);
          for (; at.length; ) at.pop()();
          (ct = !1), pt.clear(), tt(t);
        }
        function bt(t) {
          if (null !== t.fragment) {
            t.update(), i(t.before_update);
            const e = t.dirty;
            (t.dirty = [-1]),
              t.fragment && t.fragment.p(t.ctx, e),
              t.after_update.forEach(ht);
          }
        }
        function wt(t, e, n) {
          t.dispatchEvent(W(`${e ? "intro" : "outro"}${n}`));
        }
        const vt = new Set();
        let At;
        function xt() {
          At = { r: 0, c: [], p: At };
        }
        function $t() {
          At.r || i(At.c), (At = At.p);
        }
        function kt(t, e) {
          t && t.i && (vt.delete(t), t.i(e));
        }
        function Et(t, e, n, r) {
          if (t && t.o) {
            if (vt.has(t)) return;
            vt.add(t),
              At.c.push(() => {
                vt.delete(t), r && (n && t.d(1), r());
              }),
              t.o(e);
          } else r && r();
        }
        const Ct = { duration: 0 };
        function St(n, r, s, a) {
          const l = { direction: "both" };
          let c = r(n, s, l),
            u = a ? 0 : 1,
            d = null,
            h = null,
            f = null;
          function p() {
            f && X(n, f);
          }
          function g(t, e) {
            const n = t.b - u;
            return (
              (e *= Math.abs(n)),
              {
                a: u,
                b: t.b,
                d: n,
                duration: e,
                start: t.start,
                end: t.start + e,
                group: t.group,
              }
            );
          }
          function m(r) {
            const {
                delay: s = 0,
                duration: o = 300,
                easing: a = e,
                tick: l = t,
                css: m,
              } = c || Ct,
              y = { start: w() + s, b: r };
            r || ((y.group = At), (At.r += 1)),
              d || h
                ? (h = y)
                : (m && (p(), (f = Z(n, u, r, o, s, a, m))),
                  r && l(0, 1),
                  (d = g(y, o)),
                  ht(() => wt(n, r, "start")),
                  (function (t) {
                    let e;
                    0 === A.size && v(x),
                      new Promise((n) => {
                        A.add((e = { c: t, f: n }));
                      });
                  })((t) => {
                    if (
                      (h &&
                        t > h.start &&
                        ((d = g(h, o)),
                        (h = null),
                        wt(n, d.b, "start"),
                        m &&
                          (p(), (f = Z(n, u, d.b, d.duration, 0, a, c.css)))),
                      d)
                    )
                      if (t >= d.end)
                        l((u = d.b), 1 - u),
                          wt(n, d.b, "end"),
                          h || (d.b ? p() : --d.group.r || i(d.group.c)),
                          (d = null);
                      else if (t >= d.start) {
                        const e = t - d.start;
                        (u = d.a + d.d * a(e / d.duration)), l(u, 1 - u);
                      }
                    return !(!d && !h);
                  }));
          }
          return {
            run(t) {
              o(c)
                ? (gt ||
                    ((gt = Promise.resolve()),
                    gt.then(() => {
                      gt = null;
                    })),
                  gt).then(() => {
                    (c = c(l)), m(t);
                  })
                : m(t);
            },
            end() {
              p(), (d = h = null);
            },
          };
        }
        function Pt(t, e) {
          const n = {},
            r = {},
            s = { $$scope: 1 };
          let i = t.length;
          for (; i--; ) {
            const o = t[i],
              a = e[i];
            if (a) {
              for (const t in o) t in a || (r[t] = 1);
              for (const t in a) s[t] || ((n[t] = a[t]), (s[t] = 1));
              t[i] = a;
            } else for (const t in o) s[t] = 1;
          }
          for (const t in r) t in n || (n[t] = void 0);
          return n;
        }
        function It(t) {
          return "object" == typeof t && null !== t ? t : {};
        }
        function Bt(t, e, n) {
          const r = t.$$.props[e];
          void 0 !== r && ((t.$$.bound[r] = n), n(t.$$.ctx[r]));
        }
        function Nt(t) {
          t && t.c();
        }
        function Tt(t, e, n, s) {
          const { fragment: a, after_update: l } = t.$$;
          a && a.m(e, n),
            s ||
              ht(() => {
                const e = t.$$.on_mount.map(r).filter(o);
                t.$$.on_destroy ? t.$$.on_destroy.push(...e) : i(e),
                  (t.$$.on_mount = []);
              }),
            l.forEach(ht);
        }
        function Ot(t, e) {
          const n = t.$$;
          null !== n.fragment &&
            (!(function (t) {
              const e = [],
                n = [];
              ot.forEach((r) => (-1 === t.indexOf(r) ? e.push(r) : n.push(r))),
                n.forEach((t) => t()),
                (ot = e);
            })(n.after_update),
            i(n.on_destroy),
            n.fragment && n.fragment.d(e),
            (n.on_destroy = n.fragment = null),
            (n.ctx = []));
        }
        function Rt(e, n, r, o, a, l, c, u = [-1]) {
          const d = q;
          tt(e);
          const h = (e.$$ = {
            fragment: null,
            ctx: [],
            props: l,
            update: t,
            not_equal: a,
            bound: s(),
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(n.context || (d ? d.$$.context : [])),
            callbacks: s(),
            dirty: u,
            skip_bound: !1,
            root: n.target || d.$$.root,
          });
          c && c(h.root);
          let f = !1;
          if (
            ((h.ctx = r
              ? r(e, n.props || {}, (t, n, ...r) => {
                  const s = r.length ? r[0] : n;
                  return (
                    h.ctx &&
                      a(h.ctx[t], (h.ctx[t] = s)) &&
                      (!h.skip_bound && h.bound[t] && h.bound[t](s),
                      f &&
                        (function (t, e) {
                          -1 === t.$$.dirty[0] &&
                            (st.push(t), ut(), t.$$.dirty.fill(0)),
                            (t.$$.dirty[(e / 31) | 0] |= 1 << e % 31);
                        })(e, t)),
                    n
                  );
                })
              : []),
            h.update(),
            (f = !0),
            i(h.before_update),
            (h.fragment = !!o && o(h.ctx)),
            n.target)
          ) {
            if (n.hydrate) {
              const t = (function (t) {
                return Array.from(t.childNodes);
              })(n.target);
              h.fragment && h.fragment.l(t), t.forEach(I);
            } else h.fragment && h.fragment.c();
            n.intro && kt(e.$$.fragment),
              Tt(e, n.target, n.anchor, n.customElement),
              yt();
          }
          tt(d);
        }
        class Lt {
          $destroy() {
            Ot(this, 1), (this.$destroy = t);
          }
          $on(e, n) {
            if (!o(n)) return t;
            const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
            return (
              r.push(n),
              () => {
                const t = r.indexOf(n);
                -1 !== t && r.splice(t, 1);
              }
            );
          }
          $set(t) {
            var e;
            this.$$set &&
              ((e = t), 0 !== Object.keys(e).length) &&
              ((this.$$.skip_bound = !0),
              this.$$set(t),
              (this.$$.skip_bound = !1));
          }
        }
        function zt(t) {
          let e,
            n,
            r = Gt(t[1], t[2]) + "";
          return {
            c() {
              (e = new J(!1)), (n = R()), (e.a = n);
            },
            m(t, s) {
              e.m(r, t, s), P(t, n, s);
            },
            p(t, n) {
              6 & n && r !== (r = Gt(t[1], t[2]) + "") && e.p(r);
            },
            d(t) {
              t && I(n), t && e.d();
            },
          };
        }
        function Ut(e) {
          let n,
            r = e[0] && zt(e);
          return {
            c() {
              r && r.c(), (n = R());
            },
            m(t, e) {
              r && r.m(t, e), P(t, n, e);
            },
            p(t, [e]) {
              t[0]
                ? r
                  ? r.p(t, e)
                  : ((r = zt(t)), r.c(), r.m(n.parentNode, n))
                : r && (r.d(1), (r = null));
            },
            i: t,
            o: t,
            d(t) {
              r && r.d(t), t && I(n);
            },
          };
        }
        function Ft(t, e, n) {
          let { observable: r = !1 } = e,
            { component: s } = e,
            { code: i } = e;
          return (
            (t.$$set = (t) => {
              "observable" in t && n(0, (r = t.observable)),
                "component" in t && n(1, (s = t.component)),
                "code" in t && n(2, (i = t.code));
            }),
            [r, s, i]
          );
        }
        var Dt = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Ft, Ut, a, { observable: 0, component: 1, code: 2 });
          }
        };
        const Mt = "undefined" != typeof window,
          jt = Mt ? document.createElement("style") : void 0;
        if (Mt) {
          const t = jt;
          (t.textContent =
            ".modal-header{padding: 2px 16px;background-color: #339af0;color: white;}.modal-body{padding: 2px 16px;}.modal-footer{padding: 2px 16px;background-color: #339af0;color: white;}.modal-content{position: relative;background-color: #fefefe;margin: auto;padding: 0;border: 1px solid #888;width: 80%;box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);animation-name: animateTop;animation-duration: 0.4s;}@keyframes animateTop {from {top: -300px; opacity: 0}to {top: 0; opacity: 1}}"),
            (t.id = "svelteui-inject");
        }
        function Ht(t, e, n) {
          Mt && document.head.appendChild(jt);
          return `\n    <div class="modal-content">\n        <div class="modal-header">\n            <h2>[${t} Component Error]:</h2>\n            <h3>${e}</h3>\n        </div>\n        <div class="modal-body">\n            <pre>\n                ${
            n || ""
          }\n            </pre>\n        </div>\n        <div class="modal-footer">\n            <h3>Fix the code to dismiss this error.</h3>\n        </div>\n    </div>        \n    `;
        }
        function Gt(t, e) {
          const { message: n, solution: r } = e;
          return r ? Ht(t, n, r) : Ht(t, n);
        }
        function Vt(t, e) {
          const n = [];
          if (e)
            for (let r = 0; r < e.length; r++) {
              const s = e[r],
                i = Array.isArray(s) ? s[0] : s;
              Array.isArray(s) && s.length > 1
                ? n.push(i(t, s[1]))
                : n.push(i(t));
            }
          return {
            update(t) {
              if (((t && t.length) || 0) != n.length)
                throw new Error(
                  "You must not change the length of an actions array."
                );
              if (t)
                for (let e = 0; e < t.length; e++) {
                  const r = n[e];
                  if (r && r.update) {
                    const n = t[e];
                    Array.isArray(n) && n.length > 1
                      ? r.update(n[1])
                      : r.update();
                  }
                }
            },
            destroy() {
              for (let t = 0; t < n.length; t++) {
                const e = n[t];
                e && e.destroy && e.destroy();
              }
            },
          };
        }
        const Qt = "!",
          Wt = new RegExp(
            `^[^${Qt}]+(?:${Qt}(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$`
          );
        function Jt(t, e = []) {
          let n;
          const r = [];
          function s(e) {
            !(function (t, e) {
              const n = t.$$.callbacks[e.type];
              n && n.slice().forEach((t) => t.call(this, e));
            })(t, e);
          }
          return (
            (t.$on = (s, i) => {
              const o = s;
              let a = () => {};
              for (const n of e) {
                if ("string" == typeof n && n === o) {
                  const e = t.$$.callbacks[o] || (t.$$.callbacks[o] = []);
                  return (
                    e.push(i),
                    () => {
                      const t = e.indexOf(i);
                      -1 !== t && e.splice(t, 1);
                    }
                  );
                }
                if ("object" == typeof n && n.name === o) {
                  const t = i;
                  i = (...e) => {
                    ("object" == typeof n && n.shouldExclude()) || t(...e);
                  };
                }
              }
              return (
                n ? (a = n(o, i)) : r.push([o, i]),
                () => {
                  a();
                }
              );
            }),
            (t) => {
              const e = [],
                i = {};
              n = (n, r) => {
                let o = n,
                  a = r,
                  l = !1;
                if (o.match(Wt)) {
                  const t = o.split(Qt);
                  o = t[0];
                  const e = Object.fromEntries(t.slice(1).map((t) => [t, !0]));
                  e.passive && ((l = l || {}), (l.passive = !0)),
                    e.nonpassive && ((l = l || {}), (l.passive = !1)),
                    e.capture && ((l = l || {}), (l.capture = !0)),
                    e.once && ((l = l || {}), (l.once = !0)),
                    e.preventDefault &&
                      ((c = a),
                      (a = function (t) {
                        return t.preventDefault(), c.call(this, t);
                      })),
                    e.stopPropagation &&
                      (a = (function (t) {
                        return function (e) {
                          return e.stopPropagation(), t.call(this, e);
                        };
                      })(a));
                }
                var c;
                const u = L(t, o, a, l),
                  d = () => {
                    u();
                    const t = e.indexOf(d);
                    t > -1 && e.splice(t, 1);
                  };
                return e.push(d), o in i || (i[o] = L(t, o, s)), d;
              };
              for (let t = 0; t < r.length; t++) n(r[t][0], r[t][1]);
              return {
                destroy: () => {
                  for (let t = 0; t < e.length; t++) e[t]();
                  for (const t of Object.entries(i)) t[1]();
                },
              };
            }
          );
        }
        function _t(t) {
          const e = t - 1;
          return e * e * e + 1;
        }
        function Kt(t) {
          return -0.5 * (Math.cos(Math.PI * t) - 1);
        }
        function qt(
          t,
          { delay: n = 0, duration: r = 400, easing: s = e } = {}
        ) {
          const i = +getComputedStyle(t).opacity;
          return {
            delay: n,
            duration: r,
            easing: s,
            css: (t) => "opacity: " + t * i,
          };
        }
        function Yt(
          t,
          {
            delay: e = 0,
            duration: n = 400,
            easing: r = _t,
            start: s = 0,
            opacity: i = 0,
          } = {}
        ) {
          const o = getComputedStyle(t),
            a = +o.opacity,
            l = "none" === o.transform ? "" : o.transform,
            c = 1 - s,
            u = a * (1 - i);
          return {
            delay: e,
            duration: n,
            easing: r,
            css: (t, e) =>
              `\n\t\t\ttransform: ${l} scale(${1 - c * e});\n\t\t\topacity: ${
                a - u * e
              }\n\t\t`,
          };
        }
        const Zt = {};
        function Xt() {
          return (function (t) {
            return et().$$.context.get(t);
          })(Zt);
        }
        const te = [];
        const ee = (function (e, n = t) {
          let r;
          const s = new Set();
          function i(t) {
            if (a(e, t) && ((e = t), r)) {
              const t = !te.length;
              for (const t of s) t[1](), te.push(t, e);
              if (t) {
                for (let t = 0; t < te.length; t += 2) te[t][0](te[t + 1]);
                te.length = 0;
              }
            }
          }
          return {
            set: i,
            update: function (t) {
              i(t(e));
            },
            subscribe: function (o, a = t) {
              const l = [o, a];
              return (
                s.add(l),
                1 === s.size && (r = n(i) || t),
                o(e),
                () => {
                  s.delete(l), 0 === s.size && r && (r(), (r = null));
                }
              );
            },
          };
        })("light");
        function ne() {
          let t;
          ee?.subscribe((e) => {
            t = e;
          });
          return {
            ...$n,
            colorNames: ye,
            colorScheme: t,
            dark: Sn?.selector,
            fn: {
              cover: ge.cover,
              themeColor: ge.themeColor,
              size: ge.size,
              radius: ge.radius,
              rgba: ge.rgba,
              variant: ge.variant,
            },
          };
        }
        function re(t) {
          let e, r, s, a, l, u;
          const p = t[19].default,
            g = c(p, t, t[18], null);
          let m = [
              { id: "SVELTEUI_PROVIDER" },
              { class: (r = t[5](t[2], t[4].root, t[3])) },
              t[7],
            ],
            b = {};
          for (let t = 0; t < m.length; t += 1) b = n(b, m[t]);
          return {
            c() {
              (e = B("div")), g && g.c(), F(e, b);
            },
            m(n, r) {
              P(n, e, r),
                g && g.m(e, null),
                t[20](e),
                (a = !0),
                l ||
                  ((u = [
                    y((s = Vt.call(null, e, t[1]))),
                    y(t[6].call(null, e)),
                  ]),
                  (l = !0));
            },
            p(t, [n]) {
              g &&
                g.p &&
                (!a || 262144 & n) &&
                h(g, p, t, t[18], a ? d(p, t[18], n, null) : f(t[18]), null),
                F(
                  e,
                  (b = Pt(m, [
                    { id: "SVELTEUI_PROVIDER" },
                    (!a ||
                      (60 & n && r !== (r = t[5](t[2], t[4].root, t[3])))) && {
                      class: r,
                    },
                    128 & n && t[7],
                  ]))
                ),
                s && o(s.update) && 2 & n && s.update.call(null, t[1]);
            },
            i(t) {
              a || (kt(g, t), (a = !0));
            },
            o(t) {
              Et(g, t), (a = !1);
            },
            d(n) {
              n && I(e), g && g.d(n), t[20](null), (l = !1), i(u);
            },
          };
        }
        function se(t, e, r) {
          let s, i, o, a;
          const c = [
            "use",
            "class",
            "element",
            "theme",
            "styles",
            "defaultProps",
            "themeObserver",
            "withNormalizeCSS",
            "withGlobalStyles",
            "override",
            "inherit",
          ];
          let u,
            d = g(e, c);
          l(t, ee, (t) => r(21, (u = t)));
          let { $$slots: h = {}, $$scope: f } = e,
            {
              use: m = [],
              class: y = "",
              element: b,
              theme: w = ne(),
              styles: v = {},
              defaultProps: A = {},
              themeObserver: x = "light",
              withNormalizeCSS: $ = !1,
              withGlobalStyles: k = !1,
              override: E = {},
              inherit: C = !1,
            } = e;
          var S;
          (S = () => {
            const t = document.documentElement.classList;
            "dark" === u && t.add(Sn.className),
              "light" === u && t.remove(Sn.className);
          }),
            et().$$.before_update.push(S);
          const P = Xt(),
            I = ke(() => ({ root: {} })),
            B = Jt(et()),
            N = ne();
          let T = null;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (d = g(e, c))),
                "use" in t && r(1, (m = t.use)),
                "class" in t && r(2, (y = t.class)),
                "element" in t && r(0, (b = t.element)),
                "theme" in t && r(8, (w = t.theme)),
                "styles" in t && r(9, (v = t.styles)),
                "defaultProps" in t && r(10, (A = t.defaultProps)),
                "themeObserver" in t && r(11, (x = t.themeObserver)),
                "withNormalizeCSS" in t && r(12, ($ = t.withNormalizeCSS)),
                "withGlobalStyles" in t && r(13, (k = t.withGlobalStyles)),
                "override" in t && r(14, (E = t.override)),
                "inherit" in t && r(15, (C = t.inherit)),
                "$$scope" in t && r(18, (f = t.$$scope));
            }),
            (t.$$.update = () => {
              34560 & t.$$.dirty &&
                r(
                  16,
                  (s = {
                    themeOverride: C ? { ...P.theme, ...w } : w,
                    styles: C ? { ...P.styles, ...v } : v,
                    defaultProps: C ? { ...P.styles, ...A } : A,
                  })
                ),
                65536 & t.$$.dirty &&
                  r(
                    17,
                    (i = (function (t, e) {
                      if (!e) return t;
                      return Object.keys(t).reduce(
                        (n, r) => (
                          (n[r] =
                            "object" == typeof e[r]
                              ? { ...t[r], ...e[r] }
                              : "number" == typeof e[r]
                              ? e[r]
                              : e[r] || t[r]),
                          n
                        ),
                        {}
                      );
                    })(N, s.themeOverride))
                  ),
                133120 & t.$$.dirty &&
                  null !== x &&
                  r(3, (T = "light" === x ? i : Sn)),
                8192 & t.$$.dirty && k && Pn(),
                4096 & t.$$.dirty && $ && In(),
                65536 & t.$$.dirty &&
                  (function (t, e) {
                    et().$$.context.set(t, e);
                  })(Zt, {
                    theme: s.themeOverride,
                    styles: {},
                    defaultProps: {},
                  }),
                2048 & t.$$.dirty && ee.set(x),
                16384 & t.$$.dirty &&
                  r(
                    5,
                    ({ cx: o, classes: a } = I(null, { override: E })),
                    o,
                    (r(4, a), r(14, E))
                  );
            }),
            [
              b,
              m,
              y,
              T,
              a,
              o,
              B,
              d,
              w,
              v,
              A,
              x,
              $,
              k,
              E,
              C,
              s,
              i,
              f,
              h,
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (b = t), r(0, b);
                });
              },
            ]
          );
        }
        var ie = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, se, re, a, {
                use: 1,
                class: 2,
                element: 0,
                theme: 8,
                styles: 9,
                defaultProps: 10,
                themeObserver: 11,
                withNormalizeCSS: 12,
                withGlobalStyles: 13,
                override: 14,
                inherit: 15,
              });
          }
        };
        function oe(t, e = 0) {
          const n = Xt()?.theme || ne();
          let r = "50";
          return (function (t) {
            let e = !1;
            switch (t) {
              case "dark":
              case "gray":
              case "red":
              case "pink":
              case "grape":
              case "violet":
              case "indigo":
              case "blue":
              case "cyan":
              case "teal":
              case "green":
              case "lime":
              case "yellow":
              case "orange":
                e = !0;
                break;
              default:
                e = !1;
            }
            return e;
          })(t)
            ? (e !== Number(0) && (r = `${e.toString()}00`),
              n.colors[`${t}${r}`]?.value)
            : t;
        }
        function ae(t) {
          return (function (t) {
            const e = t.replace("#", "");
            return (
              "string" == typeof e &&
              6 === e.length &&
              !Number.isNaN(Number(`0x${e}`))
            );
          })(t)
            ? (function (t) {
                const e = t.replace("#", ""),
                  n = parseInt(e, 16);
                return {
                  r: (n >> 16) & 255,
                  g: (n >> 8) & 255,
                  b: 255 & n,
                  a: 1,
                };
              })(t)
            : t.startsWith("rgb")
            ? (function (t) {
                const [e, n, r, s] = t
                  .replace(/[^0-9,.]/g, "")
                  .split(",")
                  .map(Number);
                return { r: e, g: n, b: r, a: s || 1 };
              })(t)
            : { r: 0, g: 0, b: 0, a: 1 };
        }
        const le = (t, e) => {
          const { themeColor: n, rgba: r } = ge,
            s = {
              filled: {
                [`${Sn.selector} &`]: { backgroundColor: n(t, 8) },
                border: "transparent",
                backgroundColor: n(t, 6),
                color: "White",
                "&:hover": { backgroundColor: n(t, 7) },
              },
              light: {
                [`${Sn.selector} &`]: {
                  backgroundColor: r(n(t, 8), 0.35),
                  color: "dark" === t ? n("dark", 0) : n(t, 2),
                  "&:hover": { backgroundColor: r(n(t, 7), 0.45) },
                },
                border: "transparent",
                backgroundColor: n(t, 0),
                color: "dark" === t ? n("dark", 9) : n(t, 6),
                "&:hover": { backgroundColor: n(t, 1) },
              },
              outline: {
                [`${Sn.selector} &`]: {
                  border: `1px solid ${n(t, 4)}`,
                  color: `${n(t, 4)}`,
                  "&:hover": { backgroundColor: r(n(t, 4), 0.05) },
                },
                border: `1px solid ${n(t, 7)}`,
                backgroundColor: "transparent",
                color: n(t, 7),
                "&:hover": { backgroundColor: r(n(t, 0), 0.35) },
              },
              subtle: {
                [`${Sn.selector} &`]: {
                  color: "dark" === t ? n("dark", 0) : n(t, 2),
                  "&:hover": { backgroundColor: r(n(t, 8), 0.35) },
                },
                border: "transparent",
                backgroundColor: "transparent",
                color: "dark" === t ? n("dark", 9) : n(t, 6),
                "&:hover": { backgroundColor: n(t, 0) },
              },
              default: {
                [`${Sn.selector} &`]: {
                  border: `1px solid ${n("dark", 5)}`,
                  backgroundColor: n("dark", 5),
                  color: "White",
                  "&:hover": { backgroundColor: n("dark", 4) },
                },
                border: `1px solid ${n("gray", 4)}`,
                backgroundColor: "White",
                color: "Black",
                "&:hover": { backgroundColor: n("gray", 0) },
              },
              white: {
                border: "transparent",
                backgroundColor: "White",
                color: n(t, 7),
                "&:hover": { backgroundColor: "White" },
              },
              gradient: {},
            };
          return (
            e &&
              (s.gradient = {
                border: "transparent",
                background: `linear-gradient(${e.deg}deg, $${e.from}600 0%, $${e.to}600 100%)`,
                color: "White",
              }),
            s
          );
        };
        const ce =
          ((ue = "rem"),
          (t) => {
            if ("number" == typeof t) return `${t / 16}${ue}`;
            if ("string" == typeof t) {
              const e = t.replace("px", "");
              if (!Number.isNaN(Number(e))) return `${Number(e) / 16}${ue}`;
            }
            return t;
          });
        var ue;
        function de(t, e = 1) {
          if ("string" != typeof t || e > 1 || e < 0) return "rgba(0, 0, 0, 1)";
          const { r: n, g: r, b: s } = ae(t);
          return `rgba(${n}, ${r}, ${s}, ${e})`;
        }
        const he = "indigo",
          fe = "cyan",
          pe = 45;
        const ge = {
            cover: function (t = 0) {
              return {
                position: "absolute",
                top: ce(t),
                right: ce(t),
                left: ce(t),
                bottom: ce(t),
              };
            },
            size: function (t) {
              return "number" == typeof t.size
                ? t.size
                : "number" == typeof t.sizes[t.size]
                ? t.sizes[t.size]
                : +t.sizes[t.size]?.value || +t.sizes.md?.value;
            },
            radius: function (t) {
              const e = Xt()?.theme || ne();
              return "number" == typeof t ? t : e.radii[t].value;
            },
            themeColor: oe,
            variant: function ({ variant: t, color: e, gradient: n }) {
              const r = Xt()?.theme || ne();
              if ("light" === t)
                return {
                  border: "transparent",
                  background: [de(oe(e, 8), 0.35), de(oe(e, 0), 1)],
                  color: [
                    "dark" === e ? oe("dark", 0) : oe(e, 2),
                    "dark" === e ? oe("dark", 9) : oe(e, 6),
                  ],
                  hover: [de(oe(e, 7), 0.45), de(oe(e, 1), 0.65)],
                };
              if ("default" === t)
                return {
                  border: [oe("dark", 5), oe("gray", 4)],
                  background: [oe("dark", 5), r.colors.white.value],
                  color: [r.colors.white.value, r.colors.black.value],
                  hover: [oe("dark", 4), oe("gray", 0)],
                };
              if ("white" === t)
                return {
                  border: "transparent",
                  background: r.colors.white.value,
                  color: oe(e, 6),
                  hover: null,
                };
              if ("outline" === t)
                return {
                  border: [oe(e, 4), oe(e, 6)],
                  background: "transparent",
                  color: [oe(e, 4), oe(e, 6)],
                  hover: [de(oe(e, 4), 0.05), de(oe(e, 0), 0.35)],
                };
              if ("gradient" === t) {
                const t = {
                  from: n?.from || he,
                  to: n?.to || fe,
                  deg: n?.deg || pe,
                };
                return {
                  background: `linear-gradient(${t.deg}deg, ${oe(
                    t.from,
                    6
                  )} 0%, ${oe(t.to, 6)} 100%)`,
                  color: r.colors.white.value,
                  border: "transparent",
                  hover: null,
                };
              }
              return "subtle" === t
                ? {
                    border: "transparent",
                    background: "transparent",
                    color: [
                      "dark" === e ? oe("dark", 0) : oe(e, 2),
                      "dark" === e ? oe("dark", 9) : oe(e, 6),
                    ],
                    hover: [de(oe(e, 8), 0.35), de(oe(e, 0), 1)],
                  }
                : {
                    border: "transparent",
                    background: [oe(e, 8), oe(e, 6)],
                    color: r.colors.white.value,
                    hover: oe(e, 7),
                  };
            },
            rgba: de,
          },
          me = {
            primary: "#228be6",
            white: "#ffffff",
            black: "#000000",
            dark50: "#C1C2C5",
            dark100: "#A6A7AB",
            dark200: "#909296",
            dark300: "#5c5f66",
            dark400: "#373A40",
            dark500: "#2C2E33",
            dark600: "#25262b",
            dark700: "#1A1B1E",
            dark800: "#141517",
            dark900: "#101113",
            gray50: "#f8f9fa",
            gray100: "#f1f3f5",
            gray200: "#e9ecef",
            gray300: "#dee2e6",
            gray400: "#ced4da",
            gray500: "#adb5bd",
            gray600: "#868e96",
            gray700: "#495057",
            gray800: "#343a40",
            gray900: "#212529",
            red50: "#fff5f5",
            red100: "#ffe3e3",
            red200: "#ffc9c9",
            red300: "#ffa8a8",
            red400: "#ff8787",
            red500: "#ff6b6b",
            red600: "#fa5252",
            red700: "#f03e3e",
            red800: "#e03131",
            red900: "#c92a2a",
            pink50: "#fff0f6",
            pink100: "#ffdeeb",
            pink200: "#fcc2d7",
            pink300: "#faa2c1",
            pink400: "#f783ac",
            pink500: "#f06595",
            pink600: "#e64980",
            pink700: "#d6336c",
            pink800: "#c2255c",
            pink900: "#a61e4d",
            grape50: "#f8f0fc",
            grape100: "#f3d9fa",
            grape200: "#eebefa",
            grape300: "#e599f7",
            grape400: "#da77f2",
            grape500: "#cc5de8",
            grape600: "#be4bdb",
            grape700: "#ae3ec9",
            grape800: "#9c36b5",
            grape900: "#862e9c",
            violet50: "#f3f0ff",
            violet100: "#e5dbff",
            violet200: "#d0bfff",
            violet300: "#b197fc",
            violet400: "#9775fa",
            violet500: "#845ef7",
            violet600: "#7950f2",
            violet700: "#7048e8",
            violet800: "#6741d9",
            violet900: "#5f3dc4",
            indigo50: "#edf2ff",
            indigo100: "#dbe4ff",
            indigo200: "#bac8ff",
            indigo300: "#91a7ff",
            indigo400: "#748ffc",
            indigo500: "#5c7cfa",
            indigo600: "#4c6ef5",
            indigo700: "#4263eb",
            indigo800: "#3b5bdb",
            indigo900: "#364fc7",
            blue50: "#e7f5ff",
            blue100: "#d0ebff",
            blue200: "#a5d8ff",
            blue300: "#74c0fc",
            blue400: "#4dabf7",
            blue500: "#339af0",
            blue600: "#228be6",
            blue700: "#1c7ed6",
            blue800: "#1971c2",
            blue900: "#1864ab",
            cyan50: "#e3fafc",
            cyan100: "#c5f6fa",
            cyan200: "#99e9f2",
            cyan300: "#66d9e8",
            cyan400: "#3bc9db",
            cyan500: "#22b8cf",
            cyan600: "#15aabf",
            cyan700: "#1098ad",
            cyan800: "#0c8599",
            cyan900: "#0b7285",
            teal50: "#e6fcf5",
            teal100: "#c3fae8",
            teal200: "#96f2d7",
            teal300: "#63e6be",
            teal400: "#38d9a9",
            teal500: "#20c997",
            teal600: "#12b886",
            teal700: "#0ca678",
            teal800: "#099268",
            teal900: "#087f5b",
            green50: "#ebfbee",
            green100: "#d3f9d8",
            green200: "#b2f2bb",
            green300: "#8ce99a",
            green400: "#69db7c",
            green500: "#51cf66",
            green600: "#40c057",
            green700: "#37b24d",
            green800: "#2f9e44",
            green900: "#2b8a3e",
            lime50: "#f4fce3",
            lime100: "#e9fac8",
            lime200: "#d8f5a2",
            lime300: "#c0eb75",
            lime400: "#a9e34b",
            lime500: "#94d82d",
            lime600: "#82c91e",
            lime700: "#74b816",
            lime800: "#66a80f",
            lime900: "#5c940d",
            yellow50: "#fff9db",
            yellow100: "#fff3bf",
            yellow200: "#ffec99",
            yellow300: "#ffe066",
            yellow400: "#ffd43b",
            yellow500: "#fcc419",
            yellow600: "#fab005",
            yellow700: "#f59f00",
            yellow800: "#f08c00",
            yellow900: "#e67700",
            orange50: "#fff4e6",
            orange100: "#ffe8cc",
            orange200: "#ffd8a8",
            orange300: "#ffc078",
            orange400: "#ffa94d",
            orange500: "#ff922b",
            orange600: "#fd7e14",
            orange700: "#f76707",
            orange800: "#e8590c",
            orange900: "#d9480f",
          },
          ye = {
            blue: "blue",
            cyan: "cyan",
            dark: "dark",
            grape: "grape",
            gray: "gray",
            green: "green",
            indigo: "indigo",
            lime: "lime",
            orange: "orange",
            pink: "pink",
            red: "red",
            teal: "teal",
            violet: "violet",
            yellow: "yellow",
          },
          be = {}.hasOwnProperty;
        function we(...t) {
          const e = [];
          for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (!r) continue;
            const s = typeof r;
            if ("string" === s || "number" === s) e.push(r);
            else if (Array.isArray(r)) {
              if (r.length) {
                const t = { ...r };
                t && e.push(t);
              }
            } else if ("object" === s)
              if (r.toString === Object.prototype.toString)
                for (const t in r) be.call(r, t) && r[t] && e.push(t);
              else e.push(r.toString());
          }
          return e.join(" ");
        }
        function ve() {
          return { cx: we };
        }
        const Ae = "svelteui";
        function xe(t) {
          return `__svelteui-ref-${t || ""}`;
        }
        function $e(t, e) {
          const n = [],
            r = {},
            s = (t) => {
              Object.keys(t).map((i) => {
                if ("variants" !== i) {
                  if (
                    ("ref" === i && n.push(t.ref),
                    "darkMode" === i && (t[`${e.dark} &`] = t.darkMode),
                    null !== t[i] && "object" == typeof t[i])
                  )
                    if ((s(t[i]), "darkMode" === i)) delete t[i];
                    else if (i.startsWith("@media"));
                    else if (!i.startsWith("&") && !i.startsWith(e.dark)) {
                      const e = wn(t[i]);
                      (r[i] = e().toString()),
                        (t[`& .${e().toString()}`] = t[i]),
                        delete t[i];
                    }
                } else
                  ((t) => {
                    const e = Object.keys(t.variation);
                    for (const n of e) s(t.variation[n]);
                  })(t[i]);
              });
            };
          return (
            s(t),
            delete t["& .root"],
            { classMap: r, refs: Array.from(new Set(n)) }
          );
        }
        function ke(t) {
          const e = "function" == typeof t ? t : () => t;
          return function (t = {}, n) {
            const r = Xt()?.theme || ne(),
              { cx: s } = ve(),
              { override: i, name: o } = n || {},
              a = e(r, t, xe),
              l = Object.assign({}, a),
              { classMap: c, refs: u } = $e(l, r),
              d = a.root ?? void 0,
              h = void 0 !== d ? { ...d, ...l } : a,
              f = wn(h),
              p = (function (t) {
                const e = {};
                return (
                  Object.keys(t).forEach((n) => {
                    const [r, s] = t[n];
                    e[r] = s;
                  }),
                  e
                );
              })(
                Object.keys(a).map((t) => {
                  const e = u.find((e) => e.includes(t)) ?? "",
                    n = e?.split("-") ?? [],
                    r = e?.split("-")[n?.length - 1] === t,
                    s = t.toString();
                  let a = c[s] ?? s;
                  e && r && (a = `${a} ${e}`),
                    "root" === t && (a = f({ css: i }).toString());
                  let l = `${Ae}-${t.toString()}`;
                  return (
                    o &&
                      ((l = `${Ae}-${o}-${t.toString()}`), (a = `${a} ${l}`)),
                    [t, a]
                  );
                })
              );
            return { cx: s, theme: r, classes: p, getStyles: wn(h) };
          };
        }
        var Ee = "colors",
          Ce = "sizes",
          Se = "space",
          Pe = {
            gap: Se,
            gridGap: Se,
            columnGap: Se,
            gridColumnGap: Se,
            rowGap: Se,
            gridRowGap: Se,
            inset: Se,
            insetBlock: Se,
            insetBlockEnd: Se,
            insetBlockStart: Se,
            insetInline: Se,
            insetInlineEnd: Se,
            insetInlineStart: Se,
            margin: Se,
            marginTop: Se,
            marginRight: Se,
            marginBottom: Se,
            marginLeft: Se,
            marginBlock: Se,
            marginBlockEnd: Se,
            marginBlockStart: Se,
            marginInline: Se,
            marginInlineEnd: Se,
            marginInlineStart: Se,
            padding: Se,
            paddingTop: Se,
            paddingRight: Se,
            paddingBottom: Se,
            paddingLeft: Se,
            paddingBlock: Se,
            paddingBlockEnd: Se,
            paddingBlockStart: Se,
            paddingInline: Se,
            paddingInlineEnd: Se,
            paddingInlineStart: Se,
            top: Se,
            right: Se,
            bottom: Se,
            left: Se,
            scrollMargin: Se,
            scrollMarginTop: Se,
            scrollMarginRight: Se,
            scrollMarginBottom: Se,
            scrollMarginLeft: Se,
            scrollMarginX: Se,
            scrollMarginY: Se,
            scrollMarginBlock: Se,
            scrollMarginBlockEnd: Se,
            scrollMarginBlockStart: Se,
            scrollMarginInline: Se,
            scrollMarginInlineEnd: Se,
            scrollMarginInlineStart: Se,
            scrollPadding: Se,
            scrollPaddingTop: Se,
            scrollPaddingRight: Se,
            scrollPaddingBottom: Se,
            scrollPaddingLeft: Se,
            scrollPaddingX: Se,
            scrollPaddingY: Se,
            scrollPaddingBlock: Se,
            scrollPaddingBlockEnd: Se,
            scrollPaddingBlockStart: Se,
            scrollPaddingInline: Se,
            scrollPaddingInlineEnd: Se,
            scrollPaddingInlineStart: Se,
            fontSize: "fontSizes",
            background: Ee,
            backgroundColor: Ee,
            backgroundImage: Ee,
            borderImage: Ee,
            border: Ee,
            borderBlock: Ee,
            borderBlockEnd: Ee,
            borderBlockStart: Ee,
            borderBottom: Ee,
            borderBottomColor: Ee,
            borderColor: Ee,
            borderInline: Ee,
            borderInlineEnd: Ee,
            borderInlineStart: Ee,
            borderLeft: Ee,
            borderLeftColor: Ee,
            borderRight: Ee,
            borderRightColor: Ee,
            borderTop: Ee,
            borderTopColor: Ee,
            caretColor: Ee,
            color: Ee,
            columnRuleColor: Ee,
            fill: Ee,
            outline: Ee,
            outlineColor: Ee,
            stroke: Ee,
            textDecorationColor: Ee,
            fontFamily: "fonts",
            fontWeight: "fontWeights",
            lineHeight: "lineHeights",
            letterSpacing: "letterSpacings",
            blockSize: Ce,
            minBlockSize: Ce,
            maxBlockSize: Ce,
            inlineSize: Ce,
            minInlineSize: Ce,
            maxInlineSize: Ce,
            width: Ce,
            minWidth: Ce,
            maxWidth: Ce,
            height: Ce,
            minHeight: Ce,
            maxHeight: Ce,
            flexBasis: Ce,
            gridTemplateColumns: Ce,
            gridTemplateRows: Ce,
            borderWidth: "borderWidths",
            borderTopWidth: "borderWidths",
            borderRightWidth: "borderWidths",
            borderBottomWidth: "borderWidths",
            borderLeftWidth: "borderWidths",
            borderStyle: "borderStyles",
            borderTopStyle: "borderStyles",
            borderRightStyle: "borderStyles",
            borderBottomStyle: "borderStyles",
            borderLeftStyle: "borderStyles",
            borderRadius: "radii",
            borderTopLeftRadius: "radii",
            borderTopRightRadius: "radii",
            borderBottomRightRadius: "radii",
            borderBottomLeftRadius: "radii",
            boxShadow: "shadows",
            textShadow: "shadows",
            transition: "transitions",
            zIndex: "zIndices",
          },
          Ie = (t, e) =>
            "function" == typeof e
              ? { "()": Function.prototype.toString.call(e) }
              : e,
          Be = () => {
            const t = Object.create(null);
            return (e, n, ...r) => {
              const s = ((t) => JSON.stringify(t, Ie))(e);
              return s in t ? t[s] : (t[s] = n(e, ...r));
            };
          },
          Ne = Symbol.for("sxs.internal"),
          Te = (t, e) =>
            Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)),
          Oe = (t) => {
            for (const e in t) return !0;
            return !1;
          },
          { hasOwnProperty: Re } = Object.prototype,
          Le = (t) =>
            t.includes("-")
              ? t
              : t.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()),
          ze = /\s+(?![^()]*\))/,
          Ue = (t) => (e) =>
            t(...("string" == typeof e ? String(e).split(ze) : [e])),
          Fe = {
            appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
            backfaceVisibility: (t) => ({
              WebkitBackfaceVisibility: t,
              backfaceVisibility: t,
            }),
            backdropFilter: (t) => ({
              WebkitBackdropFilter: t,
              backdropFilter: t,
            }),
            backgroundClip: (t) => ({
              WebkitBackgroundClip: t,
              backgroundClip: t,
            }),
            boxDecorationBreak: (t) => ({
              WebkitBoxDecorationBreak: t,
              boxDecorationBreak: t,
            }),
            clipPath: (t) => ({ WebkitClipPath: t, clipPath: t }),
            content: (t) => ({
              content:
                t.includes('"') ||
                t.includes("'") ||
                /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(
                  t
                )
                  ? t
                  : `"${t}"`,
            }),
            hyphens: (t) => ({ WebkitHyphens: t, hyphens: t }),
            maskImage: (t) => ({ WebkitMaskImage: t, maskImage: t }),
            maskSize: (t) => ({ WebkitMaskSize: t, maskSize: t }),
            tabSize: (t) => ({ MozTabSize: t, tabSize: t }),
            textSizeAdjust: (t) => ({
              WebkitTextSizeAdjust: t,
              textSizeAdjust: t,
            }),
            userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
            marginBlock: Ue((t, e) => ({
              marginBlockStart: t,
              marginBlockEnd: e || t,
            })),
            marginInline: Ue((t, e) => ({
              marginInlineStart: t,
              marginInlineEnd: e || t,
            })),
            maxSize: Ue((t, e) => ({ maxBlockSize: t, maxInlineSize: e || t })),
            minSize: Ue((t, e) => ({ minBlockSize: t, minInlineSize: e || t })),
            paddingBlock: Ue((t, e) => ({
              paddingBlockStart: t,
              paddingBlockEnd: e || t,
            })),
            paddingInline: Ue((t, e) => ({
              paddingInlineStart: t,
              paddingInlineEnd: e || t,
            })),
          },
          De = /([\d.]+)([^]*)/,
          Me = (t, e) =>
            t.length
              ? t.reduce(
                  (t, n) => (
                    t.push(
                      ...e.map((t) =>
                        t.includes("&")
                          ? t.replace(
                              /&/g,
                              /[ +>|~]/.test(n) && /&.*&/.test(t)
                                ? `:is(${n})`
                                : n
                            )
                          : n + " " + t
                      )
                    ),
                    t
                  ),
                  []
                )
              : e,
          je = (t, e) =>
            t in He && "string" == typeof e
              ? e.replace(
                  /^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,
                  (e, n, r, s) =>
                    n +
                    ("stretch" === r
                      ? `-moz-available${s};${Le(t)}:${n}-webkit-fill-available`
                      : `-moz-fit-content${s};${Le(t)}:${n}fit-content`) +
                    s
                )
              : String(e),
          He = {
            blockSize: 1,
            height: 1,
            inlineSize: 1,
            maxBlockSize: 1,
            maxHeight: 1,
            maxInlineSize: 1,
            maxWidth: 1,
            minBlockSize: 1,
            minHeight: 1,
            minInlineSize: 1,
            minWidth: 1,
            width: 1,
          },
          Ge = (t) => (t ? t + "-" : ""),
          Ve = (t, e, n) =>
            t.replace(
              /([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,
              (t, r, s, i, o) =>
                ("$" == i) == !!s
                  ? t
                  : (r || "--" == i ? "calc(" : "") +
                    "var(--" +
                    ("$" === i
                      ? Ge(e) +
                        (o.includes("$") ? "" : Ge(n)) +
                        o.replace(/\$/g, "-")
                      : o) +
                    ")" +
                    (r || "--" == i ? "*" + (r || "") + (s || "1") + ")" : "")
            ),
          Qe = /\s*,\s*(?![^()]*\))/,
          We = Object.prototype.toString,
          Je = (t, e, n, r, s) => {
            let i, o, a;
            const l = (t, e, n) => {
              let c, u;
              const d = (t) => {
                for (c in t) {
                  const p = 64 === c.charCodeAt(0),
                    g = p && Array.isArray(t[c]) ? t[c] : [t[c]];
                  for (u of g) {
                    const t = /[A-Z]/.test((f = c))
                        ? f
                        : f.replace(/-[^]/g, (t) => t[1].toUpperCase()),
                      g =
                        "object" == typeof u &&
                        u &&
                        u.toString === We &&
                        (!r.utils[t] || !e.length);
                    if (t in r.utils && !g) {
                      const e = r.utils[t];
                      if (e !== o) {
                        (o = e), d(e(u)), (o = null);
                        continue;
                      }
                    } else if (t in Fe) {
                      const e = Fe[t];
                      if (e !== a) {
                        (a = e), d(e(u)), (a = null);
                        continue;
                      }
                    }
                    if (
                      (p &&
                        ((h =
                          c.slice(1) in r.media
                            ? "@media " + r.media[c.slice(1)]
                            : c),
                        (c = h.replace(
                          /\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,
                          (t, e, n, r, s, i) => {
                            const o = De.test(e),
                              a = 0.0625 * (o ? -1 : 1),
                              [l, c] = o ? [r, e] : [e, r];
                            return (
                              "(" +
                              ("=" === n[0]
                                ? ""
                                : (">" === n[0]) === o
                                ? "max-"
                                : "min-") +
                              l +
                              ":" +
                              ("=" !== n[0] && 1 === n.length
                                ? c.replace(
                                    De,
                                    (t, e, r) =>
                                      Number(e) + a * (">" === n ? 1 : -1) + r
                                  )
                                : c) +
                              (s
                                ? ") and (" +
                                  (">" === s[0] ? "min-" : "max-") +
                                  l +
                                  ":" +
                                  (1 === s.length
                                    ? i.replace(
                                        De,
                                        (t, e, n) =>
                                          Number(e) +
                                          a * (">" === s ? -1 : 1) +
                                          n
                                      )
                                    : i)
                                : "") +
                              ")"
                            );
                          }
                        ))),
                      g)
                    ) {
                      const t = p ? n.concat(c) : [...n],
                        r = p ? [...e] : Me(e, c.split(Qe));
                      void 0 !== i && s(_e(...i)), (i = void 0), l(u, r, t);
                    } else
                      void 0 === i && (i = [[], e, n]),
                        (c =
                          p || 36 !== c.charCodeAt(0)
                            ? c
                            : `--${Ge(r.prefix)}${c
                                .slice(1)
                                .replace(/\$/g, "-")}`),
                        (u = g
                          ? u
                          : "number" == typeof u
                          ? u && t in Ke
                            ? String(u) + "px"
                            : String(u)
                          : Ve(
                              je(t, null == u ? "" : u),
                              r.prefix,
                              r.themeMap[t]
                            )),
                        i[0].push(`${p ? `${c} ` : `${Le(c)}:`}${u}`);
                  }
                }
                var h, f;
              };
              d(t), void 0 !== i && s(_e(...i)), (i = void 0);
            };
            l(t, e, n);
          },
          _e = (t, e, n) =>
            `${n.map((t) => `${t}{`).join("")}${
              e.length ? `${e.join(",")}{` : ""
            }${t.join(";")}${e.length ? "}" : ""}${Array(
              n.length ? n.length + 1 : 0
            ).join("}")}`,
          Ke = {
            animationDelay: 1,
            animationDuration: 1,
            backgroundSize: 1,
            blockSize: 1,
            border: 1,
            borderBlock: 1,
            borderBlockEnd: 1,
            borderBlockEndWidth: 1,
            borderBlockStart: 1,
            borderBlockStartWidth: 1,
            borderBlockWidth: 1,
            borderBottom: 1,
            borderBottomLeftRadius: 1,
            borderBottomRightRadius: 1,
            borderBottomWidth: 1,
            borderEndEndRadius: 1,
            borderEndStartRadius: 1,
            borderInlineEnd: 1,
            borderInlineEndWidth: 1,
            borderInlineStart: 1,
            borderInlineStartWidth: 1,
            borderInlineWidth: 1,
            borderLeft: 1,
            borderLeftWidth: 1,
            borderRadius: 1,
            borderRight: 1,
            borderRightWidth: 1,
            borderSpacing: 1,
            borderStartEndRadius: 1,
            borderStartStartRadius: 1,
            borderTop: 1,
            borderTopLeftRadius: 1,
            borderTopRightRadius: 1,
            borderTopWidth: 1,
            borderWidth: 1,
            bottom: 1,
            columnGap: 1,
            columnRule: 1,
            columnRuleWidth: 1,
            columnWidth: 1,
            containIntrinsicSize: 1,
            flexBasis: 1,
            fontSize: 1,
            gap: 1,
            gridAutoColumns: 1,
            gridAutoRows: 1,
            gridTemplateColumns: 1,
            gridTemplateRows: 1,
            height: 1,
            inlineSize: 1,
            inset: 1,
            insetBlock: 1,
            insetBlockEnd: 1,
            insetBlockStart: 1,
            insetInline: 1,
            insetInlineEnd: 1,
            insetInlineStart: 1,
            left: 1,
            letterSpacing: 1,
            margin: 1,
            marginBlock: 1,
            marginBlockEnd: 1,
            marginBlockStart: 1,
            marginBottom: 1,
            marginInline: 1,
            marginInlineEnd: 1,
            marginInlineStart: 1,
            marginLeft: 1,
            marginRight: 1,
            marginTop: 1,
            maxBlockSize: 1,
            maxHeight: 1,
            maxInlineSize: 1,
            maxWidth: 1,
            minBlockSize: 1,
            minHeight: 1,
            minInlineSize: 1,
            minWidth: 1,
            offsetDistance: 1,
            offsetRotate: 1,
            outline: 1,
            outlineOffset: 1,
            outlineWidth: 1,
            overflowClipMargin: 1,
            padding: 1,
            paddingBlock: 1,
            paddingBlockEnd: 1,
            paddingBlockStart: 1,
            paddingBottom: 1,
            paddingInline: 1,
            paddingInlineEnd: 1,
            paddingInlineStart: 1,
            paddingLeft: 1,
            paddingRight: 1,
            paddingTop: 1,
            perspective: 1,
            right: 1,
            rowGap: 1,
            scrollMargin: 1,
            scrollMarginBlock: 1,
            scrollMarginBlockEnd: 1,
            scrollMarginBlockStart: 1,
            scrollMarginBottom: 1,
            scrollMarginInline: 1,
            scrollMarginInlineEnd: 1,
            scrollMarginInlineStart: 1,
            scrollMarginLeft: 1,
            scrollMarginRight: 1,
            scrollMarginTop: 1,
            scrollPadding: 1,
            scrollPaddingBlock: 1,
            scrollPaddingBlockEnd: 1,
            scrollPaddingBlockStart: 1,
            scrollPaddingBottom: 1,
            scrollPaddingInline: 1,
            scrollPaddingInlineEnd: 1,
            scrollPaddingInlineStart: 1,
            scrollPaddingLeft: 1,
            scrollPaddingRight: 1,
            scrollPaddingTop: 1,
            shapeMargin: 1,
            textDecoration: 1,
            textDecorationThickness: 1,
            textIndent: 1,
            textUnderlineOffset: 1,
            top: 1,
            transitionDelay: 1,
            transitionDuration: 1,
            verticalAlign: 1,
            width: 1,
            wordSpacing: 1,
          },
          qe = (t) => String.fromCharCode(t + (t > 25 ? 39 : 97)),
          Ye = (t) =>
            ((t) => {
              let e,
                n = "";
              for (e = Math.abs(t); e > 52; e = (e / 52) | 0)
                n = qe(e % 52) + n;
              return qe(e % 52) + n;
            })(
              ((t, e) => {
                let n = e.length;
                for (; n; ) t = (33 * t) ^ e.charCodeAt(--n);
                return t;
              })(5381, JSON.stringify(t)) >>> 0
            ),
          Ze = [
            "themed",
            "global",
            "styled",
            "onevar",
            "resonevar",
            "allvar",
            "inline",
          ],
          Xe = (t) => {
            if (t.href && !t.href.startsWith(location.origin)) return !1;
            try {
              return !!t.cssRules;
            } catch (t) {
              return !1;
            }
          },
          tn = (t) => {
            let e;
            const n = () => {
                const { cssRules: t } = e.sheet;
                return [].map
                  .call(t, (n, r) => {
                    const { cssText: s } = n;
                    let i = "";
                    if (s.startsWith("--sxs")) return "";
                    if (
                      t[r - 1] &&
                      (i = t[r - 1].cssText).startsWith("--sxs")
                    ) {
                      if (!n.cssRules.length) return "";
                      for (const t in e.rules)
                        if (e.rules[t].group === n)
                          return `--sxs{--sxs:${[...e.rules[t].cache].join(
                            " "
                          )}}${s}`;
                      return n.cssRules.length ? `${i}${s}` : "";
                    }
                    return s;
                  })
                  .join("");
              },
              r = () => {
                if (e) {
                  const { rules: t, sheet: n } = e;
                  if (!n.deleteRule) {
                    for (; 3 === Object(Object(n.cssRules)[0]).type; )
                      n.cssRules.splice(0, 1);
                    n.cssRules = [];
                  }
                  for (const e in t) delete t[e];
                }
                const s = Object(t).styleSheets || [];
                for (const t of s)
                  if (Xe(t)) {
                    for (let s = 0, i = t.cssRules; i[s]; ++s) {
                      const o = Object(i[s]);
                      if (1 !== o.type) continue;
                      const a = Object(i[s + 1]);
                      if (4 !== a.type) continue;
                      ++s;
                      const { cssText: l } = o;
                      if (!l.startsWith("--sxs")) continue;
                      const c = l.slice(14, -3).trim().split(/\s+/),
                        u = Ze[c[0]];
                      u &&
                        (e ||
                          (e = { sheet: t, reset: r, rules: {}, toString: n }),
                        (e.rules[u] = {
                          group: a,
                          index: s,
                          cache: new Set(c),
                        }));
                    }
                    if (e) break;
                  }
                if (!e) {
                  const s = (t, e) => ({
                    type: e,
                    cssRules: [],
                    insertRule(t, e) {
                      this.cssRules.splice(
                        e,
                        0,
                        s(
                          t,
                          { import: 3, undefined: 1 }[
                            (t.toLowerCase().match(/^@([a-z]+)/) || [])[1]
                          ] || 4
                        )
                      );
                    },
                    get cssText() {
                      return "@media{}" === t
                        ? `@media{${[].map
                            .call(this.cssRules, (t) => t.cssText)
                            .join("")}}`
                        : t;
                    },
                  });
                  e = {
                    sheet: t
                      ? (t.head || t).appendChild(
                          document.createElement("style")
                        ).sheet
                      : s("", "text/css"),
                    rules: {},
                    reset: r,
                    toString: n,
                  };
                }
                const { sheet: i, rules: o } = e;
                for (let t = Ze.length - 1; t >= 0; --t) {
                  const e = Ze[t];
                  if (!o[e]) {
                    const n = Ze[t + 1],
                      r = o[n] ? o[n].index : i.cssRules.length;
                    i.insertRule("@media{}", r),
                      i.insertRule(`--sxs{--sxs:${t}}`, r),
                      (o[e] = {
                        group: i.cssRules[r + 1],
                        index: r,
                        cache: new Set([t]),
                      });
                  }
                  en(o[e]);
                }
              };
            return r(), e;
          },
          en = (t) => {
            const e = t.group;
            let n = e.cssRules.length;
            t.apply = (t) => {
              try {
                e.insertRule(t, n), ++n;
              } catch (t) {}
            };
          },
          nn = Symbol(),
          rn = Be(),
          sn = (t, e) =>
            rn(t, () => (...n) => {
              let r = { type: null, composers: new Set() };
              for (const e of n)
                if (null != e)
                  if (e[Ne]) {
                    null == r.type && (r.type = e[Ne].type);
                    for (const t of e[Ne].composers) r.composers.add(t);
                  } else
                    e.constructor !== Object || e.$$typeof
                      ? null == r.type && (r.type = e)
                      : r.composers.add(on(e, t));
              return (
                null == r.type && (r.type = "span"),
                r.composers.size ||
                  r.composers.add(["PJLV", {}, [], [], {}, []]),
                an(t, r, e)
              );
            }),
          on = (
            { variants: t, compoundVariants: e, defaultVariants: n, ...r },
            s
          ) => {
            const i = `${Ge(s.prefix)}c-${Ye(r)}`,
              o = [],
              a = [],
              l = Object.create(null),
              c = [];
            for (const t in n) l[t] = String(n[t]);
            if ("object" == typeof t && t)
              for (const e in t) {
                (u = l), (d = e), Re.call(u, d) || (l[e] = "undefined");
                const n = t[e];
                for (const t in n) {
                  const r = { [e]: String(t) };
                  "undefined" === String(t) && c.push(e);
                  const s = n[t],
                    i = [r, s, !Oe(s)];
                  o.push(i);
                }
              }
            var u, d;
            if ("object" == typeof e && e)
              for (const t of e) {
                let { css: e, ...n } = t;
                e = ("object" == typeof e && e) || {};
                for (const t in n) n[t] = String(n[t]);
                const r = [n, e, !Oe(e)];
                a.push(r);
              }
            return [i, r, o, a, l, c];
          },
          an = (t, e, n) => {
            const [r, s, i, o] = ln(e.composers),
              a =
                "function" == typeof e.type || e.type.$$typeof
                  ? ((t) => {
                      function e() {
                        for (let n = 0; n < e[nn].length; n++) {
                          const [r, s] = e[nn][n];
                          t.rules[r].apply(s);
                        }
                        return (e[nn] = []), null;
                      }
                      return (
                        (e[nn] = []),
                        (e.rules = {}),
                        Ze.forEach(
                          (t) =>
                            (e.rules[t] = { apply: (n) => e[nn].push([t, n]) })
                        ),
                        e
                      );
                    })(n)
                  : null,
              l = (a || n).rules,
              c = `.${r}${
                s.length > 1 ? `:where(.${s.slice(1).join(".")})` : ""
              }`,
              u = (u) => {
                u = ("object" == typeof u && u) || un;
                const { css: d, ...h } = u,
                  f = {};
                for (const t in i)
                  if ((delete h[t], t in u)) {
                    let e = u[t];
                    "object" == typeof e && e
                      ? (f[t] = { "@initial": i[t], ...e })
                      : ((e = String(e)),
                        (f[t] = "undefined" !== e || o.has(t) ? e : i[t]));
                  } else f[t] = i[t];
                const p = new Set([...s]);
                for (const [r, s, i, o] of e.composers) {
                  n.rules.styled.cache.has(r) ||
                    (n.rules.styled.cache.add(r),
                    Je(s, [`.${r}`], [], t, (t) => {
                      l.styled.apply(t);
                    }));
                  const e = cn(i, f, t.media),
                    a = cn(o, f, t.media, !0);
                  for (const s of e)
                    if (void 0 !== s)
                      for (const [e, i, o] of s) {
                        const s = `${r}-${Ye(i)}-${e}`;
                        p.add(s);
                        const a = (o ? n.rules.resonevar : n.rules.onevar)
                            .cache,
                          c = o ? l.resonevar : l.onevar;
                        a.has(s) ||
                          (a.add(s),
                          Je(i, [`.${s}`], [], t, (t) => {
                            c.apply(t);
                          }));
                      }
                  for (const e of a)
                    if (void 0 !== e)
                      for (const [s, i] of e) {
                        const e = `${r}-${Ye(i)}-${s}`;
                        p.add(e),
                          n.rules.allvar.cache.has(e) ||
                            (n.rules.allvar.cache.add(e),
                            Je(i, [`.${e}`], [], t, (t) => {
                              l.allvar.apply(t);
                            }));
                      }
                }
                if ("object" == typeof d && d) {
                  const e = `${r}-i${Ye(d)}-css`;
                  p.add(e),
                    n.rules.inline.cache.has(e) ||
                      (n.rules.inline.cache.add(e),
                      Je(d, [`.${e}`], [], t, (t) => {
                        l.inline.apply(t);
                      }));
                }
                for (const t of String(u.className || "")
                  .trim()
                  .split(/\s+/))
                  t && p.add(t);
                const g = (h.className = [...p].join(" "));
                return {
                  type: e.type,
                  className: g,
                  selector: c,
                  props: h,
                  toString: () => g,
                  deferredInjector: a,
                };
              };
            return Te(u, {
              className: r,
              selector: c,
              [Ne]: e,
              toString: () => (n.rules.styled.cache.has(r) || u(), r),
            });
          },
          ln = (t) => {
            let e = "";
            const n = [],
              r = {},
              s = [];
            for (const [i, , , , o, a] of t) {
              "" === e && (e = i), n.push(i), s.push(...a);
              for (const t in o) {
                const e = o[t];
                (void 0 === r[t] || "undefined" !== e || a.includes(e)) &&
                  (r[t] = e);
              }
            }
            return [e, n, r, new Set(s)];
          },
          cn = (t, e, n, r) => {
            const s = [];
            t: for (let [i, o, a] of t) {
              if (a) continue;
              let t,
                l = 0,
                c = !1;
              for (t in i) {
                const r = i[t];
                let s = e[t];
                if (s !== r) {
                  if ("object" != typeof s || !s) continue t;
                  {
                    let t,
                      e,
                      i = 0;
                    for (const o in s) {
                      if (r === String(s[o])) {
                        if ("@initial" !== o) {
                          const t = o.slice(1);
                          (e = e || []).push(
                            t in n ? n[t] : o.replace(/^@media ?/, "")
                          ),
                            (c = !0);
                        }
                        (l += i), (t = !0);
                      }
                      ++i;
                    }
                    if (
                      (e && e.length && (o = { ["@media " + e.join(", ")]: o }),
                      !t)
                    )
                      continue t;
                  }
                }
              }
              (s[l] = s[l] || []).push([r ? "cv" : `${t}-${i[t]}`, o, c]);
            }
            return s;
          },
          un = {},
          dn = Be(),
          hn = (t, e) =>
            dn(t, () => (...n) => {
              const r = () => {
                for (let r of n) {
                  r = ("object" == typeof r && r) || {};
                  let n = Ye(r);
                  if (!e.rules.global.cache.has(n)) {
                    if ((e.rules.global.cache.add(n), "@import" in r)) {
                      let t =
                        [].indexOf.call(
                          e.sheet.cssRules,
                          e.rules.themed.group
                        ) - 1;
                      for (let n of [].concat(r["@import"]))
                        (n = n.includes('"') || n.includes("'") ? n : `"${n}"`),
                          e.sheet.insertRule(`@import ${n};`, t++);
                      delete r["@import"];
                    }
                    Je(r, [], [], t, (t) => {
                      e.rules.global.apply(t);
                    });
                  }
                }
                return "";
              };
              return Te(r, { toString: r });
            }),
          fn = Be(),
          pn = (t, e) =>
            fn(t, () => (n) => {
              const r = `${Ge(t.prefix)}k-${Ye(n)}`,
                s = () => {
                  if (!e.rules.global.cache.has(r)) {
                    e.rules.global.cache.add(r);
                    const s = [];
                    Je(n, [], [], t, (t) => s.push(t));
                    const i = `@keyframes ${r}{${s.join("")}}`;
                    e.rules.global.apply(i);
                  }
                  return r;
                };
              return Te(s, {
                get name() {
                  return s();
                },
                toString: s,
              });
            }),
          gn = class {
            constructor(t, e, n, r) {
              (this.token = null == t ? "" : String(t)),
                (this.value = null == e ? "" : String(e)),
                (this.scale = null == n ? "" : String(n)),
                (this.prefix = null == r ? "" : String(r));
            }
            get computedValue() {
              return "var(" + this.variable + ")";
            }
            get variable() {
              return "--" + Ge(this.prefix) + Ge(this.scale) + this.token;
            }
            toString() {
              return this.computedValue;
            }
          },
          mn = Be(),
          yn = (t, e) =>
            mn(t, () => (n, r) => {
              r = ("object" == typeof n && n) || Object(r);
              const s = `.${(n =
                  (n = "string" == typeof n ? n : "") ||
                  `${Ge(t.prefix)}t-${Ye(r)}`)}`,
                i = {},
                o = [];
              for (const e in r) {
                i[e] = {};
                for (const n in r[e]) {
                  const s = `--${Ge(t.prefix)}${e}-${n}`,
                    a = Ve(String(r[e][n]), t.prefix, e);
                  (i[e][n] = new gn(n, a, e, t.prefix)), o.push(`${s}:${a}`);
                }
              }
              const a = () => {
                if (o.length && !e.rules.themed.cache.has(n)) {
                  e.rules.themed.cache.add(n);
                  const s = `${r === t.theme ? ":root," : ""}.${n}{${o.join(
                    ";"
                  )}}`;
                  e.rules.themed.apply(s);
                }
                return n;
              };
              return {
                ...i,
                get className() {
                  return a();
                },
                selector: s,
                toString: a,
              };
            }),
          bn = Be();
        const {
            css: wn,
            globalCss: vn,
            keyframes: An,
            getCssText: xn,
            theme: $n,
            createTheme: kn,
            config: En,
            reset: Cn,
          } = ((t) => {
            let e = !1;
            const n = bn(t, (t) => {
              e = !0;
              const n =
                  "prefix" in (t = ("object" == typeof t && t) || {})
                    ? String(t.prefix)
                    : "",
                r = ("object" == typeof t.media && t.media) || {},
                s =
                  "object" == typeof t.root
                    ? t.root || null
                    : globalThis.document || null,
                i = ("object" == typeof t.theme && t.theme) || {},
                o = {
                  prefix: n,
                  media: r,
                  theme: i,
                  themeMap: ("object" == typeof t.themeMap && t.themeMap) || {
                    ...Pe,
                  },
                  utils: ("object" == typeof t.utils && t.utils) || {},
                },
                a = tn(s),
                l = {
                  css: sn(o, a),
                  globalCss: hn(o, a),
                  keyframes: pn(o, a),
                  createTheme: yn(o, a),
                  reset() {
                    a.reset(), l.theme.toString();
                  },
                  theme: {},
                  sheet: a,
                  config: o,
                  prefix: n,
                  getCssText: a.toString,
                  toString: a.toString,
                };
              return String((l.theme = l.createTheme(i))), l;
            });
            return e || n.reset(), n;
          })({
            prefix: "svelteui",
            theme: {
              colors: me,
              space: {
                0: "0rem",
                xs: 10,
                sm: 12,
                md: 16,
                lg: 20,
                xl: 24,
                xsPX: "10px",
                smPX: "12px",
                mdPX: "16px",
                lgPX: "20px",
                xlPX: "24px",
                1: "0.125rem",
                2: "0.25rem",
                3: "0.375rem",
                4: "0.5rem",
                5: "0.625rem",
                6: "0.75rem",
                7: "0.875rem",
                8: "1rem",
                9: "1.25rem",
                10: "1.5rem",
                11: "1.75rem",
                12: "2rem",
                13: "2.25rem",
                14: "2.5rem",
                15: "2.75rem",
                16: "3rem",
                17: "3.5rem",
                18: "4rem",
                20: "5rem",
                24: "6rem",
                28: "7rem",
                32: "8rem",
                36: "9rem",
                40: "10rem",
                44: "11rem",
                48: "12rem",
                52: "13rem",
                56: "14rem",
                60: "15rem",
                64: "16rem",
                72: "18rem",
                80: "20rem",
                96: "24rem",
              },
              fontSizes: {
                xs: "12px",
                sm: "14px",
                md: "16px",
                lg: "18px",
                xl: "20px",
              },
              fonts: {
                standard:
                  "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
                mono: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
                fallback: "Segoe UI, system-ui, sans-serif",
              },
              fontWeights: {
                thin: 100,
                extralight: 200,
                light: 300,
                normal: 400,
                medium: 500,
                semibold: 600,
                bold: 700,
                extrabold: 800,
              },
              lineHeights: { xs: 1, sm: 1.25, md: 1.5, lg: 1.625, xl: 1.75 },
              letterSpacings: {
                tighter: "-0.05em",
                tight: "-0.025em",
                normal: "0",
                wide: "0.025em",
                wider: "0.05em",
                widest: "0.1em",
              },
              sizes: {},
              radii: {
                xs: "2px",
                sm: "4px",
                md: "8px",
                lg: "16px",
                xl: "32px",
                squared: "33%",
                rounded: "50%",
                pill: "9999px",
              },
              shadows: {
                xs: "0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)",
                sm: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 10px 15px -5px, rgba(0, 0, 0, 0.04) 0px 7px 7px -5px",
                md: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 20px 25px -5px, rgba(0, 0, 0, 0.04) 0px 10px 10px -5px",
                lg: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 28px 23px -7px, rgba(0, 0, 0, 0.04) 0px 12px 12px -7px",
                xl: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 36px 28px -7px, rgba(0, 0, 0, 0.04) 0px 17px 17px -7px",
              },
              zIndices: {
                1: "100",
                2: "200",
                3: "300",
                4: "400",
                5: "500",
                10: "1000",
                max: "9999",
              },
              borderWidths: {
                light: "1px",
                normal: "2px",
                bold: "3px",
                extrabold: "4px",
                black: "5px",
                xs: "1px",
                sm: "2px",
                md: "3px",
                lg: "4px",
                xl: "5px",
              },
              breakpoints: { xs: 576, sm: 768, md: 992, lg: 1200, xl: 1400 },
              borderStyles: {},
              transitions: {},
            },
            media: {
              xs: "(min-width: 576px)",
              sm: "(min-width: 768px)",
              md: "(min-width: 992px)",
              lg: "(min-width: 1200px)",
              xl: "(min-width: 1400px)",
            },
            utils: {
              focusRing: (t) => ({
                WebkitTapHighlightColor: "transparent",
                "&:focus": {
                  outlineOffset: 2,
                  outline:
                    "always" === t || "auto" === t
                      ? "2px solid $primary"
                      : "none",
                },
                "&:focus:not(:focus-visible)": {
                  outline: "auto" === t || "never" === t ? "none" : void 0,
                },
              }),
              p: (t) => ({ padding: t }),
              pt: (t) => ({ paddingTop: t }),
              pr: (t) => ({ paddingRight: t }),
              pb: (t) => ({ paddingBottom: t }),
              pl: (t) => ({ paddingLeft: t }),
              px: (t) => ({ paddingLeft: t, paddingRight: t }),
              py: (t) => ({ paddingTop: t, paddingBottom: t }),
              m: (t) => ({ margin: t }),
              mt: (t) => ({ marginTop: t }),
              mr: (t) => ({ marginRight: t }),
              mb: (t) => ({ marginBottom: t }),
              ml: (t) => ({ marginLeft: t }),
              mx: (t) => ({ marginLeft: t, marginRight: t }),
              my: (t) => ({ marginTop: t, marginBottom: t }),
              ta: (t) => ({ textAlign: t }),
              tt: (t) => ({ textTransform: t }),
              to: (t) => ({ textOverflow: t }),
              d: (t) => ({ display: t }),
              dflex: (t) => ({
                display: "flex",
                alignItems: t,
                justifyContent: t,
              }),
              fd: (t) => ({ flexDirection: t }),
              fw: (t) => ({ flexWrap: t }),
              ai: (t) => ({ alignItems: t }),
              ac: (t) => ({ alignContent: t }),
              jc: (t) => ({ justifyContent: t }),
              as: (t) => ({ alignSelf: t }),
              fg: (t) => ({ flexGrow: t }),
              fs: (t) => ({ fontSize: t }),
              fb: (t) => ({ flexBasis: t }),
              bc: (t) => ({ backgroundColor: t }),
              bf: (t) => ({ backdropFilter: t }),
              bg: (t) => ({ background: t }),
              bgBlur: (t) => ({ bf: "saturate(180%) blur(10px)", bg: t }),
              bgColor: (t) => ({ backgroundColor: t }),
              backgroundClip: (t) => ({
                WebkitBackgroundClip: t,
                backgroundClip: t,
              }),
              bgClip: (t) => ({ WebkitBackgroundClip: t, backgroundClip: t }),
              br: (t) => ({ borderRadius: t }),
              bw: (t) => ({ borderWidth: t }),
              btrr: (t) => ({ borderTopRightRadius: t }),
              bbrr: (t) => ({ borderBottomRightRadius: t }),
              bblr: (t) => ({ borderBottomLeftRadius: t }),
              btlr: (t) => ({ borderTopLeftRadius: t }),
              bs: (t) => ({ boxShadow: t }),
              normalShadow: (t) => ({ boxShadow: `0 4px 14px 0 $${t}` }),
              lh: (t) => ({ lineHeight: t }),
              ov: (t) => ({ overflow: t }),
              ox: (t) => ({ overflowX: t }),
              oy: (t) => ({ overflowY: t }),
              pe: (t) => ({ pointerEvents: t }),
              events: (t) => ({ pointerEvents: t }),
              us: (t) => ({ WebkitUserSelect: t, userSelect: t }),
              userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
              w: (t) => ({ width: t }),
              h: (t) => ({ height: t }),
              minW: (t) => ({ minWidth: t }),
              minH: (t) => ({ minWidth: t }),
              mw: (t) => ({ maxWidth: t }),
              maxW: (t) => ({ maxWidth: t }),
              mh: (t) => ({ maxHeight: t }),
              maxH: (t) => ({ maxHeight: t }),
              size: (t) => ({ width: t, height: t }),
              minSize: (t) => ({
                minWidth: t,
                minHeight: t,
                width: t,
                height: t,
              }),
              sizeMin: (t) => ({
                minWidth: t,
                minHeight: t,
                width: t,
                height: t,
              }),
              maxSize: (t) => ({ maxWidth: t, maxHeight: t }),
              sizeMax: (t) => ({ maxWidth: t, maxHeight: t }),
              appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
              scale: (t) => ({ transform: `scale(${t})` }),
              linearGradient: (t) => ({
                backgroundImage: `linear-gradient(${t})`,
              }),
              tdl: (t) => ({ textDecorationLine: t }),
              textGradient: (t) => ({
                backgroundImage: `linear-gradient(${t})`,
                WebkitBackgroundClip: "text",
                WebkitTextFillColor: "transparent",
              }),
            },
            themeMap: {
              ...Pe,
              width: "space",
              height: "space",
              minWidth: "space",
              maxWidth: "space",
              minHeight: "space",
              maxHeight: "space",
              flexBasis: "space",
              gridTemplateColumns: "space",
              gridTemplateRows: "space",
              blockSize: "space",
              minBlockSize: "space",
              maxBlockSize: "space",
              inlineSize: "space",
              minInlineSize: "space",
              maxInlineSize: "space",
              borderWidth: "borderWeights",
            },
          }),
          Sn = kn("dark-theme", {
            colors: me,
            shadows: {
              xs: "-4px 0 15px rgb(0 0 0 / 50%)",
              sm: "0 5px 20px -5px rgba(20, 20, 20, 0.1)",
              md: "0 8px 30px rgba(20, 20, 20, 0.15)",
              lg: "0 30px 60px rgba(20, 20, 20, 0.15)",
              xl: "0 40px 80px rgba(20, 20, 20, 0.25)",
            },
          }),
          Pn = vn({
            a: { focusRing: "auto" },
            body: {
              [`${Sn.selector} &`]: {
                backgroundColor: "$dark700",
                color: "$dark50",
              },
              backgroundColor: "$white",
              color: "$black",
            },
          }),
          In = vn({
            html: {
              fontFamily: "sans-serif",
              lineHeight: "1.15",
              textSizeAdjust: "100%",
              margin: 0,
            },
            body: { margin: 0 },
            "article, aside, footer, header, nav, section, figcaption, figure, main":
              { display: "block" },
            h1: { fontSize: "2em", margin: 0 },
            hr: { boxSizing: "content-box", height: 0, overflow: "visible" },
            pre: { fontFamily: "monospace, monospace", fontSize: "1em" },
            a: { background: "transparent", textDecorationSkip: "objects" },
            "a:active, a:hover": { outlineWidth: 0 },
            "abbr[title]": {
              borderBottom: "none",
              textDecoration: "underline",
            },
            "b, strong": { fontWeight: "bolder" },
            "code, kbp, samp": {
              fontFamily: "monospace, monospace",
              fontSize: "1em",
            },
            dfn: { fontStyle: "italic" },
            mark: { backgroundColor: "#ff0", color: "#000" },
            small: { fontSize: "80%" },
            "sub, sup": {
              fontSize: "75%",
              lineHeight: 0,
              position: "relative",
              verticalAlign: "baseline",
            },
            sup: { top: "-0.5em" },
            sub: { bottom: "-0.25em" },
            "audio, video": { display: "inline-block" },
            "audio:not([controls])": { display: "none", height: 0 },
            img: { borderStyle: "none", verticalAlign: "middle" },
            "svg:not(:root)": { overflow: "hidden" },
            "button, input, optgroup, select, textarea": {
              fontFamily: "sans-serif",
              fontSize: "100%",
              lineHeight: "1.15",
              margin: 0,
            },
            "button, input": { overflow: "visible" },
            "button, select": { textTransform: "none" },
            "button, [type=reset], [type=submit]": {
              WebkitAppearance: "button",
            },
            "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner":
              { borderStyle: "none", padding: 0 },
            "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring":
              { outline: "1px dotted ButtonText" },
            legend: {
              boxSizing: "border-box",
              color: "inherit",
              display: "table",
              maxWidth: "100%",
              padding: 0,
              whiteSpace: "normal",
            },
            progress: { display: "inline-block", verticalAlign: "baseline" },
            textarea: { overflow: "auto" },
            "[type=checkbox], [type=radio]": {
              boxSizing: "border-box",
              padding: 0,
            },
            "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button":
              { height: "auto" },
            "[type=search]": { appearance: "textfield", outlineOffset: "-2px" },
            "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration":
              { appearance: "none" },
            "::-webkit-file-upload-button": {
              appearance: "button",
              font: "inherit",
            },
            "details, menu": { display: "block" },
            summary: { display: "list-item" },
            canvas: { display: "inline-block" },
            template: { display: "none" },
            "[hidden]": { display: "none" },
          }),
          Bn = {
            mt: "marginTop",
            mb: "marginBottom",
            ml: "marginLeft",
            mr: "marginRight",
            pt: "paddingTop",
            pb: "paddingBottom",
            pl: "paddingLeft",
            pr: "paddingRight",
          },
          Nn = ["-xs", "-sm", "-md", "-lg", "-xl"];
        function Tn(t) {
          return "string" == typeof t || "number" == typeof t;
        }
        function On(t, e) {
          return Nn.includes(t)
            ? -1 * e.fn.size({ size: t.replace("-", ""), sizes: e.space })
            : e.fn.size({ size: t, sizes: e.space });
        }
        function Rn(t) {
          let e, r, s, a, l, u;
          const p = t[28].default,
            g = c(p, t, t[32], null);
          let m = [
              {
                class: (r =
                  t[2] + " " + t[7]({ css: { ...t[11](t[10]), ...t[6] } })),
              },
              t[12],
            ],
            b = {};
          for (let t = 0; t < m.length; t += 1) b = n(b, m[t]);
          return {
            c() {
              (e = B("div")), g && g.c(), F(e, b);
            },
            m(n, r) {
              P(n, e, r),
                g && g.m(e, null),
                t[31](e),
                (a = !0),
                l ||
                  ((u = [
                    y(t[8].call(null, e)),
                    y((s = Vt.call(null, e, t[1]))),
                  ]),
                  (l = !0));
            },
            p(t, n) {
              g &&
                g.p &&
                (!a || 2 & n[1]) &&
                h(g, p, t, t[32], a ? d(p, t[32], n, null) : f(t[32]), null),
                F(
                  e,
                  (b = Pt(m, [
                    (!a ||
                      (196 & n[0] &&
                        r !==
                          (r =
                            t[2] +
                            " " +
                            t[7]({ css: { ...t[11](t[10]), ...t[6] } })))) && {
                      class: r,
                    },
                    4096 & n[0] && t[12],
                  ]))
                ),
                s && o(s.update) && 2 & n[0] && s.update.call(null, t[1]);
            },
            i(t) {
              a || (kt(g, t), (a = !0));
            },
            o(t) {
              Et(g, t), (a = !1);
            },
            d(n) {
              n && I(e), g && g.d(n), t[31](null), (l = !1), i(u);
            },
          };
        }
        function Ln(t) {
          let e, r, s;
          const i = [
            { use: [t[8], [Vt, t[1]]] },
            { class: t[2] + " " + t[7]({ css: { ...t[11](t[10]), ...t[6] } }) },
            t[12],
          ];
          var o = t[3];
          function a(t) {
            let e = { $$slots: { default: [Un] }, $$scope: { ctx: t } };
            for (let t = 0; t < i.length; t += 1) e = n(e, i[t]);
            return { props: e };
          }
          return (
            o && ((e = _(o, a(t))), t[30](e)),
            {
              c() {
                e && Nt(e.$$.fragment), (r = R());
              },
              m(t, n) {
                e && Tt(e, t, n), P(t, r, n), (s = !0);
              },
              p(t, n) {
                const s =
                  7622 & n[0]
                    ? Pt(i, [
                        258 & n[0] && { use: [t[8], [Vt, t[1]]] },
                        3268 & n[0] && {
                          class:
                            t[2] +
                            " " +
                            t[7]({ css: { ...t[11](t[10]), ...t[6] } }),
                        },
                        4096 & n[0] && It(t[12]),
                      ])
                    : {};
                if (
                  (2 & n[1] && (s.$$scope = { dirty: n, ctx: t }),
                  8 & n[0] && o !== (o = t[3]))
                ) {
                  if (e) {
                    xt();
                    const t = e;
                    Et(t.$$.fragment, 1, 0, () => {
                      Ot(t, 1);
                    }),
                      $t();
                  }
                  o
                    ? ((e = _(o, a(t))),
                      t[30](e),
                      Nt(e.$$.fragment),
                      kt(e.$$.fragment, 1),
                      Tt(e, r.parentNode, r))
                    : (e = null);
                } else o && e.$set(s);
              },
              i(t) {
                s || (e && kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                e && Et(e.$$.fragment, t), (s = !1);
              },
              d(n) {
                t[30](null), n && I(r), e && Ot(e, n);
              },
            }
          );
        }
        function zn(t) {
          let e,
            r =
              t[9]() &&
              (function (t) {
                let e, r, s, a, l, u;
                const p = t[28].default,
                  g = c(p, t, t[32], null);
                let m = [
                    {
                      class: (r =
                        t[2] +
                        " " +
                        t[7]({ css: { ...t[11](t[10]), ...t[6] } })),
                    },
                    t[12],
                  ],
                  b = {};
                for (let t = 0; t < m.length; t += 1) b = n(b, m[t]);
                return {
                  c() {
                    (e = B(t[9]())), g && g.c(), j(t[9]())(e, b);
                  },
                  m(n, r) {
                    P(n, e, r),
                      g && g.m(e, null),
                      t[29](e),
                      (a = !0),
                      l ||
                        ((u = [
                          y(t[8].call(null, e)),
                          y((s = Vt.call(null, e, t[1]))),
                        ]),
                        (l = !0));
                  },
                  p(t, n) {
                    g &&
                      g.p &&
                      (!a || 2 & n[1]) &&
                      h(
                        g,
                        p,
                        t,
                        t[32],
                        a ? d(p, t[32], n, null) : f(t[32]),
                        null
                      ),
                      j(t[9]())(
                        e,
                        (b = Pt(m, [
                          (!a ||
                            (196 & n[0] &&
                              r !==
                                (r =
                                  t[2] +
                                  " " +
                                  t[7]({
                                    css: { ...t[11](t[10]), ...t[6] },
                                  })))) && { class: r },
                          4096 & n[0] && t[12],
                        ]))
                      ),
                      s && o(s.update) && 2 & n[0] && s.update.call(null, t[1]);
                  },
                  i(t) {
                    a || (kt(g, t), (a = !0));
                  },
                  o(t) {
                    Et(g, t), (a = !1);
                  },
                  d(n) {
                    n && I(e), g && g.d(n), t[29](null), (l = !1), i(u);
                  },
                };
              })(t);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, e) {
              t[9]() && r.p(t, e);
            },
            i(t) {
              e || (kt(r), (e = !0));
            },
            o(t) {
              Et(r), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Un(t) {
          let e;
          const n = t[28].default,
            r = c(n, t, t[32], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2 & s[1]) &&
                h(r, n, t, t[32], e ? d(n, t[32], s, null) : f(t[32]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Fn(t) {
          let e, n, r, s;
          const i = [zn, Ln, Rn],
            o = [];
          function a(t, e) {
            return t[4] ? 0 : t[5] && "string" != typeof t[3] ? 1 : 2;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, s) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (xt(),
                      Et(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      $t(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      kt(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (kt(n), (s = !0));
              },
              o(t) {
                Et(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Dn(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "css",
            "root",
            "m",
            "my",
            "mx",
            "mt",
            "mb",
            "ml",
            "mr",
            "p",
            "py",
            "px",
            "pt",
            "pb",
            "pl",
            "pr",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e,
            {
              use: u = [],
              element: d,
              class: h = "",
              css: f = {},
              root: m,
              m: y,
              my: b,
              mx: w,
              mt: v,
              mb: A,
              ml: x,
              mr: $,
              p: k,
              py: E,
              px: C,
              pt: S,
              pb: P,
              pl: I,
              pr: B,
            } = e;
          const N = Jt(et()),
            T = Xt()?.theme || ne(),
            O = "function" == typeof f ? f : () => f;
          let R, L;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(12, (a = g(e, o))),
                "use" in t && r(1, (u = t.use)),
                "element" in t && r(0, (d = t.element)),
                "class" in t && r(2, (h = t.class)),
                "css" in t && r(13, (f = t.css)),
                "root" in t && r(3, (m = t.root)),
                "m" in t && r(14, (y = t.m)),
                "my" in t && r(15, (b = t.my)),
                "mx" in t && r(16, (w = t.mx)),
                "mt" in t && r(17, (v = t.mt)),
                "mb" in t && r(18, (A = t.mb)),
                "ml" in t && r(19, (x = t.ml)),
                "mr" in t && r(20, ($ = t.mr)),
                "p" in t && r(21, (k = t.p)),
                "py" in t && r(22, (E = t.py)),
                "px" in t && r(23, (C = t.px)),
                "pt" in t && r(24, (S = t.pt)),
                "pb" in t && r(25, (P = t.pb)),
                "pl" in t && r(26, (I = t.pl)),
                "pr" in t && r(27, (B = t.pr)),
                "$$scope" in t && r(32, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              8 & t.$$.dirty[0] &&
                (r(4, (R = m && "string" == typeof m)),
                r(5, (L = m && "function" == typeof m))),
                268419072 & t.$$.dirty[0] &&
                  r(
                    6,
                    (i = (function (t, e) {
                      const n = {};
                      if (Tn(t.p)) {
                        const r = On(t.p, e);
                        n.padding = r;
                      }
                      if (Tn(t.m)) {
                        const r = On(t.m, e);
                        n.margin = r;
                      }
                      if (Tn(t.py)) {
                        const r = On(t.py, e);
                        (n.paddingTop = r), (n.paddingBottom = r);
                      }
                      if (Tn(t.px)) {
                        const r = On(t.px, e);
                        (n.paddingLeft = r), (n.paddingRight = r);
                      }
                      if (Tn(t.my)) {
                        const r = On(t.my, e);
                        (n.marginTop = r), (n.marginBottom = r);
                      }
                      if (Tn(t.mx)) {
                        const r = On(t.mx, e);
                        (n.marginLeft = r), (n.marginRight = r);
                      }
                      return (
                        Object.keys(Bn).forEach((r) => {
                          Tn(t[r]) &&
                            (n[Bn[r]] = e.fn.size({
                              size: On(t[r], e),
                              sizes: e.space,
                            }));
                        }),
                        n
                      );
                    })(
                      {
                        m: y,
                        my: b,
                        mx: w,
                        mt: v,
                        mb: A,
                        ml: x,
                        mr: $,
                        p: k,
                        py: E,
                        px: C,
                        pt: S,
                        pb: P,
                        pl: I,
                        pr: B,
                      },
                      T
                    ))
                  );
            }),
            r(7, (s = wn({}))),
            [
              d,
              u,
              h,
              m,
              R,
              L,
              i,
              s,
              N,
              () => m,
              T,
              O,
              a,
              f,
              y,
              b,
              w,
              v,
              A,
              x,
              $,
              k,
              E,
              C,
              S,
              P,
              I,
              B,
              l,
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (d = t), r(0, d);
                });
              },
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (d = t), r(0, d);
                });
              },
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (d = t), r(0, d);
                });
              },
              c,
            ]
          );
        }
        var Mn = class extends Lt {
          constructor(t) {
            super(),
              Rt(
                this,
                t,
                Dn,
                Fn,
                a,
                {
                  use: 1,
                  element: 0,
                  class: 2,
                  css: 13,
                  root: 3,
                  m: 14,
                  my: 15,
                  mx: 16,
                  mt: 17,
                  mb: 18,
                  ml: 19,
                  mr: 20,
                  p: 21,
                  py: 22,
                  px: 23,
                  pt: 24,
                  pb: 25,
                  pl: 26,
                  pr: 27,
                },
                null,
                [-1, -1]
              );
          }
        };
        const jn = {
          xs: { height: 30, padding: "0px 14px" },
          sm: { height: 36, padding: "0px 18px" },
          md: { height: 42, padding: "0px 22px" },
          lg: { height: 50, padding: "0px 26px" },
          xl: { height: 60, padding: "0px 32px" },
          "compact-xs": { height: 22, padding: "0 7px" },
          "compact-sm": { height: 26, padding: "0 8px" },
          "compact-md": { height: 30, padding: "0 10px" },
          "compact-lg": { height: 34, padding: "0 12px" },
          "compact-xl": { height: 40, padding: "0 14px" },
        };
        var Hn = ke(
          (
            t,
            {
              color: e,
              compact: n,
              fullSize: r,
              gradient: s,
              radius: i,
              size: o,
              variant: a,
            }
          ) => ({
            root: {
              focusRing: "auto",
              cursor: "pointer",
              position: "relative",
              boxSizing: "border-box",
              textDecoration: "none",
              outline: "none",
              userSelect: "none",
              appearance: "none",
              textAlign: "center",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              background: null,
              borderRadius: "number" == typeof i ? i : `$${i}`,
              height:
                "number" == typeof o
                  ? `${o}px`
                  : jn[n ? `compact-${o}` : o].height,
              padding:
                "number" == typeof o
                  ? `0px ${o}px`
                  : jn[n ? `compact-${o}` : o].padding,
              fontFamily: "$standard",
              fontWeight: "$semibold",
              fontSize: `$${o}`,
              lineHeight: 1,
              flexGrow: 0,
              width: r ? "100%" : "fit-content",
              "&:hover": {
                backgroundColor:
                  "gradient" === a ? null : t.fn.themeColor(e, 7),
                backgroundSize: "gradient" === a ? "200%" : null,
              },
              "&:active": { transform: "translateY(1px)" },
              "&:disabled": {
                pointerEvents: "none",
                borderColor: "transparent",
                background: t.fn.themeColor("gray", 2),
                backgroundColor: t.fn.themeColor("gray", 2),
                color: t.fn.themeColor("gray", 5),
                cursor: "not-allowed",
                darkMode: {
                  borderColor: "transparent",
                  backgroundColor: t.fn.themeColor("dark", 4),
                  color: t.fn.themeColor("dark", 6),
                },
              },
            },
            disabled: {
              pointerEvents: "none",
              borderColor: "transparent",
              background: t.fn.themeColor("gray", 2),
              backgroundColor: t.fn.themeColor("gray", 2),
              color: t.fn.themeColor("gray", 5),
              cursor: "not-allowed",
              darkMode: {
                backgroundColor: t.fn.themeColor("dark", 4),
                color: t.fn.themeColor("dark", 6),
              },
            },
            loading: {
              pointerEvents: "none",
              "&::before": {
                content: '""',
                position: "absolute",
                inset: -1,
                backgroundColor: "rgba(255, 255, 255, .5)",
                borderRadius: `$${i}`,
                cursor: "not-allowed",
              },
            },
            variants: {
              variation: le(e, s),
              disabled: {
                true: {
                  pointerEvents: "none",
                  borderColor: "transparent",
                  background: t.fn.themeColor("gray", 2),
                  backgroundColor: t.fn.themeColor("gray", 2),
                  color: t.fn.themeColor("gray", 5),
                  cursor: "not-allowed",
                  [`${Sn.selector} &`]: {
                    borderColor: "transparent",
                    backgroundColor: t.fn.themeColor("dark", 4),
                    color: t.fn.themeColor("dark", 6),
                  },
                },
              },
            },
          })
        );
        const Gn = Object.freeze([
          {
            error: !0,
            message:
              "If using the disabled prop, a loading cannot be set at the same time",
            solution:
              "\n                If your component looks like this:\n                \n                &lt;Button disabled loading ...&gt; Button Text &lt;/Button&gt;\n                         ^^^^^^^^ ^^^^^^^ - Try removing one of these\n                ",
          },
          {
            error: !0,
            message:
              "If using the external prop, a href prop must be associated with it. If you have an href prop there must be content inside.",
            solution:
              "\n                If your component looks like this:\n                \n                &lt;Button external ...&gt; Button Text &lt;/Button&gt;\n                         ^^^^^^^^ - Try adding the href prop too\n                ",
          },
        ]);
        function Vn(e) {
          let n, r, s, i, a, l, c, u, d, h, f;
          return {
            c() {
              (n = N("svg")),
                (r = N("g")),
                (s = N("g")),
                (i = N("circle")),
                (a = N("path")),
                (l = N("animateTransform")),
                z(i, "stroke-opacity", ".5"),
                z(i, "cx", "16"),
                z(i, "cy", "16"),
                z(i, "r", "16"),
                z(l, "attributeName", "transform"),
                z(l, "type", "rotate"),
                z(l, "from", "0 16 16"),
                z(l, "to", "360 16 16"),
                z(l, "dur", "1s"),
                z(l, "repeatCount", "indefinite"),
                z(a, "d", "M32 16c0-9.94-8.06-16-16-16"),
                z(s, "transform", "translate(2.5 2.5)"),
                z(s, "stroke-width", "5"),
                z(r, "fill", "none"),
                z(r, "fill-rule", "evenodd"),
                z(n, "width", (c = `${e[1]}px`)),
                z(n, "height", (u = `${e[1]}px`)),
                z(n, "viewBox", "0 0 38 38"),
                z(n, "xmlns", "http://www.w3.org/2000/svg"),
                z(n, "stroke", e[2]),
                z(n, "class", e[3]);
            },
            m(t, o) {
              P(t, n, o),
                $(n, r),
                $(r, s),
                $(s, i),
                $(s, a),
                $(a, l),
                h || ((f = y((d = Vt.call(null, n, e[0])))), (h = !0));
            },
            p(t, [e]) {
              2 & e && c !== (c = `${t[1]}px`) && z(n, "width", c),
                2 & e && u !== (u = `${t[1]}px`) && z(n, "height", u),
                4 & e && z(n, "stroke", t[2]),
                8 & e && z(n, "class", t[3]),
                d && o(d.update) && 1 & e && d.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && I(n), (h = !1), f();
            },
          };
        }
        function Qn(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var Wn = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Qn, Vn, a, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        function Jn(e) {
          let n, r, s, i, a, l, c, u, d, h, f, p, g, m, b, w, v, A, x, k;
          return {
            c() {
              (n = N("svg")),
                (r = N("rect")),
                (s = N("animate")),
                (i = N("animate")),
                (a = N("rect")),
                (l = N("animate")),
                (c = N("animate")),
                (u = N("rect")),
                (d = N("animate")),
                (h = N("animate")),
                (f = N("rect")),
                (p = N("animate")),
                (g = N("animate")),
                (m = N("rect")),
                (b = N("animate")),
                (w = N("animate")),
                z(s, "attributeName", "height"),
                z(s, "begin", "0.5s"),
                z(s, "dur", "1s"),
                z(s, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(s, "calcMode", "linear"),
                z(s, "repeatCount", "indefinite"),
                z(i, "attributeName", "y"),
                z(i, "begin", "0.5s"),
                z(i, "dur", "1s"),
                z(i, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(i, "calcMode", "linear"),
                z(i, "repeatCount", "indefinite"),
                z(r, "y", "10"),
                z(r, "width", "15"),
                z(r, "height", "120"),
                z(r, "rx", "6"),
                z(l, "attributeName", "height"),
                z(l, "begin", "0.25s"),
                z(l, "dur", "1s"),
                z(l, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(l, "calcMode", "linear"),
                z(l, "repeatCount", "indefinite"),
                z(c, "attributeName", "y"),
                z(c, "begin", "0.25s"),
                z(c, "dur", "1s"),
                z(c, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(c, "calcMode", "linear"),
                z(c, "repeatCount", "indefinite"),
                z(a, "x", "30"),
                z(a, "y", "10"),
                z(a, "width", "15"),
                z(a, "height", "120"),
                z(a, "rx", "6"),
                z(d, "attributeName", "height"),
                z(d, "begin", "0s"),
                z(d, "dur", "1s"),
                z(d, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(d, "calcMode", "linear"),
                z(d, "repeatCount", "indefinite"),
                z(h, "attributeName", "y"),
                z(h, "begin", "0s"),
                z(h, "dur", "1s"),
                z(h, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(h, "calcMode", "linear"),
                z(h, "repeatCount", "indefinite"),
                z(u, "x", "60"),
                z(u, "width", "15"),
                z(u, "height", "140"),
                z(u, "rx", "6"),
                z(p, "attributeName", "height"),
                z(p, "begin", "0.25s"),
                z(p, "dur", "1s"),
                z(p, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(p, "calcMode", "linear"),
                z(p, "repeatCount", "indefinite"),
                z(g, "attributeName", "y"),
                z(g, "begin", "0.25s"),
                z(g, "dur", "1s"),
                z(g, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(g, "calcMode", "linear"),
                z(g, "repeatCount", "indefinite"),
                z(f, "x", "90"),
                z(f, "y", "10"),
                z(f, "width", "15"),
                z(f, "height", "120"),
                z(f, "rx", "6"),
                z(b, "attributeName", "height"),
                z(b, "begin", "0.5s"),
                z(b, "dur", "1s"),
                z(b, "values", "120;110;100;90;80;70;60;50;40;140;120"),
                z(b, "calcMode", "linear"),
                z(b, "repeatCount", "indefinite"),
                z(w, "attributeName", "y"),
                z(w, "begin", "0.5s"),
                z(w, "dur", "1s"),
                z(w, "values", "10;15;20;25;30;35;40;45;50;0;10"),
                z(w, "calcMode", "linear"),
                z(w, "repeatCount", "indefinite"),
                z(m, "x", "120"),
                z(m, "y", "10"),
                z(m, "width", "15"),
                z(m, "height", "120"),
                z(m, "rx", "6"),
                z(n, "viewBox", "0 0 135 140"),
                z(n, "xmlns", "http://www.w3.org/2000/svg"),
                z(n, "fill", e[2]),
                z(n, "width", (v = `${e[1]}px`)),
                z(n, "class", e[3]);
            },
            m(t, o) {
              P(t, n, o),
                $(n, r),
                $(r, s),
                $(r, i),
                $(n, a),
                $(a, l),
                $(a, c),
                $(n, u),
                $(u, d),
                $(u, h),
                $(n, f),
                $(f, p),
                $(f, g),
                $(n, m),
                $(m, b),
                $(m, w),
                x || ((k = y((A = Vt.call(null, n, e[0])))), (x = !0));
            },
            p(t, [e]) {
              4 & e && z(n, "fill", t[2]),
                2 & e && v !== (v = `${t[1]}px`) && z(n, "width", v),
                8 & e && z(n, "class", t[3]),
                A && o(A.update) && 1 & e && A.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && I(n), (x = !1), k();
            },
          };
        }
        function _n(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var Kn = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, _n, Jn, a, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        function qn(e) {
          let n, r, s, i, a, l, c, u, d, h, f, p, g, m, b;
          return {
            c() {
              (n = N("svg")),
                (r = N("circle")),
                (s = N("animate")),
                (i = N("animate")),
                (a = N("circle")),
                (l = N("animate")),
                (c = N("animate")),
                (u = N("circle")),
                (d = N("animate")),
                (h = N("animate")),
                z(s, "attributeName", "r"),
                z(s, "from", "15"),
                z(s, "to", "15"),
                z(s, "begin", "0s"),
                z(s, "dur", "0.8s"),
                z(s, "values", "15;9;15"),
                z(s, "calcMode", "linear"),
                z(s, "repeatCount", "indefinite"),
                z(i, "attributeName", "fill-opacity"),
                z(i, "from", "1"),
                z(i, "to", "1"),
                z(i, "begin", "0s"),
                z(i, "dur", "0.8s"),
                z(i, "values", "1;.5;1"),
                z(i, "calcMode", "linear"),
                z(i, "repeatCount", "indefinite"),
                z(r, "cx", "15"),
                z(r, "cy", "15"),
                z(r, "r", "15"),
                z(l, "attributeName", "r"),
                z(l, "from", "9"),
                z(l, "to", "9"),
                z(l, "begin", "0s"),
                z(l, "dur", "0.8s"),
                z(l, "values", "9;15;9"),
                z(l, "calcMode", "linear"),
                z(l, "repeatCount", "indefinite"),
                z(c, "attributeName", "fill-opacity"),
                z(c, "from", "0.5"),
                z(c, "to", "0.5"),
                z(c, "begin", "0s"),
                z(c, "dur", "0.8s"),
                z(c, "values", ".5;1;.5"),
                z(c, "calcMode", "linear"),
                z(c, "repeatCount", "indefinite"),
                z(a, "cx", "60"),
                z(a, "cy", "15"),
                z(a, "r", "9"),
                z(a, "fill-opacity", "0.3"),
                z(d, "attributeName", "r"),
                z(d, "from", "15"),
                z(d, "to", "15"),
                z(d, "begin", "0s"),
                z(d, "dur", "0.8s"),
                z(d, "values", "15;9;15"),
                z(d, "calcMode", "linear"),
                z(d, "repeatCount", "indefinite"),
                z(h, "attributeName", "fill-opacity"),
                z(h, "from", "1"),
                z(h, "to", "1"),
                z(h, "begin", "0s"),
                z(h, "dur", "0.8s"),
                z(h, "values", "1;.5;1"),
                z(h, "calcMode", "linear"),
                z(h, "repeatCount", "indefinite"),
                z(u, "cx", "105"),
                z(u, "cy", "15"),
                z(u, "r", "15"),
                z(n, "width", (f = `${e[1]}px`)),
                z(n, "height", (p = Number(e[1]) / 4 + "px")),
                z(n, "viewBox", "0 0 120 30"),
                z(n, "xmlns", "http://www.w3.org/2000/svg"),
                z(n, "fill", e[2]),
                z(n, "class", e[3]);
            },
            m(t, o) {
              P(t, n, o),
                $(n, r),
                $(r, s),
                $(r, i),
                $(n, a),
                $(a, l),
                $(a, c),
                $(n, u),
                $(u, d),
                $(u, h),
                m || ((b = y((g = Vt.call(null, n, e[0])))), (m = !0));
            },
            p(t, [e]) {
              2 & e && f !== (f = `${t[1]}px`) && z(n, "width", f),
                2 & e &&
                  p !== (p = Number(t[1]) / 4 + "px") &&
                  z(n, "height", p),
                4 & e && z(n, "fill", t[2]),
                8 & e && z(n, "class", t[3]),
                g && o(g.update) && 1 & e && g.update.call(null, t[0]);
            },
            i: t,
            o: t,
            d(t) {
              t && I(n), (m = !1), b();
            },
          };
        }
        function Yn(t, e, n) {
          let { use: r = [] } = e,
            { size: s = 25 } = e,
            { color: i = "blue" } = e,
            { class: o = "" } = e;
          return (
            (t.$$set = (t) => {
              "use" in t && n(0, (r = t.use)),
                "size" in t && n(1, (s = t.size)),
                "color" in t && n(2, (i = t.color)),
                "class" in t && n(3, (o = t.class));
            }),
            [r, s, i, o]
          );
        }
        var Zn = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Yn, qn, a, { use: 0, size: 1, color: 2, class: 3 });
          }
        };
        const Xn = { xs: 18, sm: 22, md: 36, lg: 44, xl: 58 },
          tr = (t, e = !1) => $n.colors[e ? `${t}400` : `${t}600`].value;
        function er(t) {
          let e, r, s;
          const i = [
            { use: [t[5], [Vt, t[1]]] },
            { color: "white" === t[4] ? "white" : tr(t[4]) },
            { size: Xn[t[3]] },
            { class: t[2] },
            t[8],
          ];
          var o = t[6][t[7]];
          function a(t) {
            let e = {};
            for (let t = 0; t < i.length; t += 1) e = n(e, i[t]);
            return { props: e };
          }
          return (
            o && ((e = _(o, a())), t[10](e)),
            {
              c() {
                e && Nt(e.$$.fragment), (r = R());
              },
              m(t, n) {
                e && Tt(e, t, n), P(t, r, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  318 & n
                    ? Pt(i, [
                        34 & n && { use: [t[5], [Vt, t[1]]] },
                        16 & n && {
                          color: "white" === t[4] ? "white" : tr(t[4]),
                        },
                        8 & n && { size: Xn[t[3]] },
                        4 & n && { class: t[2] },
                        256 & n && It(t[8]),
                      ])
                    : {};
                if (o !== (o = t[6][t[7]])) {
                  if (e) {
                    xt();
                    const t = e;
                    Et(t.$$.fragment, 1, 0, () => {
                      Ot(t, 1);
                    }),
                      $t();
                  }
                  o
                    ? ((e = _(o, a())),
                      t[10](e),
                      Nt(e.$$.fragment),
                      kt(e.$$.fragment, 1),
                      Tt(e, r.parentNode, r))
                    : (e = null);
                } else o && e.$set(s);
              },
              i(t) {
                s || (e && kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                e && Et(e.$$.fragment, t), (s = !1);
              },
              d(n) {
                t[10](null), n && I(r), e && Ot(e, n);
              },
            }
          );
        }
        function nr(t, e, r) {
          const s = ["use", "element", "class", "size", "color", "variant"];
          let i = g(e, s),
            {
              use: o = [],
              element: a,
              class: l = "",
              size: c = "md",
              color: u = "blue",
              variant: d = "circle",
            } = e;
          const h = Jt(et()),
            f = { bars: Kn, circle: Wn, dots: Zn },
            m = d in f ? d : "circle";
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(8, (i = g(e, s))),
                "use" in t && r(1, (o = t.use)),
                "element" in t && r(0, (a = t.element)),
                "class" in t && r(2, (l = t.class)),
                "size" in t && r(3, (c = t.size)),
                "color" in t && r(4, (u = t.color)),
                "variant" in t && r(9, (d = t.variant));
            }),
            [
              a,
              o,
              l,
              c,
              u,
              h,
              f,
              m,
              i,
              d,
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (a = t), r(0, a);
                });
              },
            ]
          );
        }
        var rr = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, nr, er, a, {
                use: 1,
                element: 0,
                class: 2,
                size: 3,
                color: 4,
                variant: 9,
              });
          }
        };
        function sr(t) {
          k(
            t,
            "svelte-3pkhve",
            ".ripple.svelte-3pkhve{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-3pkhve .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-3pkhve .animation-enter{transition:none}.ripple.svelte-3pkhve .animation-in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-3pkhve .animation-out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}"
          );
        }
        function ir(e) {
          let n;
          return {
            c() {
              (n = B("div")), z(n, "class", "ripple svelte-3pkhve");
            },
            m(t, r) {
              P(t, n, r), e[4](n);
            },
            p: t,
            i: t,
            o: t,
            d(t) {
              t && I(n), e[4](null);
            },
          };
        }
        function or(t, e) {
          (t.style.transform = e), (t.style.webkitTransform = e);
        }
        function ar(t, e) {
          t.style.opacity = e.toString();
        }
        const lr = function (t, e) {
            const n = ["touchcancel", "mouseleave", "dragstart"];
            let r = e.currentTarget || e.target;
            if (
              (r &&
                !r.classList.contains("ripple") &&
                (r = r.querySelector(".ripple")),
              !r)
            )
              return;
            const s = r.dataset.event;
            if (s && s !== t) return;
            r.dataset.event = t;
            const i = document.createElement("span"),
              {
                radius: o,
                scale: a,
                x: l,
                y: c,
                centerX: u,
                centerY: d,
              } = ((t, e) => {
                const n = e.getBoundingClientRect(),
                  r = (function (t) {
                    return "TouchEvent" === t.constructor.name;
                  })(t)
                    ? t.touches[t.touches.length - 1]
                    : t,
                  s = r.clientX - n.left,
                  i = r.clientY - n.top;
                let o = 0,
                  a = 0.3;
                const l = e.dataset.center;
                e.dataset.circle
                  ? ((a = 0.15),
                    (o = e.clientWidth / 2),
                    (o = l
                      ? o
                      : o + Math.sqrt((s - o) ** 2 + (i - o) ** 2) / 4))
                  : (o =
                      Math.sqrt(e.clientWidth ** 2 + e.clientHeight ** 2) / 2);
                const c = (e.clientWidth - 2 * o) / 2 + "px",
                  u = (e.clientHeight - 2 * o) / 2 + "px";
                return {
                  radius: o,
                  scale: a,
                  x: l ? c : s - o + "px",
                  y: l ? u : i - o + "px",
                  centerX: c,
                  centerY: u,
                };
              })(e, r),
              h = r.dataset.color,
              f = 2 * o + "px";
            (i.className = "animation"),
              (i.style.width = f),
              (i.style.height = f),
              (i.style.background = h),
              i.classList.add("animation-enter"),
              i.classList.add("animation--visible"),
              or(i, `translate(${l}, ${c}) scale3d(${a},${a},${a})`),
              ar(i, 0),
              (i.dataset.activated = String(performance.now())),
              r.appendChild(i),
              setTimeout(() => {
                i.classList.remove("animation-enter"),
                  i.classList.add("animation-in"),
                  or(i, `translate(${u}, ${d}) scale3d(1,1,1)`),
                  ar(i, 0.25);
              }, 0);
            const p = "mousedown" === t ? "mouseup" : "touchend",
              g = function () {
                document.removeEventListener(p, g),
                  n.forEach((t) => {
                    document.removeEventListener(t, g);
                  });
                const t = performance.now() - Number(i.dataset.activated),
                  e = Math.max(250 - t, 0);
                setTimeout(() => {
                  i.classList.remove("animation-in"),
                    i.classList.add("animation-out"),
                    ar(i, 0),
                    setTimeout(() => {
                      i && r.removeChild(i),
                        0 === r.children.length && delete r.dataset.event;
                    }, 300);
                }, e);
              };
            document.addEventListener(p, g),
              n.forEach((t) => {
                document.addEventListener(t, g, { passive: !0 });
              });
          },
          cr = function (t) {
            0 === t.button && lr(t.type, t);
          },
          ur = function (t) {
            if (t.changedTouches)
              for (let e = 0; e < t.changedTouches.length; ++e)
                lr(t.type, t.changedTouches[e]);
          };
        function dr(t, e, n) {
          let r,
            s,
            { center: i = !1 } = e,
            { circle: o = !1 } = e,
            { color: a = "currentColor" } = e;
          var l;
          return (
            nt(async () => {
              await dt();
              try {
                i && n(0, (r.dataset.center = "true"), r),
                  o && n(0, (r.dataset.circle = "true"), r),
                  n(0, (r.dataset.color = a), r),
                  (s = r.parentElement);
              } catch (t) {}
              if (!s)
                return void console.error("Ripple: Trigger element not found.");
              let t = window.getComputedStyle(s);
              (0 !== t.position.length && "static" !== t.position) ||
                (s.style.position = "relative"),
                s.addEventListener("touchstart", ur, { passive: !0 }),
                s.addEventListener("mousedown", cr, { passive: !0 });
            }),
            (l = () => {
              s &&
                (s.removeEventListener("mousedown", cr),
                s.removeEventListener("touchstart", ur));
            }),
            et().$$.on_destroy.push(l),
            (t.$$set = (t) => {
              "center" in t && n(1, (i = t.center)),
                "circle" in t && n(2, (o = t.circle)),
                "color" in t && n(3, (a = t.color));
            }),
            [
              r,
              i,
              o,
              a,
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (r = t), n(0, r);
                });
              },
            ]
          );
        }
        var hr = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, dr, ir, a, { center: 1, circle: 2, color: 3 }, sr);
          }
        };
        function fr(t) {
          k(
            t,
            "svelte-5xpm5q",
            ".uppercase.svelte-5xpm5q{text-transform:uppercase}.left-section.svelte-5xpm5q{margin-right:10px;display:flex;align-items:center;justify-content:center}.right-section.svelte-5xpm5q{margin-left:10px;display:flex;align-items:center;justify-content:center}"
          );
        }
        const pr = (t) => ({}),
          gr = (t) => ({}),
          mr = (t) => ({}),
          yr = (t) => ({}),
          br = (t) => ({}),
          wr = (t) => ({}),
          vr = (t) => ({}),
          Ar = (t) => ({});
        function xr(t) {
          let e, r, s, a, l, u, p, g, m, b, w, v, A;
          const x = [Er, kr],
            k = [];
          function E(t, e) {
            return t[11] && "left" === t[5] ? 0 : t[21].leftIcon ? 1 : -1;
          }
          ~(r = E(t)) && (s = k[r] = x[r](t));
          const C = t[28].default,
            S = c(C, t, t[27], null),
            N =
              S ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("Button");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          let R = t[13] && Cr();
          const L = [Pr, Sr],
            z = [];
          function U(t, e) {
            return t[11] && "right" === t[5] ? 0 : t[21].rightIcon ? 1 : -1;
          }
          ~(p = U(t)) && (g = z[p] = L[p](t));
          let D = [
              {
                class: (m = t[18](
                  t[3],
                  t[17].root,
                  t[16]({ css: t[1], variation: t[4] }),
                  { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                )),
              },
              { disabled: t[9] },
              t[20],
              { tabindex: "0" },
            ],
            M = {};
          for (let t = 0; t < D.length; t += 1) M = n(M, D[t]);
          return {
            c() {
              (e = B("button")),
                s && s.c(),
                (a = O()),
                N && N.c(),
                (l = O()),
                R && R.c(),
                (u = O()),
                g && g.c(),
                F(e, M),
                Q(e, "compact", t[10]),
                Q(e, "uppercase", t[12]),
                Q(e, "svelte-5xpm5q", !0);
            },
            m(n, s) {
              P(n, e, s),
                ~r && k[r].m(e, null),
                $(e, a),
                N && N.m(e, null),
                $(e, l),
                R && R.m(e, null),
                $(e, u),
                ~p && z[p].m(e, null),
                e.autofocus && e.focus(),
                t[30](e),
                (w = !0),
                v ||
                  ((A = [
                    y((b = Vt.call(null, e, t[2]))),
                    y(t[19].call(null, e)),
                  ]),
                  (v = !0));
            },
            p(t, n) {
              let i = r;
              (r = E(t)),
                r === i
                  ? ~r && k[r].p(t, n)
                  : (s &&
                      (xt(),
                      Et(k[i], 1, 1, () => {
                        k[i] = null;
                      }),
                      $t()),
                    ~r
                      ? ((s = k[r]),
                        s ? s.p(t, n) : ((s = k[r] = x[r](t)), s.c()),
                        kt(s, 1),
                        s.m(e, a))
                      : (s = null)),
                S &&
                  S.p &&
                  (!w || 134217728 & n) &&
                  h(S, C, t, t[27], w ? d(C, t[27], n, null) : f(t[27]), null),
                t[13]
                  ? R
                    ? 8192 & n && kt(R, 1)
                    : ((R = Cr()), R.c(), kt(R, 1), R.m(e, u))
                  : R &&
                    (xt(),
                    Et(R, 1, 1, () => {
                      R = null;
                    }),
                    $t());
              let l = p;
              (p = U(t)),
                p === l
                  ? ~p && z[p].p(t, n)
                  : (g &&
                      (xt(),
                      Et(z[l], 1, 1, () => {
                        z[l] = null;
                      }),
                      $t()),
                    ~p
                      ? ((g = z[p]),
                        g ? g.p(t, n) : ((g = z[p] = L[p](t)), g.c()),
                        kt(g, 1),
                        g.m(e, null))
                      : (g = null)),
                F(
                  e,
                  (M = Pt(D, [
                    (!w ||
                      (461338 & n &&
                        m !==
                          (m = t[18](
                            t[3],
                            t[17].root,
                            t[16]({ css: t[1], variation: t[4] }),
                            { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                          )))) && { class: m },
                    (!w || 512 & n) && { disabled: t[9] },
                    1048576 & n && t[20],
                    { tabindex: "0" },
                  ]))
                ),
                b && o(b.update) && 4 & n && b.update.call(null, t[2]),
                Q(e, "compact", t[10]),
                Q(e, "uppercase", t[12]),
                Q(e, "svelte-5xpm5q", !0);
            },
            i(t) {
              w || (kt(s), kt(N, t), kt(R), kt(g), (w = !0));
            },
            o(t) {
              Et(s), Et(N, t), Et(R), Et(g), (w = !1);
            },
            d(n) {
              n && I(e),
                ~r && k[r].d(),
                N && N.d(n),
                R && R.d(),
                ~p && z[p].d(),
                t[30](null),
                (v = !1),
                i(A);
            },
          };
        }
        function $r(t) {
          let e, r, s, a, l, u, p, g, m, b, w, v, A, x;
          const k = [Br, Ir],
            E = [];
          function C(t, e) {
            return t[11] && "left" === t[5] ? 0 : t[21].leftIcon ? 1 : -1;
          }
          ~(r = C(t)) && (s = E[r] = k[r](t));
          const S = t[28].default,
            N = c(S, t, t[27], null),
            R =
              N ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("Button");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          let L = t[13] && Nr();
          const z = [Or, Tr],
            U = [];
          function D(t, e) {
            return t[11] && "right" === t[5] ? 0 : t[21].rightIcon ? 1 : -1;
          }
          ~(p = D(t)) && (g = U[p] = z[p](t));
          let M = [
              { href: t[7] },
              {
                class: (m = t[18](
                  t[3],
                  t[17].root,
                  t[16]({ css: t[1], variation: t[4], disabled: t[9] }),
                  { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                )),
              },
              { role: "button" },
              { rel: "noreferrer noopener" },
              { target: (b = t[8] ? "_blank" : "_self") },
              t[20],
              { tabindex: "0" },
            ],
            j = {};
          for (let t = 0; t < M.length; t += 1) j = n(j, M[t]);
          return {
            c() {
              (e = B("a")),
                s && s.c(),
                (a = O()),
                R && R.c(),
                (l = O()),
                L && L.c(),
                (u = O()),
                g && g.c(),
                F(e, j),
                Q(e, "compact", t[10]),
                Q(e, "uppercase", t[12]),
                Q(e, "svelte-5xpm5q", !0);
            },
            m(n, s) {
              P(n, e, s),
                ~r && E[r].m(e, null),
                $(e, a),
                R && R.m(e, null),
                $(e, l),
                L && L.m(e, null),
                $(e, u),
                ~p && U[p].m(e, null),
                t[29](e),
                (v = !0),
                A ||
                  ((x = [
                    y((w = Vt.call(null, e, t[2]))),
                    y(t[19].call(null, e)),
                  ]),
                  (A = !0));
            },
            p(t, n) {
              let i = r;
              (r = C(t)),
                r === i
                  ? ~r && E[r].p(t, n)
                  : (s &&
                      (xt(),
                      Et(E[i], 1, 1, () => {
                        E[i] = null;
                      }),
                      $t()),
                    ~r
                      ? ((s = E[r]),
                        s ? s.p(t, n) : ((s = E[r] = k[r](t)), s.c()),
                        kt(s, 1),
                        s.m(e, a))
                      : (s = null)),
                N &&
                  N.p &&
                  (!v || 134217728 & n) &&
                  h(N, S, t, t[27], v ? d(S, t[27], n, null) : f(t[27]), null),
                t[13]
                  ? L
                    ? 8192 & n && kt(L, 1)
                    : ((L = Nr()), L.c(), kt(L, 1), L.m(e, u))
                  : L &&
                    (xt(),
                    Et(L, 1, 1, () => {
                      L = null;
                    }),
                    $t());
              let l = p;
              (p = D(t)),
                p === l
                  ? ~p && U[p].p(t, n)
                  : (g &&
                      (xt(),
                      Et(U[l], 1, 1, () => {
                        U[l] = null;
                      }),
                      $t()),
                    ~p
                      ? ((g = U[p]),
                        g ? g.p(t, n) : ((g = U[p] = z[p](t)), g.c()),
                        kt(g, 1),
                        g.m(e, null))
                      : (g = null)),
                F(
                  e,
                  (j = Pt(M, [
                    (!v || 128 & n) && { href: t[7] },
                    (!v ||
                      (461338 & n &&
                        m !==
                          (m = t[18](
                            t[3],
                            t[17].root,
                            t[16]({
                              css: t[1],
                              variation: t[4],
                              disabled: t[9],
                            }),
                            { [t[17].disabled]: t[9], [t[17].loading]: t[11] }
                          )))) && { class: m },
                    { role: "button" },
                    { rel: "noreferrer noopener" },
                    (!v ||
                      (256 & n && b !== (b = t[8] ? "_blank" : "_self"))) && {
                      target: b,
                    },
                    1048576 & n && t[20],
                    { tabindex: "0" },
                  ]))
                ),
                w && o(w.update) && 4 & n && w.update.call(null, t[2]),
                Q(e, "compact", t[10]),
                Q(e, "uppercase", t[12]),
                Q(e, "svelte-5xpm5q", !0);
            },
            i(t) {
              v || (kt(s), kt(R, t), kt(L), kt(g), (v = !0));
            },
            o(t) {
              Et(s), Et(R, t), Et(L), Et(g), (v = !1);
            },
            d(n) {
              n && I(e),
                ~r && E[r].d(),
                R && R.d(n),
                L && L.d(),
                ~p && U[p].d(),
                t[29](null),
                (A = !1),
                i(x);
            },
          };
        }
        function kr(t) {
          let e, n;
          const r = t[28].leftIcon,
            s = c(r, t, t[27], yr),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = B("span")),
                i && i.c(),
                z(e, "class", "left-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, mr) : f(t[27]), yr);
            },
            i(t) {
              n || (kt(i, t), (n = !0));
            },
            o(t) {
              Et(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function Er(t) {
          let e, n, r;
          return (
            (n = new rr({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = B("span")),
                  Nt(n.$$.fragment),
                  z(e, "class", "left-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Tt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (kt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                Et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Ot(n);
              },
            }
          );
        }
        function Cr(t) {
          let e, n;
          return (
            (e = new hr({ props: { center: !1, circle: !1 } })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Sr(t) {
          let e, n;
          const r = t[28].rightIcon,
            s = c(r, t, t[27], gr),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = B("span")),
                i && i.c(),
                z(e, "class", "right-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, pr) : f(t[27]), gr);
            },
            i(t) {
              n || (kt(i, t), (n = !0));
            },
            o(t) {
              Et(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function Pr(t) {
          let e, n, r;
          return (
            (n = new rr({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = B("span")),
                  Nt(n.$$.fragment),
                  z(e, "class", "right-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Tt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (kt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                Et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Ot(n);
              },
            }
          );
        }
        function Ir(t) {
          let e, n;
          const r = t[28].leftIcon,
            s = c(r, t, t[27], Ar),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = B("span")),
                i && i.c(),
                z(e, "class", "left-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, vr) : f(t[27]), Ar);
            },
            i(t) {
              n || (kt(i, t), (n = !0));
            },
            o(t) {
              Et(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function Br(t) {
          let e, n, r;
          return (
            (n = new rr({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = B("span")),
                  Nt(n.$$.fragment),
                  z(e, "class", "left-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Tt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (kt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                Et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Ot(n);
              },
            }
          );
        }
        function Nr(t) {
          let e, n;
          return (
            (e = new hr({ props: { center: !1, circle: !1 } })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Tr(t) {
          let e, n;
          const r = t[28].rightIcon,
            s = c(r, t, t[27], wr),
            i =
              s ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("X");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              (e = B("span")),
                i && i.c(),
                z(e, "class", "right-section svelte-5xpm5q");
            },
            m(t, r) {
              P(t, e, r), i && i.m(e, null), (n = !0);
            },
            p(t, e) {
              s &&
                s.p &&
                (!n || 134217728 & e) &&
                h(s, r, t, t[27], n ? d(r, t[27], e, br) : f(t[27]), wr);
            },
            i(t) {
              n || (kt(i, t), (n = !0));
            },
            o(t) {
              Et(i, t), (n = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function Or(t) {
          let e, n, r;
          return (
            (n = new rr({
              props: {
                variant: t[6].variant,
                size: t[6].size,
                color: t[6].color,
              },
            })),
            {
              c() {
                (e = B("span")),
                  Nt(n.$$.fragment),
                  z(e, "class", "right-section svelte-5xpm5q");
              },
              m(t, s) {
                P(t, e, s), Tt(n, e, null), (r = !0);
              },
              p(t, e) {
                const r = {};
                64 & e && (r.variant = t[6].variant),
                  64 & e && (r.size = t[6].size),
                  64 & e && (r.color = t[6].color),
                  n.$set(r);
              },
              i(t) {
                r || (kt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                Et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                t && I(e), Ot(n);
              },
            }
          );
        }
        function Rr(t) {
          let e, n, r, s, i, o;
          e = new Dt({
            props: { observable: t[14], component: "Button", code: t[15] },
          });
          const a = [$r, xr],
            l = [];
          function c(t, e) {
            return t[7] ? 0 : 1;
          }
          return (
            (r = c(t)),
            (s = l[r] = a[r](t)),
            {
              c() {
                Nt(e.$$.fragment), (n = O()), s.c(), (i = R());
              },
              m(t, s) {
                Tt(e, t, s), P(t, n, s), l[r].m(t, s), P(t, i, s), (o = !0);
              },
              p(t, [n]) {
                const o = {};
                16384 & n && (o.observable = t[14]),
                  32768 & n && (o.code = t[15]),
                  e.$set(o);
                let u = r;
                (r = c(t)),
                  r === u
                    ? l[r].p(t, n)
                    : (xt(),
                      Et(l[u], 1, 1, () => {
                        l[u] = null;
                      }),
                      $t(),
                      (s = l[r]),
                      s ? s.p(t, n) : ((s = l[r] = a[r](t)), s.c()),
                      kt(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (kt(e.$$.fragment, t), kt(s), (o = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), Et(s), (o = !1);
              },
              d(t) {
                Ot(e, t), t && I(n), l[r].d(t), t && I(i);
              },
            }
          );
        }
        function Lr(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "variant",
            "color",
            "size",
            "radius",
            "gradient",
            "loaderPosition",
            "loaderProps",
            "href",
            "external",
            "disabled",
            "compact",
            "loading",
            "uppercase",
            "fullSize",
            "ripple",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e;
          const d = m(c);
          let {
            use: h = [],
            element: f,
            class: y = "",
            override: b = {},
            variant: w = "filled",
            color: v = "blue",
            size: A = "sm",
            radius: x = "sm",
            gradient: $ = { from: "indigo", to: "cyan", deg: 45 },
            loaderPosition: k = "left",
            loaderProps: E = { size: "xs", color: "white", variant: "circle" },
            href: C = null,
            external: S = !1,
            disabled: P = !1,
            compact: I = !1,
            loading: B = !1,
            uppercase: N = !1,
            fullSize: T = !1,
            ripple: O = !1,
          } = e;
          const R = Jt(et());
          let L,
            z = !1;
          return (
            P && B && ((z = !0), (L = Gn[0])),
            ((S && "string" != typeof C) || C?.length < 1) &&
              ((z = !0), (L = Gn[1])),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(20, (l = g(e, a))),
                "use" in t && r(2, (h = t.use)),
                "element" in t && r(0, (f = t.element)),
                "class" in t && r(3, (y = t.class)),
                "override" in t && r(1, (b = t.override)),
                "variant" in t && r(4, (w = t.variant)),
                "color" in t && r(22, (v = t.color)),
                "size" in t && r(23, (A = t.size)),
                "radius" in t && r(24, (x = t.radius)),
                "gradient" in t && r(25, ($ = t.gradient)),
                "loaderPosition" in t && r(5, (k = t.loaderPosition)),
                "loaderProps" in t && r(6, (E = t.loaderProps)),
                "href" in t && r(7, (C = t.href)),
                "external" in t && r(8, (S = t.external)),
                "disabled" in t && r(9, (P = t.disabled)),
                "compact" in t && r(10, (I = t.compact)),
                "loading" in t && r(11, (B = t.loading)),
                "uppercase" in t && r(12, (N = t.uppercase)),
                "fullSize" in t && r(26, (T = t.fullSize)),
                "ripple" in t && r(13, (O = t.ripple)),
                "$$scope" in t && r(27, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              16384 & t.$$.dirty && z && r(1, (b = { display: "none" })),
                130024464 & t.$$.dirty &&
                  r(
                    18,
                    ({
                      cx: s,
                      classes: i,
                      getStyles: o,
                    } = Hn(
                      {
                        color: v,
                        compact: I,
                        fullSize: T,
                        gradient: $,
                        radius: x,
                        size: A,
                        variant: w,
                      },
                      { name: "Button" }
                    )),
                    s,
                    (r(17, i),
                    r(22, v),
                    r(10, I),
                    r(26, T),
                    r(25, $),
                    r(24, x),
                    r(23, A),
                    r(4, w)),
                    (r(16, o),
                    r(22, v),
                    r(10, I),
                    r(26, T),
                    r(25, $),
                    r(24, x),
                    r(23, A),
                    r(4, w))
                  );
            }),
            [
              f,
              b,
              h,
              y,
              w,
              k,
              E,
              C,
              S,
              P,
              I,
              B,
              N,
              O,
              z,
              L,
              o,
              i,
              s,
              R,
              l,
              d,
              v,
              A,
              x,
              $,
              T,
              u,
              c,
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (f = t), r(0, f);
                });
              },
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (f = t), r(0, f);
                });
              },
            ]
          );
        }
        var zr = class extends Lt {
          constructor(t) {
            super(),
              Rt(
                this,
                t,
                Lr,
                Rr,
                a,
                {
                  use: 2,
                  element: 0,
                  class: 3,
                  override: 1,
                  variant: 4,
                  color: 22,
                  size: 23,
                  radius: 24,
                  gradient: 25,
                  loaderPosition: 5,
                  loaderProps: 6,
                  href: 7,
                  external: 8,
                  disabled: 9,
                  compact: 10,
                  loading: 11,
                  uppercase: 12,
                  fullSize: 26,
                  ripple: 13,
                },
                fr
              );
          }
        };
        const Ur = { xs: 18, sm: 22, md: 28, lg: 34, xl: 44 };
        function Fr(t) {
          const { themeColor: e } = ge;
          return {
            ...le(t),
            hover: {
              [`${Sn.selector} &`]: {
                color: e(t, 8),
                "&:hover": { backgroundColor: e("dark", 8) },
              },
              border: "1px solid transparent",
              backgroundColor: "transparent",
              color: e(t, 7),
              "&:hover": { backgroundColor: e(t) },
            },
            transparent: {
              [`${Sn.selector} &`]: {
                color: e(t, 8),
                "&:hover": { backgroundColor: null },
              },
              border: "1px solid transparent",
              backgroundColor: "transparent",
              color: e(t, 7),
              "&:hover": { backgroundColor: null },
            },
          };
        }
        var Dr = ke((t, { color: e, radius: n, size: r }) => ({
          root: {
            focusRing: "auto",
            position: "relative",
            appearance: "none",
            WebkitAppearance: "none",
            WebkitTapHighlightColor: "transparent",
            boxSizing: "border-box",
            height: "string" == typeof r ? Ur[r] : `${r}px`,
            minHeight: "string" == typeof r ? Ur[r] : `${r}px`,
            width: "string" == typeof r ? Ur[r] : `${r}px`,
            minWidth: "string" == typeof r ? Ur[r] : `${r}px`,
            borderRadius: `$${n}`,
            padding: 0,
            lineHeight: 1,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            textDecoration: "none",
            "&:not(:disabled):active": { transform: "translateY(1px)" },
            "&:disabled": {
              pointerEvents: "none",
              borderColor: "transparent",
              background: t.fn.themeColor("gray", 2),
              backgroundColor: t.fn.themeColor("gray", 2),
              color: t.fn.themeColor("gray", 5),
              cursor: "not-allowed",
              darkMode: {
                borderColor: "transparent",
                backgroundColor: t.fn.themeColor("dark", 4),
                color: t.fn.themeColor("dark", 6),
              },
            },
          },
          loading: {
            pointerEvents: "none",
            "&::before": {
              content: '""',
              position: "absolute",
              top: -1,
              left: -1,
              right: -1,
              bottom: -1,
              backgroundColor: "rgba(255, 255, 255, .5)",
              borderRadius: `$${n}`,
              cursor: "not-allowed",
            },
          },
          variants: { variation: Fr(e) },
        }));
        const Mr = Object.freeze([
          {
            error: !0,
            message:
              "If using the 'href' prop, set 'root' prop to an anchor ('a') tag",
            solution:
              "\n                If your component looks like this:\n\n                &lt;ActionIcon href='https://example.com'&gt;\n                          ^^^ - Try adding prop root='a'\n                       &lt;Icon /&gt;\n                &lt;/ActionIcon&gt;\n                ",
          },
        ]);
        function jr(t) {
          let e;
          const n = t[21].default,
            r = c(n, t, t[23], null),
            s =
              r ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("+");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              s && s.c();
            },
            m(t, n) {
              s && s.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 8388608 & s) &&
                h(r, n, t, t[23], e ? d(n, t[23], s, null) : f(t[23]), null);
            },
            i(t) {
              e || (kt(s, t), (e = !0));
            },
            o(t) {
              Et(s, t), (e = !1);
            },
            d(t) {
              s && s.d(t);
            },
          };
        }
        function Hr(t) {
          let e, n;
          return (
            (e = new rr({
              props: {
                size: t[6].size,
                color: t[6].color,
                variant: t[6].variant,
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                64 & n && (r.size = t[6].size),
                  64 & n && (r.color = t[6].color),
                  64 & n && (r.variant = t[6].variant),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Gr(t) {
          let e, n, r, s;
          const i = [Hr, jr],
            o = [];
          function a(t, e) {
            return t[7] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, s) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (xt(),
                      Et(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      $t(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      kt(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (kt(n), (s = !0));
              },
              o(t) {
                Et(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Vr(t) {
          let e, r, s, i, o;
          e = new Dt({
            props: { observable: t[11], component: "ActionIcon", code: t[12] },
          });
          const a = [
            { use: [t[16], [Vt, t[2]]] },
            { tabindex: 0 },
            { disabled: t[8] || t[7] },
            {
              class: t[15](
                t[3],
                t[14].root,
                { [t[14].loading]: t[7] },
                t[13]({ css: t[1], variation: t[5] })
              ),
            },
            { target: t[10] ? "_blank" : null },
            { rel: t[10] ? "noreferrer noopener" : null },
            { root: t[4] },
            { href: t[9] },
            t[17],
          ];
          function l(e) {
            t[22](e);
          }
          let c = { $$slots: { default: [Gr] }, $$scope: { ctx: t } };
          for (let t = 0; t < a.length; t += 1) c = n(c, a[t]);
          return (
            void 0 !== t[0] && (c.element = t[0]),
            (s = new Mn({ props: c })),
            it.push(() => Bt(s, "element", l)),
            {
              c() {
                Nt(e.$$.fragment), (r = O()), Nt(s.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), P(t, r, n), Tt(s, t, n), (o = !0);
              },
              p(t, [n]) {
                const r = {};
                2048 & n && (r.observable = t[11]),
                  4096 & n && (r.code = t[12]),
                  e.$set(r);
                const o =
                  255934 & n
                    ? Pt(a, [
                        65540 & n && { use: [t[16], [Vt, t[2]]] },
                        a[1],
                        384 & n && { disabled: t[8] || t[7] },
                        57514 & n && {
                          class: t[15](
                            t[3],
                            t[14].root,
                            { [t[14].loading]: t[7] },
                            t[13]({ css: t[1], variation: t[5] })
                          ),
                        },
                        1024 & n && { target: t[10] ? "_blank" : null },
                        1024 & n && {
                          rel: t[10] ? "noreferrer noopener" : null,
                        },
                        16 & n && { root: t[4] },
                        512 & n && { href: t[9] },
                        131072 & n && It(t[17]),
                      ])
                    : {};
                8388800 & n && (o.$$scope = { dirty: n, ctx: t }),
                  !i &&
                    1 & n &&
                    ((i = !0), (o.element = t[0]), ft(() => (i = !1))),
                  s.$set(o);
              },
              i(t) {
                o || (kt(e.$$.fragment, t), kt(s.$$.fragment, t), (o = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), Et(s.$$.fragment, t), (o = !1);
              },
              d(t) {
                Ot(e, t), t && I(r), Ot(s, t);
              },
            }
          );
        }
        function Qr(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "root",
            "color",
            "variant",
            "size",
            "radius",
            "loaderProps",
            "loading",
            "disabled",
            "href",
            "external",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              root: y = "button",
              color: b = "gray",
              variant: w = "hover",
              size: v = "md",
              radius: A = "sm",
              loaderProps: x = { size: "xs", color: "gray", variant: "circle" },
              loading: $ = !1,
              disabled: k = !1,
              href: E = "",
              external: C = !1,
            } = e;
          const S = Jt(et());
          let P,
            I = !1;
          return (
            "a" !== y && e.href && ((I = !0), (P = Mr[0])),
            (t.$$set = (t) => {
              r(24, (e = n(n({}, e), p(t)))),
                r(17, (l = g(e, a))),
                "use" in t && r(2, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(3, (f = t.class)),
                "override" in t && r(1, (m = t.override)),
                "root" in t && r(4, (y = t.root)),
                "color" in t && r(18, (b = t.color)),
                "variant" in t && r(5, (w = t.variant)),
                "size" in t && r(19, (v = t.size)),
                "radius" in t && r(20, (A = t.radius)),
                "loaderProps" in t && r(6, (x = t.loaderProps)),
                "loading" in t && r(7, ($ = t.loading)),
                "disabled" in t && r(8, (k = t.disabled)),
                "href" in t && r(9, (E = t.href)),
                "external" in t && r(10, (C = t.external)),
                "$$scope" in t && r(23, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              2048 & t.$$.dirty && I && r(1, (m = { display: "none" })),
                1835008 & t.$$.dirty &&
                  r(
                    15,
                    ({
                      cx: s,
                      classes: i,
                      getStyles: o,
                    } = Dr(
                      { color: b, radius: A, size: v },
                      { name: "ActionIcon" }
                    )),
                    s,
                    (r(14, i), r(18, b), r(20, A), r(19, v)),
                    (r(13, o), r(18, b), r(20, A), r(19, v))
                  );
            }),
            (e = p(e)),
            [
              h,
              m,
              d,
              f,
              y,
              w,
              x,
              $,
              k,
              E,
              C,
              I,
              P,
              o,
              i,
              s,
              S,
              l,
              b,
              v,
              A,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Wr = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Qr, Vr, a, {
                use: 2,
                element: 0,
                class: 3,
                override: 1,
                root: 4,
                color: 18,
                variant: 5,
                size: 19,
                radius: 20,
                loaderProps: 6,
                loading: 7,
                disabled: 8,
                href: 9,
                external: 10,
              });
          }
        };
        function Jr(e) {
          let r,
            s,
            i = [
              { width: e[0] },
              { height: e[1] },
              { viewBox: "0 0 15 15" },
              { fill: "none" },
              { xmlns: "http://www.w3.org/2000/svg" },
              e[2],
            ],
            o = {};
          for (let t = 0; t < i.length; t += 1) o = n(o, i[t]);
          return {
            c() {
              (r = N("svg")),
                (s = N("path")),
                z(
                  s,
                  "d",
                  "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z"
                ),
                z(s, "fill", "currentColor"),
                z(s, "fill-rule", "evenodd"),
                z(s, "clip-rule", "evenodd"),
                D(r, o);
            },
            m(t, e) {
              P(t, r, e), $(r, s);
            },
            p(t, [e]) {
              D(
                r,
                (o = Pt(i, [
                  1 & e && { width: t[0] },
                  2 & e && { height: t[1] },
                  { viewBox: "0 0 15 15" },
                  { fill: "none" },
                  { xmlns: "http://www.w3.org/2000/svg" },
                  4 & e && t[2],
                ]))
              );
            },
            i: t,
            o: t,
            d(t) {
              t && I(r);
            },
          };
        }
        function _r(t, e, r) {
          const s = ["width", "height"];
          let i = g(e, s),
            { width: o = 16 } = e,
            { height: a = 16 } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(2, (i = g(e, s))),
                "width" in t && r(0, (o = t.width)),
                "height" in t && r(1, (a = t.height));
            }),
            [o, a, i]
          );
        }
        var Kr = class extends Lt {
          constructor(t) {
            super(), Rt(this, t, _r, Jr, a, { width: 0, height: 1 });
          }
        };
        function qr(t) {
          let e, n;
          return (
            (e = new Kr({
              props: { width: t[16][t[4]], height: t[16][t[4]] },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                16 & n && (r.width = t[16][t[4]]),
                  16 & n && (r.height = t[16][t[4]]),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Yr(t) {
          let e, r, s;
          const i = [
            { class: t[2] },
            { use: [t[15], [Vt, t[1]]] },
            { override: t[3] },
            { root: t[5] },
            { color: t[6] },
            { variant: t[7] },
            { size: t[8] },
            { radius: t[9] },
            { loaderProps: t[10] },
            { loading: t[11] },
            { disabled: t[12] },
            { href: t[13] },
            { external: t[14] },
            t[17],
          ];
          function o(e) {
            t[18](e);
          }
          let a = { $$slots: { default: [qr] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Wr({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  196590 & n
                    ? Pt(i, [
                        4 & n && { class: t[2] },
                        32770 & n && { use: [t[15], [Vt, t[1]]] },
                        8 & n && { override: t[3] },
                        32 & n && { root: t[5] },
                        64 & n && { color: t[6] },
                        128 & n && { variant: t[7] },
                        256 & n && { size: t[8] },
                        512 & n && { radius: t[9] },
                        1024 & n && { loaderProps: t[10] },
                        2048 & n && { loading: t[11] },
                        4096 & n && { disabled: t[12] },
                        8192 & n && { href: t[13] },
                        16384 & n && { external: t[14] },
                        131072 & n && It(t[17]),
                      ])
                    : {};
                524304 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Zr(t, e, r) {
          const s = [
            "use",
            "element",
            "class",
            "override",
            "iconSize",
            "root",
            "color",
            "variant",
            "size",
            "radius",
            "loaderProps",
            "loading",
            "disabled",
            "href",
            "external",
          ];
          let i = g(e, s),
            {
              use: o = [],
              element: a,
              class: l = "",
              override: c = {},
              iconSize: u = "md",
              root: d = "button",
              color: h = "gray",
              variant: f = "hover",
              size: m = "md",
              radius: y = "sm",
              loaderProps: b = { size: "xs", color: "gray", variant: "circle" },
              loading: w = !1,
              disabled: v = !1,
              href: A = "",
              external: x = !1,
            } = e;
          const $ = Jt(et());
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(17, (i = g(e, s))),
                "use" in t && r(1, (o = t.use)),
                "element" in t && r(0, (a = t.element)),
                "class" in t && r(2, (l = t.class)),
                "override" in t && r(3, (c = t.override)),
                "iconSize" in t && r(4, (u = t.iconSize)),
                "root" in t && r(5, (d = t.root)),
                "color" in t && r(6, (h = t.color)),
                "variant" in t && r(7, (f = t.variant)),
                "size" in t && r(8, (m = t.size)),
                "radius" in t && r(9, (y = t.radius)),
                "loaderProps" in t && r(10, (b = t.loaderProps)),
                "loading" in t && r(11, (w = t.loading)),
                "disabled" in t && r(12, (v = t.disabled)),
                "href" in t && r(13, (A = t.href)),
                "external" in t && r(14, (x = t.external));
            }),
            [
              a,
              o,
              l,
              c,
              u,
              d,
              h,
              f,
              m,
              y,
              b,
              w,
              v,
              A,
              x,
              $,
              { xs: 12, sm: 14, md: 16, lg: 20, xl: 24 },
              i,
              function (t) {
                (a = t), r(0, a);
              },
            ]
          );
        }
        var Xr = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Zr, Yr, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                iconSize: 4,
                root: 5,
                color: 6,
                variant: 7,
                size: 8,
                radius: 9,
                loaderProps: 10,
                loading: 11,
                disabled: 12,
                href: 13,
                external: 14,
              });
          }
        };
        const ts = /input|select|textarea|button|object/,
          es = "a, input, select, textarea, button, object, [tabindex]";
        function ns(t) {
          return "test" !== process.env.NODE_ENV && "none" === t.style.display;
        }
        function rs(t) {
          const e = t.getAttribute("tabindex");
          return e ? parseInt(e, 10) : null;
        }
        function ss(t) {
          const e = t.nodeName.toLowerCase(),
            n = null !== rs(t);
          return (
            ((ts.test(e) && !t.disabled) ||
              (t instanceof HTMLAnchorElement && t.href) ||
              n) &&
            (function (t) {
              if (
                t.getAttribute("aria-hidden") ||
                t.getAttribute("hidden") ||
                "hidden" === t.getAttribute("type")
              )
                return !1;
              let e = t;
              for (; e && e !== document.body && 11 !== e.nodeType; ) {
                if (ns(e)) return !1;
                e = e.parentNode;
              }
              return !0;
            })(t)
          );
        }
        function is(t) {
          const e = rs(t);
          return (null === e || e >= 0) && ss(t);
        }
        function os(t) {
          return Array.from(t.querySelectorAll(es)).filter(is);
        }
        function as(t, e = !0) {
          let n = null;
          const r = (n) => {
            e &&
              "Tab" === n.key &&
              t &&
              (function (t, e) {
                const n = os(t);
                if (!n.length) return void e.preventDefault();
                const r = n[e.shiftKey ? 0 : n.length - 1],
                  s = t.getRootNode();
                if (r !== s.activeElement && t !== s.activeElement) return;
                e.preventDefault();
                const i = n[e.shiftKey ? n.length - 1 : 0];
                i && i.focus();
              })(t, n);
          };
          function s() {
            if (!e) return void (n && n());
            n = (function (t) {
              const e = [];
              return (
                (function t(n) {
                  if (n && n !== document.querySelector("body")) {
                    const r = n.parentElement;
                    [...Array.from(r.children)].forEach((t) => {
                      const r = t.getAttribute("aria-hidden");
                      t === n ||
                        "SCRIPT" === t.nodeName ||
                        (null !== r && "false" !== r) ||
                        e.push({ node: t, ariaHidden: r });
                    }),
                      t(r);
                  }
                })(t),
                e.map(({ node: t }) => {
                  t.setAttribute("aria-hidden", "true");
                }),
                () => {
                  e.forEach((t) => {
                    t &&
                      (null === t.ariaHidden
                        ? t.node.removeAttribute("aria-hidden")
                        : t.node.setAttribute("aria-hidden", t.ariaHidden));
                  });
                }
              );
            })(t);
            setTimeout(() => {
              t.getRootNode()
                ? (() => {
                    let e = t.querySelector("[autofocus]");
                    if (!e) {
                      const n = Array.from(t.querySelectorAll(es));
                      (e = n.find(is) || n.find(ss) || null),
                        !e && ss(t) && (e = t);
                    }
                    e
                      ? e.focus({ preventScroll: !0 })
                      : "development" === process.env.NODE_ENV &&
                        console.warn(
                          "[@svelteuidev/composables/use-focus-trap] Failed to find focusable element within provided node",
                          t
                        );
                  })()
                : "development" === process.env.NODE_ENV &&
                  console.warn(
                    "[@svelteuidev/composables/use-focus-trap] node is not part of the dom",
                    t
                  );
            });
          }
          return (
            document.addEventListener("keydown", r),
            s(),
            {
              update(t) {
                (e = t), s();
              },
              destroy() {
                document.removeEventListener("keydown", r), n && n();
              },
            }
          );
        }
        const ls = ({ disableBodyPadding: t }) => {
          const e = t
            ? null
            : "undefined" == typeof window || "undefined" == typeof document
            ? 0
            : parseInt(
                window.getComputedStyle(document.body).paddingRight,
                10
              ) +
              (window.innerWidth - document.documentElement.clientWidth);
          return `body {\n        --removed-scroll-width: ${e}px;\n        touch-action: none;\n        overflow: hidden !important;\n        position: relative !important;\n        ${
            e ? "padding-right: var(--removed-scroll-width) !important;" : ""
          }\n        `;
        };
        const cs = () => "undefined" != typeof window,
          us = { browser: cs(), server: !cs() },
          ds = us.browser ? window : void 0;
        function hs(t, e, n = { disableBodyPadding: !1 }) {
          const { browser: r } = us;
          let s;
          r && (s = ds);
          let i = e ?? !1;
          const { disableBodyPadding: o } = n;
          let a;
          const l = () => {
              const t = ls({ disableBodyPadding: o }),
                e = (function () {
                  const t = document.createElement("style");
                  return (
                    (t.type = "text/css"),
                    t.setAttribute("svelteui-scroll-lock", ""),
                    t
                  );
                })();
              var n;
              !(function (t, e) {
                t.styleSheet
                  ? (t.styleSheet.cssText = e)
                  : t.appendChild(document.createTextNode(e));
              })(e, t),
                (n = e),
                (
                  document.head || document.getElementsByTagName("head")[0]
                ).appendChild(n),
                (a = e);
            },
            c = () => {
              a && (a?.parentNode?.removeChild(a), (a = null));
            };
          return (
            i ? l() : c(),
            void 0 !== e && (i = e),
            void 0 === e &&
              void 0 !== s &&
              "hidden" === s.document.body.style.overflow &&
              (i = e),
            {
              update: (t) => {
                t
                  ? l()
                  : ("visible" === s.document.body.style.overflow && (i = e),
                    c());
              },
              destroy: () => {
                c();
              },
            }
          );
        }
        function fs(t, e = "body") {
          let n;
          async function r(r) {
            if ("string" == typeof (e = r)) {
              if (
                ((n = document.querySelector(e)),
                null === n && (await dt(), (n = document.querySelector(e))),
                null === n)
              )
                throw new Error(
                  `No element found matching css selector: "${e}"`
                );
            } else {
              if (!(e instanceof HTMLElement))
                throw new TypeError(
                  `Unknown portal target type: ${
                    null === e ? "null" : typeof e
                  }. Allowed types: string (CSS selector) or HTMLElement.`
                );
              n = e;
            }
            n.appendChild(t), (t.hidden = !1);
          }
          return (
            r(e),
            {
              update: r,
              destroy: function () {
                t.parentNode && t.parentNode.removeChild(t);
              },
            }
          );
        }
        function ps(t) {
          let e, n, r, s, a, l;
          const u = t[8].default,
            p = c(u, t, t[7], null);
          return {
            c() {
              (e = B("div")),
                p && p.c(),
                z(e, "class", t[2]),
                (e.hidden = !0),
                V(e, "position", t[4]),
                V(e, "zIndex", t[5]);
            },
            m(i, o) {
              P(i, e, o),
                p && p.m(e, null),
                t[9](e),
                (s = !0),
                a ||
                  ((l = [
                    y((n = Vt.call(null, e, t[1]))),
                    y(t[6].call(null, e)),
                    y((r = fs.call(null, e, t[3]))),
                  ]),
                  (a = !0));
            },
            p(t, [i]) {
              p &&
                p.p &&
                (!s || 128 & i) &&
                h(p, u, t, t[7], s ? d(u, t[7], i, null) : f(t[7]), null),
                (!s || 4 & i) && z(e, "class", t[2]),
                (!s || 16 & i) && V(e, "position", t[4]),
                (!s || 32 & i) && V(e, "zIndex", t[5]),
                n && o(n.update) && 2 & i && n.update.call(null, t[1]),
                r && o(r.update) && 8 & i && r.update.call(null, t[3]);
            },
            i(t) {
              s || (kt(p, t), (s = !0));
            },
            o(t) {
              Et(p, t), (s = !1);
            },
            d(n) {
              n && I(e), p && p.d(n), t[9](null), (a = !1), i(l);
            },
          };
        }
        function gs(t, e, n) {
          let { $$slots: r = {}, $$scope: s } = e,
            {
              use: i = [],
              element: o,
              class: a = "",
              target: l = "body",
              position: c = "relative",
              zIndex: u = 1,
            } = e;
          const d = Jt(et());
          return (
            (t.$$set = (t) => {
              "use" in t && n(1, (i = t.use)),
                "element" in t && n(0, (o = t.element)),
                "class" in t && n(2, (a = t.class)),
                "target" in t && n(3, (l = t.target)),
                "position" in t && n(4, (c = t.position)),
                "zIndex" in t && n(5, (u = t.zIndex)),
                "$$scope" in t && n(7, (s = t.$$scope));
            }),
            [
              o,
              i,
              a,
              l,
              c,
              u,
              d,
              s,
              r,
              function (t) {
                it[t ? "unshift" : "push"](() => {
                  (o = t), n(0, o);
                });
              },
            ]
          );
        }
        var ms = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, gs, ps, a, {
                use: 1,
                element: 0,
                class: 2,
                target: 3,
                position: 4,
                zIndex: 5,
              });
          }
        };
        function ys(t) {
          let e;
          const n = t[5].default,
            r = c(n, t, t[7], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 128 & s) &&
                h(r, n, t, t[7], e ? d(n, t[7], s, null) : f(t[7]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function bs(t) {
          let e, n, r;
          function s(e) {
            t[6](e);
          }
          let i = {
            class: t[3],
            use: t[2],
            target: t[4],
            $$slots: { default: [ws] },
            $$scope: { ctx: t },
          };
          return (
            void 0 !== t[0] && (i.element = t[0]),
            (e = new ms({ props: i })),
            it.push(() => Bt(e, "element", s)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (r = !0);
              },
              p(t, r) {
                const s = {};
                8 & r && (s.class = t[3]),
                  4 & r && (s.use = t[2]),
                  16 & r && (s.target = t[4]),
                  128 & r && (s.$$scope = { dirty: r, ctx: t }),
                  !n &&
                    1 & r &&
                    ((n = !0), (s.element = t[0]), ft(() => (n = !1))),
                  e.$set(s);
              },
              i(t) {
                r || (kt(e.$$.fragment, t), (r = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (r = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function ws(t) {
          let e;
          const n = t[5].default,
            r = c(n, t, t[7], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 128 & s) &&
                h(r, n, t, t[7], e ? d(n, t[7], s, null) : f(t[7]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function vs(t) {
          let e, n, r, s;
          const i = [bs, ys],
            o = [];
          function a(t, e) {
            return t[1] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, [s]) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (xt(),
                      Et(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      $t(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      kt(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (kt(n), (s = !0));
              },
              o(t) {
                Et(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function As(t, e, n) {
          let { $$slots: r = {}, $$scope: s } = e,
            {
              withinPortal: i = !0,
              use: o = [],
              element: a,
              class: l = "",
              target: c = "body",
            } = e;
          return (
            (t.$$set = (t) => {
              "withinPortal" in t && n(1, (i = t.withinPortal)),
                "use" in t && n(2, (o = t.use)),
                "element" in t && n(0, (a = t.element)),
                "class" in t && n(3, (l = t.class)),
                "target" in t && n(4, (c = t.target)),
                "$$scope" in t && n(7, (s = t.$$scope));
            }),
            [
              a,
              i,
              o,
              l,
              c,
              r,
              function (t) {
                (a = t), n(0, a);
              },
              s,
            ]
          );
        }
        var xs = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, As, vs, a, {
                withinPortal: 1,
                use: 2,
                element: 0,
                class: 3,
                target: 4,
              });
          }
        };
        function $s(t) {
          let e;
          const n = t[8].default,
            r = c(n, t, t[10], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 1024 & s) &&
                h(r, n, t, t[10], e ? d(n, t[10], s, null) : f(t[10]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function ks(t) {
          let e, r, s;
          const i = [
            { class: t[2] },
            { css: { position: "fixed", ...t[5], ...t[3] } },
            { use: t[1] },
            t[7],
          ];
          function o(e) {
            t[9](e);
          }
          let a = { $$slots: { default: [$s] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  174 & n
                    ? Pt(i, [
                        4 & n && { class: t[2] },
                        40 & n && {
                          css: { position: "fixed", ...t[5], ...t[3] },
                        },
                        2 & n && { use: t[1] },
                        128 & n && It(t[7]),
                      ])
                    : {};
                1024 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Es(t) {
          let e, n;
          return (
            (e = new ms({
              props: {
                zIndex: t[6],
                target: t[4],
                $$slots: { default: [ks] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                64 & n && (r.zIndex = t[6]),
                  16 & n && (r.target = t[4]),
                  1199 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Cs(t, e, r) {
          const s = [
            "use",
            "element",
            "class",
            "override",
            "target",
            "position",
            "zIndex",
          ];
          let i = g(e, s),
            { $$slots: o = {}, $$scope: a } = e,
            {
              use: l = [],
              element: c,
              class: u = "",
              override: d = {},
              target: h = "body",
              position: f = { bottom: 0, right: 0 },
              zIndex: m = 200,
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (i = g(e, s))),
                "use" in t && r(1, (l = t.use)),
                "element" in t && r(0, (c = t.element)),
                "class" in t && r(2, (u = t.class)),
                "override" in t && r(3, (d = t.override)),
                "target" in t && r(4, (h = t.target)),
                "position" in t && r(5, (f = t.position)),
                "zIndex" in t && r(6, (m = t.zIndex)),
                "$$scope" in t && r(10, (a = t.$$scope));
            }),
            [
              c,
              l,
              u,
              d,
              h,
              f,
              m,
              i,
              o,
              function (t) {
                (c = t), r(0, c);
              },
              a,
            ]
          );
        }
        var Ss = class extends Lt {
            constructor(t) {
              super(),
                Rt(this, t, Cs, Es, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 3,
                  target: 4,
                  position: 5,
                  zIndex: 6,
                });
            }
          },
          Ps = ke((t, { color: e, radius: n, variant: r }, s) => ({
            root: {
              position: "relative",
              overflow: "hidden",
              padding: `${t.space.sm.value}px ${t.space.md.value}px`,
              borderRadius: t.fn.radius(n),
              border: "1px solid transparent",
              "&.light": {
                darkMode: {
                  backgroundColor: t.fn.variant({ variant: "light", color: e })
                    .background[0],
                  color: t.fn.variant({ variant: "light", color: e }).color[0],
                },
                backgroundColor: t.fn.variant({ variant: "light", color: e })
                  .background[1],
                color: t.fn.variant({ variant: "light", color: e }).color[1],
              },
              "&.filled": {
                darkMode: {
                  backgroundColor: t.fn.variant({ variant: "filled", color: e })
                    .background[0],
                },
                backgroundColor: t.fn.variant({ variant: "filled", color: e })
                  .background[1],
                color: t.colors.white.value,
                [`& .${s("closeButton")}`]: { color: t.colors.white.value },
              },
              "&.outline": {
                darkMode: {
                  color: t.fn.variant({ variant: "outline", color: e })
                    .color[0],
                  borderColor: t.fn.variant({ variant: "outline", color: e })
                    .border[0],
                },
                color: t.fn.variant({ variant: "outline", color: e }).color[1],
                borderColor: t.fn.variant({ variant: "outline", color: e })
                  .border[1],
              },
            },
            wrapper: { display: "flex" },
            content: { flex: 1 },
            title: {
              boxSizing: "border-box",
              margin: 0,
              marginBottom: 7,
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              lineHeight: t.lineHeights.sm.value,
              fontSize: t.fontSizes.sm.value,
              fontWeight: "$bold",
            },
            label: {
              display: "block",
              overflow: "hidden",
              textOverflow: "ellipsis",
            },
            icon: {
              lineHeight: 1,
              width: 20,
              height: 20,
              display: "flex",
              alignItems: "center",
              justifyContent: "flex-start",
              marginRight: t.space.mdPX.value,
              marginTop: 1,
            },
            message: {
              darkMode: {
                color:
                  "filled" === r || "light" === r
                    ? t.colors.white.value
                    : t.fn.themeColor("dark", 0),
              },
              lineHeight: t.lineHeights.sm.value,
              textOverflow: "ellipsis",
              overflow: "hidden",
              fontSize: t.fontSizes.sm.value,
              color:
                "filled" === r ? t.colors.white.value : t.colors.black.value,
            },
            closeButton: { ref: s("closeButton"), marginTop: 2 },
          })),
          Is = ke((t, { iconSize: e }) => ({
            root: {
              focusRing: "auto",
              position: "relative",
              appearance: "none",
              WebkitAppearance: "none",
              WebkitTapHighlightColor: "transparent",
              boxSizing: "border-box",
              height: `${t.fn.size({ size: e, sizes: t.space })}px`,
              minHeight: `${t.fn.size({ size: e, sizes: t.space })}px`,
              width: `${t.fn.size({ size: e, sizes: t.space })}px`,
              minWidth: `${t.fn.size({ size: e, sizes: t.space })}px`,
              padding: 0,
              lineHeight: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              cursor: "pointer",
              textDecoration: "none",
            },
            icon: {
              height: `${t.fn.size({ size: e, sizes: t.space })}px`,
              minHeight: `${t.fn.size({ size: e, sizes: t.space })}px`,
              position: "static",
              margin: 0,
              ml: 0,
              mr: 0,
              mt: 0,
              mb: 0,
            },
          }));
        function Bs(e) {
          let n,
            r =
              (e[2] instanceof HTMLElement || e[2] instanceof SVGElement) &&
              Ts(e);
          return {
            c() {
              r && r.c(), (n = R());
            },
            m(t, e) {
              r && r.m(t, e), P(t, n, e);
            },
            p(t, e) {
              t[2] instanceof HTMLElement || t[2] instanceof SVGElement
                ? r
                  ? r.p(t, e)
                  : ((r = Ts(t)), r.c(), r.m(n.parentNode, n))
                : r && (r.d(1), (r = null));
            },
            i: t,
            o: t,
            d(t) {
              r && r.d(t), t && I(n);
            },
          };
        }
        function Ns(t) {
          let e, r, s;
          const i = [
            { class: t[6](t[0], t[4].root, t[5]({ css: t[1] })) },
            t[3],
          ];
          var o = t[2];
          function a(t) {
            let e = {};
            for (let t = 0; t < i.length; t += 1) e = n(e, i[t]);
            return { props: e };
          }
          return (
            o && (e = _(o, a())),
            {
              c() {
                e && Nt(e.$$.fragment), (r = R());
              },
              m(t, n) {
                e && Tt(e, t, n), P(t, r, n), (s = !0);
              },
              p(t, n) {
                const s =
                  123 & n
                    ? Pt(i, [
                        115 & n && {
                          class: t[6](t[0], t[4].root, t[5]({ css: t[1] })),
                        },
                        8 & n && It(t[3]),
                      ])
                    : {};
                if (4 & n && o !== (o = t[2])) {
                  if (e) {
                    xt();
                    const t = e;
                    Et(t.$$.fragment, 1, 0, () => {
                      Ot(t, 1);
                    }),
                      $t();
                  }
                  o
                    ? ((e = _(o, a())),
                      Nt(e.$$.fragment),
                      kt(e.$$.fragment, 1),
                      Tt(e, r.parentNode, r))
                    : (e = null);
                } else o && e.$set(s);
              },
              i(t) {
                s || (e && kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                e && Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                t && I(r), e && Ot(e, t);
              },
            }
          );
        }
        function Ts(t) {
          let e,
            n,
            r = t[2].outerHTML + "";
          return {
            c() {
              (e = B("span")),
                z(e, "class", (n = t[6](t[0], t[4].root, t[5]({ css: t[1] }))));
            },
            m(t, n) {
              P(t, e, n), (e.innerHTML = r);
            },
            p(t, s) {
              4 & s && r !== (r = t[2].outerHTML + "") && (e.innerHTML = r),
                115 & s &&
                  n !== (n = t[6](t[0], t[4].root, t[5]({ css: t[1] }))) &&
                  z(e, "class", n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Os(t) {
          let e, n, r, s;
          const i = [Ns, Bs],
            o = [];
          function a(t, e) {
            return "function" == typeof t[2] ? 0 : t[7] ? -1 : 1;
          }
          return (
            ~(e = a(t)) && (n = o[e] = i[e](t)),
            {
              c() {
                n && n.c(), (r = R());
              },
              m(t, n) {
                ~e && o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, [s]) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? ~e && o[e].p(t, s)
                    : (n &&
                        (xt(),
                        Et(o[l], 1, 1, () => {
                          o[l] = null;
                        }),
                        $t()),
                      ~e
                        ? ((n = o[e]),
                          n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                          kt(n, 1),
                          n.m(r.parentNode, r))
                        : (n = null));
              },
              i(t) {
                s || (kt(n), (s = !0));
              },
              o(t) {
                Et(n), (s = !1);
              },
              d(t) {
                ~e && o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Rs(t, e, n) {
          let r,
            s,
            i,
            {
              className: o = "",
              override: a = {},
              icon: l,
              iconSize: c = 16,
              iconProps: u = {},
            } = e;
          const d =
            "undefined" == typeof HTMLElement &&
            "undefined" == typeof SVGElement;
          return (
            (t.$$set = (t) => {
              "className" in t && n(0, (o = t.className)),
                "override" in t && n(1, (a = t.override)),
                "icon" in t && n(2, (l = t.icon)),
                "iconSize" in t && n(8, (c = t.iconSize)),
                "iconProps" in t && n(3, (u = t.iconProps));
            }),
            (t.$$.update = () => {
              256 & t.$$.dirty &&
                n(
                  6,
                  ({
                    cx: r,
                    getStyles: s,
                    classes: i,
                  } = Is({ iconSize: c }, { name: "IconRenderer" })),
                  r,
                  (n(5, s), n(8, c)),
                  (n(4, i), n(8, c))
                ),
                20 & t.$$.dirty &&
                  !d &&
                  (l instanceof HTMLElement || l instanceof SVGElement) &&
                  l.classList.add(...i.icon.split(" "));
            }),
            [o, a, l, u, i, s, r, d, c]
          );
        }
        var Ls = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Rs, Os, a, {
                className: 0,
                override: 1,
                icon: 2,
                iconSize: 8,
                iconProps: 3,
              });
          }
        };
        function zs(t) {
          let e, n;
          return (
            (e = new Ls({
              props: {
                icon: t[5],
                className: t[10].icon,
                iconSize: t[6],
                iconProps: t[7],
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                32 & n && (r.icon = t[5]),
                  1024 & n && (r.className = t[10].icon),
                  64 & n && (r.iconSize = t[6]),
                  128 & n && (r.iconProps = t[7]),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Us(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l = t[8] && Fs(t);
          return {
            c() {
              (e = B("div")),
                (n = B("span")),
                (r = T(t[3])),
                (i = O()),
                l && l.c(),
                z(n, "class", (s = t[10].label)),
                z(e, "class", (o = t[10].title));
            },
            m(t, s) {
              P(t, e, s),
                $(e, n),
                $(n, r),
                $(e, i),
                l && l.m(e, null),
                (a = !0);
            },
            p(t, i) {
              (!a || 8 & i) && H(r, t[3]),
                (!a || (1024 & i && s !== (s = t[10].label))) &&
                  z(n, "class", s),
                t[8]
                  ? l
                    ? (l.p(t, i), 256 & i && kt(l, 1))
                    : ((l = Fs(t)), l.c(), kt(l, 1), l.m(e, null))
                  : l &&
                    (xt(),
                    Et(l, 1, 1, () => {
                      l = null;
                    }),
                    $t()),
                (!a || (1024 & i && o !== (o = t[10].title))) &&
                  z(e, "class", o);
            },
            i(t) {
              a || (kt(l), (a = !0));
            },
            o(t) {
              Et(l), (a = !1);
            },
            d(t) {
              t && I(e), l && l.d();
            },
          };
        }
        function Fs(t) {
          let e, n;
          return (
            (e = new Xr({
              props: {
                class: t[10].closeButton,
                "aria-label": t[9],
                variant: "transparent",
                size: t[6],
                iconSize: t[6],
              },
            })),
            e.$on("click", t[12]),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                1024 & n && (r.class = t[10].closeButton),
                  512 & n && (r["aria-label"] = t[9]),
                  64 & n && (r.size = t[6]),
                  64 & n && (r.iconSize = t[6]),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Ds(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l,
            u,
            p = t[5] && zs(t),
            g = t[3] && Us(t);
          const m = t[17].default,
            y = c(m, t, t[19], null);
          return {
            c() {
              (e = B("div")),
                p && p.c(),
                (n = O()),
                (r = B("div")),
                g && g.c(),
                (s = O()),
                (i = B("div")),
                y && y.c(),
                z(i, "class", (o = t[10].message)),
                z(r, "class", (a = t[10].content)),
                z(e, "class", (l = t[10].wrapper));
            },
            m(t, o) {
              P(t, e, o),
                p && p.m(e, null),
                $(e, n),
                $(e, r),
                g && g.m(r, null),
                $(r, s),
                $(r, i),
                y && y.m(i, null),
                (u = !0);
            },
            p(t, c) {
              t[5]
                ? p
                  ? (p.p(t, c), 32 & c && kt(p, 1))
                  : ((p = zs(t)), p.c(), kt(p, 1), p.m(e, n))
                : p &&
                  (xt(),
                  Et(p, 1, 1, () => {
                    p = null;
                  }),
                  $t()),
                t[3]
                  ? g
                    ? (g.p(t, c), 8 & c && kt(g, 1))
                    : ((g = Us(t)), g.c(), kt(g, 1), g.m(r, s))
                  : g &&
                    (xt(),
                    Et(g, 1, 1, () => {
                      g = null;
                    }),
                    $t()),
                y &&
                  y.p &&
                  (!u || 524288 & c) &&
                  h(y, m, t, t[19], u ? d(m, t[19], c, null) : f(t[19]), null),
                (!u || (1024 & c && o !== (o = t[10].message))) &&
                  z(i, "class", o),
                (!u || (1024 & c && a !== (a = t[10].content))) &&
                  z(r, "class", a),
                (!u || (1024 & c && l !== (l = t[10].wrapper))) &&
                  z(e, "class", l);
            },
            i(t) {
              u || (kt(p), kt(g), kt(y, t), (u = !0));
            },
            o(t) {
              Et(p), Et(g), Et(y, t), (u = !1);
            },
            d(t) {
              t && I(e), p && p.d(), g && g.d(), y && y.d(t);
            },
          };
        }
        function Ms(t) {
          let e, r, s;
          const i = [
            { use: t[1] },
            { role: "alert" },
            { class: t[11](t[2], t[4], t[10].root) },
            t[13],
          ];
          function o(e) {
            t[18](e);
          }
          let a = { $$slots: { default: [Ds] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  11286 & n
                    ? Pt(i, [
                        2 & n && { use: t[1] },
                        i[1],
                        3092 & n && { class: t[11](t[2], t[4], t[10].root) },
                        8192 & n && It(t[13]),
                      ])
                    : {};
                526312 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function js(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "override",
            "title",
            "color",
            "radius",
            "variant",
            "icon",
            "iconSize",
            "iconProps",
            "withCloseButton",
            "closeButtonLabel",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e,
            {
              use: u = [],
              element: d,
              class: h = "blue",
              override: f = {},
              title: m,
              color: y = "red",
              radius: b = "sm",
              variant: w = "light",
              icon: v,
              iconSize: A = 16,
              iconProps: x = {},
              withCloseButton: $ = !1,
              closeButtonLabel: k,
            } = e;
          const E = rt();
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(13, (a = g(e, o))),
                "use" in t && r(1, (u = t.use)),
                "element" in t && r(0, (d = t.element)),
                "class" in t && r(2, (h = t.class)),
                "override" in t && r(14, (f = t.override)),
                "title" in t && r(3, (m = t.title)),
                "color" in t && r(15, (y = t.color)),
                "radius" in t && r(16, (b = t.radius)),
                "variant" in t && r(4, (w = t.variant)),
                "icon" in t && r(5, (v = t.icon)),
                "iconSize" in t && r(6, (A = t.iconSize)),
                "iconProps" in t && r(7, (x = t.iconProps)),
                "withCloseButton" in t && r(8, ($ = t.withCloseButton)),
                "closeButtonLabel" in t && r(9, (k = t.closeButtonLabel)),
                "$$scope" in t && r(19, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              114704 & t.$$.dirty &&
                r(
                  11,
                  ({ cx: s, classes: i } = Ps(
                    { color: y, radius: b, variant: w },
                    { name: "Alert", override: f }
                  )),
                  s,
                  (r(10, i), r(15, y), r(16, b), r(4, w), r(14, f))
                );
            }),
            [
              d,
              u,
              h,
              m,
              w,
              v,
              A,
              x,
              $,
              k,
              i,
              s,
              function () {
                E("close");
              },
              a,
              f,
              y,
              b,
              l,
              function (t) {
                (d = t), r(0, d);
              },
              c,
            ]
          );
        }
        var Hs = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, js, Ms, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 14,
                title: 3,
                color: 15,
                radius: 16,
                variant: 4,
                icon: 5,
                iconSize: 6,
                iconProps: 7,
                withCloseButton: 8,
                closeButtonLabel: 9,
              });
          }
        };
        function Gs(t, e, n, r, s = !1) {
          return "dimmed" === e
            ? s
              ? t.fn.themeColor("dark", 2)
              : t.fn.themeColor("gray", 6)
            : "gradient" === n || r
            ? t.fn.themeColor(e, 6)
            : "link" === n
            ? s
              ? t.fn.themeColor("blue", 4)
              : t.fn.themeColor("blue", 7)
            : "text" === n
            ? s
              ? t.fn.themeColor(e, 5)
              : t.fn.themeColor(e, 7)
            : void 0;
        }
        var Vs = ke(
          (
            t,
            {
              align: e,
              color: n,
              inherit: r,
              inline: s,
              lineClamp: i,
              size: o,
              tracking: a,
              transform: l,
              underline: c,
              weight: u,
              gradient: d,
              variant: h,
            }
          ) => ({
            root: {
              focusRing: "auto",
              [`${t.dark} &`]: {
                color: "dark" === n ? "$dark50" : Gs(t, n, h, d, !0),
              },
              fontFamily: r ? "inherit" : "$standard",
              fontSize: r
                ? "inherit"
                : "string" == typeof o
                ? `$${o}`
                : `${o}px`,
              fontWeight: r ? "inherit" : `$${u}`,
              letterSpacing: t.letterSpacings[a]?.value,
              lineHeight: r
                ? "inherit"
                : s
                ? 1
                : "string" == typeof o
                ? `$${o}`
                : `${o}px`,
              textTransform: l,
              textDecoration: c ? "underline" : "none",
              textAlign: e,
              cursor: "link" === h ? "pointer" : "inherit",
              color: "green" === n ? "Black" : Gs(t, n, h, d),
              backgroundImage:
                "gradient" === h
                  ? `linear-gradient(${d?.deg}deg, $${d?.from}600 0%, $${d?.to}600 100%)`
                  : null,
              WebkitBackgroundClip: "gradient" === h ? "text" : null,
              WebkitTextFillColor: "gradient" === h ? "transparent" : null,
              ...(void 0 !== i
                ? {
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    display: "-webkit-box",
                    WebkitLineClamp: i,
                    WebkitBoxOrient: "vertical",
                  }
                : {}),
              "&:hover":
                "link" === h && !0 === c
                  ? { textDecoration: "underline" }
                  : void 0,
            },
          })
        );
        const Qs = Object.freeze([
          {
            error: !0,
            message:
              "If using the 'gradient' prop, set 'variant' prop to 'gradient' to apply the gradient",
            solution:
              "\n                If your component looks like this:\n\n                &lt;Text gradient={{from: 'blue', to: 'red', deg: 45}}&gt;Text string &lt;/Text&gt;\n                                                                    ^^^ - Try adding prop variant='gradient'\n                ",
          },
          {
            error: !0,
            message:
              "If using the 'link' variant, an href needs to be set and the root must be an anchor",
            solution:
              "\n                If your component looks like this:\n\n                &lt;Text variant='link'&gt;Text string &lt;/Text&gt;\n                                    ^^^ - Try adding props href && root={'a'}'\n                ",
          },
        ]);
        function Ws(t) {
          let e;
          const n = t[25].default,
            r = c(n, t, t[27], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 134217728 & s) &&
                h(r, n, t, t[27], e ? d(n, t[27], s, null) : f(t[27]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Js(t) {
          let e, r, s, i, o;
          e = new Dt({
            props: { observable: t[6], component: "Text", code: t[7] },
          });
          const a = [
            { root: t[4] },
            { use: [t[11], [Vt, t[1]]] },
            { class: t[10](t[2], t[9].root, t[8]({ css: t[3] })) },
            { href: t[5] ?? void 0 },
            t[12],
          ];
          function l(e) {
            t[26](e);
          }
          let c = { $$slots: { default: [Ws] }, $$scope: { ctx: t } };
          for (let t = 0; t < a.length; t += 1) c = n(c, a[t]);
          return (
            void 0 !== t[0] && (c.element = t[0]),
            (s = new Mn({ props: c })),
            it.push(() => Bt(s, "element", l)),
            {
              c() {
                Nt(e.$$.fragment), (r = O()), Nt(s.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), P(t, r, n), Tt(s, t, n), (o = !0);
              },
              p(t, [n]) {
                const r = {};
                64 & n && (r.observable = t[6]),
                  128 & n && (r.code = t[7]),
                  e.$set(r);
                const o =
                  7998 & n
                    ? Pt(a, [
                        16 & n && { root: t[4] },
                        2050 & n && { use: [t[11], [Vt, t[1]]] },
                        1804 & n && {
                          class: t[10](t[2], t[9].root, t[8]({ css: t[3] })),
                        },
                        32 & n && { href: t[5] ?? void 0 },
                        4096 & n && It(t[12]),
                      ])
                    : {};
                134217728 & n && (o.$$scope = { dirty: n, ctx: t }),
                  !i &&
                    1 & n &&
                    ((i = !0), (o.element = t[0]), ft(() => (i = !1))),
                  s.$set(o);
              },
              i(t) {
                o || (kt(e.$$.fragment, t), kt(s.$$.fragment, t), (o = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), Et(s.$$.fragment, t), (o = !1);
              },
              d(t) {
                Ot(e, t), t && I(r), Ot(s, t);
              },
            }
          );
        }
        function _s(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "align",
            "color",
            "root",
            "transform",
            "variant",
            "size",
            "weight",
            "gradient",
            "inline",
            "lineClamp",
            "underline",
            "inherit",
            "href",
            "tracking",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              align: y = "left",
              color: b = "dark",
              root: w,
              transform: v = "none",
              variant: A = "text",
              size: x = "md",
              weight: $ = "normal",
              gradient: k = { from: "indigo", to: "cyan", deg: 45 },
              inline: E = !0,
              lineClamp: C,
              underline: S = !1,
              inherit: P = !1,
              href: I = "",
              tracking: B = "normal",
            } = e;
          const N = Jt(et());
          let T,
            O = !1;
          return (
            "indigo" === k.from &&
              "cyan0" === k.to &&
              45 === k.deg &&
              "gradient" !== A &&
              ((O = !0), (T = Qs[0])),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(12, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "align" in t && r(13, (y = t.align)),
                "color" in t && r(14, (b = t.color)),
                "root" in t && r(4, (w = t.root)),
                "transform" in t && r(15, (v = t.transform)),
                "variant" in t && r(16, (A = t.variant)),
                "size" in t && r(17, (x = t.size)),
                "weight" in t && r(18, ($ = t.weight)),
                "gradient" in t && r(19, (k = t.gradient)),
                "inline" in t && r(20, (E = t.inline)),
                "lineClamp" in t && r(21, (C = t.lineClamp)),
                "underline" in t && r(22, (S = t.underline)),
                "inherit" in t && r(23, (P = t.inherit)),
                "href" in t && r(5, (I = t.href)),
                "tracking" in t && r(24, (B = t.tracking)),
                "$$scope" in t && r(27, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              33546240 & t.$$.dirty &&
                r(
                  10,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = Vs(
                    {
                      lineClamp: C,
                      underline: S,
                      inline: E,
                      inherit: P,
                      gradient: k,
                      variant: A,
                      align: y,
                      color: b,
                      transform: v,
                      size: x,
                      weight: $,
                      tracking: B,
                    },
                    { name: "Text" }
                  )),
                  s,
                  (r(9, i),
                  r(21, C),
                  r(22, S),
                  r(20, E),
                  r(23, P),
                  r(19, k),
                  r(16, A),
                  r(13, y),
                  r(14, b),
                  r(15, v),
                  r(17, x),
                  r(18, $),
                  r(24, B)),
                  (r(8, o),
                  r(21, C),
                  r(22, S),
                  r(20, E),
                  r(23, P),
                  r(19, k),
                  r(16, A),
                  r(13, y),
                  r(14, b),
                  r(15, v),
                  r(17, x),
                  r(18, $),
                  r(24, B))
                );
            }),
            [
              h,
              d,
              f,
              m,
              w,
              I,
              O,
              T,
              o,
              i,
              s,
              N,
              l,
              y,
              b,
              v,
              A,
              x,
              $,
              k,
              E,
              C,
              S,
              P,
              B,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Ks = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, _s, Js, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                align: 13,
                color: 14,
                root: 4,
                transform: 15,
                variant: 16,
                size: 17,
                weight: 18,
                gradient: 19,
                inline: 20,
                lineClamp: 21,
                underline: 22,
                inherit: 23,
                href: 5,
                tracking: 24,
              });
          }
        };
        const qs = {
            xs: { fontSize: 9, height: 16 },
            sm: { fontSize: 10, height: 18 },
            md: { fontSize: 11, height: 20 },
            lg: { fontSize: 13, height: 26 },
            xl: { fontSize: 16, height: 32 },
          },
          Ys = { xs: 4, sm: 4, md: 6, lg: 8, xl: 10 };
        var Zs = ke(
          (
            t,
            {
              fullWidth: e,
              radius: n,
              size: r,
              color: s,
              gradientDeg: i,
              gradientFrom: o,
              gradientTo: a,
            }
          ) => {
            const l = t.fn.size({ size: r, sizes: Ys }),
              c = t.fn.variant({ color: s, variant: "light" }),
              u = t.fn.variant({ color: s, variant: "filled" }),
              d = t.fn.variant({ color: s, variant: "outline" }),
              h = t.fn.variant({
                variant: "gradient",
                gradient: { from: o, to: a, deg: i },
              }),
              { fontSize: f, height: p } = r in qs ? qs[r] : qs.md;
            return {
              root: {
                focusRing: "auto",
                fontSize: f,
                height: p,
                WebkitTapHighlightColor: "transparent",
                lineHeight: p - 2 + "px",
                textDecoration: "none",
                padding: `0 ${t.fn.size({ size: r, sizes: t.space }) / 1.5}px`,
                boxSizing: "border-box",
                display: e ? "flex" : "inline-flex",
                alignItems: "center",
                justifyContent: "center",
                width: e ? "100%" : "auto",
                textTransform: "uppercase",
                borderRadius: t.fn.radius(n),
                fontWeight: 700,
                letterSpacing: 0.25,
                cursor: "default",
                textOverflow: "ellipsis",
                overflow: "hidden",
                "&.light": {
                  [`${t.dark} &`]: {
                    backgroundColor: c.background[0],
                    color: c.color[0],
                  },
                  backgroundColor: c.background[1],
                  color: c.color[1],
                  border: "1px solid transparent",
                },
                "&.filled": {
                  [`${t.dark} &`]: { backgroundColor: u.background[0] },
                  backgroundColor: u.background[1],
                  color: u.color,
                  border: "1px solid transparent",
                },
                "&.outline": {
                  [`${t.dark} &`]: {
                    color: d.color[0],
                    border: `1px solid ${d.border[0]}`,
                  },
                  backgroundColor: d.background,
                  color: d.color[1],
                  border: `1px solid ${d.border[1]}`,
                },
                "&.gradient": {
                  backgroundImage: h.background,
                  color: h.color,
                  border: 0,
                },
                "&.dot": {
                  darkMode: {
                    color: t.fn.themeColor("dark", 0),
                    border: `1px solid ${t.fn.themeColor("dark", 3)}`,
                    "&::before": { backgroundColor: t.fn.themeColor(s, 4) },
                  },
                  backgroundColor: "transparent",
                  color: t.fn.themeColor("gray", 7),
                  border: `1px solid ${t.fn.themeColor("gray", 3)}`,
                  paddingLeft:
                    t.fn.size({ size: r, sizes: t.space }) / 1.5 - l / 2,
                  "&::before": {
                    content: '""',
                    display: "block",
                    width: l,
                    height: l,
                    borderRadius: l,
                    backgroundColor: t.fn.themeColor(s, 6),
                    marginRight: l,
                  },
                },
              },
              leftSection: { marginRight: parseInt(t.space.xs.value) / 2 },
              rightSection: { marginLeft: parseInt(t.space.xs.value) / 2 },
              inner: {
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
              },
            };
          }
        );
        const Xs = (t) => ({}),
          ti = (t) => ({}),
          ei = (t) => ({}),
          ni = (t) => ({});
        function ri(t) {
          let e, n, r;
          const s = t[15].leftSection,
            i = c(s, t, t[17], ni);
          return {
            c() {
              (e = B("span")),
                i && i.c(),
                z(e, "class", (n = t[4].leftSection));
            },
            m(t, n) {
              P(t, e, n), i && i.m(e, null), (r = !0);
            },
            p(t, o) {
              i &&
                i.p &&
                (!r || 131072 & o) &&
                h(i, s, t, t[17], r ? d(s, t[17], o, ei) : f(t[17]), ni),
                (!r || (16 & o && n !== (n = t[4].leftSection))) &&
                  z(e, "class", n);
            },
            i(t) {
              r || (kt(i, t), (r = !0));
            },
            o(t) {
              Et(i, t), (r = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function si(t) {
          let e, n, r;
          const s = t[15].rightSection,
            i = c(s, t, t[17], ti);
          return {
            c() {
              (e = B("span")),
                i && i.c(),
                z(e, "class", (n = t[4].rightSection));
            },
            m(t, n) {
              P(t, e, n), i && i.m(e, null), (r = !0);
            },
            p(t, o) {
              i &&
                i.p &&
                (!r || 131072 & o) &&
                h(i, s, t, t[17], r ? d(s, t[17], o, Xs) : f(t[17]), ti),
                (!r || (16 & o && n !== (n = t[4].rightSection))) &&
                  z(e, "class", n);
            },
            i(t) {
              r || (kt(i, t), (r = !0));
            },
            o(t) {
              Et(i, t), (r = !1);
            },
            d(t) {
              t && I(e), i && i.d(t);
            },
          };
        }
        function ii(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a = t[8].leftSection && ri(t);
          const l = t[15].default,
            u = c(l, t, t[17], null);
          let p = t[8].rightSection && si(t);
          return {
            c() {
              a && a.c(),
                (e = O()),
                (n = B("span")),
                u && u.c(),
                (s = O()),
                p && p.c(),
                (i = R()),
                z(n, "class", (r = t[4].inner));
            },
            m(t, r) {
              a && a.m(t, r),
                P(t, e, r),
                P(t, n, r),
                u && u.m(n, null),
                P(t, s, r),
                p && p.m(t, r),
                P(t, i, r),
                (o = !0);
            },
            p(t, s) {
              t[8].leftSection
                ? a
                  ? (a.p(t, s), 256 & s && kt(a, 1))
                  : ((a = ri(t)), a.c(), kt(a, 1), a.m(e.parentNode, e))
                : a &&
                  (xt(),
                  Et(a, 1, 1, () => {
                    a = null;
                  }),
                  $t()),
                u &&
                  u.p &&
                  (!o || 131072 & s) &&
                  h(u, l, t, t[17], o ? d(l, t[17], s, null) : f(t[17]), null),
                (!o || (16 & s && r !== (r = t[4].inner))) && z(n, "class", r),
                t[8].rightSection
                  ? p
                    ? (p.p(t, s), 256 & s && kt(p, 1))
                    : ((p = si(t)), p.c(), kt(p, 1), p.m(i.parentNode, i))
                  : p &&
                    (xt(),
                    Et(p, 1, 1, () => {
                      p = null;
                    }),
                    $t());
            },
            i(t) {
              o || (kt(a), kt(u, t), kt(p), (o = !0));
            },
            o(t) {
              Et(a), Et(u, t), Et(p), (o = !1);
            },
            d(t) {
              a && a.d(t),
                t && I(e),
                t && I(n),
                u && u.d(t),
                t && I(s),
                p && p.d(t),
                t && I(i);
            },
          };
        }
        function oi(t) {
          let e, r, s;
          const i = [
            { use: [t[6], [Vt, t[1]]] },
            { class: t[5](t[2], t[3], t[4].root) },
            t[7],
          ];
          function o(e) {
            t[16](e);
          }
          let a = { $$slots: { default: [ii] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Pt(i, [
                        66 & n && { use: [t[6], [Vt, t[1]]] },
                        60 & n && { class: t[5](t[2], t[3], t[4].root) },
                        128 & n && It(t[7]),
                      ])
                    : {};
                131344 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function ai(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "override",
            "color",
            "variant",
            "gradient",
            "size",
            "radius",
            "fullWidth",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e;
          const u = m(l);
          let {
            use: d = [],
            element: h,
            class: f = "",
            override: y = {},
            color: b = "blue",
            variant: w = "light",
            gradient: v = { from: "blue", to: "cyan", deg: 45 },
            size: A = "md",
            radius: x = "xl",
            fullWidth: $ = !1,
          } = e;
          const k = Jt(et());
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (a = g(e, o))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(9, (y = t.override)),
                "color" in t && r(10, (b = t.color)),
                "variant" in t && r(3, (w = t.variant)),
                "gradient" in t && r(11, (v = t.gradient)),
                "size" in t && r(12, (A = t.size)),
                "radius" in t && r(13, (x = t.radius)),
                "fullWidth" in t && r(14, ($ = t.fullWidth)),
                "$$scope" in t && r(17, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              32256 & t.$$.dirty &&
                r(
                  5,
                  ({ cx: s, classes: i } = Zs(
                    {
                      color: b,
                      fullWidth: $,
                      size: A,
                      radius: x,
                      gradientDeg: v.deg,
                      gradientFrom: v.from,
                      gradientTo: v.to,
                    },
                    { override: y, name: "Badge" }
                  )),
                  s,
                  (r(4, i),
                  r(10, b),
                  r(14, $),
                  r(12, A),
                  r(13, x),
                  r(11, v),
                  r(9, y))
                );
            }),
            [
              h,
              d,
              f,
              w,
              i,
              s,
              k,
              a,
              u,
              y,
              b,
              v,
              A,
              x,
              $,
              l,
              function (t) {
                (h = t), r(0, h);
              },
              c,
            ]
          );
        }
        var li = class extends Lt {
            constructor(t) {
              super(),
                Rt(this, t, ai, oi, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 9,
                  color: 10,
                  variant: 3,
                  gradient: 11,
                  size: 12,
                  radius: 13,
                  fullWidth: 14,
                });
            }
          },
          ci = ke((t) => ({
            root: {
              position: "relative",
              overflow: "hidden",
              backgroundColor: t.colors.white.value,
            },
          })),
          ui = ke((t, { radius: e, shadow: n, withBorder: r, padding: s }) => ({
            root: {
              darkMode: {
                backgroundColor: t.fn.themeColor("dark", 7),
                color: t.fn.themeColor("dark"),
              },
              padding: t.fn.size({ size: s, sizes: t.space }),
              outline: 0,
              display: "block",
              textDecoration: "none",
              color: t.colors.black.value,
              backgroundColor: t.colors.white.value,
              boxSizing: "border-box",
              borderRadius: `$${e}`,
              WebkitTapHighlightColor: "transparent",
              boxShadow: t.shadows[n].value || n || "none",
              border: void 0,
            },
            withBorder: {
              darkMode: { border: `1px solid ${t.fn.themeColor("dark", 4)}` },
              border: `1px solid ${t.fn.themeColor("gray", 3)}`,
            },
          }));
        function di(t) {
          let e;
          const n = t[12].default,
            r = c(n, t, t[14], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 16384 & s) &&
                h(r, n, t, t[14], e ? d(n, t[14], s, null) : f(t[14]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function hi(t) {
          let e, r, s;
          const i = [
            {
              class: t[7](
                t[6].root,
                t[2],
                t[4] && t[6].withBorder,
                t[5]({ css: t[3] })
              ),
            },
            { use: t[1] },
            t[8],
          ];
          function o(e) {
            t[13](e);
          }
          let a = { $$slots: { default: [di] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  510 & n
                    ? Pt(i, [
                        252 & n && {
                          class: t[7](
                            t[6].root,
                            t[2],
                            t[4] && t[6].withBorder,
                            t[5]({ css: t[3] })
                          ),
                        },
                        2 & n && { use: t[1] },
                        256 & n && It(t[8]),
                      ])
                    : {};
                16384 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function fi(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "shadow",
            "radius",
            "withBorder",
            "padding",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              shadow: y = "xs",
              radius: b = "sm",
              withBorder: w = !1,
              padding: v = "md",
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(8, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "shadow" in t && r(9, (y = t.shadow)),
                "radius" in t && r(10, (b = t.radius)),
                "withBorder" in t && r(4, (w = t.withBorder)),
                "padding" in t && r(11, (v = t.padding)),
                "$$scope" in t && r(14, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              3600 & t.$$.dirty &&
                r(
                  7,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = ui(
                    { radius: b, shadow: y, withBorder: w, padding: v },
                    { name: "Paper" }
                  )),
                  s,
                  (r(6, i), r(10, b), r(9, y), r(4, w), r(11, v)),
                  (r(5, o), r(10, b), r(9, y), r(4, w), r(11, v))
                );
            }),
            [
              h,
              d,
              f,
              m,
              w,
              o,
              i,
              s,
              l,
              y,
              b,
              v,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var pi = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, fi, hi, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                shadow: 9,
                radius: 10,
                withBorder: 4,
                padding: 11,
              });
          }
        };
        function gi(t) {
          let e;
          const n = t[9].default,
            r = c(n, t, t[11], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2048 & s) &&
                h(r, n, t, t[11], e ? d(n, t[11], s, null) : f(t[11]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function mi(t) {
          let e, r, s;
          const i = [
            { class: t[7](t[2], t[6].root) },
            {
              override: {
                [`${t[5].dark} &`]: {
                  backgroundColor: t[5].fn.themeColor("dark", 6),
                },
                ...t[3],
              },
            },
            { padding: t[4] },
            { use: t[1] },
            t[8],
          ];
          function o(e) {
            t[10](e);
          }
          let a = { $$slots: { default: [gi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new pi({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  510 & n
                    ? Pt(i, [
                        196 & n && { class: t[7](t[2], t[6].root) },
                        40 & n && {
                          override: {
                            [`${t[5].dark} &`]: {
                              backgroundColor: t[5].fn.themeColor("dark", 6),
                            },
                            ...t[3],
                          },
                        },
                        16 & n && { padding: t[4] },
                        2 & n && { use: t[1] },
                        256 & n && It(t[8]),
                      ])
                    : {};
                2048 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function yi(t, e, r) {
          let s, i, o;
          const a = ["use", "element", "class", "override", "padding"];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              padding: y = "md",
            } = e;
          return (
            nt(() => {
              const t = h.children.length,
                e = h.children[0],
                n = h.children[t - 1];
              "svelteui_card_section" === e?.id &&
                (e.style.marginTop =
                  -1 * o.fn.size({ size: y, sizes: o.space }) + "px"),
                "svelteui_card_section" === n?.id &&
                  (n.style.marginBottom =
                    -1 * o.fn.size({ size: y, sizes: o.space }) + "px");
            }),
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(8, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "padding" in t && r(4, (y = t.padding)),
                "$$scope" in t && r(11, (u = t.$$scope));
            }),
            r(
              7,
              ({ cx: s, classes: i, theme: o } = ci(null, { name: "Card" })),
              s,
              r(6, i),
              r(5, o)
            ),
            [
              h,
              d,
              f,
              m,
              y,
              o,
              i,
              s,
              l,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var bi = class extends Lt {
            constructor(t) {
              super(),
                Rt(this, t, yi, mi, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 3,
                  padding: 4,
                });
            }
          },
          wi = ke((t, { padding: e }) => ({
            root: {
              display: "block",
              marginLeft: -1 * t.fn.size({ size: e, sizes: t.space }),
              marginRight: -1 * t.fn.size({ size: e, sizes: t.space }),
            },
          }));
        function vi(t) {
          let e;
          const n = t[9].default,
            r = c(n, t, t[11], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2048 & s) &&
                h(r, n, t, t[11], e ? d(n, t[11], s, null) : f(t[11]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Ai(t) {
          let e, r, s;
          const i = [
            { id: "svelteui_card_section" },
            { class: t[6](t[2], t[5].root, t[4]({ css: t[3] })) },
            { use: t[1] },
            t[7],
          ];
          function o(e) {
            t[10](e);
          }
          let a = { $$slots: { default: [vi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Pt(i, [
                        i[0],
                        124 & n && {
                          class: t[6](t[2], t[5].root, t[4]({ css: t[3] })),
                        },
                        2 & n && { use: t[1] },
                        128 & n && It(t[7]),
                      ])
                    : {};
                2048 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function xi(t, e, r) {
          let s, i, o;
          const a = ["use", "element", "class", "override", "padding"];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              padding: y = "md",
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "padding" in t && r(8, (y = t.padding)),
                "$$scope" in t && r(11, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              256 & t.$$.dirty &&
                r(
                  6,
                  ({ cx: s, classes: i, getStyles: o } = wi({ padding: y })),
                  s,
                  (r(5, i), r(8, y)),
                  (r(4, o), r(8, y))
                );
            }),
            [
              h,
              d,
              f,
              m,
              o,
              i,
              s,
              l,
              y,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var $i = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, xi, Ai, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                padding: 8,
              });
          }
        };
        bi.Section = $i;
        const ki = bi;
        var Ei = ke((t, { inline: e }) => ({
          root: {
            display: e ? "inline-flex" : "flex",
            alignItems: "center",
            justifyContent: "center",
          },
        }));
        function Ci(t) {
          let e;
          const n = t[9].default,
            r = c(n, t, t[11], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 2048 & s) &&
                h(r, n, t, t[11], e ? d(n, t[11], s, null) : f(t[11]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Si(t) {
          let e, r, s;
          const i = [
            { use: t[1] },
            { class: t[6](t[2], t[5].root, t[4]({ css: t[3] })) },
            t[7],
          ];
          function o(e) {
            t[10](e);
          }
          let a = { $$slots: { default: [Ci] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Pt(i, [
                        2 & n && { use: t[1] },
                        124 & n && {
                          class: t[6](t[2], t[5].root, t[4]({ css: t[3] })),
                        },
                        128 & n && It(t[7]),
                      ])
                    : {};
                2048 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Pi(t, e, r) {
          let s, i, o;
          const a = ["use", "element", "class", "override", "inline"];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              inline: y = !1,
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "inline" in t && r(8, (y = t.inline)),
                "$$scope" in t && r(11, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              256 & t.$$.dirty &&
                r(
                  6,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = Ei({ inline: y }, { name: "Center" })),
                  s,
                  (r(5, i), r(8, y)),
                  (r(4, o), r(8, y))
                );
            }),
            [
              h,
              d,
              f,
              m,
              o,
              i,
              s,
              l,
              y,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Ii = class extends Lt {
            constructor(t) {
              super(),
                Rt(this, t, Pi, Si, a, {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 3,
                  inline: 8,
                });
            }
          },
          Bi = ke((t, { fluid: e, size: n, sizes: r }) => ({
            root: {
              paddingLeft: t.fn.size({ size: n, sizes: t.space }),
              paddingRight: t.fn.size({ size: n, sizes: t.space }),
              maxWidth: e
                ? "100%"
                : "number" == typeof n
                ? `${n}px`
                : r[n] ?? r.md,
              marginLeft: "auto",
              marginRight: "auto",
            },
          }));
        function Ni(t) {
          let e;
          const n = t[11].default,
            r = c(n, t, t[13], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 8192 & s) &&
                h(r, n, t, t[13], e ? d(n, t[13], s, null) : f(t[13]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Ti(t) {
          let e, r, s;
          const i = [
            { use: t[1] },
            { class: t[6](t[2], t[5].root, t[4]({ css: t[3] })) },
            t[7],
          ];
          function o(e) {
            t[12](e);
          }
          let a = { $$slots: { default: [Ni] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, [n]) {
                const s =
                  254 & n
                    ? Pt(i, [
                        2 & n && { use: t[1] },
                        124 & n && {
                          class: t[6](t[2], t[5].root, t[4]({ css: t[3] })),
                        },
                        128 & n && It(t[7]),
                      ])
                    : {};
                8192 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Oi(t, e, r) {
          let s, i, o;
          const a = [
            "use",
            "element",
            "class",
            "override",
            "size",
            "fluid",
            "sizes",
          ];
          let l = g(e, a),
            { $$slots: c = {}, $$scope: u } = e,
            {
              use: d = [],
              element: h,
              class: f = "",
              override: m = {},
              size: y = "md",
              fluid: b = !1,
              sizes: w = { xs: 540, sm: 720, md: 960, lg: 1140, xl: 1320 },
            } = e;
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(7, (l = g(e, a))),
                "use" in t && r(1, (d = t.use)),
                "element" in t && r(0, (h = t.element)),
                "class" in t && r(2, (f = t.class)),
                "override" in t && r(3, (m = t.override)),
                "size" in t && r(8, (y = t.size)),
                "fluid" in t && r(9, (b = t.fluid)),
                "sizes" in t && r(10, (w = t.sizes)),
                "$$scope" in t && r(13, (u = t.$$scope));
            }),
            (t.$$.update = () => {
              1792 & t.$$.dirty &&
                r(
                  6,
                  ({
                    cx: s,
                    classes: i,
                    getStyles: o,
                  } = Bi(
                    { fluid: b, size: y, sizes: w },
                    { name: "Container" }
                  )),
                  s,
                  (r(5, i), r(9, b), r(8, y), r(10, w)),
                  (r(4, o), r(9, b), r(8, y), r(10, w))
                );
            }),
            [
              h,
              d,
              f,
              m,
              o,
              i,
              s,
              l,
              y,
              b,
              w,
              c,
              function (t) {
                (h = t), r(0, h);
              },
              u,
            ]
          );
        }
        var Ri = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Oi, Ti, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                size: 8,
                fluid: 9,
                sizes: 10,
              });
          }
        };
        const Li = { app: 100, modal: 200, popover: 300, overlay: 400 };
        function zi(t) {
          return Li[t];
        }
        function Ui(t) {
          let e, r, s;
          const i = [
            { use: [t[10], [Vt, t[1]]] },
            {
              css: {
                ...t[9],
                ...t[8],
                opacity: t[4],
                borderRadius: `${t[6]}`,
                ...t[3],
              },
            },
            t[11],
            { class: t[2] },
          ];
          function o(e) {
            t[17](e);
          }
          let a = { $$slots: { default: [Hi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  3934 & n
                    ? Pt(i, [
                        1026 & n && { use: [t[10], [Vt, t[1]]] },
                        856 & n && {
                          css: {
                            ...t[9],
                            ...t[8],
                            opacity: t[4],
                            borderRadius: `${t[6]}`,
                            ...t[3],
                          },
                        },
                        2048 & n && It(t[11]),
                        4 & n && { class: t[2] },
                      ])
                    : {};
                262272 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Fi(t) {
          let e, r, s;
          const i = [
            { use: [t[10], [Vt, t[1]]] },
            { css: { ...t[8], backdropFilter: `blur(${t[5]}px)` } },
            { class: t[2] },
            t[11],
          ];
          function o(e) {
            t[16](e);
          }
          let a = { $$slots: { default: [Gi] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  3366 & n
                    ? Pt(i, [
                        1026 & n && { use: [t[10], [Vt, t[1]]] },
                        288 & n && {
                          css: { ...t[8], backdropFilter: `blur(${t[5]}px)` },
                        },
                        4 & n && { class: t[2] },
                        2048 & n && It(t[11]),
                      ])
                    : {};
                263e3 & n && (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Di(t) {
          let e;
          const n = t[15].default,
            r = c(n, t, t[18], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 262144 & s) &&
                h(r, n, t, t[18], e ? d(n, t[18], s, null) : f(t[18]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Mi(t) {
          let e, n;
          return (
            (e = new Ii({
              props: { $$slots: { default: [ji] }, $$scope: { ctx: t } },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                262144 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function ji(t) {
          let e;
          const n = t[15].default,
            r = c(n, t, t[18], null);
          return {
            c() {
              r && r.c();
            },
            m(t, n) {
              r && r.m(t, n), (e = !0);
            },
            p(t, s) {
              r &&
                r.p &&
                (!e || 262144 & s) &&
                h(r, n, t, t[18], e ? d(n, t[18], s, null) : f(t[18]), null);
            },
            i(t) {
              e || (kt(r, t), (e = !0));
            },
            o(t) {
              Et(r, t), (e = !1);
            },
            d(t) {
              r && r.d(t);
            },
          };
        }
        function Hi(t) {
          let e, n, r, s;
          const i = [Mi, Di],
            o = [];
          function a(t, e) {
            return t[7] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, s) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (xt(),
                      Et(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      $t(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      kt(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (kt(n), (s = !0));
              },
              o(t) {
                Et(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Gi(t) {
          let e, n;
          return (
            (e = new Mn({
              props: {
                css: {
                  ...t[9],
                  ...t[8],
                  opacity: t[4],
                  borderRadius: `${t[6]}`,
                  ...t[3],
                },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                856 & n &&
                  (r.css = {
                    ...t[9],
                    ...t[8],
                    opacity: t[4],
                    borderRadius: `${t[6]}`,
                    ...t[3],
                  }),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Vi(t) {
          let e, n, r, s;
          const i = [Fi, Ui],
            o = [];
          function a(t, e) {
            return t[5] ? 0 : 1;
          }
          return (
            (e = a(t)),
            (n = o[e] = i[e](t)),
            {
              c() {
                n.c(), (r = R());
              },
              m(t, n) {
                o[e].m(t, n), P(t, r, n), (s = !0);
              },
              p(t, [s]) {
                let l = e;
                (e = a(t)),
                  e === l
                    ? o[e].p(t, s)
                    : (xt(),
                      Et(o[l], 1, 1, () => {
                        o[l] = null;
                      }),
                      $t(),
                      (n = o[e]),
                      n ? n.p(t, s) : ((n = o[e] = i[e](t)), n.c()),
                      kt(n, 1),
                      n.m(r.parentNode, r));
              },
              i(t) {
                s || (kt(n), (s = !0));
              },
              o(t) {
                Et(n), (s = !1);
              },
              d(t) {
                o[e].d(t), t && I(r);
              },
            }
          );
        }
        function Qi(t, e, r) {
          let s, i;
          const o = [
            "use",
            "element",
            "class",
            "override",
            "opacity",
            "color",
            "blur",
            "gradient",
            "zIndex",
            "radius",
            "center",
          ];
          let a = g(e, o),
            { $$slots: l = {}, $$scope: c } = e,
            {
              use: u = [],
              element: d,
              class: h = "",
              override: f = {},
              opacity: m = 0.6,
              color: y = "#fff",
              blur: b = 0,
              gradient: w = "",
              zIndex: v = zi("modal"),
              radius: A = 0,
              center: x = !1,
            } = e;
          const $ = Jt(et());
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(11, (a = g(e, o))),
                "use" in t && r(1, (u = t.use)),
                "element" in t && r(0, (d = t.element)),
                "class" in t && r(2, (h = t.class)),
                "override" in t && r(3, (f = t.override)),
                "opacity" in t && r(4, (m = t.opacity)),
                "color" in t && r(12, (y = t.color)),
                "blur" in t && r(5, (b = t.blur)),
                "gradient" in t && r(13, (w = t.gradient)),
                "zIndex" in t && r(14, (v = t.zIndex)),
                "radius" in t && r(6, (A = t.radius)),
                "center" in t && r(7, (x = t.center)),
                "$$scope" in t && r(18, (c = t.$$scope));
            }),
            (t.$$.update = () => {
              12288 & t.$$.dirty &&
                r(9, (s = w ? { backgroundImage: w } : { backgroundColor: y })),
                16384 & t.$$.dirty &&
                  r(
                    8,
                    (i = {
                      position: "absolute",
                      top: 0,
                      bottom: 0,
                      left: 0,
                      right: 0,
                      zIndex: v,
                    })
                  );
            }),
            [
              d,
              u,
              h,
              f,
              m,
              b,
              A,
              x,
              i,
              s,
              $,
              a,
              y,
              w,
              v,
              l,
              function (t) {
                (d = t), r(0, d);
              },
              function (t) {
                (d = t), r(0, d);
              },
              c,
            ]
          );
        }
        var Wi = class extends Lt {
          constructor(t) {
            super(),
              Rt(this, t, Qi, Vi, a, {
                use: 1,
                element: 0,
                class: 2,
                override: 3,
                opacity: 4,
                color: 12,
                blur: 5,
                gradient: 13,
                zIndex: 14,
                radius: 6,
                center: 7,
              });
          }
        };
        const Ji = {
          xs: 320,
          sm: 380,
          md: 440,
          lg: 620,
          xl: 780,
          full: "100%",
        };
        var _i = ke((t, { centered: e, overflow: n, size: r, zIndex: s }) => {
          const i = r in Ji == !1;
          return {
            close: {},
            overlay: {},
            root: {
              position: "fixed",
              zIndex: s,
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
            },
            inner: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              overflowY: "auto",
              padding: `${2 * +t.space.xl.value}px ${+t.space.md.value}px`,
              display: "flex",
              justifyContent: "center",
              alignItems: e ? "center" : "flex-start",
            },
            title: {
              marginRight: +t.space.md.value,
              textOverflow: "ellipsis",
              display: "block",
              wordBreak: "break-word",
            },
            modal: {
              [`${t.dark} &`]: { backgroundColor: t.fn.themeColor("dark", 7) },
              position: "relative",
              width:
                "string" == typeof r && i
                  ? r
                  : t.fn.size({ sizes: Ji, size: r }),
              outline: 0,
              backgroundColor: "white",
              marginTop: e ? "auto" : void 0,
              marginBottom: e ? "auto" : void 0,
              zIndex: 1,
              marginLeft: "calc(var(--removed-scroll-width, 0px) * -1)",
            },
            header: {
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              marginBottom: parseInt(t.space.md.value),
              marginRight: -9,
            },
            body: {
              maxHeight: "inside" === n ? "calc(100vh - 185px)" : null,
              overflowY: "inside" === n ? "auto" : null,
              wordBreak: "break-word",
            },
          };
        });
        function Ki(t) {
          let e, n;
          return (
            (e = new xs({
              props: {
                class: t[28](),
                withinPortal: t[17],
                target: t[16],
                $$slots: { default: [eo] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                131072 & n[0] && (r.withinPortal = t[17]),
                  65536 & n[0] && (r.target = t[16]),
                  (540868591 & n[0]) | (512 & n[1]) &&
                    (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function qi(t) {
          let e, n, r, s, i;
          n = new Ks({
            props: {
              id: t[24],
              class: t[19].title,
              $$slots: { default: [Yi] },
              $$scope: { ctx: t },
            },
          });
          let o = t[6] && Zi(t);
          return {
            c() {
              (e = B("div")),
                Nt(n.$$.fragment),
                (r = O()),
                o && o.c(),
                z(e, "class", (s = t[19].header));
            },
            m(t, s) {
              P(t, e, s), Tt(n, e, null), $(e, r), o && o.m(e, null), (i = !0);
            },
            p(t, r) {
              const a = {};
              524288 & r[0] && (a.class = t[19].title),
                (32 & r[0]) | (512 & r[1]) &&
                  (a.$$scope = { dirty: r, ctx: t }),
                n.$set(a),
                t[6]
                  ? o
                    ? (o.p(t, r), 64 & r[0] && kt(o, 1))
                    : ((o = Zi(t)), o.c(), kt(o, 1), o.m(e, null))
                  : o &&
                    (xt(),
                    Et(o, 1, 1, () => {
                      o = null;
                    }),
                    $t()),
                (!i || (524288 & r[0] && s !== (s = t[19].header))) &&
                  z(e, "class", s);
            },
            i(t) {
              i || (kt(n.$$.fragment, t), kt(o), (i = !0));
            },
            o(t) {
              Et(n.$$.fragment, t), Et(o), (i = !1);
            },
            d(t) {
              t && I(e), Ot(n), o && o.d();
            },
          };
        }
        function Yi(t) {
          let e;
          return {
            c() {
              e = T(t[5]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              32 & n[0] && H(e, t[5]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Zi(t) {
          let e, n;
          return (
            (e = new Xr({
              props: { iconSize: 16, "aria-label": t[10], class: t[19].close },
            })),
            e.$on("click", t[27]),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                1024 & n[0] && (r["aria-label"] = t[10]),
                  524288 & n[0] && (r.class = t[19].close),
                  e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Xi(t) {
          let e,
            n,
            r,
            s,
            i = (t[5] || t[6]) && qi(t);
          const o = t[36].default,
            a = c(o, t, t[40], null),
            l =
              a ||
              (function (t) {
                let e;
                return {
                  c() {
                    e = T("Place some content");
                  },
                  m(t, n) {
                    P(t, e, n);
                  },
                  d(t) {
                    t && I(e);
                  },
                };
              })();
          return {
            c() {
              i && i.c(),
                (e = O()),
                (n = B("div")),
                l && l.c(),
                z(n, "id", t[25]),
                z(n, "class", (r = t[19].body));
            },
            m(t, r) {
              i && i.m(t, r),
                P(t, e, r),
                P(t, n, r),
                l && l.m(n, null),
                (s = !0);
            },
            p(t, l) {
              t[5] || t[6]
                ? i
                  ? (i.p(t, l), 96 & l[0] && kt(i, 1))
                  : ((i = qi(t)), i.c(), kt(i, 1), i.m(e.parentNode, e))
                : i &&
                  (xt(),
                  Et(i, 1, 1, () => {
                    i = null;
                  }),
                  $t()),
                a &&
                  a.p &&
                  (!s || 512 & l[1]) &&
                  h(a, o, t, t[40], s ? d(o, t[40], l, null) : f(t[40]), null),
                (!s || (524288 & l[0] && r !== (r = t[19].body))) &&
                  z(n, "class", r);
            },
            i(t) {
              s || (kt(i), kt(l, t), (s = !0));
            },
            o(t) {
              Et(i), Et(l, t), (s = !1);
            },
            d(t) {
              i && i.d(t), t && I(e), t && I(n), l && l.d(t);
            },
          };
        }
        function to(t) {
          let e, n, r, s, a, l, c, u, d, h, f, p, g;
          return (
            (r = new pi({
              props: {
                class: t[19].modal,
                shadow: t[11],
                padding: t[12],
                radius: t[9],
                role: "dialog",
                "aria-labelledby": t[24],
                "aria-describedby": t[25],
                "aria-modal": !0,
                tabindex: -1,
                use: [[as, t[15]]],
                $$slots: { default: [Xi] },
                $$scope: { ctx: t },
              },
            })),
            (c = new Wi({
              props: {
                class: t[19].overlay,
                override: { position: "fixed" },
                zIndex: 0,
                blur: t[8],
                color: t[7] || "black",
                opacity: t[26],
              },
            })),
            c.$on("mousedown", t[37]),
            {
              c() {
                (e = B("div")),
                  (n = B("div")),
                  Nt(r.$$.fragment),
                  (a = O()),
                  (l = B("div")),
                  Nt(c.$$.fragment),
                  z(e, "role", "presentation"),
                  z(e, "class", (d = t[19].inner));
              },
              m(s, i) {
                P(s, e, i),
                  $(e, n),
                  Tt(r, n, null),
                  $(e, a),
                  $(e, l),
                  Tt(c, l, null),
                  (f = !0),
                  p ||
                    ((g = [
                      y((h = hs.call(null, e, t[21]))),
                      L(e, "keydown", t[38], !0),
                    ]),
                    (p = !0));
              },
              p(n, s) {
                t = n;
                const i = {};
                524288 & s[0] && (i.class = t[19].modal),
                  2048 & s[0] && (i.shadow = t[11]),
                  4096 & s[0] && (i.padding = t[12]),
                  512 & s[0] && (i.radius = t[9]),
                  32768 & s[0] && (i.use = [[as, t[15]]]),
                  (525408 & s[0]) | (512 & s[1]) &&
                    (i.$$scope = { dirty: s, ctx: t }),
                  r.$set(i);
                const a = {};
                524288 & s[0] && (a.class = t[19].overlay),
                  256 & s[0] && (a.blur = t[8]),
                  128 & s[0] && (a.color = t[7] || "black"),
                  c.$set(a),
                  (!f || (524288 & s[0] && d !== (d = t[19].inner))) &&
                    z(e, "class", d),
                  h &&
                    o(h.update) &&
                    2097152 & s[0] &&
                    h.update.call(null, t[21]);
              },
              i(t) {
                f ||
                  (kt(r.$$.fragment, t),
                  ht(() => {
                    f &&
                      (s || (s = St(n, Yt, { duration: 100, easing: Kt }, !0)),
                      s.run(1));
                  }),
                  kt(c.$$.fragment, t),
                  ht(() => {
                    f &&
                      (u || (u = St(l, qt, { duration: 200, easing: Kt }, !0)),
                      u.run(1));
                  }),
                  (f = !0));
              },
              o(t) {
                Et(r.$$.fragment, t),
                  s || (s = St(n, Yt, { duration: 100, easing: Kt }, !1)),
                  s.run(0),
                  Et(c.$$.fragment, t),
                  u || (u = St(l, qt, { duration: 200, easing: Kt }, !1)),
                  u.run(0),
                  (f = !1);
              },
              d(t) {
                t && I(e),
                  Ot(r),
                  t && s && s.end(),
                  Ot(c),
                  t && u && u.end(),
                  (p = !1),
                  i(g);
              },
            }
          );
        }
        function eo(t) {
          let e, r, s;
          const i = [
            { id: t[23] },
            { use: t[1] },
            t[29],
            { class: t[20](t[2], t[19].root, t[18]({ css: t[3] })) },
          ];
          function o(e) {
            t[39](e);
          }
          let a = { $$slots: { default: [to] }, $$scope: { ctx: t } };
          for (let t = 0; t < i.length; t += 1) a = n(a, i[t]);
          return (
            void 0 !== t[0] && (a.element = t[0]),
            (e = new Mn({ props: a })),
            it.push(() => Bt(e, "element", o)),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, n) {
                Tt(e, t, n), (s = !0);
              },
              p(t, n) {
                const s =
                  547094542 & n[0]
                    ? Pt(i, [
                        8388608 & n[0] && { id: t[23] },
                        2 & n[0] && { use: t[1] },
                        536870912 & n[0] && It(t[29]),
                        1835020 & n[0] && {
                          class: t[20](t[2], t[19].root, t[18]({ css: t[3] })),
                        },
                      ])
                    : {};
                (2686944 & n[0]) | (512 & n[1]) &&
                  (s.$$scope = { dirty: n, ctx: t }),
                  !r &&
                    1 & n[0] &&
                    ((r = !0), (s.element = t[0]), ft(() => (r = !1))),
                  e.$set(s);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function no(t) {
          let e,
            n,
            r = t[4] && Ki(t);
          return {
            c() {
              r && r.c(), (e = R());
            },
            m(t, s) {
              r && r.m(t, s), P(t, e, s), (n = !0);
            },
            p(t, n) {
              t[4]
                ? r
                  ? (r.p(t, n), 16 & n[0] && kt(r, 1))
                  : ((r = Ki(t)), r.c(), kt(r, 1), r.m(e.parentNode, e))
                : r &&
                  (xt(),
                  Et(r, 1, 1, () => {
                    r = null;
                  }),
                  $t());
            },
            i(t) {
              n || (kt(r), (n = !0));
            },
            o(t) {
              Et(r), (n = !1);
            },
            d(t) {
              r && r.d(t), t && I(e);
            },
          };
        }
        function ro(t, e, r) {
          let s, i, o, a;
          const c = [
            "use",
            "element",
            "class",
            "override",
            "opened",
            "title",
            "zIndex",
            "overflow",
            "withCloseButton",
            "overlayOpacity",
            "overlayColor",
            "overlayBlur",
            "radius",
            "size",
            "closeButtonLabel",
            "id",
            "shadow",
            "padding",
            "closeOnClickOutside",
            "closeOnEscape",
            "trapFocus",
            "centered",
            "target",
            "withinPortal",
          ];
          let u,
            d = g(e, c);
          l(t, ee, (t) => r(41, (u = t)));
          let { $$slots: h = {}, $$scope: f } = e,
            {
              use: m = [],
              element: y,
              class: b = "",
              override: w = {},
              opened: v = !1,
              title: A = "",
              zIndex: x = 200,
              overflow: $ = "outside",
              withCloseButton: k = !0,
              overlayOpacity: E = null,
              overlayColor: C = null,
              overlayBlur: S = 0,
              radius: P = "sm",
              size: I = "md",
              closeButtonLabel: B = "svelteui-close-button",
              id: N = "svelteui",
              shadow: T = "lg",
              padding: O = "lg",
              closeOnClickOutside: R = !0,
              closeOnEscape: L = !0,
              trapFocus: z = !0,
              centered: U = null,
              target: F = "#SVELTEUI_PROVIDER",
              withinPortal: D = !0,
            } = e;
          const M = rt(),
            j = (t) => t,
            H = (function (t = "svelteui") {
              return `${t}-${Math.random().toString(36).substring(2, 10)}`;
            })(N),
            G = `${H}-title`,
            V = `${H}-body`,
            Q = "number" == typeof E ? E : "dark" === u ? 0.85 : 0.75,
            { handleFocusReturn: W } = (function () {
              let t;
              const e = () => {
                t &&
                  "focus" in t &&
                  "function" == typeof t.focus &&
                  t.focus({ preventScroll: !0 });
              };
              return {
                handleFocusReturn(n, r = !0) {
                  n ? (t = document.activeElement) : r && e();
                },
                returnFocus: e,
              };
            })(),
            J = (t) => {
              !z && "Escape" === t.code && L && _();
            };
          function _() {
            M("close");
          }
          const K = wn({ zIndex: x });
          return (
            (t.$$set = (t) => {
              (e = n(n({}, e), p(t))),
                r(29, (d = g(e, c))),
                "use" in t && r(1, (m = t.use)),
                "element" in t && r(0, (y = t.element)),
                "class" in t && r(2, (b = t.class)),
                "override" in t && r(3, (w = t.override)),
                "opened" in t && r(4, (v = t.opened)),
                "title" in t && r(5, (A = t.title)),
                "zIndex" in t && r(30, (x = t.zIndex)),
                "overflow" in t && r(31, ($ = t.overflow)),
                "withCloseButton" in t && r(6, (k = t.withCloseButton)),
                "overlayOpacity" in t && r(32, (E = t.overlayOpacity)),
                "overlayColor" in t && r(7, (C = t.overlayColor)),
                "overlayBlur" in t && r(8, (S = t.overlayBlur)),
                "radius" in t && r(9, (P = t.radius)),
                "size" in t && r(33, (I = t.size)),
                "closeButtonLabel" in t && r(10, (B = t.closeButtonLabel)),
                "id" in t && r(34, (N = t.id)),
                "shadow" in t && r(11, (T = t.shadow)),
                "padding" in t && r(12, (O = t.padding)),
                "closeOnClickOutside" in t &&
                  r(13, (R = t.closeOnClickOutside)),
                "closeOnEscape" in t && r(14, (L = t.closeOnEscape)),
                "trapFocus" in t && r(15, (z = t.trapFocus)),
                "centered" in t && r(35, (U = t.centered)),
                "target" in t && r(16, (F = t.target)),
                "withinPortal" in t && r(17, (D = t.withinPortal)),
                "$$scope" in t && r(40, (f = t.$$scope));
            }),
            (t.$$.update = () => {
              if (
                (16 & t.$$.dirty[0] && W(v),
                32768 & t.$$.dirty[0] &&
                  nt(() => {
                    z ||
                      ("undefined" != typeof window &&
                        window.addEventListener("keydown", J));
                  }),
                65552 & t.$$.dirty[0] &&
                  v &&
                  (("string" == typeof F && !document.querySelector(F)) || !F))
              )
                throw new Error(
                  "Wrap your app in the SvelteUIProvider, or provide a sufficent target throught the \"target={''}\" prop "
                );
              16 & t.$$.dirty[0] && r(21, (s = v)),
                (1073741824 & t.$$.dirty[0]) | (21 & t.$$.dirty[1]) &&
                  r(
                    20,
                    ({
                      cx: i,
                      classes: o,
                      getStyles: a,
                    } = _i(
                      { centered: U, overflow: $, size: I, zIndex: x },
                      { name: "Modal" }
                    )),
                    i,
                    (r(19, o), r(35, U), r(31, $), r(33, I), r(30, x)),
                    (r(18, a), r(35, U), r(31, $), r(33, I), r(30, x))
                  );
            }),
            [
              y,
              m,
              b,
              w,
              v,
              A,
              k,
              C,
              S,
              P,
              B,
              T,
              O,
              R,
              L,
              z,
              F,
              D,
              a,
              o,
              i,
              s,
              j,
              H,
              G,
              V,
              Q,
              _,
              K,
              d,
              x,
              $,
              E,
              I,
              N,
              U,
              h,
              () => R && _(),
              (t) => {
                "true" !==
                  t.target?.getAttribute("data-svelteui-stop-propagation") &&
                  "Escape" === t.code &&
                  L &&
                  _();
              },
              function (t) {
                (y = t), r(0, y);
              },
              f,
            ]
          );
        }
        var so = class extends Lt {
          constructor(t) {
            super(),
              Rt(
                this,
                t,
                ro,
                no,
                a,
                {
                  use: 1,
                  element: 0,
                  class: 2,
                  override: 3,
                  opened: 4,
                  title: 5,
                  zIndex: 30,
                  overflow: 31,
                  withCloseButton: 6,
                  overlayOpacity: 32,
                  overlayColor: 7,
                  overlayBlur: 8,
                  radius: 9,
                  size: 33,
                  closeButtonLabel: 10,
                  id: 34,
                  shadow: 11,
                  padding: 12,
                  closeOnClickOutside: 13,
                  closeOnEscape: 14,
                  trapFocus: 15,
                  centered: 35,
                  target: 16,
                  withinPortal: 17,
                },
                null,
                [-1, -1]
              );
          }
        };
        function io(t) {
          let e, n, r, s, i, o, a;
          return (
            (e = new li({
              props: {
                variant: "filled",
                $$slots: { default: [ao] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment),
                  (n = O()),
                  (r = B("p")),
                  (s = T("Balance: ")),
                  (i = B("strong")),
                  (o = T(t[1]));
              },
              m(t, l) {
                Tt(e, t, l),
                  P(t, n, l),
                  P(t, r, l),
                  $(r, s),
                  $(r, i),
                  $(i, o),
                  (a = !0);
              },
              p(t, n) {
                const r = {};
                17 & n && (r.$$scope = { dirty: n, ctx: t }),
                  e.$set(r),
                  (!a || 2 & n) && H(o, t[1]);
              },
              i(t) {
                a || (kt(e.$$.fragment, t), (a = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (a = !1);
              },
              d(t) {
                Ot(e, t), t && I(n), t && I(r);
              },
            }
          );
        }
        function oo(t) {
          let e, n;
          return (
            (e = new li({
              props: {
                variant: "filled",
                color: "red",
                $$slots: { default: [lo] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                16 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function ao(t) {
          let e;
          return {
            c() {
              e = T(t[0]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              1 & n && H(e, t[0]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function lo(t) {
          let e;
          return {
            c() {
              e = T("not connected");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function co(t) {
          let e, n, r, s, i, o;
          const a = [oo, io],
            l = [];
          function c(t, e) {
            return t[0] && t[1] ? 1 : 0;
          }
          return (
            (r = c(t)),
            (s = l[r] = a[r](t)),
            {
              c() {
                (e = B("h3")),
                  (e.textContent = "Account Information"),
                  (n = O()),
                  s.c(),
                  (i = R());
              },
              m(t, s) {
                P(t, e, s), P(t, n, s), l[r].m(t, s), P(t, i, s), (o = !0);
              },
              p(t, e) {
                let n = r;
                (r = c(t)),
                  r === n
                    ? l[r].p(t, e)
                    : (xt(),
                      Et(l[n], 1, 1, () => {
                        l[n] = null;
                      }),
                      $t(),
                      (s = l[r]),
                      s ? s.p(t, e) : ((s = l[r] = a[r](t)), s.c()),
                      kt(s, 1),
                      s.m(i.parentNode, i));
              },
              i(t) {
                o || (kt(s), (o = !0));
              },
              o(t) {
                Et(s), (o = !1);
              },
              d(t) {
                t && I(e), t && I(n), l[r].d(t), t && I(i);
              },
            }
          );
        }
        function uo(t) {
          let e, n;
          return (
            (e = new ki({
              props: {
                shadow: "sm",
                padding: "lg",
                $$slots: { default: [co] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                19 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function ho(t, e, n) {
          let r, s;
          return (
            nt(() => {
              (async function () {
                const t = await window.ethereum
                  .request({ method: "eth_requestAccounts" })
                  .catch((t) => {
                    4001 === t.code
                      ? console.log("Please connect to MetaMask.")
                      : console.error(t);
                  });
                n(0, (r = t[0]));
              })().then(() => {
                !(async function () {
                  console.log("account", r);
                  const t = await window.ethereum
                      .request({
                        method: "eth_getBalance",
                        params: [r, "latest"],
                      })
                      .catch((t) =>
                        4001 === t.code
                          ? (console.log("Please connect to MetaMask."), null)
                          : (console.error(t), null)
                      ),
                    e = parseInt(t, 16);
                  console.log("balWei", e),
                    n(1, (s = (e / 10 ** 18).toString()));
                })();
              });
            }),
            n(0, (r = null)),
            n(1, (s = null)),
            [r, s]
          );
        }
        class fo extends Lt {
          constructor(t) {
            super(), Rt(this, t, ho, uo, a, {});
          }
        }
        const po = "6.6.4";
        function go(t, e, n) {
          const r = e.split("|").map((t) => t.trim());
          for (let n = 0; n < r.length; n++)
            switch (e) {
              case "any":
                return;
              case "bigint":
              case "boolean":
              case "number":
              case "string":
                if (typeof t === e) return;
            }
          const s = new Error(`invalid value for type ${e}`);
          throw (
            ((s.code = "INVALID_ARGUMENT"),
            (s.argument = `value.${n}`),
            (s.value = t),
            s)
          );
        }
        async function mo(t) {
          const e = Object.keys(t),
            n = await Promise.all(e.map((e) => Promise.resolve(t[e])));
          return n.reduce((t, n, r) => ((t[e[r]] = n), t), {});
        }
        function yo(t, e, n) {
          for (let r in e) {
            let s = e[r];
            const i = n ? n[r] : null;
            i && go(s, i, r),
              Object.defineProperty(t, r, {
                enumerable: !0,
                value: s,
                writable: !1,
              });
          }
        }
        function bo(t) {
          if (null == t) return "null";
          if (Array.isArray(t)) return "[ " + t.map(bo).join(", ") + " ]";
          if (t instanceof Uint8Array) {
            const e = "0123456789abcdef";
            let n = "0x";
            for (let r = 0; r < t.length; r++)
              (n += e[t[r] >> 4]), (n += e[15 & t[r]]);
            return n;
          }
          if ("object" == typeof t && "function" == typeof t.toJSON)
            return bo(t.toJSON());
          switch (typeof t) {
            case "boolean":
            case "symbol":
            case "number":
              return t.toString();
            case "bigint":
              return BigInt(t).toString();
            case "string":
              return JSON.stringify(t);
            case "object": {
              const e = Object.keys(t);
              return (
                e.sort(),
                "{ " + e.map((e) => `${bo(e)}: ${bo(t[e])}`).join(", ") + " }"
              );
            }
          }
          return "[ COULD NOT SERIALIZE ]";
        }
        function wo(t, e) {
          return t && t.code === e;
        }
        function vo(t) {
          return wo(t, "CALL_EXCEPTION");
        }
        function Ao(t, e, n) {
          {
            const r = [];
            if (n) {
              if ("message" in n || "code" in n || "name" in n)
                throw new Error(
                  `value will overwrite populated values: ${bo(n)}`
                );
              for (const t in n) {
                const e = n[t];
                r.push(t + "=" + bo(e));
              }
            }
            r.push(`code=${e}`),
              r.push(`version=${po}`),
              r.length && (t += " (" + r.join(", ") + ")");
          }
          let r;
          switch (e) {
            case "INVALID_ARGUMENT":
              r = new TypeError(t);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              r = new RangeError(t);
              break;
            default:
              r = new Error(t);
          }
          return yo(r, { code: e }), n && Object.assign(r, n), r;
        }
        function xo(t, e, n, r) {
          if (!t) throw Ao(e, n, r);
        }
        function $o(t, e, n, r) {
          xo(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
        }
        function ko(t, e, n) {
          null == n && (n = ""),
            n && (n = ": " + n),
            xo(t >= e, "missing arguemnt" + n, "MISSING_ARGUMENT", {
              count: t,
              expectedCount: e,
            }),
            xo(t <= e, "too many arguemnts" + n, "UNEXPECTED_ARGUMENT", {
              count: t,
              expectedCount: e,
            });
        }
        const Eo = ["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
          try {
            if ("test" !== "test".normalize(e)) throw new Error("bad");
            if ("NFD" === e) {
              const t = String.fromCharCode(233).normalize("NFD");
              if (t !== String.fromCharCode(101, 769))
                throw new Error("broken");
            }
            t.push(e);
          } catch (t) {}
          return t;
        }, []);
        function Co(t, e, n) {
          if ((null == n && (n = ""), t !== e)) {
            let t = n,
              e = "new";
            n && ((t += "."), (e += " " + n)),
              xo(
                !1,
                `private constructor; use ${t}from* methods`,
                "UNSUPPORTED_OPERATION",
                { operation: e }
              );
          }
        }
        function So(t, e, n) {
          if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
          if ("string" == typeof t && t.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
            const e = new Uint8Array((t.length - 2) / 2);
            let n = 2;
            for (let r = 0; r < e.length; r++)
              (e[r] = parseInt(t.substring(n, n + 2), 16)), (n += 2);
            return e;
          }
          $o(!1, "invalid BytesLike value", e || "value", t);
        }
        function Po(t, e) {
          return So(t, e, !1);
        }
        function Io(t, e) {
          return So(t, e, !0);
        }
        function Bo(t, e) {
          return (
            !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/)) &&
            ("number" != typeof e || t.length === 2 + 2 * e) &&
            (!0 !== e || t.length % 2 == 0)
          );
        }
        const No = "0123456789abcdef";
        function To(t) {
          const e = Po(t);
          let n = "0x";
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            n += No[(240 & r) >> 4] + No[15 & r];
          }
          return n;
        }
        function Oo(t) {
          return "0x" + t.map((t) => To(t).substring(2)).join("");
        }
        function Ro(t) {
          return Bo(t, !0) ? (t.length - 2) / 2 : Po(t).length;
        }
        function Lo(t, e, n) {
          const r = Po(t);
          return (
            null != n &&
              n > r.length &&
              xo(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
                buffer: r,
                length: r.length,
                offset: n,
              }),
            To(r.slice(null == e ? 0 : e, null == n ? r.length : n))
          );
        }
        function zo(t, e) {
          return (function (t, e, n) {
            const r = Po(t);
            xo(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
              buffer: new Uint8Array(r),
              length: e,
              offset: e + 1,
            });
            const s = new Uint8Array(e);
            return s.fill(0), n ? s.set(r, e - r.length) : s.set(r, 0), To(s);
          })(t, e, !0);
        }
        const Uo = BigInt(0),
          Fo = BigInt(1),
          Do = 9007199254740991;
        function Mo(t, e) {
          const n = Vo(t, "value"),
            r = BigInt(Jo(e, "width"));
          if (
            (xo(n >> r === Uo, "overflow", "NUMERIC_FAULT", {
              operation: "fromTwos",
              fault: "overflow",
              value: t,
            }),
            n >> (r - Fo))
          ) {
            return -((~n & ((Fo << r) - Fo)) + Fo);
          }
          return n;
        }
        function jo(t, e) {
          let n = Go(t, "value");
          const r = BigInt(Jo(e, "width")),
            s = Fo << (r - Fo);
          if (n < Uo) {
            (n = -n),
              xo(n <= s, "too low", "NUMERIC_FAULT", {
                operation: "toTwos",
                fault: "overflow",
                value: t,
              });
            return (~n & ((Fo << r) - Fo)) + Fo;
          }
          return (
            xo(n < s, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: t,
            }),
            n
          );
        }
        function Ho(t, e) {
          const n = Vo(t, "value"),
            r = BigInt(Jo(e, "bits"));
          return n & ((Fo << r) - Fo);
        }
        function Go(t, e) {
          switch (typeof t) {
            case "bigint":
              return t;
            case "number":
              return (
                $o(Number.isInteger(t), "underflow", e || "value", t),
                $o(t >= -Do && t <= Do, "overflow", e || "value", t),
                BigInt(t)
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return "-" === t[0] && "-" !== t[1]
                  ? -BigInt(t.substring(1))
                  : BigInt(t);
              } catch (n) {
                $o(
                  !1,
                  `invalid BigNumberish string: ${n.message}`,
                  e || "value",
                  t
                );
              }
          }
          $o(!1, "invalid BigNumberish value", e || "value", t);
        }
        function Vo(t, e) {
          const n = Go(t, e);
          return (
            xo(n >= Uo, "unsigned value cannot be negative", "NUMERIC_FAULT", {
              fault: "overflow",
              operation: "getUint",
              value: t,
            }),
            n
          );
        }
        const Qo = "0123456789abcdef";
        function Wo(t) {
          if (t instanceof Uint8Array) {
            let e = "0x0";
            for (const n of t) (e += Qo[n >> 4]), (e += Qo[15 & n]);
            return BigInt(e);
          }
          return Go(t);
        }
        function Jo(t, e) {
          switch (typeof t) {
            case "bigint":
              return (
                $o(t >= -Do && t <= Do, "overflow", e || "value", t), Number(t)
              );
            case "number":
              return (
                $o(Number.isInteger(t), "underflow", e || "value", t),
                $o(t >= -Do && t <= Do, "overflow", e || "value", t),
                t
              );
            case "string":
              try {
                if ("" === t) throw new Error("empty string");
                return Jo(BigInt(t), e);
              } catch (n) {
                $o(!1, `invalid numeric string: ${n.message}`, e || "value", t);
              }
          }
          $o(!1, "invalid numeric value", e || "value", t);
        }
        function _o(t, e) {
          let n = Vo(t, "value").toString(16);
          if (null == e) n.length % 2 && (n = "0" + n);
          else {
            const r = Jo(e, "width");
            for (
              xo(
                2 * r >= n.length,
                `value exceeds width (${r} bits)`,
                "NUMERIC_FAULT",
                { operation: "toBeHex", fault: "overflow", value: t }
              );
              n.length < 2 * r;

            )
              n = "0" + n;
          }
          return "0x" + n;
        }
        function Ko(t) {
          const e = Vo(t, "value");
          if (e === Uo) return new Uint8Array([]);
          let n = e.toString(16);
          n.length % 2 && (n = "0" + n);
          const r = new Uint8Array(n.length / 2);
          for (let t = 0; t < r.length; t++) {
            const e = 2 * t;
            r[t] = parseInt(n.substring(e, e + 2), 16);
          }
          return r;
        }
        function qo(t) {
          let e = To(
            (function (t) {
              return Bo(t, !0) || t instanceof Uint8Array;
            })(t)
              ? t
              : Ko(t)
          ).substring(2);
          for (; e.startsWith("0"); ) e = e.substring(1);
          return "" === e && (e = "0"), "0x" + e;
        }
        BigInt(0);
        const Yo = BigInt(58);
        class Zo {
          filter;
          emitter;
          #t;
          constructor(t, e, n) {
            (this.#t = e), yo(this, { emitter: t, filter: n });
          }
          async removeListener() {
            null != this.#t && (await this.emitter.off(this.filter, this.#t));
          }
        }
        function Xo(t, e, n, r, s) {
          if ("BAD_PREFIX" === t || "UNEXPECTED_CONTINUE" === t) {
            let t = 0;
            for (let r = e + 1; r < n.length && n[r] >> 6 == 2; r++) t++;
            return t;
          }
          return "OVERRUN" === t ? n.length - e - 1 : 0;
        }
        const ta = Object.freeze({
          error: function (t, e, n, r, s) {
            $o(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
          },
          ignore: Xo,
          replace: function (t, e, n, r, s) {
            return "OVERLONG" === t
              ? ($o(
                  "number" == typeof s,
                  "invalid bad code point for replacement",
                  "badCodepoint",
                  s
                ),
                r.push(s),
                0)
              : (r.push(65533), Xo(t, e, n));
          },
        });
        function ea(t, e) {
          null != e &&
            (!(function (t) {
              xo(
                Eo.indexOf(t) >= 0,
                "platform missing String.prototype.normalize",
                "UNSUPPORTED_OPERATION",
                { operation: "String.prototype.normalize", info: { form: t } }
              );
            })(e),
            (t = t.normalize(e)));
          let n = [];
          for (let e = 0; e < t.length; e++) {
            const r = t.charCodeAt(e);
            if (r < 128) n.push(r);
            else if (r < 2048) n.push((r >> 6) | 192), n.push((63 & r) | 128);
            else if (55296 == (64512 & r)) {
              e++;
              const s = t.charCodeAt(e);
              $o(
                e < t.length && 56320 == (64512 & s),
                "invalid surrogate pair",
                "str",
                t
              );
              const i = 65536 + ((1023 & r) << 10) + (1023 & s);
              n.push((i >> 18) | 240),
                n.push(((i >> 12) & 63) | 128),
                n.push(((i >> 6) & 63) | 128),
                n.push((63 & i) | 128);
            } else
              n.push((r >> 12) | 224),
                n.push(((r >> 6) & 63) | 128),
                n.push((63 & r) | 128);
          }
          return new Uint8Array(n);
        }
        function na(t, e) {
          return (
            (n = (function (t, e) {
              null == e && (e = ta.error);
              const n = Po(t, "bytes"),
                r = [];
              let s = 0;
              for (; s < n.length; ) {
                const t = n[s++];
                if (t >> 7 == 0) {
                  r.push(t);
                  continue;
                }
                let i = null,
                  o = null;
                if (192 == (224 & t)) (i = 1), (o = 127);
                else if (224 == (240 & t)) (i = 2), (o = 2047);
                else {
                  if (240 != (248 & t)) {
                    s += e(
                      128 == (192 & t) ? "UNEXPECTED_CONTINUE" : "BAD_PREFIX",
                      s - 1,
                      n,
                      r
                    );
                    continue;
                  }
                  (i = 3), (o = 65535);
                }
                if (s - 1 + i >= n.length) {
                  s += e("OVERRUN", s - 1, n, r);
                  continue;
                }
                let a = t & ((1 << (8 - i - 1)) - 1);
                for (let t = 0; t < i; t++) {
                  let t = n[s];
                  if (128 != (192 & t)) {
                    (s += e("MISSING_CONTINUE", s, n, r)), (a = null);
                    break;
                  }
                  (a = (a << 6) | (63 & t)), s++;
                }
                null !== a &&
                  (a > 1114111
                    ? (s += e("OUT_OF_RANGE", s - 1 - i, n, r, a))
                    : a >= 55296 && a <= 57343
                    ? (s += e("UTF16_SURROGATE", s - 1 - i, n, r, a))
                    : a <= o
                    ? (s += e("OVERLONG", s - 1 - i, n, r, a))
                    : r.push(a));
              }
              return r;
            })(t, e)),
            n
              .map((t) =>
                t <= 65535
                  ? String.fromCharCode(t)
                  : ((t -= 65536),
                    String.fromCharCode(
                      55296 + ((t >> 10) & 1023),
                      56320 + (1023 & t)
                    ))
              )
              .join("")
          );
          var n;
        }
        let ra = async function (t, e) {
          const n = t.url.split(":")[0].toLowerCase();
          let r;
          if (
            (xo(
              "http" === n || "https" === n,
              `unsupported protocol ${n}`,
              "UNSUPPORTED_OPERATION",
              { info: { protocol: n }, operation: "request" }
            ),
            xo(
              "https" === n || !t.credentials || t.allowInsecureAuthentication,
              "insecure authorized connections unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "request" }
            ),
            e)
          ) {
            const t = new AbortController();
            (r = t.signal),
              e.addListener(() => {
                t.abort();
              });
          }
          const s = {
              method: t.method,
              headers: new Headers(Array.from(t)),
              body: t.body || void 0,
              signal: r,
            },
            i = await fetch(t.url, s),
            o = {};
          i.headers.forEach((t, e) => {
            o[e.toLowerCase()] = t;
          });
          const a = await i.arrayBuffer(),
            l = null == a ? null : new Uint8Array(a);
          return {
            statusCode: i.status,
            statusMessage: i.statusText,
            headers: o,
            body: l,
          };
        };
        const sa = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
          ia = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
        let oa = !1;
        async function aa(t, e) {
          try {
            const e = t.match(sa);
            if (!e) throw new Error("invalid data");
            return new pa(
              200,
              "OK",
              { "content-type": e[1] || "text/plain" },
              e[2]
                ? (function (t) {
                    t = atob(t);
                    const e = new Uint8Array(t.length);
                    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
                    return Po(e);
                  })(e[3])
                : ea(
                    e[3].replace(/%([0-9a-f][0-9a-f])/gi, (t, e) =>
                      String.fromCharCode(parseInt(e, 16))
                    )
                  )
            );
          } catch (e) {
            return new pa(
              599,
              "BAD REQUEST (invalid data: URI)",
              {},
              null,
              new fa(t)
            );
          }
        }
        function la(t) {
          return async function (e, n) {
            try {
              const n = e.match(ia);
              if (!n) throw new Error("invalid link");
              return new fa(`${t}${n[2]}`);
            } catch (t) {
              return new pa(
                599,
                "BAD REQUEST (invalid IPFS URI)",
                {},
                null,
                new fa(e)
              );
            }
          };
        }
        const ca = { data: aa, ipfs: la("https://gateway.ipfs.io/ipfs/") },
          ua = new WeakMap();
        class da {
          #e;
          #n;
          constructor(t) {
            (this.#e = []),
              (this.#n = !1),
              ua.set(t, () => {
                if (!this.#n) {
                  this.#n = !0;
                  for (const t of this.#e)
                    setTimeout(() => {
                      t();
                    }, 0);
                  this.#e = [];
                }
              });
          }
          addListener(t) {
            xo(!this.#n, "singal already cancelled", "UNSUPPORTED_OPERATION", {
              operation: "fetchCancelSignal.addCancelListener",
            }),
              this.#e.push(t);
          }
          get cancelled() {
            return this.#n;
          }
          checkSignal() {
            xo(!this.cancelled, "cancelled", "CANCELLED", {});
          }
        }
        function ha(t) {
          if (null == t) throw new Error("missing signal; should not happen");
          return t.checkSignal(), t;
        }
        class fa {
          #r;
          #s;
          #i;
          #o;
          #a;
          #l;
          #c;
          #u;
          #d;
          #h;
          #f;
          #p;
          #g;
          #m;
          get url() {
            return this.#l;
          }
          set url(t) {
            this.#l = String(t);
          }
          get body() {
            return null == this.#c ? null : new Uint8Array(this.#c);
          }
          set body(t) {
            if (null == t) (this.#c = void 0), (this.#u = void 0);
            else if ("string" == typeof t)
              (this.#c = ea(t)), (this.#u = "text/plain");
            else if (t instanceof Uint8Array)
              (this.#c = t), (this.#u = "application/octet-stream");
            else {
              if ("object" != typeof t) throw new Error("invalid body");
              (this.#c = ea(JSON.stringify(t))), (this.#u = "application/json");
            }
          }
          hasBody() {
            return null != this.#c;
          }
          get method() {
            return this.#o ? this.#o : this.hasBody() ? "POST" : "GET";
          }
          set method(t) {
            null == t && (t = ""), (this.#o = String(t).toUpperCase());
          }
          get headers() {
            const t = Object.assign({}, this.#i);
            return (
              this.#d &&
                (t.authorization = `Basic ${(function (t) {
                  const e = Po(t);
                  let n = "";
                  for (let t = 0; t < e.length; t++)
                    n += String.fromCharCode(e[t]);
                  return btoa(n);
                })(ea(this.#d))}`),
              this.allowGzip && (t["accept-encoding"] = "gzip"),
              null == t["content-type"] &&
                this.#u &&
                (t["content-type"] = this.#u),
              this.body && (t["content-length"] = String(this.body.length)),
              t
            );
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          setHeader(t, e) {
            this.#i[String(t).toLowerCase()] = String(e);
          }
          clearHeaders() {
            this.#i = {};
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          get credentials() {
            return this.#d || null;
          }
          setCredentials(t, e) {
            $o(
              !t.match(/:/),
              "invalid basic authentication username",
              "username",
              "[REDACTED]"
            ),
              (this.#d = `${t}:${e}`);
          }
          get allowGzip() {
            return this.#s;
          }
          set allowGzip(t) {
            this.#s = !!t;
          }
          get allowInsecureAuthentication() {
            return !!this.#r;
          }
          set allowInsecureAuthentication(t) {
            this.#r = !!t;
          }
          get timeout() {
            return this.#a;
          }
          set timeout(t) {
            $o(t >= 0, "timeout must be non-zero", "timeout", t), (this.#a = t);
          }
          get preflightFunc() {
            return this.#h || null;
          }
          set preflightFunc(t) {
            this.#h = t;
          }
          get processFunc() {
            return this.#f || null;
          }
          set processFunc(t) {
            this.#f = t;
          }
          get retryFunc() {
            return this.#p || null;
          }
          set retryFunc(t) {
            this.#p = t;
          }
          constructor(t) {
            (this.#l = String(t)),
              (this.#r = !1),
              (this.#s = !0),
              (this.#i = {}),
              (this.#o = ""),
              (this.#a = 3e5),
              (this.#m = { slotInterval: 250, maxAttempts: 12 });
          }
          toString() {
            return `<FetchRequest method=${JSON.stringify(
              this.method
            )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
              this.headers
            )} body=${this.#c ? To(this.#c) : "null"}>`;
          }
          setThrottleParams(t) {
            null != t.slotInterval && (this.#m.slotInterval = t.slotInterval),
              null != t.maxAttempts && (this.#m.maxAttempts = t.maxAttempts);
          }
          async #y(t, e, n, r, s) {
            if (t >= this.#m.maxAttempts)
              return s.makeServerError("exceeded maximum retry limit");
            xo(ga() <= e, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: r,
            }),
              n > 0 &&
                (await (function (t) {
                  return new Promise((e) => setTimeout(e, t));
                })(n));
            let i = this.clone();
            const o = (i.url.split(":")[0] || "").toLowerCase();
            if (o in ca) {
              const t = await ca[o](i.url, ha(r.#g));
              if (t instanceof pa) {
                let e = t;
                if (this.processFunc) {
                  ha(r.#g);
                  try {
                    e = await this.processFunc(i, e);
                  } catch (t) {
                    (null != t.throttle && "number" == typeof t.stall) ||
                      e
                        .makeServerError("error in post-processing function", t)
                        .assertOk();
                  }
                }
                return e;
              }
              i = t;
            }
            this.preflightFunc && (i = await this.preflightFunc(i));
            const a = await ra(i, ha(r.#g));
            let l = new pa(a.statusCode, a.statusMessage, a.headers, a.body, r);
            if (301 === l.statusCode || 302 === l.statusCode) {
              try {
                const n = l.headers.location || "";
                return i.redirect(n).#y(t + 1, e, 0, r, l);
              } catch (t) {}
              return l;
            }
            if (
              429 === l.statusCode &&
              (null == this.retryFunc || (await this.retryFunc(i, l, t)))
            ) {
              const n = l.headers["retry-after"];
              let s =
                this.#m.slotInterval *
                Math.trunc(Math.random() * Math.pow(2, t));
              return (
                "string" == typeof n &&
                  n.match(/^[1-9][0-9]*$/) &&
                  (s = parseInt(n)),
                i.clone().#y(t + 1, e, s, r, l)
              );
            }
            if (this.processFunc) {
              ha(r.#g);
              try {
                l = await this.processFunc(i, l);
              } catch (n) {
                (null != n.throttle && "number" == typeof n.stall) ||
                  l
                    .makeServerError("error in post-processing function", n)
                    .assertOk();
                let s =
                  this.#m.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, t));
                return (
                  n.stall >= 0 && (s = n.stall), i.clone().#y(t + 1, e, s, r, l)
                );
              }
            }
            return l;
          }
          send() {
            return (
              xo(
                null == this.#g,
                "request already sent",
                "UNSUPPORTED_OPERATION",
                { operation: "fetchRequest.send" }
              ),
              (this.#g = new da(this)),
              this.#y(
                0,
                ga() + this.timeout,
                0,
                this,
                new pa(0, "", {}, null, this)
              )
            );
          }
          cancel() {
            xo(
              null != this.#g,
              "request has not been sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.cancel" }
            );
            const t = ua.get(this);
            if (!t) throw new Error("missing signal; should not happen");
            t();
          }
          redirect(t) {
            const e = this.url.split(":")[0].toLowerCase(),
              n = t.split(":")[0].toLowerCase();
            xo(
              "GET" === this.method &&
                ("https" !== e || "http" !== n) &&
                t.match(/^https?:/),
              "unsupported redirect",
              "UNSUPPORTED_OPERATION",
              {
                operation: `redirect(${this.method} ${JSON.stringify(
                  this.url
                )} => ${JSON.stringify(t)})`,
              }
            );
            const r = new fa(t);
            return (
              (r.method = "GET"),
              (r.allowGzip = this.allowGzip),
              (r.timeout = this.timeout),
              (r.#i = Object.assign({}, this.#i)),
              this.#c && (r.#c = new Uint8Array(this.#c)),
              (r.#u = this.#u),
              r
            );
          }
          clone() {
            const t = new fa(this.url);
            return (
              (t.#o = this.#o),
              this.#c && (t.#c = this.#c),
              (t.#u = this.#u),
              (t.#i = Object.assign({}, this.#i)),
              (t.#d = this.#d),
              this.allowGzip && (t.allowGzip = !0),
              (t.timeout = this.timeout),
              this.allowInsecureAuthentication &&
                (t.allowInsecureAuthentication = !0),
              (t.#h = this.#h),
              (t.#f = this.#f),
              (t.#p = this.#p),
              t
            );
          }
          static lockConfig() {
            oa = !0;
          }
          static getGateway(t) {
            return ca[t.toLowerCase()] || null;
          }
          static registerGateway(t, e) {
            if ("http" === (t = t.toLowerCase()) || "https" === t)
              throw new Error(`cannot intercept ${t}; use registerGetUrl`);
            if (oa) throw new Error("gateways locked");
            ca[t] = e;
          }
          static registerGetUrl(t) {
            if (oa) throw new Error("gateways locked");
            ra = t;
          }
          static createDataGateway() {
            return aa;
          }
          static createIpfsGatewayFunc(t) {
            return la(t);
          }
        }
        class pa {
          #b;
          #w;
          #i;
          #c;
          #v;
          #A;
          toString() {
            return `<FetchResponse status=${this.statusCode} body=${
              this.#c ? To(this.#c) : "null"
            }>`;
          }
          get statusCode() {
            return this.#b;
          }
          get statusMessage() {
            return this.#w;
          }
          get headers() {
            return Object.assign({}, this.#i);
          }
          get body() {
            return null == this.#c ? null : new Uint8Array(this.#c);
          }
          get bodyText() {
            try {
              return null == this.#c ? "" : na(this.#c);
            } catch (t) {
              xo(
                !1,
                "response body is not valid UTF-8 data",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyText", info: { response: this } }
              );
            }
          }
          get bodyJson() {
            try {
              return JSON.parse(this.bodyText);
            } catch (t) {
              xo(
                !1,
                "response body is not valid JSON",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyJson", info: { response: this } }
              );
            }
          }
          [Symbol.iterator]() {
            const t = this.headers,
              e = Object.keys(t);
            let n = 0;
            return {
              next: () => {
                if (n < e.length) {
                  const r = e[n++];
                  return { value: [r, t[r]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          constructor(t, e, n, r, s) {
            (this.#b = t),
              (this.#w = e),
              (this.#i = Object.keys(n).reduce(
                (t, e) => ((t[e.toLowerCase()] = String(n[e])), t),
                {}
              )),
              (this.#c = null == r ? null : new Uint8Array(r)),
              (this.#v = s || null),
              (this.#A = { message: "" });
          }
          makeServerError(t, e) {
            let n;
            n = t
              ? `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})`
              : `CLIENT ESCALATED SERVER ERROR (${(t = `${this.statusCode} ${this.statusMessage}`)})`;
            const r = new pa(
              599,
              n,
              this.headers,
              this.body,
              this.#v || void 0
            );
            return (r.#A = { message: t, error: e }), r;
          }
          throwThrottleError(t, e) {
            null == e
              ? (e = -1)
              : $o(
                  Number.isInteger(e) && e >= 0,
                  "invalid stall timeout",
                  "stall",
                  e
                );
            const n = new Error(t || "throttling requests");
            throw (yo(n, { stall: e, throttle: !0 }), n);
          }
          getHeader(t) {
            return this.headers[t.toLowerCase()];
          }
          hasBody() {
            return null != this.#c;
          }
          get request() {
            return this.#v;
          }
          ok() {
            return (
              "" === this.#A.message &&
              this.statusCode >= 200 &&
              this.statusCode < 300
            );
          }
          assertOk() {
            if (this.ok()) return;
            let { message: t, error: e } = this.#A;
            "" === t &&
              (t = `server response ${this.statusCode} ${this.statusMessage}`),
              xo(!1, t, "SERVER_ERROR", {
                request: this.request || "unknown request",
                response: this,
                error: e,
              });
          }
        }
        function ga() {
          return new Date().getTime();
        }
        const ma = BigInt(-1),
          ya = BigInt(0),
          ba = BigInt(1),
          wa = BigInt(5),
          va = {};
        let Aa = "0000";
        for (; Aa.length < 80; ) Aa += Aa;
        function xa(t) {
          let e = Aa;
          for (; e.length < t; ) e += e;
          return BigInt("1" + e.substring(0, t));
        }
        function $a(t, e, n) {
          const r = BigInt(e.width);
          if (e.signed) {
            const e = ba << (r - ba);
            xo(null == n || (t >= -e && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = t > ya ? Mo(Ho(t, r), r) : -Mo(Ho(-t, r), r));
          } else {
            const e = ba << r;
            xo(null == n || (t >= 0 && t < e), "overflow", "NUMERIC_FAULT", {
              operation: n,
              fault: "overflow",
              value: t,
            }),
              (t = ((t % e) + e) % e & (e - ba));
          }
          return t;
        }
        function ka(t) {
          "number" == typeof t && (t = `fixed128x${t}`);
          let e = !0,
            n = 128,
            r = 18;
          if ("string" == typeof t)
            if ("fixed" === t);
            else if ("ufixed" === t) e = !1;
            else {
              const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              $o(s, "invalid fixed format", "format", t),
                (e = "u" !== s[1]),
                (n = parseInt(s[2])),
                (r = parseInt(s[3]));
            }
          else if (t) {
            const s = t,
              i = (t, e, n) =>
                null == s[t]
                  ? n
                  : ($o(
                      typeof s[t] === e,
                      "invalid fixed format (" + t + " not " + e + ")",
                      "format." + t,
                      s[t]
                    ),
                    s[t]);
            (e = i("signed", "boolean", e)),
              (n = i("width", "number", n)),
              (r = i("decimals", "number", r));
          }
          $o(
            n % 8 == 0,
            "invalid FixedNumber width (not byte aligned)",
            "format.width",
            n
          ),
            $o(
              r <= 80,
              "invalid FixedNumber decimals (too large)",
              "format.decimals",
              r
            );
          return {
            signed: e,
            width: n,
            decimals: r,
            name: (e ? "" : "u") + "fixed" + String(n) + "x" + String(r),
          };
        }
        class Ea {
          format;
          #x;
          #$;
          #k;
          _value;
          constructor(t, e, n) {
            Co(t, va, "FixedNumber"), (this.#$ = e), (this.#x = n);
            const r = (function (t, e) {
              let n = "";
              t < ya && ((n = "-"), (t *= ma));
              let r = t.toString();
              if (0 === e) return n + r;
              for (; r.length <= e; ) r = Aa + r;
              const s = r.length - e;
              for (
                r = r.substring(0, s) + "." + r.substring(s);
                "0" === r[0] && "." !== r[1];

              )
                r = r.substring(1);
              for (; "0" === r[r.length - 1] && "." !== r[r.length - 2]; )
                r = r.substring(0, r.length - 1);
              return n + r;
            })(e, n.decimals);
            yo(this, { format: n.name, _value: r }), (this.#k = xa(n.decimals));
          }
          get signed() {
            return this.#x.signed;
          }
          get width() {
            return this.#x.width;
          }
          get decimals() {
            return this.#x.decimals;
          }
          get value() {
            return this.#$;
          }
          #E(t) {
            $o(
              this.format === t.format,
              "incompatible format; use fixedNumber.toFormat",
              "other",
              t
            );
          }
          #C(t, e) {
            return (t = $a(t, this.#x, e)), new Ea(va, t, this.#x);
          }
          #S(t, e) {
            return this.#E(t), this.#C(this.#$ + t.#$, e);
          }
          addUnsafe(t) {
            return this.#S(t);
          }
          add(t) {
            return this.#S(t, "add");
          }
          #P(t, e) {
            return this.#E(t), this.#C(this.#$ - t.#$, e);
          }
          subUnsafe(t) {
            return this.#P(t);
          }
          sub(t) {
            return this.#P(t, "sub");
          }
          #I(t, e) {
            return this.#E(t), this.#C((this.#$ * t.#$) / this.#k, e);
          }
          mulUnsafe(t) {
            return this.#I(t);
          }
          mul(t) {
            return this.#I(t, "mul");
          }
          mulSignal(t) {
            this.#E(t);
            const e = this.#$ * t.#$;
            return (
              xo(
                e % this.#k === ya,
                "precision lost during signalling mul",
                "NUMERIC_FAULT",
                { operation: "mulSignal", fault: "underflow", value: this }
              ),
              this.#C(e / this.#k, "mulSignal")
            );
          }
          #B(t, e) {
            return (
              xo(t.#$ !== ya, "division by zero", "NUMERIC_FAULT", {
                operation: "div",
                fault: "divide-by-zero",
                value: this,
              }),
              this.#E(t),
              this.#C((this.#$ * this.#k) / t.#$, e)
            );
          }
          divUnsafe(t) {
            return this.#B(t);
          }
          div(t) {
            return this.#B(t, "div");
          }
          divSignal(t) {
            xo(t.#$ !== ya, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            }),
              this.#E(t);
            const e = this.#$ * this.#k;
            return (
              xo(
                e % t.#$ === ya,
                "precision lost during signalling div",
                "NUMERIC_FAULT",
                { operation: "divSignal", fault: "underflow", value: this }
              ),
              this.#C(e / t.#$, "divSignal")
            );
          }
          cmp(t) {
            let e = this.value,
              n = t.value;
            const r = this.decimals - t.decimals;
            return (
              r > 0 ? (n *= xa(r)) : r < 0 && (e *= xa(-r)),
              e < n ? -1 : e > n ? 1 : 0
            );
          }
          eq(t) {
            return 0 === this.cmp(t);
          }
          lt(t) {
            return this.cmp(t) < 0;
          }
          lte(t) {
            return this.cmp(t) <= 0;
          }
          gt(t) {
            return this.cmp(t) > 0;
          }
          gte(t) {
            return this.cmp(t) >= 0;
          }
          floor() {
            let t = this.#$;
            return (
              this.#$ < ya && (t -= this.#k - ba),
              (t = (this.#$ / this.#k) * this.#k),
              this.#C(t, "floor")
            );
          }
          ceiling() {
            let t = this.#$;
            return (
              this.#$ > ya && (t += this.#k - ba),
              (t = (this.#$ / this.#k) * this.#k),
              this.#C(t, "ceiling")
            );
          }
          round(t) {
            if ((null == t && (t = 0), t >= this.decimals)) return this;
            const e = this.decimals - t,
              n = wa * xa(e - 1);
            let r = this.value + n;
            const s = xa(e);
            return (
              (r = (r / s) * s), $a(r, this.#x, "round"), new Ea(va, r, this.#x)
            );
          }
          isZero() {
            return this.#$ === ya;
          }
          isNegative() {
            return this.#$ < ya;
          }
          toString() {
            return this._value;
          }
          toUnsafeFloat() {
            return parseFloat(this.toString());
          }
          toFormat(t) {
            return Ea.fromString(this.toString(), t);
          }
          static fromValue(t, e, n) {
            const r = null == e ? 0 : Jo(e),
              s = ka(n);
            let i = Go(t, "value");
            const o = r - s.decimals;
            if (o > 0) {
              const e = xa(o);
              xo(
                i % e === ya,
                "value loses precision for format",
                "NUMERIC_FAULT",
                { operation: "fromValue", fault: "underflow", value: t }
              ),
                (i /= e);
            } else o < 0 && (i *= xa(-o));
            return $a(i, s, "fromValue"), new Ea(va, i, s);
          }
          static fromString(t, e) {
            const n = t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            $o(
              n && n[2].length + n[3].length > 0,
              "invalid FixedNumber string value",
              "value",
              t
            );
            const r = ka(e);
            let s = n[2] || "0",
              i = n[3] || "";
            for (; i.length < r.decimals; ) i += Aa;
            xo(
              i.substring(r.decimals).match(/^0*$/),
              "too many decimals for format",
              "NUMERIC_FAULT",
              { operation: "fromString", fault: "underflow", value: t }
            ),
              (i = i.substring(0, r.decimals));
            const o = BigInt(n[1] + s + i);
            return $a(o, r, "fromString"), new Ea(va, o, r);
          }
          static fromBytes(t, e) {
            let n = Wo(Po(t, "value"));
            const r = ka(e);
            return (
              r.signed && (n = Mo(n, r.width)),
              $a(n, r, "fromBytes"),
              new Ea(va, n, r)
            );
          }
        }
        function Ca(t) {
          let e = t.toString(16);
          for (; e.length < 2; ) e = "0" + e;
          return "0x" + e;
        }
        function Sa(t, e, n) {
          let r = 0;
          for (let s = 0; s < n; s++) r = 256 * r + t[e + s];
          return r;
        }
        function Pa(t, e, n, r) {
          const s = [];
          for (; n < e + 1 + r; ) {
            const i = Ia(t, n);
            s.push(i.result),
              xo(
                (n += i.consumed) <= e + 1 + r,
                "child data too short",
                "BUFFER_OVERRUN",
                { buffer: t, length: r, offset: e }
              );
          }
          return { consumed: 1 + r, result: s };
        }
        function Ia(t, e) {
          xo(0 !== t.length, "data too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: 0,
            offset: 1,
          });
          const n = (e) => {
            xo(
              e <= t.length,
              "data short segment too short",
              "BUFFER_OVERRUN",
              { buffer: t, length: t.length, offset: e }
            );
          };
          if (t[e] >= 248) {
            const r = t[e] - 247;
            n(e + 1 + r);
            const s = Sa(t, e + 1, r);
            return n(e + 1 + r + s), Pa(t, e, e + 1 + r, r + s);
          }
          if (t[e] >= 192) {
            const r = t[e] - 192;
            return n(e + 1 + r), Pa(t, e, e + 1, r);
          }
          if (t[e] >= 184) {
            const r = t[e] - 183;
            n(e + 1 + r);
            const s = Sa(t, e + 1, r);
            n(e + 1 + r + s);
            return {
              consumed: 1 + r + s,
              result: To(t.slice(e + 1 + r, e + 1 + r + s)),
            };
          }
          if (t[e] >= 128) {
            const r = t[e] - 128;
            n(e + 1 + r);
            return { consumed: 1 + r, result: To(t.slice(e + 1, e + 1 + r)) };
          }
          return { consumed: 1, result: Ca(t[e]) };
        }
        function Ba(t) {
          const e = Po(t, "data"),
            n = Ia(e, 0);
          return (
            $o(
              n.consumed === e.length,
              "unexpected junk after rlp payload",
              "data",
              t
            ),
            n.result
          );
        }
        function Na(t) {
          const e = [];
          for (; t; ) e.unshift(255 & t), (t >>= 8);
          return e;
        }
        function Ta(t) {
          if (Array.isArray(t)) {
            let e = [];
            if (
              (t.forEach(function (t) {
                e = e.concat(Ta(t));
              }),
              e.length <= 55)
            )
              return e.unshift(192 + e.length), e;
            const n = Na(e.length);
            return n.unshift(247 + n.length), n.concat(e);
          }
          const e = Array.prototype.slice.call(Po(t, "object"));
          if (1 === e.length && e[0] <= 127) return e;
          if (e.length <= 55) return e.unshift(128 + e.length), e;
          const n = Na(e.length);
          return n.unshift(183 + n.length), n.concat(e);
        }
        const Oa = "0123456789abcdef";
        function Ra(t) {
          let e = "0x";
          for (const n of Ta(t)) (e += Oa[n >> 4]), (e += Oa[15 & n]);
          return e;
        }
        const La = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
        function za(t) {
          return (function (t, e) {
            $o("string" == typeof t, "value must be a string", "value", t);
            let n = 18;
            if ("string" == typeof e) {
              const t = La.indexOf(e);
              $o(t >= 0, "invalid unit", "unit", e), (n = 3 * t);
            } else null != e && (n = Jo(e, "unit"));
            return Ea.fromString(t, { decimals: n, width: 512 }).value;
          })(t, 18);
        }
        const Ua = 32,
          Fa = new Uint8Array(Ua),
          Da = ["then"],
          Ma = {};
        function ja(t, e) {
          const n = new Error(
            `deferred error during ABI decoding triggered accessing ${t}`
          );
          throw ((n.error = e), n);
        }
        class Ha extends Array {
          #N;
          constructor(...t) {
            const e = t[0];
            let n = t[1],
              r = (t[2] || []).slice(),
              s = !0;
            e !== Ma && ((n = t), (r = []), (s = !1)),
              super(n.length),
              n.forEach((t, e) => {
                this[e] = t;
              });
            const i = r.reduce(
              (t, e) => (
                "string" == typeof e && t.set(e, (t.get(e) || 0) + 1), t
              ),
              new Map()
            );
            if (
              ((this.#N = Object.freeze(
                n.map((t, e) => {
                  const n = r[e];
                  return null != n && 1 === i.get(n) ? n : null;
                })
              )),
              s)
            )
              return (
                Object.freeze(this),
                new Proxy(this, {
                  get: (t, e, n) => {
                    if ("string" == typeof e) {
                      if (e.match(/^[0-9]+$/)) {
                        const n = Jo(e, "%index");
                        if (n < 0 || n >= this.length)
                          throw new RangeError("out of result range");
                        const r = t[n];
                        return r instanceof Error && ja(`index ${n}`, r), r;
                      }
                      if (Da.indexOf(e) >= 0) return Reflect.get(t, e, n);
                      const r = t[e];
                      if (r instanceof Function)
                        return function (...e) {
                          return r.apply(this === n ? t : this, e);
                        };
                      if (!(e in t))
                        return t.getValue.apply(this === n ? t : this, [e]);
                    }
                    return Reflect.get(t, e, n);
                  },
                })
              );
          }
          toArray() {
            const t = [];
            return (
              this.forEach((e, n) => {
                e instanceof Error && ja(`index ${n}`, e), t.push(e);
              }),
              t
            );
          }
          toObject() {
            return this.#N.reduce(
              (t, e, n) => (
                xo(
                  null != e,
                  "value at index ${ index } unnamed",
                  "UNSUPPORTED_OPERATION",
                  { operation: "toObject()" }
                ),
                e in t || (t[e] = this.getValue(e)),
                t
              ),
              {}
            );
          }
          slice(t, e) {
            null == t && (t = 0),
              t < 0 && (t += this.length) < 0 && (t = 0),
              null == e && (e = this.length),
              e < 0 && (e += this.length) < 0 && (e = 0),
              e > this.length && (e = this.length);
            const n = [],
              r = [];
            for (let s = t; s < e; s++) n.push(this[s]), r.push(this.#N[s]);
            return new Ha(Ma, n, r);
          }
          filter(t, e) {
            const n = [],
              r = [];
            for (let s = 0; s < this.length; s++) {
              const i = this[s];
              i instanceof Error && ja(`index ${s}`, i),
                t.call(e, i, s, this) && (n.push(i), r.push(this.#N[s]));
            }
            return new Ha(Ma, n, r);
          }
          map(t, e) {
            const n = [];
            for (let r = 0; r < this.length; r++) {
              const s = this[r];
              s instanceof Error && ja(`index ${r}`, s),
                n.push(t.call(e, s, r, this));
            }
            return n;
          }
          getValue(t) {
            const e = this.#N.indexOf(t);
            if (-1 === e) return;
            const n = this[e];
            return (
              n instanceof Error &&
                ja(`property ${JSON.stringify(t)}`, n.error),
              n
            );
          }
          static fromItems(t, e) {
            return new Ha(Ma, t, e);
          }
        }
        function Ga(t) {
          let e = Ko(t);
          return (
            xo(e.length <= Ua, "value out-of-bounds", "BUFFER_OVERRUN", {
              buffer: e,
              length: Ua,
              offset: e.length,
            }),
            e.length !== Ua && (e = Io(Oo([Fa.slice(e.length % Ua), e]))),
            e
          );
        }
        class Va {
          name;
          type;
          localName;
          dynamic;
          constructor(t, e, n, r) {
            yo(
              this,
              { name: t, type: e, localName: n, dynamic: r },
              {
                name: "string",
                type: "string",
                localName: "string",
                dynamic: "boolean",
              }
            );
          }
          _throwError(t, e) {
            $o(!1, t, this.localName, e);
          }
        }
        class Qa {
          #T;
          #O;
          constructor() {
            (this.#T = []), (this.#O = 0);
          }
          get data() {
            return Oo(this.#T);
          }
          get length() {
            return this.#O;
          }
          #R(t) {
            return this.#T.push(t), (this.#O += t.length), t.length;
          }
          appendWriter(t) {
            return this.#R(Io(t.data));
          }
          writeBytes(t) {
            let e = Io(t);
            const n = e.length % Ua;
            return n && (e = Io(Oo([e, Fa.slice(n)]))), this.#R(e);
          }
          writeValue(t) {
            return this.#R(Ga(t));
          }
          writeUpdatableValue() {
            const t = this.#T.length;
            return (
              this.#T.push(Fa),
              (this.#O += Ua),
              (e) => {
                this.#T[t] = Ga(e);
              }
            );
          }
        }
        class Wa {
          allowLoose;
          #T;
          #L;
          constructor(t, e) {
            yo(this, { allowLoose: !!e }), (this.#T = Io(t)), (this.#L = 0);
          }
          get data() {
            return To(this.#T);
          }
          get dataLength() {
            return this.#T.length;
          }
          get consumed() {
            return this.#L;
          }
          get bytes() {
            return new Uint8Array(this.#T);
          }
          #z(t, e, n) {
            let r = Math.ceil(e / Ua) * Ua;
            return (
              this.#L + r > this.#T.length &&
                (this.allowLoose && n && this.#L + e <= this.#T.length
                  ? (r = e)
                  : xo(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                      buffer: Io(this.#T),
                      length: this.#T.length,
                      offset: this.#L + r,
                    })),
              this.#T.slice(this.#L, this.#L + r)
            );
          }
          subReader(t) {
            return new Wa(this.#T.slice(this.#L + t), this.allowLoose);
          }
          readBytes(t, e) {
            let n = this.#z(0, t, !!e);
            return (this.#L += n.length), n.slice(0, t);
          }
          readValue() {
            return Wo(this.readBytes(Ua));
          }
          readIndex() {
            return Jo(Wo(this.readBytes(Ua)));
          }
        }
        function Ja(t) {
          if (!Number.isSafeInteger(t) || t < 0)
            throw new Error(`Wrong positive integer: ${t}`);
        }
        function _a(t, ...e) {
          if (!(t instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          if (e.length > 0 && !e.includes(t.length))
            throw new TypeError(
              `Expected Uint8Array of length ${e}, not of length=${t.length}`
            );
        }
        const Ka = {
            number: Ja,
            bool: function (t) {
              if ("boolean" != typeof t)
                throw new Error(`Expected boolean, not ${t}`);
            },
            bytes: _a,
            hash: function (t) {
              if ("function" != typeof t || "function" != typeof t.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              Ja(t.outputLen), Ja(t.blockLen);
            },
            exists: function (t, e = !0) {
              if (t.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (e && t.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (t, e) {
              _a(t);
              const n = e.outputLen;
              if (t.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          qa = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
          Ya = (t, e) => (t << (32 - e)) | (t >>> e);
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ if (
          !(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])
        )
          throw new Error("Non little-endian hardware is not supported");
        function Za(t) {
          if (
            ("string" == typeof t &&
              (t = (function (t) {
                if ("string" != typeof t)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof t
                  );
                return new TextEncoder().encode(t);
              })(t)),
            !(t instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof t})`
            );
          return t;
        }
        Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
        class Xa {
          clone() {
            return this._cloneInto();
          }
        }
        function tl(t) {
          const e = (e) => t().update(Za(e)).digest(),
            n = t();
          return (
            (e.outputLen = n.outputLen),
            (e.blockLen = n.blockLen),
            (e.create = () => t()),
            e
          );
        }
        class el extends Xa {
          constructor(t, e) {
            super(), (this.finished = !1), (this.destroyed = !1), Ka.hash(t);
            const n = Za(e);
            if (((this.iHash = t.create()), !(this.iHash instanceof Xa)))
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            const r = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const s = new Uint8Array(r);
            s.set(
              n.length > this.iHash.blockLen ? t.create().update(n).digest() : n
            );
            for (let t = 0; t < s.length; t++) s[t] ^= 54;
            this.iHash.update(s), (this.oHash = t.create());
            for (let t = 0; t < s.length; t++) s[t] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(t) {
            return Ka.exists(this), this.iHash.update(t), this;
          }
          digestInto(t) {
            Ka.exists(this),
              Ka.bytes(t, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(t),
              this.oHash.update(t),
              this.oHash.digestInto(t),
              this.destroy();
          }
          digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t), t;
          }
          _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: e,
              iHash: n,
              finished: r,
              destroyed: s,
              blockLen: i,
              outputLen: o,
            } = this;
            return (
              (t.finished = r),
              (t.destroyed = s),
              (t.blockLen = i),
              (t.outputLen = o),
              (t.oHash = e._cloneInto(t.oHash)),
              (t.iHash = n._cloneInto(t.iHash)),
              t
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const nl = (t, e, n) => new el(t, e).update(n).digest();
        nl.create = (t, e) => new el(t, e);
        class rl extends Xa {
          constructor(t, e, n, r) {
            super(),
              (this.blockLen = t),
              (this.outputLen = e),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(t)),
              (this.view = qa(this.buffer));
          }
          update(t) {
            Ka.exists(this);
            const { view: e, buffer: n, blockLen: r } = this,
              s = (t = Za(t)).length;
            for (let i = 0; i < s; ) {
              const o = Math.min(r - this.pos, s - i);
              if (o !== r)
                n.set(t.subarray(i, i + o), this.pos),
                  (this.pos += o),
                  (i += o),
                  this.pos === r && (this.process(e, 0), (this.pos = 0));
              else {
                const e = qa(t);
                for (; r <= s - i; i += r) this.process(e, i);
              }
            }
            return (this.length += t.length), this.roundClean(), this;
          }
          digestInto(t) {
            Ka.exists(this), Ka.output(t, this), (this.finished = !0);
            const { buffer: e, view: n, blockLen: r, isLE: s } = this;
            let { pos: i } = this;
            (e[i++] = 128),
              this.buffer.subarray(i).fill(0),
              this.padOffset > r - i && (this.process(n, 0), (i = 0));
            for (let t = i; t < r; t++) e[t] = 0;
            !(function (t, e, n, r) {
              if ("function" == typeof t.setBigUint64)
                return t.setBigUint64(e, n, r);
              const s = BigInt(32),
                i = BigInt(4294967295),
                o = Number((n >> s) & i),
                a = Number(n & i),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              t.setUint32(e + l, o, r), t.setUint32(e + c, a, r);
            })(n, r - 8, BigInt(8 * this.length), s),
              this.process(n, 0);
            const o = qa(t);
            this.get().forEach((t, e) => o.setUint32(4 * e, t, s));
          }
          digest() {
            const { buffer: t, outputLen: e } = this;
            this.digestInto(t);
            const n = t.slice(0, e);
            return this.destroy(), n;
          }
          _cloneInto(t) {
            t || (t = new this.constructor()), t.set(...this.get());
            const {
              blockLen: e,
              buffer: n,
              length: r,
              finished: s,
              destroyed: i,
              pos: o,
            } = this;
            return (
              (t.length = r),
              (t.pos = o),
              (t.finished = s),
              (t.destroyed = i),
              r % e && t.buffer.set(n),
              t
            );
          }
        }
        const sl = (t, e, n) => (t & e) ^ (~t & n),
          il = (t, e, n) => (t & e) ^ (t & n) ^ (e & n),
          ol = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          al = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          ll = new Uint32Array(64);
        class cl extends rl {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | al[0]),
              (this.B = 0 | al[1]),
              (this.C = 0 | al[2]),
              (this.D = 0 | al[3]),
              (this.E = 0 | al[4]),
              (this.F = 0 | al[5]),
              (this.G = 0 | al[6]),
              (this.H = 0 | al[7]);
          }
          get() {
            const { A: t, B: e, C: n, D: r, E: s, F: i, G: o, H: a } = this;
            return [t, e, n, r, s, i, o, a];
          }
          set(t, e, n, r, s, i, o, a) {
            (this.A = 0 | t),
              (this.B = 0 | e),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | s),
              (this.F = 0 | i),
              (this.G = 0 | o),
              (this.H = 0 | a);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4) ll[n] = t.getUint32(e, !1);
            for (let t = 16; t < 64; t++) {
              const e = ll[t - 15],
                n = ll[t - 2],
                r = Ya(e, 7) ^ Ya(e, 18) ^ (e >>> 3),
                s = Ya(n, 17) ^ Ya(n, 19) ^ (n >>> 10);
              ll[t] = (s + ll[t - 7] + r + ll[t - 16]) | 0;
            }
            let { A: n, B: r, C: s, D: i, E: o, F: a, G: l, H: c } = this;
            for (let t = 0; t < 64; t++) {
              const e =
                  (c +
                    (Ya(o, 6) ^ Ya(o, 11) ^ Ya(o, 25)) +
                    sl(o, a, l) +
                    ol[t] +
                    ll[t]) |
                  0,
                u = ((Ya(n, 2) ^ Ya(n, 13) ^ Ya(n, 22)) + il(n, r, s)) | 0;
              (c = l),
                (l = a),
                (a = o),
                (o = (i + e) | 0),
                (i = s),
                (s = r),
                (r = n),
                (n = (e + u) | 0);
            }
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (s = (s + this.C) | 0),
              (i = (i + this.D) | 0),
              (o = (o + this.E) | 0),
              (a = (a + this.F) | 0),
              (l = (l + this.G) | 0),
              (c = (c + this.H) | 0),
              this.set(n, r, s, i, o, a, l, c);
          }
          roundClean() {
            ll.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        const ul = tl(() => new cl()),
          dl = BigInt(2 ** 32 - 1),
          hl = BigInt(32);
        function fl(t, e = !1) {
          return e
            ? { h: Number(t & dl), l: Number((t >> hl) & dl) }
            : { h: 0 | Number((t >> hl) & dl), l: 0 | Number(t & dl) };
        }
        const pl = {
            fromBig: fl,
            split: function (t, e = !1) {
              let n = new Uint32Array(t.length),
                r = new Uint32Array(t.length);
              for (let s = 0; s < t.length; s++) {
                const { h: i, l: o } = fl(t[s], e);
                [n[s], r[s]] = [i, o];
              }
              return [n, r];
            },
            toBig: (t, e) => (BigInt(t >>> 0) << hl) | BigInt(e >>> 0),
            shrSH: (t, e, n) => t >>> n,
            shrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrSH: (t, e, n) => (t >>> n) | (e << (32 - n)),
            rotrSL: (t, e, n) => (t << (32 - n)) | (e >>> n),
            rotrBH: (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
            rotrBL: (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
            rotr32H: (t, e) => e,
            rotr32L: (t, e) => t,
            rotlSH: (t, e, n) => (t << n) | (e >>> (32 - n)),
            rotlSL: (t, e, n) => (e << n) | (t >>> (32 - n)),
            rotlBH: (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
            rotlBL: (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
            add: function (t, e, n, r) {
              const s = (e >>> 0) + (r >>> 0);
              return { h: (t + n + ((s / 2 ** 32) | 0)) | 0, l: 0 | s };
            },
            add3L: (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
            add3H: (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
            add4L: (t, e, n, r) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
            add4H: (t, e, n, r, s) => (e + n + r + s + ((t / 2 ** 32) | 0)) | 0,
            add5H: (t, e, n, r, s, i) =>
              (e + n + r + s + i + ((t / 2 ** 32) | 0)) | 0,
            add5L: (t, e, n, r, s) =>
              (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0),
          },
          [gl, ml] = pl.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((t) => BigInt(t))
          ),
          yl = new Uint32Array(80),
          bl = new Uint32Array(80);
        class wl extends rl {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: t,
              Al: e,
              Bh: n,
              Bl: r,
              Ch: s,
              Cl: i,
              Dh: o,
              Dl: a,
              Eh: l,
              El: c,
              Fh: u,
              Fl: d,
              Gh: h,
              Gl: f,
              Hh: p,
              Hl: g,
            } = this;
            return [t, e, n, r, s, i, o, a, l, c, u, d, h, f, p, g];
          }
          set(t, e, n, r, s, i, o, a, l, c, u, d, h, f, p, g) {
            (this.Ah = 0 | t),
              (this.Al = 0 | e),
              (this.Bh = 0 | n),
              (this.Bl = 0 | r),
              (this.Ch = 0 | s),
              (this.Cl = 0 | i),
              (this.Dh = 0 | o),
              (this.Dl = 0 | a),
              (this.Eh = 0 | l),
              (this.El = 0 | c),
              (this.Fh = 0 | u),
              (this.Fl = 0 | d),
              (this.Gh = 0 | h),
              (this.Gl = 0 | f),
              (this.Hh = 0 | p),
              (this.Hl = 0 | g);
          }
          process(t, e) {
            for (let n = 0; n < 16; n++, e += 4)
              (yl[n] = t.getUint32(e)), (bl[n] = t.getUint32((e += 4)));
            for (let t = 16; t < 80; t++) {
              const e = 0 | yl[t - 15],
                n = 0 | bl[t - 15],
                r = pl.rotrSH(e, n, 1) ^ pl.rotrSH(e, n, 8) ^ pl.shrSH(e, n, 7),
                s = pl.rotrSL(e, n, 1) ^ pl.rotrSL(e, n, 8) ^ pl.shrSL(e, n, 7),
                i = 0 | yl[t - 2],
                o = 0 | bl[t - 2],
                a =
                  pl.rotrSH(i, o, 19) ^ pl.rotrBH(i, o, 61) ^ pl.shrSH(i, o, 6),
                l =
                  pl.rotrSL(i, o, 19) ^ pl.rotrBL(i, o, 61) ^ pl.shrSL(i, o, 6),
                c = pl.add4L(s, l, bl[t - 7], bl[t - 16]),
                u = pl.add4H(c, r, a, yl[t - 7], yl[t - 16]);
              (yl[t] = 0 | u), (bl[t] = 0 | c);
            }
            let {
              Ah: n,
              Al: r,
              Bh: s,
              Bl: i,
              Ch: o,
              Cl: a,
              Dh: l,
              Dl: c,
              Eh: u,
              El: d,
              Fh: h,
              Fl: f,
              Gh: p,
              Gl: g,
              Hh: m,
              Hl: y,
            } = this;
            for (let t = 0; t < 80; t++) {
              const e =
                  pl.rotrSH(u, d, 14) ^
                  pl.rotrSH(u, d, 18) ^
                  pl.rotrBH(u, d, 41),
                b =
                  pl.rotrSL(u, d, 14) ^
                  pl.rotrSL(u, d, 18) ^
                  pl.rotrBL(u, d, 41),
                w = (u & h) ^ (~u & p),
                v = (d & f) ^ (~d & g),
                A = pl.add5L(y, b, v, ml[t], bl[t]),
                x = pl.add5H(A, m, e, w, gl[t], yl[t]),
                $ = 0 | A,
                k =
                  pl.rotrSH(n, r, 28) ^
                  pl.rotrBH(n, r, 34) ^
                  pl.rotrBH(n, r, 39),
                E =
                  pl.rotrSL(n, r, 28) ^
                  pl.rotrBL(n, r, 34) ^
                  pl.rotrBL(n, r, 39),
                C = (n & s) ^ (n & o) ^ (s & o),
                S = (r & i) ^ (r & a) ^ (i & a);
              (m = 0 | p),
                (y = 0 | g),
                (p = 0 | h),
                (g = 0 | f),
                (h = 0 | u),
                (f = 0 | d),
                ({ h: u, l: d } = pl.add(0 | l, 0 | c, 0 | x, 0 | $)),
                (l = 0 | o),
                (c = 0 | a),
                (o = 0 | s),
                (a = 0 | i),
                (s = 0 | n),
                (i = 0 | r);
              const P = pl.add3L($, E, S);
              (n = pl.add3H(P, x, k, C)), (r = 0 | P);
            }
            ({ h: n, l: r } = pl.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
              ({ h: s, l: i } = pl.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | i)),
              ({ h: o, l: a } = pl.add(0 | this.Ch, 0 | this.Cl, 0 | o, 0 | a)),
              ({ h: l, l: c } = pl.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)),
              ({ h: u, l: d } = pl.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)),
              ({ h: h, l: f } = pl.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)),
              ({ h: p, l: g } = pl.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
              ({ h: m, l: y } = pl.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
              this.set(n, r, s, i, o, a, l, c, u, d, h, f, p, g, m, y);
          }
          roundClean() {
            yl.fill(0), bl.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class vl extends wl {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class Al extends wl {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        const xl = tl(() => new wl());
        tl(() => new vl()), tl(() => new Al());
        const $l = (function () {
          if ("undefined" != typeof self) return self;
          if ("undefined" != typeof window) return window;
          if ("undefined" != typeof global) return global;
          throw new Error("unable to locate global object");
        })();
        $l.crypto || $l.msCrypto;
        let kl = !1;
        const El = function (t, e, n) {
          return (function (t, e) {
            const n = { sha256: ul, sha512: xl }[t];
            return (
              $o(null != n, "invalid hmac algorithm", "algorithm", t),
              nl.create(n, e)
            );
          })(t, e)
            .update(n)
            .digest();
        };
        let Cl = El;
        function Sl(t, e, n) {
          const r = Po(e, "key"),
            s = Po(n, "data");
          return To(Cl(t, r, s));
        }
        (Sl._ = El),
          (Sl.lock = function () {
            kl = !0;
          }),
          (Sl.register = function (t) {
            if (kl) throw new Error("computeHmac is locked");
            Cl = t;
          }),
          Object.freeze(Sl);
        const [Pl, Il, Bl] = [[], [], []],
          Nl = BigInt(0),
          Tl = BigInt(1),
          Ol = BigInt(2),
          Rl = BigInt(7),
          Ll = BigInt(256),
          zl = BigInt(113);
        for (let t = 0, e = Tl, n = 1, r = 0; t < 24; t++) {
          ([n, r] = [r, (2 * n + 3 * r) % 5]),
            Pl.push(2 * (5 * r + n)),
            Il.push((((t + 1) * (t + 2)) / 2) % 64);
          let s = Nl;
          for (let t = 0; t < 7; t++)
            (e = ((e << Tl) ^ ((e >> Rl) * zl)) % Ll),
              e & Ol && (s ^= Tl << ((Tl << BigInt(t)) - Tl));
          Bl.push(s);
        }
        const [Ul, Fl] = pl.split(Bl, !0),
          Dl = (t, e, n) => (n > 32 ? pl.rotlBH(t, e, n) : pl.rotlSH(t, e, n)),
          Ml = (t, e, n) => (n > 32 ? pl.rotlBL(t, e, n) : pl.rotlSL(t, e, n));
        class jl extends Xa {
          constructor(t, e, n, r = !1, s = 24) {
            if (
              (super(),
              (this.blockLen = t),
              (this.suffix = e),
              (this.outputLen = n),
              (this.enableXOF = r),
              (this.rounds = s),
              (this.pos = 0),
              (this.posOut = 0),
              (this.finished = !1),
              (this.destroyed = !1),
              Ka.number(n),
              0 >= this.blockLen || this.blockLen >= 200)
            )
              throw new Error("Sha3 supports only keccak-f1600 function");
            var i;
            (this.state = new Uint8Array(200)),
              (this.state32 =
                ((i = this.state),
                new Uint32Array(
                  i.buffer,
                  i.byteOffset,
                  Math.floor(i.byteLength / 4)
                )));
          }
          keccak() {
            !(function (t, e = 24) {
              const n = new Uint32Array(10);
              for (let r = 24 - e; r < 24; r++) {
                for (let e = 0; e < 10; e++)
                  n[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
                for (let e = 0; e < 10; e += 2) {
                  const r = (e + 8) % 10,
                    s = (e + 2) % 10,
                    i = n[s],
                    o = n[s + 1],
                    a = Dl(i, o, 1) ^ n[r],
                    l = Ml(i, o, 1) ^ n[r + 1];
                  for (let n = 0; n < 50; n += 10)
                    (t[e + n] ^= a), (t[e + n + 1] ^= l);
                }
                let e = t[2],
                  s = t[3];
                for (let n = 0; n < 24; n++) {
                  const r = Il[n],
                    i = Dl(e, s, r),
                    o = Ml(e, s, r),
                    a = Pl[n];
                  (e = t[a]), (s = t[a + 1]), (t[a] = i), (t[a + 1] = o);
                }
                for (let e = 0; e < 50; e += 10) {
                  for (let r = 0; r < 10; r++) n[r] = t[e + r];
                  for (let r = 0; r < 10; r++)
                    t[e + r] ^= ~n[(r + 2) % 10] & n[(r + 4) % 10];
                }
                (t[0] ^= Ul[r]), (t[1] ^= Fl[r]);
              }
              n.fill(0);
            })(this.state32, this.rounds),
              (this.posOut = 0),
              (this.pos = 0);
          }
          update(t) {
            Ka.exists(this);
            const { blockLen: e, state: n } = this,
              r = (t = Za(t)).length;
            for (let s = 0; s < r; ) {
              const i = Math.min(e - this.pos, r - s);
              for (let e = 0; e < i; e++) n[this.pos++] ^= t[s++];
              this.pos === e && this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            const { state: t, suffix: e, pos: n, blockLen: r } = this;
            (t[n] ^= e),
              0 != (128 & e) && n === r - 1 && this.keccak(),
              (t[r - 1] ^= 128),
              this.keccak();
          }
          writeInto(t) {
            Ka.exists(this, !1), Ka.bytes(t), this.finish();
            const e = this.state,
              { blockLen: n } = this;
            for (let r = 0, s = t.length; r < s; ) {
              this.posOut >= n && this.keccak();
              const i = Math.min(n - this.posOut, s - r);
              t.set(e.subarray(this.posOut, this.posOut + i), r),
                (this.posOut += i),
                (r += i);
            }
            return t;
          }
          xofInto(t) {
            if (!this.enableXOF)
              throw new Error("XOF is not possible for this instance");
            return this.writeInto(t);
          }
          xof(t) {
            return Ka.number(t), this.xofInto(new Uint8Array(t));
          }
          digestInto(t) {
            if ((Ka.output(t, this), this.finished))
              throw new Error("digest() was already called");
            return this.writeInto(t), this.destroy(), t;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            (this.destroyed = !0), this.state.fill(0);
          }
          _cloneInto(t) {
            const {
              blockLen: e,
              suffix: n,
              outputLen: r,
              rounds: s,
              enableXOF: i,
            } = this;
            return (
              t || (t = new jl(e, n, r, i, s)),
              t.state32.set(this.state32),
              (t.pos = this.pos),
              (t.posOut = this.posOut),
              (t.finished = this.finished),
              (t.rounds = s),
              (t.suffix = n),
              (t.outputLen = r),
              (t.enableXOF = i),
              (t.destroyed = this.destroyed),
              t
            );
          }
        }
        const Hl = (t, e, n) => tl(() => new jl(e, t, n));
        Hl(6, 144, 28),
          Hl(6, 136, 32),
          Hl(6, 104, 48),
          Hl(6, 72, 64),
          Hl(1, 144, 28);
        const Gl = Hl(1, 136, 32);
        Hl(1, 104, 48), Hl(1, 72, 64);
        const Vl = (t, e, n) =>
          (function (t) {
            const e = (e, n) => t(n).update(Za(e)).digest(),
              n = t({});
            return (
              (e.outputLen = n.outputLen),
              (e.blockLen = n.blockLen),
              (e.create = (e) => t(e)),
              e
            );
          })((r = {}) => new jl(e, t, void 0 === r.dkLen ? n : r.dkLen, !0));
        Vl(31, 168, 16), Vl(31, 136, 32);
        let Ql = !1;
        const Wl = function (t) {
          return Gl(t);
        };
        let Jl = Wl;
        function _l(t) {
          const e = Po(t, "data");
          return To(Jl(e));
        }
        (_l._ = Wl),
          (_l.lock = function () {
            Ql = !0;
          }),
          (_l.register = function (t) {
            if (Ql) throw new TypeError("keccak256 is locked");
            Jl = t;
          }),
          Object.freeze(_l);
        var Kl = Object.freeze({ __proto__: null, default: {} });
        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
        const ql = BigInt(0),
          Yl = BigInt(1),
          Zl = BigInt(2),
          Xl = BigInt(3),
          tc = BigInt(8),
          ec = Object.freeze({
            a: ql,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
            ),
            h: Yl,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          }),
          nc = (t, e) => (t + e / Zl) / e,
          rc = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar(t) {
              const { n: e } = ec,
                n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -Yl * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                i = n,
                o = BigInt("0x100000000000000000000000000000000"),
                a = nc(i * t, e),
                l = nc(-r * t, e);
              let c = Nc(t - a * n - l * s, e),
                u = Nc(-a * r - l * i, e);
              const d = c > o,
                h = u > o;
              if ((d && (c = e - c), h && (u = e - u), c > o || u > o))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
              return { k1neg: d, k1: c, k2neg: h, k2: u };
            },
          },
          sc = 32,
          ic = 32,
          oc = sc + 1,
          ac = 2 * sc + 1;
        function lc(t) {
          const { a: e, b: n } = ec,
            r = Nc(t * t),
            s = Nc(r * t);
          return Nc(s + e * t + n);
        }
        const cc = ec.a === ql;
        class uc extends Error {
          constructor(t) {
            super(t);
          }
        }
        function dc(t) {
          if (!(t instanceof hc)) throw new TypeError("JacobianPoint expected");
        }
        class hc {
          constructor(t, e, n) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          static fromAffine(t) {
            if (!(t instanceof gc))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(gc.ZERO) ? hc.ZERO : new hc(t.x, t.y, Yl);
          }
          static toAffineBatch(t) {
            const e = (function (t, e = ec.P) {
              const n = new Array(t.length),
                r = t.reduce(
                  (t, r, s) => (r === ql ? t : ((n[s] = t), Nc(t * r, e))),
                  Yl
                ),
                s = Oc(r, e);
              return (
                t.reduceRight(
                  (t, r, s) =>
                    r === ql ? t : ((n[s] = Nc(t * n[s], e)), Nc(t * r, e)),
                  s
                ),
                n
              );
            })(t.map((t) => t.z));
            return t.map((t, n) => t.toAffine(e[n]));
          }
          static normalizeZ(t) {
            return hc.toAffineBatch(t).map(hc.fromAffine);
          }
          equals(t) {
            dc(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: o } = t,
              a = Nc(r * r),
              l = Nc(o * o),
              c = Nc(e * l),
              u = Nc(s * a),
              d = Nc(Nc(n * o) * l),
              h = Nc(Nc(i * r) * a);
            return c === u && d === h;
          }
          negate() {
            return new hc(this.x, Nc(-this.y), this.z);
          }
          double() {
            const { x: t, y: e, z: n } = this,
              r = Nc(t * t),
              s = Nc(e * e),
              i = Nc(s * s),
              o = t + s,
              a = Nc(Zl * (Nc(o * o) - r - i)),
              l = Nc(Xl * r),
              c = Nc(l * l),
              u = Nc(c - Zl * a),
              d = Nc(l * (a - u) - tc * i),
              h = Nc(Zl * e * n);
            return new hc(u, d, h);
          }
          add(t) {
            dc(t);
            const { x: e, y: n, z: r } = this,
              { x: s, y: i, z: o } = t;
            if (s === ql || i === ql) return this;
            if (e === ql || n === ql) return t;
            const a = Nc(r * r),
              l = Nc(o * o),
              c = Nc(e * l),
              u = Nc(s * a),
              d = Nc(Nc(n * o) * l),
              h = Nc(Nc(i * r) * a),
              f = Nc(u - c),
              p = Nc(h - d);
            if (f === ql) return p === ql ? this.double() : hc.ZERO;
            const g = Nc(f * f),
              m = Nc(f * g),
              y = Nc(c * g),
              b = Nc(p * p - m - Zl * y),
              w = Nc(p * (y - b) - d * m),
              v = Nc(r * o * f);
            return new hc(b, w, v);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiplyUnsafe(t) {
            const e = hc.ZERO;
            if ("bigint" == typeof t && t === ql) return e;
            let n = Bc(t);
            if (n === Yl) return this;
            if (!cc) {
              let t = e,
                r = this;
              for (; n > ql; )
                n & Yl && (t = t.add(r)), (r = r.double()), (n >>= Yl);
              return t;
            }
            let { k1neg: r, k1: s, k2neg: i, k2: o } = rc.splitScalar(n),
              a = e,
              l = e,
              c = this;
            for (; s > ql || o > ql; )
              s & Yl && (a = a.add(c)),
                o & Yl && (l = l.add(c)),
                (c = c.double()),
                (s >>= Yl),
                (o >>= Yl);
            return (
              r && (a = a.negate()),
              i && (l = l.negate()),
              (l = new hc(Nc(l.x * rc.beta), l.y, l.z)),
              a.add(l)
            );
          }
          precomputeWindow(t) {
            const e = cc ? 128 / t + 1 : 256 / t + 1,
              n = [];
            let r = this,
              s = r;
            for (let i = 0; i < e; i++) {
              (s = r), n.push(s);
              for (let e = 1; e < 2 ** (t - 1); e++) (s = s.add(r)), n.push(s);
              r = s.double();
            }
            return n;
          }
          wNAF(t, e) {
            !e && this.equals(hc.BASE) && (e = gc.BASE);
            const n = (e && e._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = e && pc.get(e);
            r ||
              ((r = this.precomputeWindow(n)),
              e && 1 !== n && ((r = hc.normalizeZ(r)), pc.set(e, r)));
            let s = hc.ZERO,
              i = hc.BASE;
            const o = 1 + (cc ? 128 / n : 256 / n),
              a = 2 ** (n - 1),
              l = BigInt(2 ** n - 1),
              c = 2 ** n,
              u = BigInt(n);
            for (let e = 0; e < o; e++) {
              const n = e * a;
              let o = Number(t & l);
              (t >>= u), o > a && ((o -= c), (t += Yl));
              const d = n,
                h = n + Math.abs(o) - 1,
                f = e % 2 != 0,
                p = o < 0;
              0 === o ? (i = i.add(fc(f, r[d]))) : (s = s.add(fc(p, r[h])));
            }
            return { p: s, f: i };
          }
          multiply(t, e) {
            let n,
              r,
              s = Bc(t);
            if (cc) {
              const { k1neg: t, k1: i, k2neg: o, k2: a } = rc.splitScalar(s);
              let { p: l, f: c } = this.wNAF(i, e),
                { p: u, f: d } = this.wNAF(a, e);
              (l = fc(t, l)),
                (u = fc(o, u)),
                (u = new hc(Nc(u.x * rc.beta), u.y, u.z)),
                (n = l.add(u)),
                (r = c.add(d));
            } else {
              const { p: t, f: i } = this.wNAF(s, e);
              (n = t), (r = i);
            }
            return hc.normalizeZ([n, r])[0];
          }
          toAffine(t) {
            const { x: e, y: n, z: r } = this,
              s = this.equals(hc.ZERO);
            null == t && (t = s ? tc : Oc(r));
            const i = t,
              o = Nc(i * i),
              a = Nc(o * i),
              l = Nc(e * o),
              c = Nc(n * a),
              u = Nc(r * i);
            if (s) return gc.ZERO;
            if (u !== Yl) throw new Error("invZ was invalid");
            return new gc(l, c);
          }
        }
        function fc(t, e) {
          const n = e.negate();
          return t ? n : e;
        }
        (hc.BASE = new hc(ec.Gx, ec.Gy, Yl)), (hc.ZERO = new hc(ql, Yl, ql));
        const pc = new WeakMap();
        class gc {
          constructor(t, e) {
            (this.x = t), (this.y = e);
          }
          _setWindowSize(t) {
            (this._WINDOW_SIZE = t), pc.delete(this);
          }
          hasEvenY() {
            return this.y % Zl === ql;
          }
          static fromCompressedHex(t) {
            const e = 32 === t.length,
              n = Pc(e ? t : t.subarray(1));
            if (!Dc(n)) throw new Error("Point is not on curve");
            let r = (function (t) {
              const { P: e } = ec,
                n = BigInt(6),
                r = BigInt(11),
                s = BigInt(22),
                i = BigInt(23),
                o = BigInt(44),
                a = BigInt(88),
                l = (t * t * t) % e,
                c = (l * l * t) % e,
                u = (Tc(c, Xl) * c) % e,
                d = (Tc(u, Xl) * c) % e,
                h = (Tc(d, Zl) * l) % e,
                f = (Tc(h, r) * h) % e,
                p = (Tc(f, s) * f) % e,
                g = (Tc(p, o) * p) % e,
                m = (Tc(g, a) * g) % e,
                y = (Tc(m, o) * p) % e,
                b = (Tc(y, Xl) * c) % e,
                w = (Tc(b, i) * f) % e,
                v = (Tc(w, n) * l) % e,
                A = Tc(v, Zl),
                x = (A * A) % e;
              if (x !== t) throw new Error("Cannot find square root");
              return A;
            })(lc(n));
            const s = (r & Yl) === Yl;
            if (e) s && (r = Nc(-r));
            else {
              (1 == (1 & t[0])) !== s && (r = Nc(-r));
            }
            const i = new gc(n, r);
            return i.assertValidity(), i;
          }
          static fromUncompressedHex(t) {
            const e = Pc(t.subarray(1, sc + 1)),
              n = Pc(t.subarray(sc + 1, 2 * sc + 1)),
              r = new gc(e, n);
            return r.assertValidity(), r;
          }
          static fromHex(t) {
            const e = Ic(t),
              n = e.length,
              r = e[0];
            if (n === sc) return this.fromCompressedHex(e);
            if (n === oc && (2 === r || 3 === r))
              return this.fromCompressedHex(e);
            if (n === ac && 4 === r) return this.fromUncompressedHex(e);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${oc} compressed bytes or ${ac} uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(t) {
            return gc.BASE.multiply(jc(t));
          }
          static fromSignature(t, e, n) {
            const { r: r, s: s } = (function (t) {
              if (t instanceof bc) return t.assertValidity(), t;
              try {
                return bc.fromDER(t);
              } catch (e) {
                return bc.fromCompact(t);
              }
            })(e);
            if (![0, 1, 2, 3].includes(n))
              throw new Error("Cannot recover: invalid recovery bit");
            const i = Rc(Ic(t)),
              { n: o } = ec,
              a = 2 === n || 3 === n ? r + o : r,
              l = Oc(a, o),
              c = Nc(-i * l, o),
              u = Nc(s * l, o),
              d = 1 & n ? "03" : "02",
              h = gc.fromHex(d + $c(a)),
              f = gc.BASE.multiplyAndAddUnsafe(h, c, u);
            if (!f)
              throw new Error("Cannot recover signature: point at infinify");
            return f.assertValidity(), f;
          }
          toRawBytes(t = !1) {
            return Sc(this.toHex(t));
          }
          toHex(t = !1) {
            const e = $c(this.x);
            if (t) {
              return `${this.hasEvenY() ? "02" : "03"}${e}`;
            }
            return `04${e}${$c(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const t = "Point is not on elliptic curve",
              { x: e, y: n } = this;
            if (!Dc(e) || !Dc(n)) throw new Error(t);
            const r = Nc(n * n);
            if (Nc(r - lc(e)) !== ql) throw new Error(t);
          }
          equals(t) {
            return this.x === t.x && this.y === t.y;
          }
          negate() {
            return new gc(this.x, Nc(-this.y));
          }
          double() {
            return hc.fromAffine(this).double().toAffine();
          }
          add(t) {
            return hc.fromAffine(this).add(hc.fromAffine(t)).toAffine();
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            return hc.fromAffine(this).multiply(t, this).toAffine();
          }
          multiplyAndAddUnsafe(t, e, n) {
            const r = hc.fromAffine(this),
              s =
                e === ql || e === Yl || this !== gc.BASE
                  ? r.multiplyUnsafe(e)
                  : r.multiply(e),
              i = hc.fromAffine(t).multiplyUnsafe(n),
              o = s.add(i);
            return o.equals(hc.ZERO) ? void 0 : o.toAffine();
          }
        }
        function mc(t) {
          return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t;
        }
        function yc(t) {
          if (t.length < 2 || 2 !== t[0])
            throw new Error(`Invalid signature integer tag: ${Ac(t)}`);
          const e = t[1],
            n = t.subarray(2, e + 2);
          if (!e || n.length !== e)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: Pc(n), left: t.subarray(e + 2) };
        }
        (gc.BASE = new gc(ec.Gx, ec.Gy)), (gc.ZERO = new gc(ql, ql));
        let bc = class t {
          constructor(t, e) {
            (this.r = t), (this.s = e), this.assertValidity();
          }
          static fromCompact(e) {
            const n = e instanceof Uint8Array,
              r = "Signature.fromCompact";
            if ("string" != typeof e && !n)
              throw new TypeError(`${r}: Expected string or Uint8Array`);
            const s = n ? Ac(e) : e;
            if (128 !== s.length) throw new Error(`${r}: Expected 64-byte hex`);
            return new t(Cc(s.slice(0, 64)), Cc(s.slice(64, 128)));
          }
          static fromDER(e) {
            const n = e instanceof Uint8Array;
            if ("string" != typeof e && !n)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: r, s: s } = (function (t) {
              if (t.length < 2 || 48 != t[0])
                throw new Error(`Invalid signature tag: ${Ac(t)}`);
              if (t[1] !== t.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: e, left: n } = yc(t.subarray(2)),
                { data: r, left: s } = yc(n);
              if (s.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${Ac(s)}`
                );
              return { r: e, s: r };
            })(n ? e : Sc(e));
            return new t(r, s);
          }
          static fromHex(t) {
            return this.fromDER(t);
          }
          assertValidity() {
            const { r: t, s: e } = this;
            if (!Fc(t))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!Fc(e))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const t = ec.n >> Yl;
            return this.s > t;
          }
          normalizeS() {
            return this.hasHighS() ? new t(this.r, Nc(-this.s, ec.n)) : this;
          }
          toDERRawBytes() {
            return Sc(this.toDERHex());
          }
          toDERHex() {
            const t = mc(Ec(this.s)),
              e = mc(Ec(this.r)),
              n = t.length / 2,
              r = e.length / 2,
              s = Ec(n),
              i = Ec(r);
            return `30${Ec(r + n + 4)}02${i}${e}02${s}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return Sc(this.toCompactHex());
          }
          toCompactHex() {
            return $c(this.r) + $c(this.s);
          }
        };
        function wc(...t) {
          if (!t.every((t) => t instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            n = new Uint8Array(e);
          for (let e = 0, r = 0; e < t.length; e++) {
            const s = t[e];
            n.set(s, r), (r += s.length);
          }
          return n;
        }
        const vc = Array.from({ length: 256 }, (t, e) =>
          e.toString(16).padStart(2, "0")
        );
        function Ac(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let e = "";
          for (let n = 0; n < t.length; n++) e += vc[t[n]];
          return e;
        }
        const xc = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000"
        );
        function $c(t) {
          if ("bigint" != typeof t) throw new Error("Expected bigint");
          if (!(ql <= t && t < xc))
            throw new Error("Expected number 0 <= n < 2^256");
          return t.toString(16).padStart(64, "0");
        }
        function kc(t) {
          const e = Sc($c(t));
          if (32 !== e.length) throw new Error("Error: expected 32 bytes");
          return e;
        }
        function Ec(t) {
          const e = t.toString(16);
          return 1 & e.length ? `0${e}` : e;
        }
        function Cc(t) {
          if ("string" != typeof t)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof t
            );
          return BigInt(`0x${t}`);
        }
        function Sc(t) {
          if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + t.length
            );
          const e = new Uint8Array(t.length / 2);
          for (let n = 0; n < e.length; n++) {
            const r = 2 * n,
              s = t.slice(r, r + 2),
              i = Number.parseInt(s, 16);
            if (Number.isNaN(i) || i < 0)
              throw new Error("Invalid byte sequence");
            e[n] = i;
          }
          return e;
        }
        function Pc(t) {
          return Cc(Ac(t));
        }
        function Ic(t) {
          return t instanceof Uint8Array ? Uint8Array.from(t) : Sc(t);
        }
        function Bc(t) {
          if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
          if ("bigint" == typeof t && Fc(t)) return t;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function Nc(t, e = ec.P) {
          const n = t % e;
          return n >= ql ? n : e + n;
        }
        function Tc(t, e) {
          const { P: n } = ec;
          let r = t;
          for (; e-- > ql; ) (r *= r), (r %= n);
          return r;
        }
        function Oc(t, e = ec.P) {
          if (t === ql || e <= ql)
            throw new Error(
              `invert: expected positive integers, got n=${t} mod=${e}`
            );
          let n = Nc(t, e),
            r = e,
            s = ql,
            i = Yl;
          for (; n !== ql; ) {
            const t = r % n,
              e = s - i * (r / n);
            (r = n), (n = t), (s = i), (i = e);
          }
          if (r !== Yl) throw new Error("invert: does not exist");
          return Nc(s, e);
        }
        function Rc(t, e = !1) {
          const n = (function (t) {
            const e = 8 * t.length - 8 * ic,
              n = Pc(t);
            return e > 0 ? n >> BigInt(e) : n;
          })(t);
          if (e) return n;
          const { n: r } = ec;
          return n >= r ? n - r : n;
        }
        let Lc, zc;
        class Uc {
          constructor(t, e) {
            if (
              ((this.hashLen = t),
              (this.qByteLen = e),
              "number" != typeof t || t < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(t).fill(1)),
              (this.k = new Uint8Array(t).fill(0)),
              (this.counter = 0);
          }
          hmac(...t) {
            return qc.hmacSha256(this.k, ...t);
          }
          hmacSync(...t) {
            return zc(this.k, ...t);
          }
          checkSync() {
            if ("function" != typeof zc)
              throw new uc("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed(t = new Uint8Array()) {
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), t)),
              (this.v = await this.hmac(this.v)),
              0 !== t.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), t)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync(t = new Uint8Array()) {
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), t)),
              (this.v = this.hmacSync(this.v)),
              0 !== t.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), t)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return wc(...e);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const n = this.v.slice();
              e.push(n), (t += this.v.length);
            }
            return wc(...e);
          }
        }
        function Fc(t) {
          return ql < t && t < ec.n;
        }
        function Dc(t) {
          return ql < t && t < ec.P;
        }
        function Mc(t, e, n, r = !0) {
          const { n: s } = ec,
            i = Rc(t, !0);
          if (!Fc(i)) return;
          const o = Oc(i, s),
            a = gc.BASE.multiply(i),
            l = Nc(a.x, s);
          if (l === ql) return;
          const c = Nc(o * Nc(e + n * l, s), s);
          if (c === ql) return;
          let u = new bc(l, c),
            d = (a.x === u.r ? 0 : 2) | Number(a.y & Yl);
          return (
            r && u.hasHighS() && ((u = u.normalizeS()), (d ^= 1)),
            { sig: u, recovery: d }
          );
        }
        function jc(t) {
          let e;
          if ("bigint" == typeof t) e = t;
          else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
          else if ("string" == typeof t) {
            if (t.length !== 2 * ic)
              throw new Error("Expected 32 bytes of private key");
            e = Cc(t);
          } else {
            if (!(t instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (t.length !== ic)
              throw new Error("Expected 32 bytes of private key");
            e = Pc(t);
          }
          if (!Fc(e)) throw new Error("Expected private key: 0 < key < n");
          return e;
        }
        function Hc(t) {
          const e = t instanceof Uint8Array,
            n = "string" == typeof t,
            r = (e || n) && t.length;
          return e
            ? r === oc || r === ac
            : n
            ? r === 2 * oc || r === 2 * ac
            : t instanceof gc;
        }
        function Gc(t, e, n = !1) {
          if (Hc(t))
            throw new TypeError(
              "getSharedSecret: first arg must be private key"
            );
          if (!Hc(e))
            throw new TypeError(
              "getSharedSecret: second arg must be public key"
            );
          const r =
            (s = e) instanceof gc ? (s.assertValidity(), s) : gc.fromHex(s);
          var s;
          return r.assertValidity(), r.multiply(jc(t)).toRawBytes(n);
        }
        function Vc(t) {
          return Pc(t.length > sc ? t.slice(0, sc) : t);
        }
        function Qc(t) {
          const e = Vc(t),
            n = Nc(e, ec.n);
          return Wc(n < ql ? e : n);
        }
        function Wc(t) {
          return kc(t);
        }
        function Jc(t, e, n = {}) {
          const {
              seed: r,
              m: s,
              d: i,
            } = (function (t, e, n) {
              if (null == t)
                throw new Error(
                  `sign: expected valid message hash, not "${t}"`
                );
              const r = Ic(t),
                s = jc(e),
                i = [Wc(s), Qc(r)];
              if (null != n) {
                !0 === n && (n = qc.randomBytes(sc));
                const t = Ic(n);
                if (t.length !== sc)
                  throw new Error(`sign: Expected ${sc} bytes of extra data`);
                i.push(t);
              }
              return { seed: wc(...i), m: Vc(r), d: s };
            })(t, e, n.extraEntropy),
            o = new Uc(32, ic);
          let a;
          for (
            o.reseedSync(r);
            !(a = Mc(o.generateSync(), s, i, n.canonical));

          )
            o.reseedSync();
          return (function (t, e) {
            const { sig: n, recovery: r } = t,
              { der: s, recovered: i } = Object.assign(
                { canonical: !0, der: !0 },
                e
              ),
              o = s ? n.toDERRawBytes() : n.toCompactRawBytes();
            return i ? [o, r] : o;
          })(a, n);
        }
        gc.BASE._setWindowSize(8);
        const _c = {
            node: Kl,
            web:
              "object" == typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          Kc = {},
          qc = {
            bytesToHex: Ac,
            hexToBytes: Sc,
            concatBytes: wc,
            mod: Nc,
            invert: Oc,
            isValidPrivateKey(t) {
              try {
                return jc(t), !0;
              } catch (t) {
                return !1;
              }
            },
            _bigintTo32Bytes: kc,
            _normalizePrivateKey: jc,
            hashToPrivateKey: (t) => {
              t = Ic(t);
              const e = ic + 8;
              if (t.length < e || t.length > 1024)
                throw new Error(
                  "Expected valid bytes of private key as per FIPS 186"
                );
              return kc(Nc(Pc(t), ec.n - Yl) + Yl);
            },
            randomBytes: (t = 32) => {
              if (_c.web) return _c.web.getRandomValues(new Uint8Array(t));
              if (_c.node) {
                const { randomBytes: e } = _c.node;
                return Uint8Array.from(e(t));
              }
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            },
            randomPrivateKey: () => qc.hashToPrivateKey(qc.randomBytes(ic + 8)),
            precompute(t = 8, e = gc.BASE) {
              const n = e === gc.BASE ? e : new gc(e.x, e.y);
              return n._setWindowSize(t), n.multiply(Xl), n;
            },
            sha256: async (...t) => {
              if (_c.web) {
                const e = await _c.web.subtle.digest("SHA-256", wc(...t));
                return new Uint8Array(e);
              }
              if (_c.node) {
                const { createHash: e } = _c.node,
                  n = e("sha256");
                return (
                  t.forEach((t) => n.update(t)), Uint8Array.from(n.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async (t, ...e) => {
              if (_c.web) {
                const n = await _c.web.subtle.importKey(
                    "raw",
                    t,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"]
                  ),
                  r = wc(...e),
                  s = await _c.web.subtle.sign("HMAC", n, r);
                return new Uint8Array(s);
              }
              if (_c.node) {
                const { createHmac: n } = _c.node,
                  r = n("sha256", t);
                return (
                  e.forEach((t) => r.update(t)), Uint8Array.from(r.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async (t, ...e) => {
              let n = Kc[t];
              if (void 0 === n) {
                const e = await qc.sha256(
                  Uint8Array.from(t, (t) => t.charCodeAt(0))
                );
                (n = wc(e, e)), (Kc[t] = n);
              }
              return qc.sha256(n, ...e);
            },
            taggedHashSync: (t, ...e) => {
              if ("function" != typeof Lc)
                throw new uc("sha256Sync is undefined, you need to set it");
              let n = Kc[t];
              if (void 0 === n) {
                const e = Lc(Uint8Array.from(t, (t) => t.charCodeAt(0)));
                (n = wc(e, e)), (Kc[t] = n);
              }
              return Lc(n, ...e);
            },
            _JacobianPoint: hc,
          };
        Object.defineProperties(qc, {
          sha256Sync: {
            configurable: !1,
            get: () => Lc,
            set(t) {
              Lc || (Lc = t);
            },
          },
          hmacSha256Sync: {
            configurable: !1,
            get: () => zc,
            set(t) {
              zc || (zc = t);
            },
          },
        });
        const Yc = "0x0000000000000000000000000000000000000000",
          Zc =
            "0x0000000000000000000000000000000000000000000000000000000000000000",
          Xc = BigInt(0),
          tu = BigInt(1),
          eu = BigInt(2),
          nu = BigInt(27),
          ru = BigInt(28),
          su = BigInt(35),
          iu = {};
        function ou(t) {
          return zo(Ko(t), 32);
        }
        class au {
          #U;
          #F;
          #D;
          #M;
          get r() {
            return this.#U;
          }
          set r(t) {
            $o(32 === Ro(t), "invalid r", "value", t), (this.#U = To(t));
          }
          get s() {
            return this.#F;
          }
          set s(t) {
            $o(32 === Ro(t), "invalid s", "value", t);
            const e = To(t);
            $o(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e),
              (this.#F = e);
          }
          get v() {
            return this.#D;
          }
          set v(t) {
            const e = Jo(t, "value");
            $o(27 === e || 28 === e, "invalid v", "v", t), (this.#D = e);
          }
          get networkV() {
            return this.#M;
          }
          get legacyChainId() {
            const t = this.networkV;
            return null == t ? null : au.getChainId(t);
          }
          get yParity() {
            return 27 === this.v ? 0 : 1;
          }
          get yParityAndS() {
            const t = Po(this.s);
            return this.yParity && (t[0] |= 128), To(t);
          }
          get compactSerialized() {
            return Oo([this.r, this.yParityAndS]);
          }
          get serialized() {
            return Oo([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
          }
          constructor(t, e, n, r) {
            Co(t, iu, "Signature"),
              (this.#U = e),
              (this.#F = n),
              (this.#D = r),
              (this.#M = null);
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
          }
          clone() {
            const t = new au(iu, this.r, this.s, this.v);
            return this.networkV && (t.#M = this.networkV), t;
          }
          toJSON() {
            const t = this.networkV;
            return {
              _type: "signature",
              networkV: null != t ? t.toString() : null,
              r: this.r,
              s: this.s,
              v: this.v,
            };
          }
          static getChainId(t) {
            const e = Go(t, "v");
            return e == nu || e == ru
              ? Xc
              : ($o(e >= su, "invalid EIP-155 v", "v", t), (e - su) / eu);
          }
          static getChainIdV(t, e) {
            return Go(t) * eu + BigInt(35 + e - 27);
          }
          static getNormalizedV(t) {
            const e = Go(t);
            return e === Xc || e === nu
              ? 27
              : e === tu || e === ru
              ? 28
              : ($o(e >= su, "invalid v", "v", t), e & tu ? 27 : 28);
          }
          static from(t) {
            function e(e, n) {
              $o(e, n, "signature", t);
            }
            if (null == t) return new au(iu, Zc, Zc, 27);
            if ("string" == typeof t) {
              const n = Po(t, "signature");
              if (64 === n.length) {
                const t = To(n.slice(0, 32)),
                  e = n.slice(32, 64),
                  r = 128 & e[0] ? 28 : 27;
                return (e[0] &= 127), new au(iu, t, To(e), r);
              }
              if (65 === n.length) {
                const t = To(n.slice(0, 32)),
                  r = n.slice(32, 64);
                e(0 == (128 & r[0]), "non-canonical s");
                const s = au.getNormalizedV(n[64]);
                return new au(iu, t, To(r), s);
              }
              e(!1, "invalid raw signature length");
            }
            if (t instanceof au) return t.clone();
            const n = t.r;
            e(null != n, "missing r");
            const r = ou(n),
              s = (function (t, n) {
                if (null != t) return ou(t);
                if (null != n) {
                  e(Bo(n, 32), "invalid yParityAndS");
                  const t = Po(n);
                  return (t[0] &= 127), To(t);
                }
                e(!1, "missing s");
              })(t.s, t.yParityAndS);
            e(0 == (128 & Po(s)[0]), "non-canonical s");
            const { networkV: i, v: o } = (function (t, n, r) {
                if (null != t) {
                  const e = Go(t);
                  return {
                    networkV: e >= su ? e : void 0,
                    v: au.getNormalizedV(e),
                  };
                }
                if (null != n)
                  return (
                    e(Bo(n, 32), "invalid yParityAndS"),
                    { v: 128 & Po(n)[0] ? 28 : 27 }
                  );
                if (null != r) {
                  switch (Jo(r, "sig.yParity")) {
                    case 0:
                      return { v: 27 };
                    case 1:
                      return { v: 28 };
                  }
                  e(!1, "invalid yParity");
                }
                e(!1, "missing v");
              })(t.v, t.yParityAndS, t.yParity),
              a = new au(iu, r, s, o);
            return (
              i && (a.#M = i),
              e(
                null == t.yParity || Jo(t.yParity, "sig.yParity") === a.yParity,
                "yParity mismatch"
              ),
              e(
                null == t.yParityAndS || t.yParityAndS === a.yParityAndS,
                "yParityAndS mismatch"
              ),
              a
            );
          }
        }
        qc.hmacSha256Sync = function (t, ...e) {
          return Po(Sl("sha256", t, Oo(e)));
        };
        class lu {
          #j;
          constructor(t) {
            $o(32 === Ro(t), "invalid private key", "privateKey", "[REDACTED]"),
              (this.#j = To(t));
          }
          get privateKey() {
            return this.#j;
          }
          get publicKey() {
            return lu.computePublicKey(this.#j);
          }
          get compressedPublicKey() {
            return lu.computePublicKey(this.#j, !0);
          }
          sign(t) {
            $o(32 === Ro(t), "invalid digest length", "digest", t);
            const [e, n] = Jc(Io(t), Io(this.#j), {
                recovered: !0,
                canonical: !0,
              }),
              r = bc.fromHex(e);
            return au.from({
              r: _o("0x" + r.r.toString(16), 32),
              s: _o("0x" + r.s.toString(16), 32),
              v: n ? 28 : 27,
            });
          }
          computeSharedSecret(t) {
            const e = lu.computePublicKey(t);
            return To(Gc(Io(this.#j), Po(e)));
          }
          static computePublicKey(t, e) {
            let n = Po(t, "key");
            if (32 === n.length) {
              return To(
                (function (t, e = !1) {
                  return gc.fromPrivateKey(t).toRawBytes(e);
                })(n, !!e)
              );
            }
            if (64 === n.length) {
              const t = new Uint8Array(65);
              (t[0] = 4), t.set(n, 1), (n = t);
            }
            return To(gc.fromHex(n).toRawBytes(e));
          }
          static recoverPublicKey(t, e) {
            $o(32 === Ro(t), "invalid digest length", "digest", t);
            const n = au.from(e),
              r = bc.fromCompact(Io(Oo([n.r, n.s]))).toDERRawBytes(),
              s = (function (t, e, n, r = !1) {
                return gc.fromSignature(t, e, n).toRawBytes(r);
              })(Io(t), r, n.yParity);
            return (
              $o(null != s, "invalid signautre for digest", "signature", e),
              To(s)
            );
          }
          static addPoints(t, e, n) {
            const r = gc.fromHex(lu.computePublicKey(t).substring(2)),
              s = gc.fromHex(lu.computePublicKey(e).substring(2));
            return "0x" + r.add(s).toHex(!!n);
          }
        }
        const cu = BigInt(0),
          uu = BigInt(36);
        function du(t) {
          const e = (t = t.toLowerCase()).substring(2).split(""),
            n = new Uint8Array(40);
          for (let t = 0; t < 40; t++) n[t] = e[t].charCodeAt(0);
          const r = Po(_l(n));
          for (let t = 0; t < 40; t += 2)
            r[t >> 1] >> 4 >= 8 && (e[t] = e[t].toUpperCase()),
              (15 & r[t >> 1]) >= 8 && (e[t + 1] = e[t + 1].toUpperCase());
          return "0x" + e.join("");
        }
        const hu = {};
        for (let t = 0; t < 10; t++) hu[String(t)] = String(t);
        for (let t = 0; t < 26; t++)
          hu[String.fromCharCode(65 + t)] = String(10 + t);
        const fu = 15;
        const pu = (function () {
          const t = {};
          for (let e = 0; e < 36; e++) {
            t["0123456789abcdefghijklmnopqrstuvwxyz"[e]] = BigInt(e);
          }
          return t;
        })();
        function gu(t) {
          if (
            ($o("string" == typeof t, "invalid address", "address", t),
            t.match(/^(0x)?[0-9a-fA-F]{40}$/))
          ) {
            t.startsWith("0x") || (t = "0x" + t);
            const e = du(t);
            return (
              $o(
                !t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t,
                "bad address checksum",
                "address",
                t
              ),
              e
            );
          }
          if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            $o(
              t.substring(2, 4) ===
                (function (t) {
                  let e = (t =
                    (t = t.toUpperCase()).substring(4) +
                    t.substring(0, 2) +
                    "00")
                    .split("")
                    .map((t) => hu[t])
                    .join("");
                  for (; e.length >= fu; ) {
                    let t = e.substring(0, fu);
                    e = (parseInt(t, 10) % 97) + e.substring(t.length);
                  }
                  let n = String(98 - (parseInt(e, 10) % 97));
                  for (; n.length < 2; ) n = "0" + n;
                  return n;
                })(t),
              "bad icap checksum",
              "address",
              t
            );
            let e = (function (t) {
              t = t.toLowerCase();
              let e = cu;
              for (let n = 0; n < t.length; n++) e = e * uu + pu[t[n]];
              return e;
            })(t.substring(4)).toString(16);
            for (; e.length < 40; ) e = "0" + e;
            return du("0x" + e);
          }
          $o(!1, "invalid address", "address", t);
        }
        function mu(t) {
          return t && "function" == typeof t.getAddress;
        }
        async function yu(t, e) {
          const n = await e;
          return (
            (null != n && "0x0000000000000000000000000000000000000000" !== n) ||
              (xo(
                "string" != typeof t,
                "unconfigured name",
                "UNCONFIGURED_NAME",
                { value: t }
              ),
              $o(
                !1,
                "invalid AddressLike value; did not resolve to a value address",
                "target",
                t
              )),
            gu(n)
          );
        }
        function bu(t, e) {
          return "string" == typeof t
            ? t.match(/^0x[0-9a-f]{40}$/i)
              ? gu(t)
              : (xo(
                  null != e,
                  "ENS resolution requires a provider",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName" }
                ),
                yu(t, e.resolveName(t)))
            : mu(t)
            ? yu(t, t.getAddress())
            : t && "function" == typeof t.then
            ? yu(t, t)
            : void $o(!1, "unsupported addressable value", "target", t);
        }
        const wu = {};
        function vu(t, e) {
          let n = !1;
          return (
            e < 0 && ((n = !0), (e *= -1)),
            new $u(wu, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e })
          );
        }
        function Au(t, e) {
          return new $u(wu, `bytes${e || ""}`, t, { size: e });
        }
        const xu = Symbol.for("_ethers_typed");
        class $u {
          type;
          value;
          #H;
          _typedSymbol;
          constructor(t, e, n, r) {
            null == r && (r = null),
              Co(wu, t, "Typed"),
              yo(this, { _typedSymbol: xu, type: e, value: n }),
              (this.#H = r),
              this.format();
          }
          format() {
            if ("array" === this.type) throw new Error("");
            if ("dynamicArray" === this.type) throw new Error("");
            return "tuple" === this.type
              ? `tuple(${this.value.map((t) => t.format()).join(",")})`
              : this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return "string" === this.type;
          }
          get tupleName() {
            if ("tuple" !== this.type) throw TypeError("not a tuple");
            return this.#H;
          }
          get arrayLength() {
            if ("array" !== this.type) throw TypeError("not an array");
            return !0 === this.#H
              ? -1
              : !1 === this.#H
              ? this.value.length
              : null;
          }
          static from(t, e) {
            return new $u(wu, t, e);
          }
          static uint8(t) {
            return vu(t, 8);
          }
          static uint16(t) {
            return vu(t, 16);
          }
          static uint24(t) {
            return vu(t, 24);
          }
          static uint32(t) {
            return vu(t, 32);
          }
          static uint40(t) {
            return vu(t, 40);
          }
          static uint48(t) {
            return vu(t, 48);
          }
          static uint56(t) {
            return vu(t, 56);
          }
          static uint64(t) {
            return vu(t, 64);
          }
          static uint72(t) {
            return vu(t, 72);
          }
          static uint80(t) {
            return vu(t, 80);
          }
          static uint88(t) {
            return vu(t, 88);
          }
          static uint96(t) {
            return vu(t, 96);
          }
          static uint104(t) {
            return vu(t, 104);
          }
          static uint112(t) {
            return vu(t, 112);
          }
          static uint120(t) {
            return vu(t, 120);
          }
          static uint128(t) {
            return vu(t, 128);
          }
          static uint136(t) {
            return vu(t, 136);
          }
          static uint144(t) {
            return vu(t, 144);
          }
          static uint152(t) {
            return vu(t, 152);
          }
          static uint160(t) {
            return vu(t, 160);
          }
          static uint168(t) {
            return vu(t, 168);
          }
          static uint176(t) {
            return vu(t, 176);
          }
          static uint184(t) {
            return vu(t, 184);
          }
          static uint192(t) {
            return vu(t, 192);
          }
          static uint200(t) {
            return vu(t, 200);
          }
          static uint208(t) {
            return vu(t, 208);
          }
          static uint216(t) {
            return vu(t, 216);
          }
          static uint224(t) {
            return vu(t, 224);
          }
          static uint232(t) {
            return vu(t, 232);
          }
          static uint240(t) {
            return vu(t, 240);
          }
          static uint248(t) {
            return vu(t, 248);
          }
          static uint256(t) {
            return vu(t, 256);
          }
          static uint(t) {
            return vu(t, 256);
          }
          static int8(t) {
            return vu(t, -8);
          }
          static int16(t) {
            return vu(t, -16);
          }
          static int24(t) {
            return vu(t, -24);
          }
          static int32(t) {
            return vu(t, -32);
          }
          static int40(t) {
            return vu(t, -40);
          }
          static int48(t) {
            return vu(t, -48);
          }
          static int56(t) {
            return vu(t, -56);
          }
          static int64(t) {
            return vu(t, -64);
          }
          static int72(t) {
            return vu(t, -72);
          }
          static int80(t) {
            return vu(t, -80);
          }
          static int88(t) {
            return vu(t, -88);
          }
          static int96(t) {
            return vu(t, -96);
          }
          static int104(t) {
            return vu(t, -104);
          }
          static int112(t) {
            return vu(t, -112);
          }
          static int120(t) {
            return vu(t, -120);
          }
          static int128(t) {
            return vu(t, -128);
          }
          static int136(t) {
            return vu(t, -136);
          }
          static int144(t) {
            return vu(t, -144);
          }
          static int152(t) {
            return vu(t, -152);
          }
          static int160(t) {
            return vu(t, -160);
          }
          static int168(t) {
            return vu(t, -168);
          }
          static int176(t) {
            return vu(t, -176);
          }
          static int184(t) {
            return vu(t, -184);
          }
          static int192(t) {
            return vu(t, -192);
          }
          static int200(t) {
            return vu(t, -200);
          }
          static int208(t) {
            return vu(t, -208);
          }
          static int216(t) {
            return vu(t, -216);
          }
          static int224(t) {
            return vu(t, -224);
          }
          static int232(t) {
            return vu(t, -232);
          }
          static int240(t) {
            return vu(t, -240);
          }
          static int248(t) {
            return vu(t, -248);
          }
          static int256(t) {
            return vu(t, -256);
          }
          static int(t) {
            return vu(t, -256);
          }
          static bytes1(t) {
            return Au(t, 1);
          }
          static bytes2(t) {
            return Au(t, 2);
          }
          static bytes3(t) {
            return Au(t, 3);
          }
          static bytes4(t) {
            return Au(t, 4);
          }
          static bytes5(t) {
            return Au(t, 5);
          }
          static bytes6(t) {
            return Au(t, 6);
          }
          static bytes7(t) {
            return Au(t, 7);
          }
          static bytes8(t) {
            return Au(t, 8);
          }
          static bytes9(t) {
            return Au(t, 9);
          }
          static bytes10(t) {
            return Au(t, 10);
          }
          static bytes11(t) {
            return Au(t, 11);
          }
          static bytes12(t) {
            return Au(t, 12);
          }
          static bytes13(t) {
            return Au(t, 13);
          }
          static bytes14(t) {
            return Au(t, 14);
          }
          static bytes15(t) {
            return Au(t, 15);
          }
          static bytes16(t) {
            return Au(t, 16);
          }
          static bytes17(t) {
            return Au(t, 17);
          }
          static bytes18(t) {
            return Au(t, 18);
          }
          static bytes19(t) {
            return Au(t, 19);
          }
          static bytes20(t) {
            return Au(t, 20);
          }
          static bytes21(t) {
            return Au(t, 21);
          }
          static bytes22(t) {
            return Au(t, 22);
          }
          static bytes23(t) {
            return Au(t, 23);
          }
          static bytes24(t) {
            return Au(t, 24);
          }
          static bytes25(t) {
            return Au(t, 25);
          }
          static bytes26(t) {
            return Au(t, 26);
          }
          static bytes27(t) {
            return Au(t, 27);
          }
          static bytes28(t) {
            return Au(t, 28);
          }
          static bytes29(t) {
            return Au(t, 29);
          }
          static bytes30(t) {
            return Au(t, 30);
          }
          static bytes31(t) {
            return Au(t, 31);
          }
          static bytes32(t) {
            return Au(t, 32);
          }
          static address(t) {
            return new $u(wu, "address", t);
          }
          static bool(t) {
            return new $u(wu, "bool", !!t);
          }
          static bytes(t) {
            return new $u(wu, "bytes", t);
          }
          static string(t) {
            return new $u(wu, "string", t);
          }
          static array(t, e) {
            throw new Error("not implemented yet");
          }
          static tuple(t, e) {
            throw new Error("not implemented yet");
          }
          static overrides(t) {
            return new $u(wu, "overrides", Object.assign({}, t));
          }
          static isTyped(t) {
            return (
              t &&
              "object" == typeof t &&
              "_typedSymbol" in t &&
              t._typedSymbol === xu
            );
          }
          static dereference(t, e) {
            if ($u.isTyped(t)) {
              if (t.type !== e)
                throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
              return t.value;
            }
            return t;
          }
        }
        class ku extends Va {
          constructor(t) {
            super("address", "address", t, !1);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(t, e) {
            let n = $u.dereference(e, "string");
            try {
              n = gu(n);
            } catch (t) {
              return this._throwError(t.message, e);
            }
            return t.writeValue(n);
          }
          decode(t) {
            return gu(_o(t.readValue(), 20));
          }
        }
        class Eu extends Va {
          coder;
          constructor(t) {
            super(t.name, t.type, "_", t.dynamic), (this.coder = t);
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(t, e) {
            return this.coder.encode(t, e);
          }
          decode(t) {
            return this.coder.decode(t);
          }
        }
        function Cu(t, e, n) {
          let r = [];
          if (Array.isArray(n)) r = n;
          else if (n && "object" == typeof n) {
            let t = {};
            r = e.map((e) => {
              const r = e.localName;
              return (
                xo(
                  r,
                  "cannot encode object for signature with missing names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                xo(
                  !t[r],
                  "cannot encode object for signature with duplicate names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: e }, value: n }
                ),
                (t[r] = !0),
                n[r]
              );
            });
          } else $o(!1, "invalid tuple value", "tuple", n);
          $o(e.length === r.length, "types/value length mismatch", "tuple", n);
          let s = new Qa(),
            i = new Qa(),
            o = [];
          e.forEach((t, e) => {
            let n = r[e];
            if (t.dynamic) {
              let e = i.length;
              t.encode(i, n);
              let r = s.writeUpdatableValue();
              o.push((t) => {
                r(t + e);
              });
            } else t.encode(s, n);
          }),
            o.forEach((t) => {
              t(s.length);
            });
          let a = t.appendWriter(s);
          return (a += t.appendWriter(i)), a;
        }
        function Su(t, e) {
          let n = [],
            r = [],
            s = t.subReader(0);
          return (
            e.forEach((e) => {
              let i = null;
              if (e.dynamic) {
                let n = t.readIndex(),
                  r = s.subReader(n);
                try {
                  i = e.decode(r);
                } catch (t) {
                  if (wo(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              } else
                try {
                  i = e.decode(t);
                } catch (t) {
                  if (wo(t, "BUFFER_OVERRUN")) throw t;
                  (i = t),
                    (i.baseType = e.name),
                    (i.name = e.localName),
                    (i.type = e.type);
                }
              if (null == i) throw new Error("investigate");
              n.push(i), r.push(e.localName || null);
            }),
            Ha.fromItems(n, r)
          );
        }
        class Pu extends Va {
          coder;
          length;
          constructor(t, e, n) {
            super(
              "array",
              t.type + "[" + (e >= 0 ? e : "") + "]",
              n,
              -1 === e || t.dynamic
            ),
              yo(this, { coder: t, length: e });
          }
          defaultValue() {
            const t = this.coder.defaultValue(),
              e = [];
            for (let n = 0; n < this.length; n++) e.push(t);
            return e;
          }
          encode(t, e) {
            const n = $u.dereference(e, "array");
            Array.isArray(n) || this._throwError("expected array value", n);
            let r = this.length;
            -1 === r && ((r = n.length), t.writeValue(n.length)),
              ko(
                n.length,
                r,
                "coder array" + (this.localName ? " " + this.localName : "")
              );
            let s = [];
            for (let t = 0; t < n.length; t++) s.push(this.coder);
            return Cu(t, s, n);
          }
          decode(t) {
            let e = this.length;
            -1 === e &&
              ((e = t.readIndex()),
              xo(
                e * Ua <= t.dataLength,
                "insufficient data length",
                "BUFFER_OVERRUN",
                { buffer: t.bytes, offset: e * Ua, length: t.dataLength }
              ));
            let n = [];
            for (let t = 0; t < e; t++) n.push(new Eu(this.coder));
            return Su(t, n);
          }
        }
        class Iu extends Va {
          constructor(t) {
            super("bool", "bool", t, !1);
          }
          defaultValue() {
            return !1;
          }
          encode(t, e) {
            const n = $u.dereference(e, "bool");
            return t.writeValue(n ? 1 : 0);
          }
          decode(t) {
            return !!t.readValue();
          }
        }
        class Bu extends Va {
          constructor(t, e) {
            super(t, t, e, !0);
          }
          defaultValue() {
            return "0x";
          }
          encode(t, e) {
            e = Io(e);
            let n = t.writeValue(e.length);
            return (n += t.writeBytes(e)), n;
          }
          decode(t) {
            return t.readBytes(t.readIndex(), !0);
          }
        }
        class Nu extends Bu {
          constructor(t) {
            super("bytes", t);
          }
          decode(t) {
            return To(super.decode(t));
          }
        }
        class Tu extends Va {
          size;
          constructor(t, e) {
            let n = "bytes" + String(t);
            super(n, n, e, !1), yo(this, { size: t }, { size: "number" });
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + 2 * this.size
            );
          }
          encode(t, e) {
            let n = Io($u.dereference(e, this.type));
            return (
              n.length !== this.size &&
                this._throwError("incorrect data length", e),
              t.writeBytes(n)
            );
          }
          decode(t) {
            return To(t.readBytes(this.size));
          }
        }
        const Ou = new Uint8Array([]);
        class Ru extends Va {
          constructor(t) {
            super("null", "", t, !1);
          }
          defaultValue() {
            return null;
          }
          encode(t, e) {
            return (
              null != e && this._throwError("not null", e), t.writeBytes(Ou)
            );
          }
          decode(t) {
            return t.readBytes(0), null;
          }
        }
        const Lu = BigInt(0),
          zu = BigInt(1),
          Uu = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        class Fu extends Va {
          size;
          signed;
          constructor(t, e, n) {
            const r = (e ? "int" : "uint") + 8 * t;
            super(r, r, n, !1),
              yo(
                this,
                { size: t, signed: e },
                { size: "number", signed: "boolean" }
              );
          }
          defaultValue() {
            return 0;
          }
          encode(t, e) {
            let n = Go($u.dereference(e, this.type)),
              r = Ho(Uu, 256);
            if (this.signed) {
              let t = Ho(r, 8 * this.size - 1);
              (n > t || n < -(t + zu)) &&
                this._throwError("value out-of-bounds", e),
                (n = jo(n, 256));
            } else
              (n < Lu || n > Ho(r, 8 * this.size)) &&
                this._throwError("value out-of-bounds", e);
            return t.writeValue(n);
          }
          decode(t) {
            let e = Ho(t.readValue(), 8 * this.size);
            return this.signed && (e = Mo(e, 8 * this.size)), e;
          }
        }
        class Du extends Bu {
          constructor(t) {
            super("string", t);
          }
          defaultValue() {
            return "";
          }
          encode(t, e) {
            return super.encode(t, ea($u.dereference(e, "string")));
          }
          decode(t) {
            return na(super.decode(t));
          }
        }
        class Mu extends Va {
          coders;
          constructor(t, e) {
            let n = !1;
            const r = [];
            t.forEach((t) => {
              t.dynamic && (n = !0), r.push(t.type);
            });
            super("tuple", "tuple(" + r.join(",") + ")", e, n),
              yo(this, { coders: Object.freeze(t.slice()) });
          }
          defaultValue() {
            const t = [];
            this.coders.forEach((e) => {
              t.push(e.defaultValue());
            });
            const e = this.coders.reduce((t, e) => {
              const n = e.localName;
              return n && (t[n] || (t[n] = 0), t[n]++), t;
            }, {});
            return (
              this.coders.forEach((n, r) => {
                let s = n.localName;
                s &&
                  1 === e[s] &&
                  ("length" === s && (s = "_length"),
                  null == t[s] && (t[s] = t[r]));
              }),
              Object.freeze(t)
            );
          }
          encode(t, e) {
            const n = $u.dereference(e, "tuple");
            return Cu(t, this.coders, n);
          }
          decode(t) {
            return Su(t, this.coders);
          }
        }
        function ju(t) {
          return _l(ea(t));
        }
        function Hu(t) {
          return (function (t) {
            let e = 0;
            return () => t[e++];
          })(
            (function (t) {
              let e = 0;
              function n() {
                return (t[e++] << 8) | t[e++];
              }
              let r = n(),
                s = 1,
                i = [0, 1];
              for (let t = 1; t < r; t++) i.push((s += n()));
              let o = n(),
                a = e;
              e += o;
              let l = 0,
                c = 0;
              function u() {
                return (
                  0 == l && ((c = (c << 8) | t[e++]), (l = 8)), (c >> --l) & 1
                );
              }
              const d = 2 ** 31,
                h = d >>> 1,
                f = d - 1;
              let p = 0;
              for (let t = 0; t < 31; t++) p = (p << 1) | u();
              let g = [],
                m = 0,
                y = d;
              for (;;) {
                let t = Math.floor(((p - m + 1) * s - 1) / y),
                  e = 0,
                  n = r;
                for (; n - e > 1; ) {
                  let r = (e + n) >>> 1;
                  t < i[r] ? (n = r) : (e = r);
                }
                if (0 == e) break;
                g.push(e);
                let o = m + Math.floor((y * i[e]) / s),
                  a = m + Math.floor((y * i[e + 1]) / s) - 1;
                for (; 0 == ((o ^ a) & h); )
                  (p = ((p << 1) & f) | u()),
                    (o = (o << 1) & f),
                    (a = ((a << 1) & f) | 1);
                for (; o & ~a & 536870912; )
                  (p = (p & h) | ((p << 1) & (f >>> 1)) | u()),
                    (o = (o << 1) ^ h),
                    (a = ((a ^ h) << 1) | h | 1);
                (m = o), (y = 1 + a - o);
              }
              let b = r - 4;
              return g.map((e) => {
                switch (e - b) {
                  case 3:
                    return (
                      b + 65792 + ((t[a++] << 16) | (t[a++] << 8) | t[a++])
                    );
                  case 2:
                    return b + 256 + ((t[a++] << 8) | t[a++]);
                  case 1:
                    return b + t[a++];
                  default:
                    return e - 1;
                }
              });
            })(
              (function (t) {
                let e = [];
                [
                  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                ].forEach((t, n) => (e[t.charCodeAt(0)] = n));
                let n = t.length,
                  r = new Uint8Array((6 * n) >> 3);
                for (let s = 0, i = 0, o = 0, a = 0; s < n; s++)
                  (a = (a << 6) | e[t.charCodeAt(s)]),
                    (o += 6),
                    o >= 8 && (r[i++] = a >> (o -= 8));
                return r;
              })(t)
            )
          );
        }
        function Gu(t) {
          return 1 & t ? ~t >> 1 : t >> 1;
        }
        function Vu(t, e) {
          let n = Array(t);
          for (let r = 0, s = 0; r < t; r++) n[r] = s += Gu(e());
          return n;
        }
        function Qu(t, e = 0) {
          let n = [];
          for (;;) {
            let r = t(),
              s = t();
            if (!s) break;
            e += r;
            for (let t = 0; t < s; t++) n.push(e + t);
            e += s + 1;
          }
          return n;
        }
        function Wu(t) {
          return _u(() => {
            let e = Qu(t);
            if (e.length) return e;
          });
        }
        function Ju(t) {
          let e = [];
          for (;;) {
            let n = t();
            if (0 == n) break;
            e.push(qu(n, t));
          }
          for (;;) {
            let n = t() - 1;
            if (n < 0) break;
            e.push(Yu(n, t));
          }
          return e.flat();
        }
        function _u(t) {
          let e = [];
          for (;;) {
            let n = t(e.length);
            if (!n) break;
            e.push(n);
          }
          return e;
        }
        function Ku(t, e, n) {
          let r = Array(t)
            .fill()
            .map(() => []);
          for (let s = 0; s < e; s++) Vu(t, n).forEach((t, e) => r[e].push(t));
          return r;
        }
        function qu(t, e) {
          let n = 1 + e(),
            r = e(),
            s = _u(e);
          return Ku(s.length, 1 + t, e).flatMap((t, e) => {
            let [i, ...o] = t;
            return Array(s[e])
              .fill()
              .map((t, e) => {
                let s = e * r;
                return [i + e * n, o.map((t) => t + s)];
              });
          });
        }
        function Yu(t, e) {
          return Ku(1 + e(), 1 + t, e).map((t) => [t[0], t.slice(1)]);
        }
        var Zu = Hu(
          "AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE"
        );
        const Xu = new Map([
            [8217, "apostrophe"],
            [8260, "fraction slash"],
            [12539, "middle dot"],
          ]),
          td = 4;
        function ed(t) {
          return `{${(function (t) {
            return t.toString(16).toUpperCase().padStart(2, "0");
          })(t)}}`;
        }
        function nd(t) {
          let e = t.length;
          if (e < 4096) return String.fromCodePoint(...t);
          let n = [];
          for (let r = 0; r < e; )
            n.push(String.fromCodePoint(...t.slice(r, (r += 4096))));
          return n.join("");
        }
        var rd = Hu(
          "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g"
        );
        function sd(t) {
          return (t >> 24) & 255;
        }
        function id(t) {
          return 16777215 & t;
        }
        const od = new Map(
            Wu(rd).flatMap((t, e) => t.map((t) => [t, (e + 1) << 24]))
          ),
          ad = new Set(Qu(rd)),
          ld = new Map(),
          cd = new Map();
        for (let [t, e] of Ju(rd)) {
          if (!ad.has(t) && 2 == e.length) {
            let [n, r] = e,
              s = cd.get(n);
            s || ((s = new Map()), cd.set(n, s)), s.set(r, t);
          }
          ld.set(t, e.reverse());
        }
        const ud = 44032,
          dd = 4352,
          hd = 4449,
          fd = 4519,
          pd = 28,
          gd = 21 * pd,
          md = ud + 19 * gd,
          yd = dd + 19,
          bd = hd + 21,
          wd = fd + pd;
        function vd(t) {
          return t >= ud && t < md;
        }
        function Ad(t, e) {
          if (t >= dd && t < yd && e >= hd && e < bd)
            return ud + (t - dd) * gd + (e - hd) * pd;
          if (vd(t) && e > fd && e < wd && (t - ud) % pd == 0)
            return t + (e - fd);
          {
            let n = cd.get(t);
            return n && ((n = n.get(e)), n) ? n : -1;
          }
        }
        function xd(t) {
          let e = [],
            n = [],
            r = !1;
          function s(t) {
            let n = od.get(t);
            n && ((r = !0), (t |= n)), e.push(t);
          }
          for (let r of t)
            for (;;) {
              if (r < 128) e.push(r);
              else if (vd(r)) {
                let t = r - ud,
                  e = ((t % gd) / pd) | 0,
                  n = t % pd;
                s(dd + ((t / gd) | 0)), s(hd + e), n > 0 && s(fd + n);
              } else {
                let t = ld.get(r);
                t ? n.push(...t) : s(r);
              }
              if (!n.length) break;
              r = n.pop();
            }
          if (r && e.length > 1) {
            let t = sd(e[0]);
            for (let n = 1; n < e.length; n++) {
              let r = sd(e[n]);
              if (0 == r || t <= r) {
                t = r;
                continue;
              }
              let s = n - 1;
              for (;;) {
                let n = e[s + 1];
                if (((e[s + 1] = e[s]), (e[s] = n), !s)) break;
                if (((t = sd(e[--s])), t <= r)) break;
              }
              t = sd(e[n]);
            }
          }
          return e;
        }
        function $d(t) {
          return xd(t).map(id);
        }
        function kd(t) {
          return (function (t) {
            let e = [],
              n = [],
              r = -1,
              s = 0;
            for (let i of t) {
              let t = sd(i),
                o = id(i);
              if (-1 == r) 0 == t ? (r = o) : e.push(o);
              else if (s > 0 && s >= t)
                0 == t ? (e.push(r, ...n), (n.length = 0), (r = o)) : n.push(o),
                  (s = t);
              else {
                let i = Ad(r, o);
                i >= 0
                  ? (r = i)
                  : 0 == s && 0 == t
                  ? (e.push(r), (r = o))
                  : (n.push(o), (s = t));
              }
            }
            return r >= 0 && e.push(r, ...n), e;
          })(xd(t));
        }
        const Ed = 65039,
          Cd = ".",
          Sd = 1,
          Pd = 45;
        function Id() {
          return new Set(Qu(Zu));
        }
        const Bd = new Map(Ju(Zu)),
          Nd = Id(),
          Td = Id(),
          Od = new Set(
            Qu(Zu).map(
              function (t) {
                return this[t];
              },
              [...Td]
            )
          ),
          Rd = Id();
        Id();
        const Ld = Wu(Zu);
        function zd() {
          return new Set([Qu(Zu).map((t) => Ld[t]), Qu(Zu)].flat(2));
        }
        const Ud = Zu(),
          Fd = _u((t) => {
            let e = _u(Zu).map((t) => t + 96);
            if (e.length) {
              let n = t >= Ud;
              (e[0] -= 32), (e = nd(e)), n && (e = `Restricted[${e}]`);
              let r = zd(),
                s = zd(),
                i = [...r, ...s].sort((t, e) => t - e);
              return { N: e, P: r, M: !Zu(), R: n, V: new Set(i) };
            }
          }),
          Dd = Id(),
          Md = new Map();
        [...Dd, ...Id()]
          .sort((t, e) => t - e)
          .map((t, e, n) => {
            let r = Zu(),
              s = (n[e] = r ? n[e - r] : { V: [], M: new Map() });
            s.V.push(t), Dd.has(t) || Md.set(t, s);
          });
        for (let { V: t, M: e } of new Set(Md.values())) {
          let n = [];
          for (let e of t) {
            let t = Fd.filter((t) => t.V.has(e)),
              r = n.find(({ G: e }) => t.some((t) => e.has(t)));
            r || ((r = { G: new Set(), V: [] }), n.push(r)),
              r.V.push(e),
              t.forEach((t) => r.G.add(t));
          }
          let r = n.flatMap(({ G: t }) => [...t]);
          for (let { G: t, V: s } of n) {
            let n = new Set(r.filter((e) => !t.has(e)));
            for (let t of s) e.set(t, n);
          }
        }
        let jd = new Set(),
          Hd = new Set();
        for (let t of Fd) for (let e of t.V) (jd.has(e) ? Hd : jd).add(e);
        for (let t of jd) Md.has(t) || Hd.has(t) || Md.set(t, Sd);
        const Gd = new Set([...jd, ...$d(jd)]),
          Vd = Qu(Zu),
          Qd = (function t(e) {
            let n = _u(() => {
                let e = Qu(Zu).map((t) => Vd[t]);
                if (e.length) return t(e);
              }).sort((t, e) => e.Q.size - t.Q.size),
              r = Zu(),
              s = r % 3;
            r = (r / 3) | 0;
            let i = 1 & r;
            r >>= 1;
            let o = 1 & r,
              a = 2 & r;
            return { B: n, V: s, F: i, S: o, C: a, Q: new Set(e) };
          })([]);
        class Wd extends Array {
          get is_emoji() {
            return !0;
          }
        }
        function Jd(t, e = ed) {
          let n = [];
          var r;
          (r = t[0]), Td.has(r) && n.push("◌");
          let s = 0,
            i = t.length;
          for (let r = 0; r < i; r++) {
            let i = t[r];
            Yd(i) && (n.push(nd(t.slice(s, r))), n.push(e(i)), (s = r + 1));
          }
          return n.push(nd(t.slice(s, i))), n.join("");
        }
        function _d(t) {
          return (Yd(t) ? "" : `${Kd(Jd([t]))} `) + ed(t);
        }
        function Kd(t) {
          return `"${t}"‎`;
        }
        function qd(t) {
          for (let e = t.lastIndexOf(95); e > 0; )
            if (95 !== t[--e])
              throw new Error("underscore allowed only at start");
        }
        function Yd(t) {
          return Rd.has(t);
        }
        function Zd(t) {
          return (function (t) {
            return t
              .map(({ input: e, error: n, output: r }) => {
                if (n) {
                  let r = n.message;
                  throw new Error(
                    1 == t.length ? r : `Invalid label ${Kd(Jd(e))}: ${r}`
                  );
                }
                return nd(r);
              })
              .join(Cd);
          })(
            (function (t, e) {
              let n = 0;
              return t.split(Cd).map((t) => {
                let r,
                  s = (function (t) {
                    let e = [];
                    for (let n = 0, r = t.length; n < r; ) {
                      let r = t.codePointAt(n);
                      (n += r < 65536 ? 1 : 2), e.push(r);
                    }
                    return e;
                  })(t),
                  i = { input: s, offset: n };
                n += s.length + 1;
                try {
                  let t,
                    n = (i.tokens = (function (t, e) {
                      let n = [],
                        r = [];
                      t = t.slice().reverse();
                      for (; t.length; ) {
                        let s = nh(t);
                        if (s) r.length && (n.push(e(r)), (r = [])), n.push(s);
                        else {
                          let e = t.pop();
                          if (Gd.has(e)) r.push(e);
                          else {
                            let t = Bd.get(e);
                            if (t) r.push(...t);
                            else if (!Nd.has(e)) throw Xd(e);
                          }
                        }
                      }
                      r.length && n.push(e(r));
                      return n;
                    })(s, kd)),
                    o = n.length;
                  if (!o) throw new Error("empty label");
                  {
                    let s = n[0],
                      a = o > 1 || s.is_emoji;
                    if (!a && s.every((t) => t < 128))
                      (r = s),
                        qd(r),
                        (function (t) {
                          if (t.length >= 4 && t[2] == Pd && t[3] == Pd)
                            throw new Error("invalid label extension");
                        })(r),
                        (t = "ASCII");
                    else if (
                      (a &&
                        ((i.emoji = !0),
                        (s = n.flatMap((t) => (t.is_emoji ? [] : t)))),
                      (r = n.flatMap((t) =>
                        !e && t.is_emoji ? t.filter((t) => t != Ed) : t
                      )),
                      qd(r),
                      s.length)
                    ) {
                      if (Td.has(r[0])) throw eh("leading combining mark");
                      for (let t = 1; t < o; t++) {
                        let e = n[t];
                        if (!e.is_emoji && Td.has(e[0]))
                          throw eh(
                            `emoji + combining mark: "${nd(n[t - 1])} + ${Jd([
                              e[0],
                            ])}"`
                          );
                      }
                      !(function (t) {
                        let e = t[0],
                          n = Xu.get(e);
                        if (n) throw eh(`leading ${n}`);
                        let r = t.length,
                          s = -1;
                        for (let i = 1; i < r; i++) {
                          e = t[i];
                          let r = Xu.get(e);
                          if (r) {
                            if (s == i) throw eh(`${n} + ${r}`);
                            (s = i + 1), (n = r);
                          }
                        }
                        if (s == r) throw eh(`trailing ${n}`);
                      })(r);
                      let e = [...new Set(s)],
                        [i] = (function (t) {
                          let e = Fd;
                          for (let n of t) {
                            let t = e.filter((t) => t.V.has(n));
                            if (!t.length) throw e === Fd ? Xd(n) : th(e[0], n);
                            if (((e = t), 1 == t.length)) break;
                          }
                          return e;
                        })(e);
                      !(function (t, e) {
                        let { V: n, M: r } = t;
                        for (let r of e) if (!n.has(r)) throw th(t, r);
                        if (r) {
                          let t = $d(e);
                          for (let e = 1, n = t.length; e < n; e++)
                            if (Od.has(t[e])) {
                              let r = e + 1;
                              for (let s; r < n && Od.has((s = t[r])); r++)
                                for (let n = e; n < r; n++)
                                  if (t[n] == s)
                                    throw new Error(
                                      `non-spacing marks: repeated ${_d(s)}`
                                    );
                              if (r - e > td)
                                throw new Error(
                                  `non-spacing marks: too many ${Kd(
                                    Jd(t.slice(e - 1, r))
                                  )} (${r - e}/${td})`
                                );
                              e = r;
                            }
                        }
                      })(i, s),
                        (function (t, e) {
                          let n,
                            r = [];
                          for (let t of e) {
                            let e = Md.get(t);
                            if (e === Sd) return;
                            if (e) {
                              let r = e.M.get(t);
                              if (
                                ((n = n ? n.filter((t) => r.has(t)) : [...r]),
                                !n.length)
                              )
                                return;
                            } else r.push(t);
                          }
                          if (n)
                            for (let e of n)
                              if (r.every((t) => e.V.has(t)))
                                throw new Error(
                                  `whole-script confusable: ${t.N}/${e.N}`
                                );
                        })(i, e),
                        (t = i.N);
                    } else t = "Emoji";
                  }
                  i.type = t;
                } catch (t) {
                  i.error = t;
                }
                return (i.output = r), i;
              });
            })(t)
          );
        }
        function Xd(t) {
          return new Error(`disallowed character: ${_d(t)}`);
        }
        function th(t, e) {
          let n = _d(e),
            r = Fd.find((t) => t.P.has(e));
          return (
            r && (n = `${r.N} ${n}`),
            new Error(`illegal mixture: ${t.N} + ${n}`)
          );
        }
        function eh(t) {
          return new Error(`illegal placement: ${t}`);
        }
        function nh(t, e) {
          let n,
            r,
            s = Qd,
            i = [],
            o = t.length;
          for (e && (e.length = 0); o; ) {
            let a = t[--o];
            if (((s = s.B.find((t) => t.Q.has(a))), !s)) break;
            if (s.S) r = a;
            else if (s.C && a === r) break;
            i.push(a),
              s.F && (i.push(Ed), o > 0 && t[o - 1] == Ed && o--),
              s.V &&
                ((n = rh(i, s)),
                e && e.push(...t.slice(o).reverse()),
                (t.length = o));
          }
          return n;
        }
        function rh(t, e) {
          let n = Wd.from(t);
          return 2 == e.V && n.splice(1, 1), n;
        }
        const sh = new Uint8Array(32);
        function ih(t) {
          return (
            $o(0 !== t.length, "invalid ENS name; empty component", "comp", t),
            t
          );
        }
        function oh(t) {
          const e = ea(
              (function (t) {
                try {
                  return Zd(t);
                } catch (e) {
                  $o(!1, `invalid ENS name (${e.message})`, "name", t);
                }
              })(t)
            ),
            n = [];
          if (0 === t.length) return n;
          let r = 0;
          for (let t = 0; t < e.length; t++) {
            46 === e[t] && (n.push(ih(e.slice(r, t))), (r = t + 1));
          }
          return (
            $o(r < e.length, "invalid ENS name; empty component", "name", t),
            n.push(ih(e.slice(r))),
            n
          );
        }
        function ah(t) {
          $o("string" == typeof t, "invalid ENS name; not a string", "name", t);
          let e = sh;
          const n = oh(t);
          for (; n.length; ) e = _l(Oo([e, _l(n.pop())]));
          return To(e);
        }
        function lh(t, e) {
          return {
            address: gu(t),
            storageKeys: e.map(
              (t, e) => (
                $o(Bo(t, 32), "invalid slot", `storageKeys[${e}]`, t),
                t.toLowerCase()
              )
            ),
          };
        }
        function ch(t) {
          if (Array.isArray(t))
            return t.map((e, n) =>
              Array.isArray(e)
                ? ($o(2 === e.length, "invalid slot set", `value[${n}]`, e),
                  lh(e[0], e[1]))
                : ($o(
                    null != e && "object" == typeof e,
                    "invalid address-slot set",
                    "value",
                    t
                  ),
                  lh(e.address, e.storageKeys))
            );
          $o(
            null != t && "object" == typeof t,
            "invalid access list",
            "value",
            t
          );
          const e = Object.keys(t).map((e) => {
            const n = t[e].reduce((t, e) => ((t[e] = !0), t), {});
            return lh(e, Object.keys(n).sort());
          });
          return e.sort((t, e) => t.address.localeCompare(e.address)), e;
        }
        function uh(t, e) {
          return (function (t) {
            let e;
            return (
              (e =
                "string" == typeof t
                  ? lu.computePublicKey(t, !1)
                  : t.publicKey),
              gu(_l("0x" + e.substring(4)).substring(26))
            );
          })(lu.recoverPublicKey(t, e));
        }
        sh.fill(0);
        const dh = BigInt(0),
          hh = BigInt(2),
          fh = BigInt(27),
          ph = BigInt(28),
          gh = BigInt(35),
          mh = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        function yh(t) {
          return "0x" === t ? null : gu(t);
        }
        function bh(t, e) {
          try {
            return ch(t);
          } catch (n) {
            $o(!1, n.message, e, t);
          }
        }
        function wh(t, e) {
          return "0x" === t ? 0 : Jo(t, e);
        }
        function vh(t, e) {
          if ("0x" === t) return dh;
          const n = Go(t, e);
          return $o(n <= mh, "value exceeds uint size", e, n), n;
        }
        function Ah(t, e) {
          const n = Go(t, "value"),
            r = Ko(n);
          return $o(r.length <= 32, "value too large", `tx.${e}`, n), r;
        }
        function xh(t) {
          return ch(t).map((t) => [t.address, t.storageKeys]);
        }
        function $h(t, e) {
          const n = [
            Ah(t.nonce || 0, "nonce"),
            Ah(t.gasPrice || 0, "gasPrice"),
            Ah(t.gasLimit || 0, "gasLimit"),
            null != t.to ? gu(t.to) : "0x",
            Ah(t.value || 0, "value"),
            t.data || "0x",
          ];
          let r = dh;
          if (t.chainId != dh)
            (r = Go(t.chainId, "tx.chainId")),
              $o(
                !e || null == e.networkV || e.legacyChainId === r,
                "tx.chainId/sig.v mismatch",
                "sig",
                e
              );
          else if (t.signature) {
            const e = t.signature.legacyChainId;
            null != e && (r = e);
          }
          if (!e)
            return (
              r !== dh && (n.push(Ko(r)), n.push("0x"), n.push("0x")), Ra(n)
            );
          let s = BigInt(27 + e.yParity);
          return (
            r !== dh
              ? (s = au.getChainIdV(r, e.v))
              : BigInt(e.v) !== s &&
                $o(!1, "tx.chainId/sig.v mismatch", "sig", e),
            n.push(Ko(s)),
            n.push(Ko(e.r)),
            n.push(Ko(e.s)),
            Ra(n)
          );
        }
        function kh(t, e) {
          let n;
          try {
            if (((n = wh(e[0], "yParity")), 0 !== n && 1 !== n))
              throw new Error("bad yParity");
          } catch (t) {
            $o(!1, "invalid yParity", "yParity", e[0]);
          }
          const r = zo(e[1], 32),
            s = zo(e[2], 32),
            i = au.from({ r: r, s: s, yParity: n });
          t.signature = i;
        }
        function Eh(t, e) {
          const n = [
            Ah(t.chainId || 0, "chainId"),
            Ah(t.nonce || 0, "nonce"),
            Ah(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
            Ah(t.maxFeePerGas || 0, "maxFeePerGas"),
            Ah(t.gasLimit || 0, "gasLimit"),
            null != t.to ? gu(t.to) : "0x",
            Ah(t.value || 0, "value"),
            t.data || "0x",
            xh(t.accessList || []),
          ];
          return (
            e &&
              (n.push(Ah(e.yParity, "yParity")),
              n.push(Ko(e.r)),
              n.push(Ko(e.s))),
            Oo(["0x02", Ra(n)])
          );
        }
        function Ch(t, e) {
          const n = [
            Ah(t.chainId || 0, "chainId"),
            Ah(t.nonce || 0, "nonce"),
            Ah(t.gasPrice || 0, "gasPrice"),
            Ah(t.gasLimit || 0, "gasLimit"),
            null != t.to ? gu(t.to) : "0x",
            Ah(t.value || 0, "value"),
            t.data || "0x",
            xh(t.accessList || []),
          ];
          return (
            e &&
              (n.push(Ah(e.yParity, "recoveryParam")),
              n.push(Ko(e.r)),
              n.push(Ko(e.s))),
            Oo(["0x01", Ra(n)])
          );
        }
        class Sh {
          #G;
          #V;
          #T;
          #Q;
          #W;
          #J;
          #_;
          #K;
          #q;
          #Y;
          #Z;
          #X;
          get type() {
            return this.#G;
          }
          set type(t) {
            switch (t) {
              case null:
                this.#G = null;
                break;
              case 0:
              case "legacy":
                this.#G = 0;
                break;
              case 1:
              case "berlin":
              case "eip-2930":
                this.#G = 1;
                break;
              case 2:
              case "london":
              case "eip-1559":
                this.#G = 2;
                break;
              default:
                $o(!1, "unsupported transaction type", "type", t);
            }
          }
          get typeName() {
            switch (this.type) {
              case 0:
                return "legacy";
              case 1:
                return "eip-2930";
              case 2:
                return "eip-1559";
            }
            return null;
          }
          get to() {
            return this.#V;
          }
          set to(t) {
            this.#V = null == t ? null : gu(t);
          }
          get nonce() {
            return this.#Q;
          }
          set nonce(t) {
            this.#Q = Jo(t, "value");
          }
          get gasLimit() {
            return this.#W;
          }
          set gasLimit(t) {
            this.#W = Go(t);
          }
          get gasPrice() {
            const t = this.#J;
            return null != t || (0 !== this.type && 1 !== this.type) ? t : dh;
          }
          set gasPrice(t) {
            this.#J = null == t ? null : Go(t, "gasPrice");
          }
          get maxPriorityFeePerGas() {
            const t = this.#_;
            return null == t ? (2 === this.type ? dh : null) : t;
          }
          set maxPriorityFeePerGas(t) {
            this.#_ = null == t ? null : Go(t, "maxPriorityFeePerGas");
          }
          get maxFeePerGas() {
            const t = this.#K;
            return null == t ? (2 === this.type ? dh : null) : t;
          }
          set maxFeePerGas(t) {
            this.#K = null == t ? null : Go(t, "maxFeePerGas");
          }
          get data() {
            return this.#T;
          }
          set data(t) {
            this.#T = To(t);
          }
          get value() {
            return this.#q;
          }
          set value(t) {
            this.#q = Go(t, "value");
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = Go(t);
          }
          get signature() {
            return this.#Z || null;
          }
          set signature(t) {
            this.#Z = null == t ? null : au.from(t);
          }
          get accessList() {
            const t = this.#X || null;
            return null == t
              ? 1 === this.type || 2 === this.type
                ? []
                : null
              : t;
          }
          set accessList(t) {
            this.#X = null == t ? null : ch(t);
          }
          constructor() {
            (this.#G = null),
              (this.#V = null),
              (this.#Q = 0),
              (this.#W = BigInt(0)),
              (this.#J = null),
              (this.#_ = null),
              (this.#K = null),
              (this.#T = "0x"),
              (this.#q = BigInt(0)),
              (this.#Y = BigInt(0)),
              (this.#Z = null),
              (this.#X = null);
          }
          get hash() {
            return null == this.signature ? null : _l(this.serialized);
          }
          get unsignedHash() {
            return _l(this.unsignedSerialized);
          }
          get from() {
            return null == this.signature
              ? null
              : uh(this.unsignedHash, this.signature);
          }
          get fromPublicKey() {
            return null == this.signature
              ? null
              : lu.recoverPublicKey(this.unsignedHash, this.signature);
          }
          isSigned() {
            return null != this.signature;
          }
          get serialized() {
            switch (
              (xo(
                null != this.signature,
                "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
                "UNSUPPORTED_OPERATION",
                { operation: ".serialized" }
              ),
              this.inferType())
            ) {
              case 0:
                return $h(this, this.signature);
              case 1:
                return Ch(this, this.signature);
              case 2:
                return Eh(this, this.signature);
            }
            xo(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".serialized",
            });
          }
          get unsignedSerialized() {
            switch (this.inferType()) {
              case 0:
                return $h(this);
              case 1:
                return Ch(this);
              case 2:
                return Eh(this);
            }
            xo(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: ".unsignedSerialized",
            });
          }
          inferType() {
            return this.inferTypes().pop();
          }
          inferTypes() {
            const t = null != this.gasPrice,
              e =
                null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
              n = null != this.accessList;
            null != this.maxFeePerGas &&
              null != this.maxPriorityFeePerGas &&
              xo(
                this.maxFeePerGas >= this.maxPriorityFeePerGas,
                "priorityFee cannot be more than maxFee",
                "BAD_DATA",
                { value: this }
              ),
              xo(
                !e || (0 !== this.type && 1 !== this.type),
                "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
                "BAD_DATA",
                { value: this }
              ),
              xo(
                0 !== this.type || !n,
                "legacy transaction cannot have accessList",
                "BAD_DATA",
                { value: this }
              );
            const r = [];
            return (
              null != this.type
                ? r.push(this.type)
                : e
                ? r.push(2)
                : t
                ? (r.push(1), n || r.push(0))
                : n
                ? (r.push(1), r.push(2))
                : (r.push(0), r.push(1), r.push(2)),
              r.sort(),
              r
            );
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          clone() {
            return Sh.from(this);
          }
          toJSON() {
            const t = (t) => (null == t ? null : t.toString());
            return {
              type: this.type,
              to: this.to,
              data: this.data,
              nonce: this.nonce,
              gasLimit: t(this.gasLimit),
              gasPrice: t(this.gasPrice),
              maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
              maxFeePerGas: t(this.maxFeePerGas),
              value: t(this.value),
              chainId: t(this.chainId),
              sig: this.signature ? this.signature.toJSON() : null,
              accessList: this.accessList,
            };
          }
          static from(t) {
            if (null == t) return new Sh();
            if ("string" == typeof t) {
              const e = Po(t);
              if (e[0] >= 127)
                return Sh.from(
                  (function (t) {
                    const e = Ba(t);
                    $o(
                      Array.isArray(e) && (9 === e.length || 6 === e.length),
                      "invalid field count for legacy transaction",
                      "data",
                      t
                    );
                    const n = {
                      type: 0,
                      nonce: wh(e[0], "nonce"),
                      gasPrice: vh(e[1], "gasPrice"),
                      gasLimit: vh(e[2], "gasLimit"),
                      to: yh(e[3]),
                      value: vh(e[4], "value"),
                      data: To(e[5]),
                      chainId: dh,
                    };
                    if (6 === e.length) return n;
                    const r = vh(e[6], "v"),
                      s = vh(e[7], "r"),
                      i = vh(e[8], "s");
                    if (s === dh && i === dh) n.chainId = r;
                    else {
                      let s = (r - gh) / hh;
                      s < dh && (s = dh),
                        (n.chainId = s),
                        $o(
                          s !== dh || r === fh || r === ph,
                          "non-canonical legacy v",
                          "v",
                          e[6]
                        ),
                        (n.signature = au.from({
                          r: zo(e[7], 32),
                          s: zo(e[8], 32),
                          v: r,
                        })),
                        (n.hash = _l(t));
                    }
                    return n;
                  })(e)
                );
              switch (e[0]) {
                case 1:
                  return Sh.from(
                    (function (t) {
                      const e = Ba(Po(t).slice(1));
                      $o(
                        Array.isArray(e) && (8 === e.length || 11 === e.length),
                        "invalid field count for transaction type: 1",
                        "data",
                        To(t)
                      );
                      const n = {
                        type: 1,
                        chainId: vh(e[0], "chainId"),
                        nonce: wh(e[1], "nonce"),
                        gasPrice: vh(e[2], "gasPrice"),
                        gasLimit: vh(e[3], "gasLimit"),
                        to: yh(e[4]),
                        value: vh(e[5], "value"),
                        data: To(e[6]),
                        accessList: bh(e[7], "accessList"),
                      };
                      return (
                        8 === e.length || ((n.hash = _l(t)), kh(n, e.slice(8))),
                        n
                      );
                    })(e)
                  );
                case 2:
                  return Sh.from(
                    (function (t) {
                      const e = Ba(Po(t).slice(1));
                      $o(
                        Array.isArray(e) && (9 === e.length || 12 === e.length),
                        "invalid field count for transaction type: 2",
                        "data",
                        To(t)
                      );
                      const n = vh(e[2], "maxPriorityFeePerGas"),
                        r = vh(e[3], "maxFeePerGas"),
                        s = {
                          type: 2,
                          chainId: vh(e[0], "chainId"),
                          nonce: wh(e[1], "nonce"),
                          maxPriorityFeePerGas: n,
                          maxFeePerGas: r,
                          gasPrice: null,
                          gasLimit: vh(e[4], "gasLimit"),
                          to: yh(e[5]),
                          value: vh(e[6], "value"),
                          data: To(e[7]),
                          accessList: bh(e[8], "accessList"),
                        };
                      return (
                        9 === e.length || ((s.hash = _l(t)), kh(s, e.slice(9))),
                        s
                      );
                    })(e)
                  );
              }
              xo(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from",
              });
            }
            const e = new Sh();
            return (
              null != t.type && (e.type = t.type),
              null != t.to && (e.to = t.to),
              null != t.nonce && (e.nonce = t.nonce),
              null != t.gasLimit && (e.gasLimit = t.gasLimit),
              null != t.gasPrice && (e.gasPrice = t.gasPrice),
              null != t.maxPriorityFeePerGas &&
                (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas),
              null != t.maxFeePerGas && (e.maxFeePerGas = t.maxFeePerGas),
              null != t.data && (e.data = t.data),
              null != t.value && (e.value = t.value),
              null != t.chainId && (e.chainId = t.chainId),
              null != t.signature && (e.signature = au.from(t.signature)),
              null != t.accessList && (e.accessList = t.accessList),
              null != t.hash &&
                ($o(
                  e.isSigned(),
                  "unsigned transaction cannot define hash",
                  "tx",
                  t
                ),
                $o(e.hash === t.hash, "hash mismatch", "tx", t)),
              null != t.from &&
                ($o(
                  e.isSigned(),
                  "unsigned transaction cannot define from",
                  "tx",
                  t
                ),
                $o(
                  e.from.toLowerCase() === (t.from || "").toLowerCase(),
                  "from mismatch",
                  "tx",
                  t
                )),
              e
            );
          }
        }
        const Ph = new Uint8Array(32);
        Ph.fill(0);
        const Ih = BigInt(-1),
          Bh = BigInt(0),
          Nh = BigInt(1),
          Th = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        const Oh = _o(Nh, 32),
          Rh = _o(Bh, 32),
          Lh = {
            name: "string",
            version: "string",
            chainId: "uint256",
            verifyingContract: "address",
            salt: "bytes32",
          },
          zh = ["name", "version", "chainId", "verifyingContract", "salt"];
        function Uh(t) {
          return function (e) {
            return (
              $o(
                "string" == typeof e,
                `invalid domain value for ${JSON.stringify(t)}`,
                `domain.${t}`,
                e
              ),
              e
            );
          };
        }
        const Fh = {
          name: Uh("name"),
          version: Uh("version"),
          chainId: function (t) {
            const e = Go(t, "domain.chainId");
            return (
              $o(e >= 0, "invalid chain ID", "domain.chainId", t),
              Number.isSafeInteger(e) ? Number(e) : qo(e)
            );
          },
          verifyingContract: function (t) {
            try {
              return gu(t).toLowerCase();
            } catch (t) {}
            $o(
              !1,
              'invalid domain value "verifyingContract"',
              "domain.verifyingContract",
              t
            );
          },
          salt: function (t) {
            const e = Po(t, "domain.salt");
            return (
              $o(
                32 === e.length,
                'invalid domain value "salt"',
                "domain.salt",
                t
              ),
              To(e)
            );
          },
        };
        function Dh(t) {
          {
            const e = t.match(/^(u?)int(\d*)$/);
            if (e) {
              const n = "" === e[1],
                r = parseInt(e[2] || "256");
              $o(
                r % 8 == 0 &&
                  0 !== r &&
                  r <= 256 &&
                  (null == e[2] || e[2] === String(r)),
                "invalid numeric width",
                "type",
                t
              );
              const s = Ho(Th, n ? r - 1 : r),
                i = n ? (s + Nh) * Ih : Bh;
              return function (e) {
                const r = Go(e, "value");
                return (
                  $o(
                    r >= i && r <= s,
                    `value out-of-bounds for ${t}`,
                    "value",
                    r
                  ),
                  _o(n ? jo(r, 256) : r, 32)
                );
              };
            }
          }
          {
            const e = t.match(/^bytes(\d+)$/);
            if (e) {
              const n = parseInt(e[1]);
              return (
                $o(
                  0 !== n && n <= 32 && e[1] === String(n),
                  "invalid bytes width",
                  "type",
                  t
                ),
                function (e) {
                  return (
                    $o(
                      Po(e).length === n,
                      `invalid length for ${t}`,
                      "value",
                      e
                    ),
                    (function (t) {
                      const e = Po(t),
                        n = e.length % 32;
                      return n ? Oo([e, Ph.slice(n)]) : To(e);
                    })(e)
                  );
                }
              );
            }
          }
          switch (t) {
            case "address":
              return function (t) {
                return zo(gu(t), 32);
              };
            case "bool":
              return function (t) {
                return t ? Oh : Rh;
              };
            case "bytes":
              return function (t) {
                return _l(t);
              };
            case "string":
              return function (t) {
                return ju(t);
              };
          }
          return null;
        }
        function Mh(t, e) {
          return `${t}(${e
            .map(({ name: t, type: e }) => e + " " + t)
            .join(",")})`;
        }
        class jh {
          primaryType;
          #tt;
          get types() {
            return JSON.parse(this.#tt);
          }
          #et;
          #nt;
          constructor(t) {
            (this.#tt = JSON.stringify(t)),
              (this.#et = new Map()),
              (this.#nt = new Map());
            const e = new Map(),
              n = new Map(),
              r = new Map();
            Object.keys(t).forEach((t) => {
              e.set(t, new Set()), n.set(t, []), r.set(t, new Set());
            });
            for (const r in t) {
              const s = new Set();
              for (const i of t[r]) {
                $o(
                  !s.has(i.name),
                  `duplicate variable name ${JSON.stringify(
                    i.name
                  )} in ${JSON.stringify(r)}`,
                  "types",
                  t
                ),
                  s.add(i.name);
                const o = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                $o(
                  o !== r,
                  `circular type reference to ${JSON.stringify(o)}`,
                  "types",
                  t
                );
                Dh(o) ||
                  ($o(
                    n.has(o),
                    `unknown type ${JSON.stringify(o)}`,
                    "types",
                    t
                  ),
                  n.get(o).push(r),
                  e.get(r).add(o));
              }
            }
            const s = Array.from(n.keys()).filter((t) => 0 === n.get(t).length);
            $o(0 !== s.length, "missing primary type", "types", t),
              $o(
                1 === s.length,
                `ambiguous primary types or unused types: ${s
                  .map((t) => JSON.stringify(t))
                  .join(", ")}`,
                "types",
                t
              ),
              yo(this, { primaryType: s[0] }),
              (function s(i, o) {
                $o(
                  !o.has(i),
                  `circular type reference to ${JSON.stringify(i)}`,
                  "types",
                  t
                ),
                  o.add(i);
                for (const t of e.get(i))
                  if (n.has(t)) {
                    s(t, o);
                    for (const e of o) r.get(e).add(t);
                  }
                o.delete(i);
              })(this.primaryType, new Set());
            for (const [e, n] of r) {
              const r = Array.from(n);
              r.sort(),
                this.#et.set(
                  e,
                  Mh(e, t[e]) + r.map((e) => Mh(e, t[e])).join("")
                );
            }
          }
          getEncoder(t) {
            let e = this.#nt.get(t);
            return e || ((e = this.#rt(t)), this.#nt.set(t, e)), e;
          }
          #rt(t) {
            {
              const e = Dh(t);
              if (e) return e;
            }
            const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (e) {
              const t = e[1],
                n = this.getEncoder(t);
              return (r) => {
                $o(
                  !e[3] || parseInt(e[3]) === r.length,
                  `array length mismatch; expected length ${parseInt(e[3])}`,
                  "value",
                  r
                );
                let s = r.map(n);
                return this.#et.has(t) && (s = s.map(_l)), _l(Oo(s));
              };
            }
            const n = this.types[t];
            if (n) {
              const e = ju(this.#et.get(t));
              return (t) => {
                const r = n.map(({ name: e, type: n }) => {
                  const r = this.getEncoder(n)(t[e]);
                  return this.#et.has(n) ? _l(r) : r;
                });
                return r.unshift(e), Oo(r);
              };
            }
            $o(!1, `unknown type: ${t}`, "type", t);
          }
          encodeType(t) {
            const e = this.#et.get(t);
            return $o(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
          }
          encodeData(t, e) {
            return this.getEncoder(t)(e);
          }
          hashStruct(t, e) {
            return _l(this.encodeData(t, e));
          }
          encode(t) {
            return this.encodeData(this.primaryType, t);
          }
          hash(t) {
            return this.hashStruct(this.primaryType, t);
          }
          _visit(t, e, n) {
            if (Dh(t)) return n(t, e);
            const r = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (r)
              return (
                $o(
                  !r[3] || parseInt(r[3]) === e.length,
                  `array length mismatch; expected length ${parseInt(r[3])}`,
                  "value",
                  e
                ),
                e.map((t) => this._visit(r[1], t, n))
              );
            const s = this.types[t];
            if (s)
              return s.reduce(
                (t, { name: r, type: s }) => (
                  (t[r] = this._visit(s, e[r], n)), t
                ),
                {}
              );
            $o(!1, `unknown type: ${t}`, "type", t);
          }
          visit(t, e) {
            return this._visit(this.primaryType, t, e);
          }
          static from(t) {
            return new jh(t);
          }
          static getPrimaryType(t) {
            return jh.from(t).primaryType;
          }
          static hashStruct(t, e, n) {
            return jh.from(e).hashStruct(t, n);
          }
          static hashDomain(t) {
            const e = [];
            for (const n in t) {
              if (null == t[n]) continue;
              const r = Lh[n];
              $o(
                r,
                `invalid typed-data domain key: ${JSON.stringify(n)}`,
                "domain",
                t
              ),
                e.push({ name: n, type: r });
            }
            return (
              e.sort((t, e) => zh.indexOf(t.name) - zh.indexOf(e.name)),
              jh.hashStruct("EIP712Domain", { EIP712Domain: e }, t)
            );
          }
          static encode(t, e, n) {
            return Oo(["0x1901", jh.hashDomain(t), jh.from(e).hash(n)]);
          }
          static hash(t, e, n) {
            return _l(jh.encode(t, e, n));
          }
          static async resolveNames(t, e, n, r) {
            t = Object.assign({}, t);
            for (const e in t) null == t[e] && delete t[e];
            const s = {};
            t.verifyingContract &&
              !Bo(t.verifyingContract, 20) &&
              (s[t.verifyingContract] = "0x");
            const i = jh.from(e);
            i.visit(
              n,
              (t, e) => ("address" !== t || Bo(e, 20) || (s[e] = "0x"), e)
            );
            for (const t in s) s[t] = await r(t);
            return (
              t.verifyingContract &&
                s[t.verifyingContract] &&
                (t.verifyingContract = s[t.verifyingContract]),
              {
                domain: t,
                value: (n = i.visit(n, (t, e) =>
                  "address" === t && s[e] ? s[e] : e
                )),
              }
            );
          }
          static getPayload(t, e, n) {
            jh.hashDomain(t);
            const r = {},
              s = [];
            zh.forEach((e) => {
              const n = t[e];
              null != n &&
                ((r[e] = Fh[e](n)), s.push({ name: e, type: Lh[e] }));
            });
            const i = jh.from(e),
              o = Object.assign({}, e);
            return (
              $o(
                null == o.EIP712Domain,
                "types must not contain EIP712Domain type",
                "types.EIP712Domain",
                e
              ),
              (o.EIP712Domain = s),
              i.encode(n),
              {
                types: o,
                domain: r,
                primaryType: i.primaryType,
                message: i.visit(n, (t, e) => {
                  if (t.match(/^bytes(\d*)/)) return To(Po(e));
                  if (t.match(/^u?int/)) return Go(e).toString();
                  switch (t) {
                    case "address":
                      return e.toLowerCase();
                    case "bool":
                      return !!e;
                    case "string":
                      return (
                        $o("string" == typeof e, "invalid string", "value", e),
                        e
                      );
                  }
                  $o(!1, "unsupported type", "type", t);
                }),
              }
            );
          }
        }
        function Hh(t) {
          const e = new Set();
          return t.forEach((t) => e.add(t)), Object.freeze(e);
        }
        const Gh =
            "constant external internal payable private public pure view",
          Vh = Hh(Gh.split(" ")),
          Qh = "constructor error event fallback function receive struct",
          Wh = Hh(Qh.split(" ")),
          Jh = "calldata memory storage payable indexed",
          _h = Hh(Jh.split(" ")),
          Kh = Hh([Qh, Jh, "tuple returns", Gh].join(" ").split(" ")),
          qh = {
            "(": "OPEN_PAREN",
            ")": "CLOSE_PAREN",
            "[": "OPEN_BRACKET",
            "]": "CLOSE_BRACKET",
            ",": "COMMA",
            "@": "AT",
          },
          Yh = new RegExp("^(\\s*)"),
          Zh = new RegExp("^([0-9]+)"),
          Xh = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
          tf = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
          ef = new RegExp(
            "^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"
          );
        class nf {
          #L;
          #st;
          get offset() {
            return this.#L;
          }
          get length() {
            return this.#st.length - this.#L;
          }
          constructor(t) {
            (this.#L = 0), (this.#st = t.slice());
          }
          clone() {
            return new nf(this.#st);
          }
          reset() {
            this.#L = 0;
          }
          #it(t = 0, e = 0) {
            return new nf(
              this.#st
                .slice(t, e)
                .map((e) =>
                  Object.freeze(
                    Object.assign({}, e, {
                      match: e.match - t,
                      linkBack: e.linkBack - t,
                      linkNext: e.linkNext - t,
                    })
                  )
                )
            );
          }
          popKeyword(t) {
            const e = this.peek();
            if ("KEYWORD" !== e.type || !t.has(e.text))
              throw new Error(`expected keyword ${e.text}`);
            return this.pop().text;
          }
          popType(t) {
            if (this.peek().type !== t)
              throw new Error(
                `expected ${t}; got ${JSON.stringify(this.peek())}`
              );
            return this.pop().text;
          }
          popParen() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = this.#it(this.#L + 1, t.match + 1);
            return (this.#L = t.match + 1), e;
          }
          popParams() {
            const t = this.peek();
            if ("OPEN_PAREN" !== t.type) throw new Error("bad start");
            const e = [];
            for (; this.#L < t.match - 1; ) {
              const t = this.peek().linkNext;
              e.push(this.#it(this.#L + 1, t)), (this.#L = t);
            }
            return (this.#L = t.match + 1), e;
          }
          peek() {
            if (this.#L >= this.#st.length) throw new Error("out-of-bounds");
            return this.#st[this.#L];
          }
          peekKeyword(t) {
            const e = this.peekType("KEYWORD");
            return null != e && t.has(e) ? e : null;
          }
          peekType(t) {
            if (0 === this.length) return null;
            const e = this.peek();
            return e.type === t ? e.text : null;
          }
          pop() {
            const t = this.peek();
            return this.#L++, t;
          }
          toString() {
            const t = [];
            for (let e = this.#L; e < this.#st.length; e++) {
              const n = this.#st[e];
              t.push(`${n.type}:${n.text}`);
            }
            return `<TokenString ${t.join(" ")}>`;
          }
        }
        function rf(t) {
          const e = [],
            n = (e) => {
              const n = i < t.length ? JSON.stringify(t[i]) : "$EOI";
              throw new Error(`invalid token ${n} at ${i}: ${e}`);
            };
          let r = [],
            s = [],
            i = 0;
          for (; i < t.length; ) {
            let o = t.substring(i),
              a = o.match(Yh);
            a && ((i += a[1].length), (o = t.substring(i)));
            const l = {
              depth: r.length,
              linkBack: -1,
              linkNext: -1,
              match: -1,
              type: "",
              text: "",
              offset: i,
              value: -1,
            };
            e.push(l);
            let c = qh[o[0]] || "";
            if (c) {
              if (((l.type = c), (l.text = o[0]), i++, "OPEN_PAREN" === c))
                r.push(e.length - 1), s.push(e.length - 1);
              else if ("CLOSE_PAREN" == c)
                0 === r.length && n("no matching open bracket"),
                  (l.match = r.pop()),
                  (e[l.match].match = e.length - 1),
                  l.depth--,
                  (l.linkBack = s.pop()),
                  (e[l.linkBack].linkNext = e.length - 1);
              else if ("COMMA" === c)
                (l.linkBack = s.pop()),
                  (e[l.linkBack].linkNext = e.length - 1),
                  s.push(e.length - 1);
              else if ("OPEN_BRACKET" === c) l.type = "BRACKET";
              else if ("CLOSE_BRACKET" === c) {
                let t = e.pop().text;
                if (e.length > 0 && "NUMBER" === e[e.length - 1].type) {
                  const n = e.pop().text;
                  (t = n + t), (e[e.length - 1].value = Jo(n));
                }
                if (0 === e.length || "BRACKET" !== e[e.length - 1].type)
                  throw new Error("missing opening bracket");
                e[e.length - 1].text += t;
              }
            } else if (((a = o.match(Xh)), a)) {
              if (((l.text = a[1]), (i += l.text.length), Kh.has(l.text))) {
                l.type = "KEYWORD";
                continue;
              }
              if (l.text.match(ef)) {
                l.type = "TYPE";
                continue;
              }
              l.type = "ID";
            } else {
              if (((a = o.match(Zh)), !a))
                throw new Error(
                  `unexpected token ${JSON.stringify(o[0])} at position ${i}`
                );
              (l.text = a[1]), (l.type = "NUMBER"), (i += l.text.length);
            }
          }
          return new nf(e.map((t) => Object.freeze(t)));
        }
        function sf(t, e) {
          let n = [];
          for (const r in e.keys()) t.has(r) && n.push(r);
          if (n.length > 1)
            throw new Error(`conflicting types: ${n.join(", ")}`);
        }
        function of(t, e) {
          if (e.peekKeyword(Wh)) {
            const n = e.pop().text;
            if (n !== t) throw new Error(`expected ${t}, got ${n}`);
          }
          return e.popType("ID");
        }
        function af(t, e) {
          const n = new Set();
          for (;;) {
            const r = t.peekType("KEYWORD");
            if (null == r || (e && !e.has(r))) break;
            if ((t.pop(), n.has(r)))
              throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
            n.add(r);
          }
          return Object.freeze(n);
        }
        function lf(t) {
          let e = af(t, Vh);
          return (
            sf(e, Hh("constant payable nonpayable".split(" "))),
            sf(e, Hh("pure view payable nonpayable".split(" "))),
            e.has("view")
              ? "view"
              : e.has("pure")
              ? "pure"
              : e.has("payable")
              ? "payable"
              : e.has("nonpayable")
              ? "nonpayable"
              : e.has("constant")
              ? "view"
              : "nonpayable"
          );
        }
        function cf(t, e) {
          return t.popParams().map((t) => $f.from(t, e));
        }
        function uf(t) {
          if (t.peekType("AT")) {
            if ((t.pop(), t.peekType("NUMBER"))) return Go(t.pop().text);
            throw new Error("invalid gas");
          }
          return null;
        }
        function df(t) {
          if (t.length) throw new Error(`unexpected tokens: ${t.toString()}`);
        }
        const hf = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function ff(t) {
          const e = t.match(ef);
          if (($o(e, "invalid type", "type", t), "uint" === t))
            return "uint256";
          if ("int" === t) return "int256";
          if (e[2]) {
            const n = parseInt(e[2]);
            $o(0 !== n && n <= 32, "invalid bytes length", "type", t);
          } else if (e[3]) {
            const n = parseInt(e[3]);
            $o(
              0 !== n && n <= 256 && n % 8 == 0,
              "invalid numeric width",
              "type",
              t
            );
          }
          return t;
        }
        const pf = {},
          gf = Symbol.for("_ethers_internal"),
          mf = "_ParamTypeInternal",
          yf = "_ErrorInternal",
          bf = "_EventInternal",
          wf = "_ConstructorInternal",
          vf = "_FallbackInternal",
          Af = "_FunctionInternal",
          xf = "_StructInternal";
        class $f {
          name;
          type;
          baseType;
          indexed;
          components;
          arrayLength;
          arrayChildren;
          constructor(t, e, n, r, s, i, o, a) {
            if (
              (Co(t, pf, "ParamType"),
              Object.defineProperty(this, gf, { value: mf }),
              i && (i = Object.freeze(i.slice())),
              "array" === r)
            ) {
              if (null == o || null == a) throw new Error("");
            } else if (null != o || null != a) throw new Error("");
            if ("tuple" === r) {
              if (null == i) throw new Error("");
            } else if (null != i) throw new Error("");
            yo(this, {
              name: e,
              type: n,
              baseType: r,
              indexed: s,
              components: i,
              arrayLength: o,
              arrayChildren: a,
            });
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t)) {
              let e = {
                type: "tuple" === this.baseType ? "tuple" : this.type,
                name: this.name || void 0,
              };
              return (
                "boolean" == typeof this.indexed && (e.indexed = this.indexed),
                this.isTuple() &&
                  (e.components = this.components.map((e) =>
                    JSON.parse(e.format(t))
                  )),
                JSON.stringify(e)
              );
            }
            let e = "";
            return (
              this.isArray()
                ? ((e += this.arrayChildren.format(t)),
                  (e += `[${
                    this.arrayLength < 0 ? "" : String(this.arrayLength)
                  }]`))
                : this.isTuple()
                ? ("sighash" !== t && (e += this.type),
                  (e +=
                    "(" +
                    this.components
                      .map((e) => e.format(t))
                      .join("full" === t ? ", " : ",") +
                    ")"))
                : (e += this.type),
              "sighash" !== t &&
                (!0 === this.indexed && (e += " indexed"),
                "full" === t && this.name && (e += " " + this.name)),
              e
            );
          }
          isArray() {
            return "array" === this.baseType;
          }
          isTuple() {
            return "tuple" === this.baseType;
          }
          isIndexable() {
            return null != this.indexed;
          }
          walk(t, e) {
            if (this.isArray()) {
              if (!Array.isArray(t)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && t.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t) => n.arrayChildren.walk(t, e));
            }
            if (this.isTuple()) {
              if (!Array.isArray(t)) throw new Error("invalid tuple value");
              if (t.length !== this.components.length)
                throw new Error("array is wrong length");
              const n = this;
              return t.map((t, r) => n.components[r].walk(t, e));
            }
            return e(this.type, t);
          }
          #ot(t, e, n, r) {
            if (this.isArray()) {
              if (!Array.isArray(e)) throw new Error("invalid array value");
              if (-1 !== this.arrayLength && e.length !== this.arrayLength)
                throw new Error("array is wrong length");
              const s = this.arrayChildren,
                i = e.slice();
              return (
                i.forEach((e, r) => {
                  s.#ot(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            if (this.isTuple()) {
              const s = this.components;
              let i;
              if (Array.isArray(e)) i = e.slice();
              else {
                if (null == e || "object" != typeof e)
                  throw new Error("invalid tuple value");
                i = s.map((t) => {
                  if (!t.name)
                    throw new Error(
                      "cannot use object value with unnamed components"
                    );
                  if (!(t.name in e))
                    throw new Error(`missing value for component ${t.name}`);
                  return e[t.name];
                });
              }
              if (i.length !== this.components.length)
                throw new Error("array is wrong length");
              return (
                i.forEach((e, r) => {
                  s[r].#ot(t, e, n, (t) => {
                    i[r] = t;
                  });
                }),
                void r(i)
              );
            }
            const s = n(this.type, e);
            s.then
              ? t.push(
                  (async function () {
                    r(await s);
                  })()
                )
              : r(s);
          }
          async walkAsync(t, e) {
            const n = [],
              r = [t];
            return (
              this.#ot(n, t, e, (t) => {
                r[0] = t;
              }),
              n.length && (await Promise.all(n)),
              r[0]
            );
          }
          static from(t, e) {
            if ($f.isParamType(t)) return t;
            if ("string" == typeof t) return $f.from(rf(t), e);
            if (t instanceof nf) {
              let n = "",
                r = "",
                s = null;
              af(t, Hh(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN")
                ? ((r = "tuple"),
                  (s = t.popParams().map((t) => $f.from(t))),
                  (n = `tuple(${s.map((t) => t.format()).join(",")})`))
                : ((n = ff(t.popType("TYPE"))), (r = n));
              let i = null,
                o = null;
              for (; t.length && t.peekType("BRACKET"); ) {
                const e = t.pop();
                (i = new $f(pf, "", n, r, null, s, o, i)),
                  (o = e.value),
                  (n += e.text),
                  (r = "array"),
                  (s = null);
              }
              let a = null;
              if (af(t, _h).has("indexed")) {
                if (!e) throw new Error("");
                a = !0;
              }
              const l = t.peekType("ID") ? t.pop().text : "";
              if (t.length) throw new Error("leftover tokens");
              return new $f(pf, l, n, r, a, s, o, i);
            }
            const n = t.name;
            $o(
              !n || ("string" == typeof n && n.match(tf)),
              "invalid name",
              "obj.name",
              n
            );
            let r = t.indexed;
            null != r &&
              ($o(e, "parameter cannot be indexed", "obj.indexed", t.indexed),
              (r = !!r));
            let s = t.type,
              i = s.match(hf);
            if (i) {
              const e = parseInt(i[2] || "-1"),
                o = $f.from({ type: i[1], components: t.components });
              return new $f(pf, n || "", s, "array", r, null, e, o);
            }
            if ("tuple" === s || s.startsWith("tuple(") || s.startsWith("(")) {
              const e =
                null != t.components
                  ? t.components.map((t) => $f.from(t))
                  : null;
              return new $f(pf, n || "", s, "tuple", r, e, null, null);
            }
            return (
              (s = ff(t.type)), new $f(pf, n || "", s, s, r, null, null, null)
            );
          }
          static isParamType(t) {
            return t && t[gf] === mf;
          }
        }
        class kf {
          type;
          inputs;
          constructor(t, e, n) {
            Co(t, pf, "Fragment"),
              yo(this, { type: e, inputs: (n = Object.freeze(n.slice())) });
          }
          static from(t) {
            if ("string" == typeof t) {
              try {
                kf.from(JSON.parse(t));
              } catch (t) {}
              return kf.from(rf(t));
            }
            if (t instanceof nf) {
              switch (t.peekKeyword(Wh)) {
                case "constructor":
                  return If.from(t);
                case "error":
                  return Sf.from(t);
                case "event":
                  return Pf.from(t);
                case "fallback":
                case "receive":
                  return Bf.from(t);
                case "function":
                  return Nf.from(t);
                case "struct":
                  return Tf.from(t);
              }
            } else if ("object" == typeof t) {
              switch (t.type) {
                case "constructor":
                  return If.from(t);
                case "error":
                  return Sf.from(t);
                case "event":
                  return Pf.from(t);
                case "fallback":
                case "receive":
                  return Bf.from(t);
                case "function":
                  return Nf.from(t);
                case "struct":
                  return Tf.from(t);
              }
              xo(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from",
              });
            }
            $o(!1, "unsupported frgament object", "obj", t);
          }
          static isConstructor(t) {
            return If.isFragment(t);
          }
          static isError(t) {
            return Sf.isFragment(t);
          }
          static isEvent(t) {
            return Pf.isFragment(t);
          }
          static isFunction(t) {
            return Nf.isFragment(t);
          }
          static isStruct(t) {
            return Tf.isFragment(t);
          }
        }
        class Ef extends kf {
          name;
          constructor(t, e, n, r) {
            super(t, e, r),
              $o(
                "string" == typeof n && n.match(tf),
                "invalid identifier",
                "name",
                n
              ),
              (r = Object.freeze(r.slice())),
              yo(this, { name: n });
          }
        }
        function Cf(t, e) {
          return (
            "(" +
            e.map((e) => e.format(t)).join("full" === t ? ", " : ",") +
            ")"
          );
        }
        class Sf extends Ef {
          constructor(t, e, n) {
            super(t, "error", e, n),
              Object.defineProperty(this, gf, { value: yf });
          }
          get selector() {
            return ju(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("error"),
              e.push(this.name + Cf(t, this.inputs)),
              e.join(" ")
            );
          }
          static from(t) {
            if (Sf.isFragment(t)) return t;
            if ("string" == typeof t) return Sf.from(rf(t));
            if (t instanceof nf) {
              const e = of("error", t),
                n = cf(t);
              return df(t), new Sf(pf, e, n);
            }
            return new Sf(pf, t.name, t.inputs ? t.inputs.map($f.from) : []);
          }
          static isFragment(t) {
            return t && t[gf] === yf;
          }
        }
        class Pf extends Ef {
          anonymous;
          constructor(t, e, n, r) {
            super(t, "event", e, n),
              Object.defineProperty(this, gf, { value: bf }),
              yo(this, { anonymous: r });
          }
          get topicHash() {
            return ju(this.format("sighash"));
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("event"),
              e.push(this.name + Cf(t, this.inputs)),
              "sighash" !== t && this.anonymous && e.push("anonymous"),
              e.join(" ")
            );
          }
          static getTopicHash(t, e) {
            e = (e || []).map((t) => $f.from(t));
            return new Pf(pf, t, e, !1).topicHash;
          }
          static from(t) {
            if (Pf.isFragment(t)) return t;
            if ("string" == typeof t) return Pf.from(rf(t));
            if (t instanceof nf) {
              const e = of("event", t),
                n = cf(t, !0),
                r = !!af(t, Hh(["anonymous"])).has("anonymous");
              return df(t), new Pf(pf, e, n, r);
            }
            return new Pf(
              pf,
              t.name,
              t.inputs ? t.inputs.map((t) => $f.from(t, !0)) : [],
              !!t.anonymous
            );
          }
          static isFragment(t) {
            return t && t[gf] === bf;
          }
        }
        class If extends kf {
          payable;
          gas;
          constructor(t, e, n, r, s) {
            super(t, e, n),
              Object.defineProperty(this, gf, { value: wf }),
              yo(this, { payable: r, gas: s });
          }
          format(t) {
            if (
              (xo(
                null != t && "sighash" !== t,
                "cannot format a constructor for sighash",
                "UNSUPPORTED_OPERATION",
                { operation: "format(sighash)" }
              ),
              "json" === t)
            )
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [`constructor${Cf(t, this.inputs)}`];
            return (
              e.push(this.payable ? "payable" : "nonpayable"),
              null != this.gas && e.push(`@${this.gas.toString()}`),
              e.join(" ")
            );
          }
          static from(t) {
            if (If.isFragment(t)) return t;
            if ("string" == typeof t) return If.from(rf(t));
            if (t instanceof nf) {
              af(t, Hh(["constructor"]));
              const e = cf(t),
                n = !!af(t, Hh(["payable"])).has("payable"),
                r = uf(t);
              return df(t), new If(pf, "constructor", e, n, r);
            }
            return new If(
              pf,
              "constructor",
              t.inputs ? t.inputs.map($f.from) : [],
              !!t.payable,
              null != t.gas ? t.gas : null
            );
          }
          static isFragment(t) {
            return t && t[gf] === wf;
          }
        }
        class Bf extends kf {
          payable;
          constructor(t, e, n) {
            super(t, "fallback", e),
              Object.defineProperty(this, gf, { value: vf }),
              yo(this, { payable: n });
          }
          format(t) {
            const e = 0 === this.inputs.length ? "receive" : "fallback";
            if ("json" === t) {
              const t = this.payable ? "payable" : "nonpayable";
              return JSON.stringify({ type: e, stateMutability: t });
            }
            return `${e}()${this.payable ? " payable" : ""}`;
          }
          static from(t) {
            if (Bf.isFragment(t)) return t;
            if ("string" == typeof t) return Bf.from(rf(t));
            if (t instanceof nf) {
              const e = t.toString();
              $o(
                t.peekKeyword(Hh(["fallback", "receive"])),
                "type must be fallback or receive",
                "obj",
                e
              );
              if ("receive" === t.popKeyword(Hh(["fallback", "receive"]))) {
                const e = cf(t);
                return (
                  $o(
                    0 === e.length,
                    "receive cannot have arguments",
                    "obj.inputs",
                    e
                  ),
                  af(t, Hh(["payable"])),
                  df(t),
                  new Bf(pf, [], !0)
                );
              }
              let n = cf(t);
              n.length
                ? $o(
                    1 === n.length && "bytes" === n[0].type,
                    "invalid fallback inputs",
                    "obj.inputs",
                    n.map((t) => t.format("minimal")).join(", ")
                  )
                : (n = [$f.from("bytes")]);
              const r = lf(t);
              if (
                ($o(
                  "nonpayable" === r || "payable" === r,
                  "fallback cannot be constants",
                  "obj.stateMutability",
                  r
                ),
                af(t, Hh(["returns"])).has("returns"))
              ) {
                const e = cf(t);
                $o(
                  1 === e.length && "bytes" === e[0].type,
                  "invalid fallback outputs",
                  "obj.outputs",
                  e.map((t) => t.format("minimal")).join(", ")
                );
              }
              return df(t), new Bf(pf, n, "payable" === r);
            }
            if ("receive" === t.type) return new Bf(pf, [], !0);
            if ("fallback" === t.type) {
              const e = [$f.from("bytes")],
                n = "payable" === t.stateMutability;
              return new Bf(pf, e, n);
            }
            $o(!1, "invalid fallback description", "obj", t);
          }
          static isFragment(t) {
            return t && t[gf] === vf;
          }
        }
        class Nf extends Ef {
          constant;
          outputs;
          stateMutability;
          payable;
          gas;
          constructor(t, e, n, r, s, i) {
            super(t, "function", e, r),
              Object.defineProperty(this, gf, { value: Af });
            yo(this, {
              constant: "view" === n || "pure" === n,
              gas: i,
              outputs: (s = Object.freeze(s.slice())),
              payable: "payable" === n,
              stateMutability: n,
            });
          }
          get selector() {
            return ju(this.format("sighash")).substring(0, 10);
          }
          format(t) {
            if ((null == t && (t = "sighash"), "json" === t))
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  "nonpayable" !== this.stateMutability
                    ? this.stateMutability
                    : void 0,
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((e) => JSON.parse(e.format(t))),
                outputs: this.outputs.map((e) => JSON.parse(e.format(t))),
              });
            const e = [];
            return (
              "sighash" !== t && e.push("function"),
              e.push(this.name + Cf(t, this.inputs)),
              "sighash" !== t &&
                ("nonpayable" !== this.stateMutability &&
                  e.push(this.stateMutability),
                this.outputs &&
                  this.outputs.length &&
                  (e.push("returns"), e.push(Cf(t, this.outputs))),
                null != this.gas && e.push(`@${this.gas.toString()}`)),
              e.join(" ")
            );
          }
          static getSelector(t, e) {
            e = (e || []).map((t) => $f.from(t));
            return new Nf(pf, t, "view", e, [], null).selector;
          }
          static from(t) {
            if (Nf.isFragment(t)) return t;
            if ("string" == typeof t) return Nf.from(rf(t));
            if (t instanceof nf) {
              const e = of("function", t),
                n = cf(t),
                r = lf(t);
              let s = [];
              af(t, Hh(["returns"])).has("returns") && (s = cf(t));
              const i = uf(t);
              return df(t), new Nf(pf, e, r, n, s, i);
            }
            let e = t.stateMutability;
            return (
              null == e &&
                ((e = "payable"),
                "boolean" == typeof t.constant
                  ? ((e = "view"),
                    t.constant ||
                      ((e = "payable"),
                      "boolean" != typeof t.payable ||
                        t.payable ||
                        (e = "nonpayable")))
                  : "boolean" != typeof t.payable ||
                    t.payable ||
                    (e = "nonpayable")),
              new Nf(
                pf,
                t.name,
                e,
                t.inputs ? t.inputs.map($f.from) : [],
                t.outputs ? t.outputs.map($f.from) : [],
                null != t.gas ? t.gas : null
              )
            );
          }
          static isFragment(t) {
            return t && t[gf] === Af;
          }
        }
        class Tf extends Ef {
          constructor(t, e, n) {
            super(t, "struct", e, n),
              Object.defineProperty(this, gf, { value: xf });
          }
          format() {
            throw new Error("@TODO");
          }
          static from(t) {
            if ("string" == typeof t) return Tf.from(rf(t));
            if (t instanceof nf) {
              const e = of("struct", t),
                n = cf(t);
              return df(t), new Tf(pf, e, n);
            }
            return new Tf(pf, t.name, t.inputs ? t.inputs.map($f.from) : []);
          }
          static isFragment(t) {
            return t && t[gf] === xf;
          }
        }
        const Of = new Map();
        Of.set(0, "GENERIC_PANIC"),
          Of.set(1, "ASSERT_FALSE"),
          Of.set(17, "OVERFLOW"),
          Of.set(18, "DIVIDE_BY_ZERO"),
          Of.set(33, "ENUM_RANGE_ERROR"),
          Of.set(34, "BAD_STORAGE_DATA"),
          Of.set(49, "STACK_UNDERFLOW"),
          Of.set(50, "ARRAY_RANGE_ERROR"),
          Of.set(65, "OUT_OF_MEMORY"),
          Of.set(81, "UNINITIALIZED_FUNCTION_CALL");
        const Rf = new RegExp(/^bytes([0-9]*)$/),
          Lf = new RegExp(/^(u?int)([0-9]*)$/);
        let zf = null;
        class Uf {
          #at(t) {
            if (t.isArray())
              return new Pu(this.#at(t.arrayChildren), t.arrayLength, t.name);
            if (t.isTuple())
              return new Mu(
                t.components.map((t) => this.#at(t)),
                t.name
              );
            switch (t.baseType) {
              case "address":
                return new ku(t.name);
              case "bool":
                return new Iu(t.name);
              case "string":
                return new Du(t.name);
              case "bytes":
                return new Nu(t.name);
              case "":
                return new Ru(t.name);
            }
            let e = t.type.match(Lf);
            if (e) {
              let n = parseInt(e[2] || "256");
              return (
                $o(
                  0 !== n && n <= 256 && n % 8 == 0,
                  "invalid " + e[1] + " bit length",
                  "param",
                  t
                ),
                new Fu(n / 8, "int" === e[1], t.name)
              );
            }
            if (((e = t.type.match(Rf)), e)) {
              let n = parseInt(e[1]);
              return (
                $o(0 !== n && n <= 32, "invalid bytes length", "param", t),
                new Tu(n, t.name)
              );
            }
            $o(!1, "invalid type", "type", t.type);
          }
          getDefaultValue(t) {
            const e = t.map((t) => this.#at($f.from(t)));
            return new Mu(e, "_").defaultValue();
          }
          encode(t, e) {
            ko(e.length, t.length, "types/values length mismatch");
            const n = t.map((t) => this.#at($f.from(t))),
              r = new Mu(n, "_"),
              s = new Qa();
            return r.encode(s, e), s.data;
          }
          decode(t, e, n) {
            const r = t.map((t) => this.#at($f.from(t)));
            return new Mu(r, "_").decode(new Wa(e, n));
          }
          static defaultAbiCoder() {
            return null == zf && (zf = new Uf()), zf;
          }
          static getBuiltinCallException(t, e, n) {
            return (function (t, e, n, r) {
              let s = "missing revert data",
                i = null,
                o = null;
              if (n) {
                s = "execution reverted";
                const t = Po(n);
                if (((n = To(n)), 0 === t.length))
                  (s += " (no data present; likely require(false) occurred"),
                    (i = "require(false)");
                else if (t.length % 32 != 4)
                  s += " (could not decode reason; invalid data length)";
                else if ("0x08c379a0" === To(t.slice(0, 4)))
                  try {
                    (i = r.decode(["string"], t.slice(4))[0]),
                      (o = {
                        signature: "Error(string)",
                        name: "Error",
                        args: [i],
                      }),
                      (s += `: ${JSON.stringify(i)}`);
                  } catch (t) {
                    s += " (could not decode reason; invalid string data)";
                  }
                else if ("0x4e487b71" === To(t.slice(0, 4)))
                  try {
                    const e = Number(r.decode(["uint256"], t.slice(4))[0]);
                    (o = {
                      signature: "Panic(uint256)",
                      name: "Panic",
                      args: [e],
                    }),
                      (i = `Panic due to ${Of.get(e) || "UNKNOWN"}(${e})`),
                      (s += `: ${i}`);
                  } catch (t) {
                    s += " (could not decode panic code)";
                  }
                else s += " (unknown custom error)";
              }
              const a = { to: e.to ? gu(e.to) : null, data: e.data || "0x" };
              return (
                e.from && (a.from = gu(e.from)),
                Ao(s, "CALL_EXCEPTION", {
                  action: t,
                  data: n,
                  reason: i,
                  transaction: a,
                  invocation: null,
                  revert: o,
                })
              );
            })(t, e, n, Uf.defaultAbiCoder());
          }
        }
        class Ff {
          fragment;
          name;
          signature;
          topic;
          args;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            yo(this, { fragment: t, name: r, signature: s, topic: e, args: n });
          }
        }
        class Df {
          fragment;
          name;
          args;
          signature;
          selector;
          value;
          constructor(t, e, n, r) {
            const s = t.name,
              i = t.format();
            yo(this, {
              fragment: t,
              name: s,
              args: n,
              signature: i,
              selector: e,
              value: r,
            });
          }
        }
        class Mf {
          fragment;
          name;
          args;
          signature;
          selector;
          constructor(t, e, n) {
            const r = t.name,
              s = t.format();
            yo(this, {
              fragment: t,
              name: r,
              args: n,
              signature: s,
              selector: e,
            });
          }
        }
        class jf {
          hash;
          _isIndexed;
          static isIndexed(t) {
            return !(!t || !t._isIndexed);
          }
          constructor(t) {
            yo(this, { hash: t, _isIndexed: !0 });
          }
        }
        const Hf = {
            0: "generic panic",
            1: "assert(false)",
            17: "arithmetic overflow",
            18: "division or modulo by zero",
            33: "enum overflow",
            34: "invalid encoded storage byte array accessed",
            49: "out-of-bounds array access; popping on an empty array",
            50: "out-of-bounds access of an array or bytesN",
            65: "out of memory",
            81: "uninitialized function",
          },
          Gf = {
            "0x08c379a0": {
              signature: "Error(string)",
              name: "Error",
              inputs: ["string"],
              reason: (t) => `reverted with reason string ${JSON.stringify(t)}`,
            },
            "0x4e487b71": {
              signature: "Panic(uint256)",
              name: "Panic",
              inputs: ["uint256"],
              reason: (t) => {
                let e = "unknown panic code";
                return (
                  t >= 0 &&
                    t <= 255 &&
                    Hf[t.toString()] &&
                    (e = Hf[t.toString()]),
                  `reverted with panic code 0x${t.toString(16)} (${e})`
                );
              },
            },
          };
        class Vf {
          fragments;
          deploy;
          fallback;
          receive;
          #lt;
          #ct;
          #ut;
          #dt;
          constructor(t) {
            let e = [];
            (e = "string" == typeof t ? JSON.parse(t) : t),
              (this.#ut = new Map()),
              (this.#lt = new Map()),
              (this.#ct = new Map());
            const n = [];
            for (const t of e)
              try {
                n.push(kf.from(t));
              } catch (t) {
                console.log("EE", t);
              }
            yo(this, { fragments: Object.freeze(n) });
            let r = null,
              s = !1;
            (this.#dt = this.getAbiCoder()),
              this.fragments.forEach((t, e) => {
                let n;
                switch (t.type) {
                  case "constructor":
                    return this.deploy
                      ? void console.log("duplicate definition - constructor")
                      : void yo(this, { deploy: t });
                  case "fallback":
                    return void (0 === t.inputs.length
                      ? (s = !0)
                      : ($o(
                          !r || t.payable !== r.payable,
                          "conflicting fallback fragments",
                          `fragments[${e}]`,
                          t
                        ),
                        (r = t),
                        (s = r.payable)));
                  case "function":
                    n = this.#ut;
                    break;
                  case "event":
                    n = this.#ct;
                    break;
                  case "error":
                    n = this.#lt;
                    break;
                  default:
                    return;
                }
                const i = t.format();
                n.has(i) || n.set(i, t);
              }),
              this.deploy || yo(this, { deploy: If.from("constructor()") }),
              yo(this, { fallback: r, receive: s });
          }
          format(t) {
            const e = t ? "minimal" : "full",
              n = this.fragments.map((t) => t.format(e));
            return n;
          }
          formatJson() {
            const t = this.fragments.map((t) => t.format("json"));
            return JSON.stringify(t.map((t) => JSON.parse(t)));
          }
          getAbiCoder() {
            return Uf.defaultAbiCoder();
          }
          #ht(t, e, n) {
            if (Bo(t)) {
              const e = t.toLowerCase();
              for (const t of this.#ut.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#ut) e.split("(")[0] === t && r.push(n);
              if (e) {
                const t = e.length > 0 ? e[e.length - 1] : null;
                let n = e.length,
                  s = !0;
                $u.isTyped(t) && "overrides" === t.type && ((s = !1), n--);
                for (let t = r.length - 1; t >= 0; t--) {
                  const e = r[t].inputs.length;
                  e === n || (s && e === n - 1) || r.splice(t, 1);
                }
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if ($u.isTyped(e[s])) {
                      if (s >= n.length) {
                        if ("overrides" === e[s].type) continue;
                        r.splice(t, 1);
                        break;
                      }
                      if (e[s].type !== n[s].baseType) {
                        r.splice(t, 1);
                        break;
                      }
                    }
                }
              }
              if (1 === r.length && e && e.length !== r[0].inputs.length) {
                const t = e[e.length - 1];
                (null == t || Array.isArray(t) || "object" != typeof t) &&
                  r.splice(0, 1);
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                const e = r.map((t) => JSON.stringify(t.format())).join(", ");
                $o(
                  !1,
                  `ambiguous function description (i.e. matches ${e})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#ut.get(Nf.from(t).format());
            return r || null;
          }
          getFunctionName(t) {
            const e = this.#ht(t, null, !1);
            return $o(e, "no matching function", "key", t), e.name;
          }
          hasFunction(t) {
            return !!this.#ht(t, null, !1);
          }
          getFunction(t, e) {
            return this.#ht(t, e || null, !0);
          }
          forEachFunction(t) {
            const e = Array.from(this.#ut.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ut.get(r), n);
            }
          }
          #ft(t, e, n) {
            if (Bo(t)) {
              const e = t.toLowerCase();
              for (const t of this.#ct.values())
                if (e === t.topicHash) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const r = [];
              for (const [e, n] of this.#ct) e.split("(")[0] === t && r.push(n);
              if (e) {
                for (let t = r.length - 1; t >= 0; t--)
                  r[t].inputs.length < e.length && r.splice(t, 1);
                for (let t = r.length - 1; t >= 0; t--) {
                  const n = r[t].inputs;
                  for (let s = 0; s < e.length; s++)
                    if ($u.isTyped(e[s]) && e[s].type !== n[s].baseType) {
                      r.splice(t, 1);
                      break;
                    }
                }
              }
              if (0 === r.length) return null;
              if (r.length > 1 && n) {
                const e = r.map((t) => JSON.stringify(t.format())).join(", ");
                $o(
                  !1,
                  `ambiguous event description (i.e. matches ${e})`,
                  "key",
                  t
                );
              }
              return r[0];
            }
            const r = this.#ct.get(Pf.from(t).format());
            return r || null;
          }
          getEventName(t) {
            const e = this.#ft(t, null, !1);
            return $o(e, "no matching event", "key", t), e.name;
          }
          hasEvent(t) {
            return !!this.#ft(t, null, !1);
          }
          getEvent(t, e) {
            return this.#ft(t, e || null, !0);
          }
          forEachEvent(t) {
            const e = Array.from(this.#ct.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#ct.get(r), n);
            }
          }
          getError(t, e) {
            if (Bo(t)) {
              const e = t.toLowerCase();
              if (Gf[e]) return Sf.from(Gf[e].signature);
              for (const t of this.#lt.values()) if (e === t.selector) return t;
              return null;
            }
            if (-1 === t.indexOf("(")) {
              const e = [];
              for (const [n, r] of this.#lt) n.split("(")[0] === t && e.push(r);
              if (0 === e.length)
                return "Error" === t
                  ? Sf.from("error Error(string)")
                  : "Panic" === t
                  ? Sf.from("error Panic(uint256)")
                  : null;
              if (e.length > 1) {
                const n = e.map((t) => JSON.stringify(t.format())).join(", ");
                $o(!1, `ambiguous error description (i.e. ${n})`, "name", t);
              }
              return e[0];
            }
            if ("Error(string)" === (t = Sf.from(t).format()))
              return Sf.from("error Error(string)");
            if ("Panic(uint256)" === t) return Sf.from("error Panic(uint256)");
            const n = this.#lt.get(t);
            return n || null;
          }
          forEachError(t) {
            const e = Array.from(this.#lt.keys());
            e.sort((t, e) => t.localeCompare(e));
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              t(this.#lt.get(r), n);
            }
          }
          _decodeParams(t, e) {
            return this.#dt.decode(t, e);
          }
          _encodeParams(t, e) {
            return this.#dt.encode(t, e);
          }
          encodeDeploy(t) {
            return this._encodeParams(this.deploy.inputs, t || []);
          }
          decodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              $o(e, "unknown error", "fragment", t), (t = e);
            }
            return (
              $o(
                Lo(e, 0, 4) === t.selector,
                `data signature does not match error ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, Lo(e, 4))
            );
          }
          encodeErrorResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getError(t);
              $o(e, "unknown error", "fragment", t), (t = e);
            }
            return Oo([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              $o(e, "unknown function", "fragment", t), (t = e);
            }
            return (
              $o(
                Lo(e, 0, 4) === t.selector,
                `data signature does not match function ${t.name}.`,
                "data",
                e
              ),
              this._decodeParams(t.inputs, Lo(e, 4))
            );
          }
          encodeFunctionData(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              $o(e, "unknown function", "fragment", t), (t = e);
            }
            return Oo([t.selector, this._encodeParams(t.inputs, e || [])]);
          }
          decodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              $o(e, "unknown function", "fragment", t), (t = e);
            }
            let n = "invalid length for result data";
            const r = Io(e);
            if (r.length % 32 == 0)
              try {
                return this.#dt.decode(t.outputs, r);
              } catch (t) {
                n = "could not decode result data";
              }
            xo(!1, n, "BAD_DATA", {
              value: To(r),
              info: { method: t.name, signature: t.format() },
            });
          }
          makeError(t, e) {
            const n = Po(t, "data"),
              r = Uf.getBuiltinCallException("call", e, n);
            if (
              r.message.startsWith("execution reverted (unknown custom error)")
            ) {
              const t = To(n.slice(0, 4)),
                e = this.getError(t);
              if (e)
                try {
                  const t = this.#dt.decode(e.inputs, n.slice(4));
                  (r.revert = { name: e.name, signature: e.format(), args: t }),
                    (r.reason = r.revert.signature),
                    (r.message = `execution reverted: ${r.reason}`);
                } catch (t) {
                  r.message =
                    "execution reverted (coult not decode custom error)";
                }
            }
            const s = this.parseTransaction(e);
            return (
              s &&
                (r.invocation = {
                  method: s.name,
                  signature: s.signature,
                  args: s.args,
                }),
              r
            );
          }
          encodeFunctionResult(t, e) {
            if ("string" == typeof t) {
              const e = this.getFunction(t);
              $o(e, "unknown function", "fragment", t), (t = e);
            }
            return To(this.#dt.encode(t.outputs, e || []));
          }
          encodeFilterTopics(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              $o(e, "unknown event", "eventFragment", t), (t = e);
            }
            xo(
              e.length <= t.inputs.length,
              `too many arguments for ${t.format()}`,
              "UNEXPECTED_ARGUMENT",
              { count: e.length, expectedCount: t.inputs.length }
            );
            const n = [];
            t.anonymous || n.push(t.topicHash);
            const r = (t, e) =>
              "string" === t.type
                ? ju(e)
                : "bytes" === t.type
                ? _l(To(e))
                : ("bool" === t.type &&
                    "boolean" == typeof e &&
                    (e = e ? "0x01" : "0x00"),
                  t.type.match(/^u?int/) && (e = _o(e)),
                  "address" === t.type && this.#dt.encode(["address"], [e]),
                  zo(To(e), 32));
            for (
              e.forEach((e, s) => {
                const i = t.inputs[s];
                i.indexed
                  ? null == e
                    ? n.push(null)
                    : "array" === i.baseType || "tuple" === i.baseType
                    ? $o(
                        !1,
                        "filtering with tuples or arrays not supported",
                        "contract." + i.name,
                        e
                      )
                    : Array.isArray(e)
                    ? n.push(e.map((t) => r(i, t)))
                    : n.push(r(i, e))
                  : $o(
                      null == e,
                      "cannot filter non-indexed parameters; must be null",
                      "contract." + i.name,
                      e
                    );
              });
              n.length && null === n[n.length - 1];

            )
              n.pop();
            return n;
          }
          encodeEventLog(t, e) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              $o(e, "unknown event", "eventFragment", t), (t = e);
            }
            const n = [],
              r = [],
              s = [];
            return (
              t.anonymous || n.push(t.topicHash),
              $o(
                e.length === t.inputs.length,
                "event arguments/values mismatch",
                "values",
                e
              ),
              t.inputs.forEach((t, i) => {
                const o = e[i];
                if (t.indexed)
                  if ("string" === t.type) n.push(ju(o));
                  else if ("bytes" === t.type) n.push(_l(o));
                  else {
                    if ("tuple" === t.baseType || "array" === t.baseType)
                      throw new Error("not implemented");
                    n.push(this.#dt.encode([t.type], [o]));
                  }
                else r.push(t), s.push(o);
              }),
              { data: this.#dt.encode(r, s), topics: n }
            );
          }
          decodeEventLog(t, e, n) {
            if ("string" == typeof t) {
              const e = this.getEvent(t);
              $o(e, "unknown event", "eventFragment", t), (t = e);
            }
            if (null != n && !t.anonymous) {
              const e = t.topicHash;
              $o(
                Bo(n[0], 32) && n[0].toLowerCase() === e,
                "fragment/topic mismatch",
                "topics[0]",
                n[0]
              ),
                (n = n.slice(1));
            }
            const r = [],
              s = [],
              i = [];
            t.inputs.forEach((t, e) => {
              t.indexed
                ? "string" === t.type ||
                  "bytes" === t.type ||
                  "tuple" === t.baseType ||
                  "array" === t.baseType
                  ? (r.push($f.from({ type: "bytes32", name: t.name })),
                    i.push(!0))
                  : (r.push(t), i.push(!1))
                : (s.push(t), i.push(!1));
            });
            const o = null != n ? this.#dt.decode(r, Oo(n)) : null,
              a = this.#dt.decode(s, e, !0),
              l = [],
              c = [];
            let u = 0,
              d = 0;
            return (
              t.inputs.forEach((t, e) => {
                let n = null;
                if (t.indexed)
                  if (null == o) n = new jf(null);
                  else if (i[e]) n = new jf(o[d++]);
                  else
                    try {
                      n = o[d++];
                    } catch (t) {
                      n = t;
                    }
                else
                  try {
                    n = a[u++];
                  } catch (t) {
                    n = t;
                  }
                l.push(n), c.push(t.name || null);
              }),
              Ha.fromItems(l, c)
            );
          }
          parseTransaction(t) {
            const e = Po(t.data, "tx.data"),
              n = Go(null != t.value ? t.value : 0, "tx.value"),
              r = this.getFunction(To(e.slice(0, 4)));
            if (!r) return null;
            const s = this.#dt.decode(r.inputs, e.slice(4));
            return new Df(r, r.selector, s, n);
          }
          parseCallResult(t) {
            throw new Error("@TODO");
          }
          parseLog(t) {
            const e = this.getEvent(t.topics[0]);
            return !e || e.anonymous
              ? null
              : new Ff(
                  e,
                  e.topicHash,
                  this.decodeEventLog(e, t.data, t.topics)
                );
          }
          parseError(t) {
            const e = To(t),
              n = this.getError(Lo(e, 0, 4));
            if (!n) return null;
            const r = this.#dt.decode(n.inputs, Lo(e, 4));
            return new Mf(n, n.selector, r);
          }
          static from(t) {
            return t instanceof Vf
              ? t
              : "string" == typeof t
              ? new Vf(JSON.parse(t))
              : "function" == typeof t.format
              ? new Vf(t.format("json"))
              : new Vf(t);
          }
        }
        const Qf = BigInt(0);
        function Wf(t) {
          return null == t ? null : t;
        }
        function Jf(t) {
          return null == t ? null : t.toString();
        }
        class _f {
          gasPrice;
          maxFeePerGas;
          maxPriorityFeePerGas;
          constructor(t, e, n) {
            yo(this, {
              gasPrice: Wf(t),
              maxFeePerGas: Wf(e),
              maxPriorityFeePerGas: Wf(n),
            });
          }
          toJSON() {
            const {
              gasPrice: t,
              maxFeePerGas: e,
              maxPriorityFeePerGas: n,
            } = this;
            return {
              _type: "FeeData",
              gasPrice: Jf(t),
              maxFeePerGas: Jf(e),
              maxPriorityFeePerGas: Jf(n),
            };
          }
        }
        function Kf(t) {
          const e = {};
          t.to && (e.to = t.to),
            t.from && (e.from = t.from),
            t.data && (e.data = To(t.data));
          const n =
            "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
              /,/
            );
          for (const r of n)
            r in t && null != t[r] && (e[r] = Go(t[r], `request.${r}`));
          const r = "type,nonce".split(/,/);
          for (const n of r)
            n in t && null != t[n] && (e[n] = Jo(t[n], `request.${n}`));
          return (
            t.accessList && (e.accessList = ch(t.accessList)),
            "blockTag" in t && (e.blockTag = t.blockTag),
            "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead),
            "customData" in t && (e.customData = t.customData),
            e
          );
        }
        class qf {
          provider;
          number;
          hash;
          timestamp;
          parentHash;
          nonce;
          difficulty;
          gasLimit;
          gasUsed;
          miner;
          extraData;
          baseFeePerGas;
          #pt;
          constructor(t, e) {
            (this.#pt = t.transactions.map((t) =>
              "string" != typeof t ? new Xf(t, e) : t
            )),
              yo(this, {
                provider: e,
                hash: Wf(t.hash),
                number: t.number,
                timestamp: t.timestamp,
                parentHash: t.parentHash,
                nonce: t.nonce,
                difficulty: t.difficulty,
                gasLimit: t.gasLimit,
                gasUsed: t.gasUsed,
                miner: t.miner,
                extraData: t.extraData,
                baseFeePerGas: Wf(t.baseFeePerGas),
              });
          }
          get transactions() {
            return this.#pt.map((t) => ("string" == typeof t ? t : t.hash));
          }
          get prefetchedTransactions() {
            const t = this.#pt.slice();
            return 0 === t.length
              ? []
              : (xo(
                  "object" == typeof t[0],
                  "transactions were not prefetched with block request",
                  "UNSUPPORTED_OPERATION",
                  { operation: "transactionResponses()" }
                ),
                t);
          }
          toJSON() {
            const {
              baseFeePerGas: t,
              difficulty: e,
              extraData: n,
              gasLimit: r,
              gasUsed: s,
              hash: i,
              miner: o,
              nonce: a,
              number: l,
              parentHash: c,
              timestamp: u,
              transactions: d,
            } = this;
            return {
              _type: "Block",
              baseFeePerGas: Jf(t),
              difficulty: Jf(e),
              extraData: n,
              gasLimit: Jf(r),
              gasUsed: Jf(s),
              hash: i,
              miner: o,
              nonce: a,
              number: l,
              parentHash: c,
              timestamp: u,
              transactions: d,
            };
          }
          [Symbol.iterator]() {
            let t = 0;
            const e = this.transactions;
            return {
              next: () =>
                t < this.length
                  ? { value: e[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get length() {
            return this.#pt.length;
          }
          get date() {
            return null == this.timestamp
              ? null
              : new Date(1e3 * this.timestamp);
          }
          async getTransaction(t) {
            let e;
            if ("number" == typeof t) e = this.#pt[t];
            else {
              const n = t.toLowerCase();
              for (const t of this.#pt) {
                if ("string" == typeof t) {
                  if (t !== n) continue;
                  e = t;
                  break;
                }
                if (t.hash !== n) {
                  e = t;
                  break;
                }
              }
            }
            if (null == e) throw new Error("no such tx");
            return "string" == typeof e
              ? await this.provider.getTransaction(e)
              : e;
          }
          getPrefetchedTransaction(t) {
            const e = this.prefetchedTransactions;
            if ("number" == typeof t) return e[t];
            t = t.toLowerCase();
            for (const n of e) if (n.hash === t) return n;
            $o(!1, "no matching transaction", "indexOrHash", t);
          }
          isMined() {
            return !!this.hash;
          }
          isLondon() {
            return !!this.baseFeePerGas;
          }
          orphanedEvent() {
            if (!this.isMined()) throw new Error("");
            return {
              orphan: "drop-block",
              hash: (t = this).hash,
              number: t.number,
            };
            var t;
          }
        }
        class Yf {
          provider;
          transactionHash;
          blockHash;
          blockNumber;
          removed;
          address;
          data;
          topics;
          index;
          transactionIndex;
          constructor(t, e) {
            this.provider = e;
            const n = Object.freeze(t.topics.slice());
            yo(this, {
              transactionHash: t.transactionHash,
              blockHash: t.blockHash,
              blockNumber: t.blockNumber,
              removed: t.removed,
              address: t.address,
              data: t.data,
              topics: n,
              index: t.index,
              transactionIndex: t.transactionIndex,
            });
          }
          toJSON() {
            const {
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: o,
              transactionHash: a,
              transactionIndex: l,
            } = this;
            return {
              _type: "log",
              address: t,
              blockHash: e,
              blockNumber: n,
              data: r,
              index: s,
              removed: i,
              topics: o,
              transactionHash: a,
              transactionIndex: l,
            };
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            return (
              xo(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t
            );
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.transactionHash);
            return (
              xo(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t
            );
          }
          async getTransactionReceipt() {
            const t = await this.provider.getTransactionReceipt(
              this.transactionHash
            );
            return (
              xo(
                !!t,
                "failed to find transaction receipt",
                "UNKNOWN_ERROR",
                {}
              ),
              t
            );
          }
          removedEvent() {
            return {
              orphan: "drop-log",
              log: {
                transactionHash: (t = this).transactionHash,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                address: t.address,
                data: t.data,
                topics: Object.freeze(t.topics.slice()),
                index: t.index,
              },
            };
            var t;
          }
        }
        class Zf {
          provider;
          to;
          from;
          contractAddress;
          hash;
          index;
          blockHash;
          blockNumber;
          logsBloom;
          gasUsed;
          cumulativeGasUsed;
          gasPrice;
          type;
          status;
          root;
          #gt;
          constructor(t, e) {
            this.#gt = Object.freeze(t.logs.map((t) => new Yf(t, e)));
            let n = Qf;
            null != t.effectiveGasPrice
              ? (n = t.effectiveGasPrice)
              : null != t.gasPrice && (n = t.gasPrice),
              yo(this, {
                provider: e,
                to: t.to,
                from: t.from,
                contractAddress: t.contractAddress,
                hash: t.hash,
                index: t.index,
                blockHash: t.blockHash,
                blockNumber: t.blockNumber,
                logsBloom: t.logsBloom,
                gasUsed: t.gasUsed,
                cumulativeGasUsed: t.cumulativeGasUsed,
                gasPrice: n,
                type: t.type,
                status: t.status,
                root: t.root,
              });
          }
          get logs() {
            return this.#gt;
          }
          toJSON() {
            const {
              to: t,
              from: e,
              contractAddress: n,
              hash: r,
              index: s,
              blockHash: i,
              blockNumber: o,
              logsBloom: a,
              logs: l,
              status: c,
              root: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              blockHash: i,
              blockNumber: o,
              contractAddress: n,
              cumulativeGasUsed: Jf(this.cumulativeGasUsed),
              from: e,
              gasPrice: Jf(this.gasPrice),
              gasUsed: Jf(this.gasUsed),
              hash: r,
              index: s,
              logs: l,
              logsBloom: a,
              root: u,
              status: c,
              to: t,
            };
          }
          get length() {
            return this.logs.length;
          }
          [Symbol.iterator]() {
            let t = 0;
            return {
              next: () =>
                t < this.length
                  ? { value: this.logs[t++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get fee() {
            return this.gasUsed * this.gasPrice;
          }
          async getBlock() {
            const t = await this.provider.getBlock(this.blockHash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getTransaction() {
            const t = await this.provider.getTransaction(this.hash);
            if (null == t) throw new Error("TODO");
            return t;
          }
          async getResult() {
            return await this.provider.getTransactionResult(this.hash);
          }
          async confirmations() {
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          removedEvent() {
            return ep(this);
          }
          reorderedEvent(t) {
            return (
              xo(
                !t || t.isMined(),
                "unmined 'other' transction cannot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "reorderedEvent(other)" }
              ),
              tp(this, t)
            );
          }
        }
        class Xf {
          provider;
          blockNumber;
          blockHash;
          index;
          hash;
          type;
          to;
          from;
          nonce;
          gasLimit;
          gasPrice;
          maxPriorityFeePerGas;
          maxFeePerGas;
          data;
          value;
          chainId;
          signature;
          accessList;
          #mt;
          constructor(t, e) {
            (this.provider = e),
              (this.blockNumber = null != t.blockNumber ? t.blockNumber : null),
              (this.blockHash = null != t.blockHash ? t.blockHash : null),
              (this.hash = t.hash),
              (this.index = t.index),
              (this.type = t.type),
              (this.from = t.from),
              (this.to = t.to || null),
              (this.gasLimit = t.gasLimit),
              (this.nonce = t.nonce),
              (this.data = t.data),
              (this.value = t.value),
              (this.gasPrice = t.gasPrice),
              (this.maxPriorityFeePerGas =
                null != t.maxPriorityFeePerGas ? t.maxPriorityFeePerGas : null),
              (this.maxFeePerGas =
                null != t.maxFeePerGas ? t.maxFeePerGas : null),
              (this.chainId = t.chainId),
              (this.signature = t.signature),
              (this.accessList = null != t.accessList ? t.accessList : null),
              (this.#mt = -1);
          }
          toJSON() {
            const {
              blockNumber: t,
              blockHash: e,
              index: n,
              hash: r,
              type: s,
              to: i,
              from: o,
              nonce: a,
              data: l,
              signature: c,
              accessList: u,
            } = this;
            return {
              _type: "TransactionReceipt",
              accessList: u,
              blockNumber: t,
              blockHash: e,
              chainId: Jf(this.chainId),
              data: l,
              from: o,
              gasLimit: Jf(this.gasLimit),
              gasPrice: Jf(this.gasPrice),
              hash: r,
              maxFeePerGas: Jf(this.maxFeePerGas),
              maxPriorityFeePerGas: Jf(this.maxPriorityFeePerGas),
              nonce: a,
              signature: c,
              to: i,
              index: n,
              type: s,
              value: Jf(this.value),
            };
          }
          async getBlock() {
            let t = this.blockNumber;
            if (null == t) {
              const e = await this.getTransaction();
              e && (t = e.blockNumber);
            }
            if (null == t) return null;
            const e = this.provider.getBlock(t);
            if (null == e) throw new Error("TODO");
            return e;
          }
          async getTransaction() {
            return this.provider.getTransaction(this.hash);
          }
          async confirmations() {
            if (null == this.blockNumber) {
              const { tx: t, blockNumber: e } = await mo({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(),
              });
              return null == t || null == t.blockNumber
                ? 0
                : e - t.blockNumber + 1;
            }
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          async wait(t, e) {
            const n = null == t ? 1 : t,
              r = null == e ? 0 : e;
            let s = this.#mt,
              i = -1,
              o = -1 === s;
            const a = async () => {
                if (o) return null;
                const { blockNumber: t, nonce: e } = await mo({
                  blockNumber: this.provider.getBlockNumber(),
                  nonce: this.provider.getTransactionCount(this.from),
                });
                if (e < this.nonce) return void (s = t);
                if (o) return null;
                const r = await this.getTransaction();
                if (!r || null == r.blockNumber)
                  for (
                    -1 === i && ((i = s - 3), i < this.#mt && (i = this.#mt));
                    i <= t;

                  ) {
                    if (o) return null;
                    const e = await this.provider.getBlock(i, !0);
                    if (null == e) return;
                    for (const t of e) if (t === this.hash) return;
                    for (let r = 0; r < e.length; r++) {
                      const i = await e.getTransaction(r);
                      if (i.from === this.from && i.nonce === this.nonce) {
                        if (o) return null;
                        const e = await this.provider.getTransactionReceipt(
                          i.hash
                        );
                        if (null == e) return;
                        if (t - e.blockNumber + 1 < n) return;
                        let r = "replaced";
                        i.data === this.data &&
                        i.to === this.to &&
                        i.value === this.value
                          ? (r = "repriced")
                          : "0x" === i.data &&
                            i.from === i.to &&
                            i.value === Qf &&
                            (r = "cancelled"),
                          xo(
                            !1,
                            "transaction was replaced",
                            "TRANSACTION_REPLACED",
                            {
                              cancelled: "replaced" === r || "cancelled" === r,
                              reason: r,
                              replacement: i.replaceableTransaction(s),
                              hash: i.hash,
                              receipt: e,
                            }
                          );
                      }
                    }
                    i++;
                  }
              },
              l = await this.provider.getTransactionReceipt(this.hash);
            if (0 === n) return l;
            if (l) {
              if ((await l.confirmations()) >= n) return l;
            } else if ((await a(), 0 === n)) return null;
            const c = new Promise((t, e) => {
              const i = [],
                l = () => {
                  i.forEach((t) => t());
                };
              if (
                (i.push(() => {
                  o = !0;
                }),
                r > 0)
              ) {
                const t = setTimeout(() => {
                  l(), e(Ao("wait for transaction timeout", "TIMEOUT"));
                }, r);
                i.push(() => {
                  clearTimeout(t);
                });
              }
              const c = async (e) => {
                (await e.confirmations()) >= n && (l(), t(e));
              };
              if (
                (i.push(() => {
                  this.provider.off(this.hash, c);
                }),
                this.provider.on(this.hash, c),
                s >= 0)
              ) {
                const t = async () => {
                  try {
                    await a();
                  } catch (t) {
                    if (wo(t, "TRANSACTION_REPLACED")) return l(), void e(t);
                  }
                  o || this.provider.once("block", t);
                };
                i.push(() => {
                  this.provider.off("block", t);
                }),
                  this.provider.once("block", t);
              }
            });
            return await c;
          }
          isMined() {
            return null != this.blockHash;
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          removedEvent() {
            return (
              xo(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              ep(this)
            );
          }
          reorderedEvent(t) {
            return (
              xo(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              xo(
                !t || t.isMined(),
                "unmined 'other' transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              tp(this, t)
            );
          }
          replaceableTransaction(t) {
            $o(
              Number.isInteger(t) && t >= 0,
              "invalid startBlock",
              "startBlock",
              t
            );
            const e = new Xf(this, this.provider);
            return (e.#mt = t), e;
          }
        }
        function tp(t, e) {
          return { orphan: "reorder-transaction", tx: t, other: e };
        }
        function ep(t) {
          return { orphan: "drop-transaction", tx: t };
        }
        class np extends Yf {
          interface;
          fragment;
          args;
          constructor(t, e, n) {
            super(t, t.provider);
            yo(this, {
              args: e.decodeEventLog(n, t.data, t.topics),
              fragment: n,
              interface: e,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        class rp extends Zf {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          get logs() {
            return super.logs.map((t) => {
              const e = t.topics.length ? this.#yt.getEvent(t.topics[0]) : null;
              return e ? new np(t, this.#yt, e) : t;
            });
          }
        }
        class sp extends Xf {
          #yt;
          constructor(t, e, n) {
            super(n, e), (this.#yt = t);
          }
          async wait(t) {
            const e = await super.wait(t);
            return null == e ? null : new rp(this.#yt, this.provider, e);
          }
        }
        class ip extends Zo {
          log;
          constructor(t, e, n, r) {
            super(t, e, n), yo(this, { log: r });
          }
          async getBlock() {
            return await this.log.getBlock();
          }
          async getTransaction() {
            return await this.log.getTransaction();
          }
          async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
          }
        }
        class op extends ip {
          constructor(t, e, n, r, s) {
            super(t, e, n, new np(s, t.interface, r));
            yo(this, {
              args: t.interface.decodeEventLog(
                r,
                this.log.data,
                this.log.topics
              ),
              fragment: r,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        const ap = BigInt(0);
        function lp(t) {
          return t && "function" == typeof t.call;
        }
        function cp(t) {
          return t && "function" == typeof t.estimateGas;
        }
        function up(t) {
          return t && "function" == typeof t.resolveName;
        }
        function dp(t) {
          return t && "function" == typeof t.sendTransaction;
        }
        class hp {
          #bt;
          fragment;
          constructor(t, e, n) {
            if ((yo(this, { fragment: e }), e.inputs.length < n.length))
              throw new Error("too many arguments");
            const r = fp(t.runner, "resolveName"),
              s = up(r) ? r : null;
            this.#bt = (async function () {
              const r = await Promise.all(
                e.inputs.map((t, e) =>
                  null == n[e]
                    ? null
                    : t.walkAsync(n[e], (t, e) =>
                        "address" === t ? bu(e, s) : e
                      )
                )
              );
              return t.interface.encodeFilterTopics(e, r);
            })();
          }
          getTopicFilter() {
            return this.#bt;
          }
        }
        function fp(t, e) {
          return null == t
            ? null
            : "function" == typeof t[e]
            ? t
            : t.provider && "function" == typeof t.provider[e]
            ? t.provider
            : null;
        }
        function pp(t) {
          return null == t ? null : t.provider || null;
        }
        async function gp(t, e) {
          const n = Kf($u.dereference(t, "overrides"));
          return (
            $o(
              null == n.to || (e || []).indexOf("to") >= 0,
              "cannot override to",
              "overrides.to",
              n.to
            ),
            $o(
              null == n.data || (e || []).indexOf("data") >= 0,
              "cannot override data",
              "overrides.data",
              n.data
            ),
            n.from && (n.from = await bu(n.from)),
            n
          );
        }
        function mp(t) {
          const e = async function (e) {
              const n = await gp(e, ["data"]);
              n.to = await t.getAddress();
              const r = t.interface,
                s = Go(n.value || ap, "overrides.value") === ap,
                i = "0x" === (n.data || "0x");
              !r.fallback ||
                r.fallback.payable ||
                !r.receive ||
                i ||
                s ||
                $o(
                  !1,
                  "cannot send data to receive or send value to non-payable fallback",
                  "overrides",
                  e
                ),
                $o(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                );
              return (
                $o(
                  r.receive || (r.fallback && r.fallback.payable) || s,
                  "cannot send value to non-payable fallback",
                  "overrides.value",
                  n.value
                ),
                $o(
                  r.fallback || i,
                  "cannot send data to receive-only contract",
                  "overrides.data",
                  n.data
                ),
                n
              );
            },
            n = async function (n) {
              const r = t.runner;
              xo(
                dp(r),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await r.sendTransaction(await e(n)),
                i = pp(t.runner);
              return new sp(t.interface, i, s);
            },
            r = async (t) => await n(t);
          return (
            yo(r, {
              _contract: t,
              estimateGas: async function (n) {
                const r = fp(t.runner, "estimateGas");
                return (
                  xo(
                    cp(r),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await r.estimateGas(await e(n))
                );
              },
              populateTransaction: e,
              send: n,
              staticCall: async function (n) {
                const r = fp(t.runner, "call");
                xo(
                  lp(r),
                  "contract runner does not support calling",
                  "UNSUPPORTED_OPERATION",
                  { operation: "call" }
                );
                const s = await e(n);
                try {
                  return await r.call(s);
                } catch (e) {
                  if (vo(e) && e.data) throw t.interface.makeError(e.data, s);
                  throw e;
                }
              },
            }),
            r
          );
        }
        function yp(t, e) {
          const n = function (...n) {
              const r = t.interface.getFunction(e, n);
              return (
                xo(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                  operation: "fragment",
                }),
                r
              );
            },
            r = async function (...e) {
              const r = n(...e);
              let s = {};
              if (
                (r.inputs.length + 1 === e.length && (s = await gp(e.pop())),
                r.inputs.length !== e.length)
              )
                throw new Error(
                  "internal error: fragment inputs doesn't match arguments; should not happen"
                );
              const i = await (async function (t, e, n) {
                const r = fp(t, "resolveName"),
                  s = up(r) ? r : null;
                return await Promise.all(
                  e.map((t, e) =>
                    t.walkAsync(
                      n[e],
                      (t, e) => (
                        (e = $u.dereference(e, t)),
                        "address" === t ? bu(e, s) : e
                      )
                    )
                  )
                );
              })(t.runner, r.inputs, e);
              return Object.assign(
                {},
                s,
                await mo({
                  to: t.getAddress(),
                  data: t.interface.encodeFunctionData(r, i),
                })
              );
            },
            s = async function (...t) {
              const e = await o(...t);
              return 1 === e.length ? e[0] : e;
            },
            i = async function (...e) {
              const n = t.runner;
              xo(
                dp(n),
                "contract runner does not support sending transactions",
                "UNSUPPORTED_OPERATION",
                { operation: "sendTransaction" }
              );
              const s = await n.sendTransaction(await r(...e)),
                i = pp(t.runner);
              return new sp(t.interface, i, s);
            },
            o = async function (...e) {
              const s = fp(t.runner, "call");
              xo(
                lp(s),
                "contract runner does not support calling",
                "UNSUPPORTED_OPERATION",
                { operation: "call" }
              );
              const i = await r(...e);
              let o = "0x";
              try {
                o = await s.call(i);
              } catch (e) {
                if (vo(e) && e.data) throw t.interface.makeError(e.data, i);
                throw e;
              }
              const a = n(...e);
              return t.interface.decodeFunctionResult(a, o);
            },
            a = async (...t) =>
              n(...t).constant ? await s(...t) : await i(...t);
          return (
            yo(a, {
              name: t.interface.getFunctionName(e),
              _contract: t,
              _key: e,
              getFragment: n,
              estimateGas: async function (...e) {
                const n = fp(t.runner, "estimateGas");
                return (
                  xo(
                    cp(n),
                    "contract runner does not support gas estimation",
                    "UNSUPPORTED_OPERATION",
                    { operation: "estimateGas" }
                  ),
                  await n.estimateGas(await r(...e))
                );
              },
              populateTransaction: r,
              send: i,
              staticCall: s,
              staticCallResult: o,
            }),
            Object.defineProperty(a, "fragment", {
              configurable: !1,
              enumerable: !0,
              get: () => {
                const n = t.interface.getFunction(e);
                return (
                  xo(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                    operation: "fragment",
                  }),
                  n
                );
              },
            }),
            a
          );
        }
        const bp = Symbol.for("_ethersInternal_contract"),
          wp = new WeakMap();
        function vp(t) {
          return wp.get(t[bp]);
        }
        async function Ap(t, e) {
          let n,
            r = null;
          if (Array.isArray(e)) {
            const r = function (e) {
              if (Bo(e, 32)) return e;
              const n = t.interface.getEvent(e);
              return $o(n, "unknown fragment", "name", e), n.topicHash;
            };
            n = e.map((t) =>
              null == t ? null : Array.isArray(t) ? t.map(r) : r(t)
            );
          } else
            "*" === e
              ? (n = [null])
              : "string" == typeof e
              ? Bo(e, 32)
                ? (n = [e])
                : ((r = t.interface.getEvent(e)),
                  $o(r, "unknown fragment", "event", e),
                  (n = [r.topicHash]))
              : (s = e) &&
                "object" == typeof s &&
                "getTopicFilter" in s &&
                "function" == typeof s.getTopicFilter &&
                s.fragment
              ? (n = await e.getTopicFilter())
              : "fragment" in e
              ? ((r = e.fragment), (n = [r.topicHash]))
              : $o(!1, "unknown event name", "event", e);
          var s;
          n = n.map((t) => {
            if (null == t) return null;
            if (Array.isArray(t)) {
              const e = Array.from(
                new Set(t.map((t) => t.toLowerCase())).values()
              );
              return 1 === e.length ? e[0] : (e.sort(), e);
            }
            return t.toLowerCase();
          });
          const i = n
            .map((t) =>
              null == t ? "null" : Array.isArray(t) ? t.join("|") : t
            )
            .join("&");
          return { fragment: r, tag: i, topics: n };
        }
        async function xp(t, e) {
          const { subs: n } = vp(t);
          return n.get((await Ap(t, e)).tag) || null;
        }
        async function $p(t, e, n) {
          const r = pp(t.runner);
          xo(
            r,
            "contract runner does not support subscribing",
            "UNSUPPORTED_OPERATION",
            { operation: e }
          );
          const { fragment: s, tag: i, topics: o } = await Ap(t, n),
            { addr: a, subs: l } = vp(t);
          let c = l.get(i);
          if (!c) {
            const e = { address: a || t, topics: o },
              u = (e) => {
                let r = s;
                if (null == r)
                  try {
                    r = t.interface.getEvent(e.topics[0]);
                  } catch (t) {}
                if (r) {
                  const i = r,
                    o = s
                      ? t.interface.decodeEventLog(s, e.data, e.topics)
                      : [];
                  Ep(t, n, o, (r) => new op(t, r, n, i, e));
                } else Ep(t, n, [], (r) => new ip(t, r, n, e));
              };
            let d = [];
            (c = {
              tag: i,
              listeners: [],
              start: () => {
                d.length || d.push(r.on(e, u));
              },
              stop: async () => {
                if (0 == d.length) return;
                let t = d;
                (d = []), await Promise.all(t), r.off(e, u);
              },
            }),
              l.set(i, c);
          }
          return c;
        }
        let kp = Promise.resolve();
        async function Ep(t, e, n, r) {
          try {
            await kp;
          } catch (t) {}
          const s = (async function (t, e, n, r) {
            await kp;
            const s = await xp(t, e);
            if (!s) return !1;
            const i = s.listeners.length;
            return (
              (s.listeners = s.listeners.filter(({ listener: e, once: s }) => {
                const i = Array.from(n);
                r && i.push(r(s ? null : e));
                try {
                  e.call(t, ...i);
                } catch (t) {}
                return !s;
              })),
              0 === s.listeners.length && (s.stop(), vp(t).subs.delete(s.tag)),
              i > 0
            );
          })(t, e, n, r);
          return (kp = s), await s;
        }
        const Cp = ["then"];
        class Sp {
          target;
          interface;
          runner;
          filters;
          [bp];
          fallback;
          constructor(t, e, n, r) {
            $o(
              "string" == typeof t || mu(t),
              "invalid value for Contract target",
              "target",
              t
            ),
              null == n && (n = null);
            const s = Vf.from(e);
            let i;
            yo(this, { target: t, runner: n, interface: s }),
              Object.defineProperty(this, bp, { value: {} });
            let o = null,
              a = null;
            if (r) {
              const t = pp(n);
              a = new sp(this.interface, t, r);
            }
            let l = new Map();
            if ("string" == typeof t)
              if (Bo(t)) (o = t), (i = Promise.resolve(t));
              else {
                const e = fp(n, "resolveName");
                if (!up(e))
                  throw Ao(
                    "contract runner does not support name resolution",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  );
                i = e.resolveName(t).then((e) => {
                  if (null == e)
                    throw Ao(
                      "an ENS name used for a contract target must be correctly configured",
                      "UNCONFIGURED_NAME",
                      { value: t }
                    );
                  return (vp(this).addr = e), e;
                });
              }
            else
              i = t.getAddress().then((t) => {
                if (null == t) throw new Error("TODO");
                return (vp(this).addr = t), t;
              });
            var c, u;
            (c = this),
              (u = { addrPromise: i, addr: o, deployTx: a, subs: l }),
              wp.set(c[bp], u);
            const d = new Proxy(
              {},
              {
                get: (t, e, n) => {
                  if (Cp.indexOf(e) >= 0) return Reflect.get(t, e, n);
                  const r = String(e),
                    s = this.getEvent(r);
                  if (s) return s;
                  throw new Error(`unknown contract event: ${r}`);
                },
                has: (t, e) =>
                  Cp.indexOf(e) >= 0
                    ? Reflect.has(t, e)
                    : Reflect.has(t, e) || this.interface.hasEvent(String(e)),
              }
            );
            return (
              yo(this, { filters: d }),
              yo(this, { fallback: s.receive || s.fallback ? mp(this) : null }),
              new Proxy(this, {
                get: (t, e, n) => {
                  if (e in t || Cp.indexOf(e) >= 0) return Reflect.get(t, e, n);
                  const r = String(e),
                    s = t.getFunction(r);
                  if (s) return s;
                  throw new Error(`unknown contract method: ${r}`);
                },
                has: (t, e) =>
                  e in t || Cp.indexOf(e) >= 0
                    ? Reflect.has(t, e)
                    : t.interface.hasFunction(String(e)),
              })
            );
          }
          connect(t) {
            return new Sp(this.target, this.interface, t);
          }
          attach(t) {
            return new Sp(t, this.interface, this.runner);
          }
          async getAddress() {
            return await vp(this).addrPromise;
          }
          async getDeployedCode() {
            const t = pp(this.runner);
            xo(
              t,
              "runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "getDeployedCode" }
            );
            const e = await t.getCode(await this.getAddress());
            return "0x" === e ? null : e;
          }
          async waitForDeployment() {
            const t = this.deploymentTransaction();
            if (t) return await t.wait(), this;
            if (null != (await this.getDeployedCode())) return this;
            const e = pp(this.runner);
            return (
              xo(
                null != e,
                "contract runner does not support .provider",
                "UNSUPPORTED_OPERATION",
                { operation: "waitForDeployment" }
              ),
              new Promise((t, n) => {
                const r = async () => {
                  try {
                    if (null != (await this.getDeployedCode())) return t(this);
                    e.once("block", r);
                  } catch (t) {
                    n(t);
                  }
                };
                r();
              })
            );
          }
          deploymentTransaction() {
            return vp(this).deployTx;
          }
          getFunction(t) {
            "string" != typeof t && (t = t.format());
            return yp(this, t);
          }
          getEvent(t) {
            return (
              "string" != typeof t && (t = t.format()),
              (function (t, e) {
                const n = function (...n) {
                    const r = t.interface.getEvent(e, n);
                    return (
                      xo(r, "no matching fragment", "UNSUPPORTED_OPERATION", {
                        operation: "fragment",
                      }),
                      r
                    );
                  },
                  r = function (...e) {
                    return new hp(t, n(...e), e);
                  };
                return (
                  yo(r, {
                    name: t.interface.getEventName(e),
                    _contract: t,
                    _key: e,
                    getFragment: n,
                  }),
                  Object.defineProperty(r, "fragment", {
                    configurable: !1,
                    enumerable: !0,
                    get: () => {
                      const n = t.interface.getEvent(e);
                      return (
                        xo(n, "no matching fragment", "UNSUPPORTED_OPERATION", {
                          operation: "fragment",
                        }),
                        n
                      );
                    },
                  }),
                  r
                );
              })(this, t)
            );
          }
          async queryTransaction(t) {
            throw new Error("@TODO");
          }
          async queryFilter(t, e, n) {
            null == e && (e = 0), null == n && (n = "latest");
            const { addr: r, addrPromise: s } = vp(this),
              i = r || (await s),
              { fragment: o, topics: a } = await Ap(this, t),
              l = { address: i, topics: a, fromBlock: e, toBlock: n },
              c = pp(this.runner);
            return (
              xo(
                c,
                "contract runner does not have a provider",
                "UNSUPPORTED_OPERATION",
                { operation: "queryFilter" }
              ),
              (await c.getLogs(l)).map((t) => {
                let e = o;
                if (null == e)
                  try {
                    e = this.interface.getEvent(t.topics[0]);
                  } catch (t) {}
                return e ? new np(t, this.interface, e) : new Yf(t, c);
              })
            );
          }
          async on(t, e) {
            const n = await $p(this, "on", t);
            return n.listeners.push({ listener: e, once: !1 }), n.start(), this;
          }
          async once(t, e) {
            const n = await $p(this, "once", t);
            return n.listeners.push({ listener: e, once: !0 }), n.start(), this;
          }
          async emit(t, ...e) {
            return await Ep(this, t, e, null);
          }
          async listenerCount(t) {
            if (t) {
              const e = await xp(this, t);
              return e ? e.listeners.length : 0;
            }
            const { subs: e } = vp(this);
            let n = 0;
            for (const { listeners: t } of e.values()) n += t.length;
            return n;
          }
          async listeners(t) {
            if (t) {
              const e = await xp(this, t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            const { subs: e } = vp(this);
            let n = [];
            for (const { listeners: t } of e.values())
              n = n.concat(t.map(({ listener: t }) => t));
            return n;
          }
          async off(t, e) {
            const n = await xp(this, t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (null != e && 0 !== n.listeners.length) ||
                (n.stop(), vp(this).subs.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const e = await xp(this, t);
              if (!e) return this;
              e.stop(), vp(this).subs.delete(e.tag);
            } else {
              const { subs: t } = vp(this);
              for (const { tag: e, stop: n } of t.values()) n(), t.delete(e);
            }
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return await this.off(t, e);
          }
          static buildClass(t) {
            return class extends Sp {
              constructor(e, n = null) {
                super(e, t, n);
              }
            };
          }
          static from(t, e, n) {
            null == n && (n = null);
            return new this(t, e, n);
          }
        }
        class Pp extends (function () {
          return Sp;
        })() {}
        function Ip(t) {
          return (
            t.match(/^ipfs:\/\/ipfs\//i)
              ? (t = t.substring(12))
              : t.match(/^ipfs:\/\//i)
              ? (t = t.substring(7))
              : $o(!1, "unsupported IPFS format", "link", t),
            `https://gateway.ipfs.io/ipfs/${t}`
          );
        }
        class Bp {
          name;
          constructor(t) {
            yo(this, { name: t });
          }
          connect(t) {
            return this;
          }
          supportsCoinType(t) {
            return !1;
          }
          async encodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
          async decodeAddress(t, e) {
            throw new Error("unsupported coin");
          }
        }
        const Np = new RegExp("^(ipfs)://(.*)$", "i"),
          Tp = [
            new RegExp("^(https)://(.*)$", "i"),
            new RegExp("^(data):(.*)$", "i"),
            Np,
            new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
          ];
        class Op {
          provider;
          address;
          name;
          #wt;
          #vt;
          constructor(t, e, n) {
            yo(this, { provider: t, address: e, name: n }),
              (this.#wt = null),
              (this.#vt = new Pp(
                e,
                [
                  "function supportsInterface(bytes4) view returns (bool)",
                  "function resolve(bytes, bytes) view returns (bytes)",
                  "function addr(bytes32) view returns (address)",
                  "function addr(bytes32, uint) view returns (bytes)",
                  "function text(bytes32, string) view returns (string)",
                  "function contenthash(bytes32) view returns (bytes)",
                ],
                t
              ));
          }
          async supportsWildcard() {
            return (
              null == this.#wt &&
                (this.#wt = (async () => {
                  try {
                    return await this.#vt.supportsInterface("0x9061b923");
                  } catch (t) {
                    if (wo(t, "CALL_EXCEPTION")) return !1;
                    throw ((this.#wt = null), t);
                  }
                })()),
              await this.#wt
            );
          }
          async #At(t, e) {
            e = (e || []).slice();
            const n = this.#vt.interface;
            e.unshift(ah(this.name));
            let r = null;
            var s;
            (await this.supportsWildcard()) &&
              ((r = n.getFunction(t)),
              xo(r, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName: t },
              }),
              (e = [
                ((s = this.name),
                To(
                  Oo(
                    oh(s).map((t) => {
                      if (t.length > 63)
                        throw new Error(
                          "invalid DNS encoded entry; length exceeds 63 bytes"
                        );
                      const e = new Uint8Array(t.length + 1);
                      return e.set(t, 1), (e[0] = e.length - 1), e;
                    })
                  )
                ) + "00"),
                n.encodeFunctionData(r, e),
              ]),
              (t = "resolve(bytes,bytes)")),
              e.push({ enableCcipRead: !0 });
            try {
              const s = await this.#vt[t](...e);
              return r ? n.decodeFunctionResult(r, s)[0] : s;
            } catch (t) {
              if (!wo(t, "CALL_EXCEPTION")) throw t;
            }
            return null;
          }
          async getAddress(t) {
            if ((null == t && (t = 60), 60 === t))
              try {
                const t = await this.#At("addr(bytes32)");
                return null == t || t === Yc ? null : t;
              } catch (t) {
                if (wo(t, "CALL_EXCEPTION")) return null;
                throw t;
              }
            if (t >= 0 && t < 2147483648) {
              let e = t + 2147483648;
              const n = await this.#At("addr(bytes32,uint)", [e]);
              if (Bo(n, 20)) return gu(n);
            }
            let e = null;
            for (const n of this.provider.plugins)
              if (n instanceof Bp && n.supportsCoinType(t)) {
                e = n;
                break;
              }
            if (null == e) return null;
            const n = await this.#At("addr(bytes32,uint)", [t]);
            if (null == n || "0x" === n) return null;
            const r = await e.decodeAddress(t, n);
            if (null != r) return r;
            xo(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${t})`,
              info: { coinType: t, data: n },
            });
          }
          async getText(t) {
            const e = await this.#At("text(bytes32,string)", [t]);
            return null == e || "0x" === e ? null : e;
          }
          async getContentHash() {
            const t = await this.#At("contenthash(bytes32)");
            if (null == t || "0x" === t) return null;
            const e = t.match(
              /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
            );
            if (e) {
              const t = "e3010170" === e[1] ? "ipfs" : "ipns",
                n = parseInt(e[4], 16);
              if (e[5].length === 2 * n)
                return `${t}://${(function (t) {
                  let e = Wo(Po(t)),
                    n = "";
                  for (; e; )
                    (n =
                      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"[
                        Number(e % Yo)
                      ] + n),
                      (e /= Yo);
                  return n;
                })("0x" + e[2])}`;
            }
            const n = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (n && 64 === n[1].length) return `bzz://${n[1]}`;
            xo(
              !1,
              "invalid or unsupported content hash data",
              "UNSUPPORTED_OPERATION",
              { operation: "getContentHash()", info: { data: t } }
            );
          }
          async getAvatar() {
            return (await this._getAvatar()).url;
          }
          async _getAvatar() {
            const t = [{ type: "name", value: this.name }];
            try {
              const e = await this.getText("avatar");
              if (null == e)
                return (
                  t.push({ type: "!avatar", value: "" }),
                  { url: null, linkage: t }
                );
              t.push({ type: "avatar", value: e });
              for (let n = 0; n < Tp.length; n++) {
                const r = e.match(Tp[n]);
                if (null == r) continue;
                const s = r[1].toLowerCase();
                switch (s) {
                  case "https":
                  case "data":
                    return (
                      t.push({ type: "url", value: e }), { linkage: t, url: e }
                    );
                  case "ipfs": {
                    const n = Ip(e);
                    return (
                      t.push({ type: "ipfs", value: e }),
                      t.push({ type: "url", value: n }),
                      { linkage: t, url: n }
                    );
                  }
                  case "erc721":
                  case "erc1155": {
                    const n =
                      "erc721" === s ? "tokenURI(uint256)" : "uri(uint256)";
                    t.push({ type: s, value: e });
                    const i = await this.getAddress();
                    if (null == i)
                      return (
                        t.push({ type: "!owner", value: "" }),
                        { url: null, linkage: t }
                      );
                    const o = (r[2] || "").split("/");
                    if (2 !== o.length)
                      return (
                        t.push({ type: `!${s}caip`, value: r[2] || "" }),
                        { url: null, linkage: t }
                      );
                    const a = o[1],
                      l = new Pp(
                        o[0],
                        [
                          "function tokenURI(uint) view returns (string)",
                          "function ownerOf(uint) view returns (address)",
                          "function uri(uint) view returns (string)",
                          "function balanceOf(address, uint256) view returns (uint)",
                        ],
                        this.provider
                      );
                    if ("erc721" === s) {
                      const e = await l.ownerOf(a);
                      if (i !== e)
                        return (
                          t.push({ type: "!owner", value: e }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "owner", value: e });
                    } else if ("erc1155" === s) {
                      const e = await l.balanceOf(i, a);
                      if (!e)
                        return (
                          t.push({ type: "!balance", value: "0" }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "balance", value: e.toString() });
                    }
                    let c = await l[n](a);
                    if (null == c || "0x" === c)
                      return (
                        t.push({ type: "!metadata-url", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata-url-base", value: c }),
                      "erc1155" === s &&
                        ((c = c.replace("{id}", _o(a, 32).substring(2))),
                        t.push({ type: "metadata-url-expanded", value: c })),
                      c.match(/^ipfs:/i) && (c = Ip(c)),
                      t.push({ type: "metadata-url", value: c });
                    let u = {};
                    const d = await new fa(c).send();
                    d.assertOk();
                    try {
                      u = d.bodyJson;
                    } catch (e) {
                      try {
                        t.push({ type: "!metadata", value: d.bodyText });
                      } catch (e) {
                        const n = d.body;
                        return (
                          n && t.push({ type: "!metadata", value: To(n) }),
                          { url: null, linkage: t }
                        );
                      }
                      return { url: null, linkage: t };
                    }
                    if (!u)
                      return (
                        t.push({ type: "!metadata", value: "" }),
                        { url: null, linkage: t }
                      );
                    t.push({ type: "metadata", value: JSON.stringify(u) });
                    let h = u.image;
                    if ("string" != typeof h)
                      return (
                        t.push({ type: "!imageUrl", value: "" }),
                        { url: null, linkage: t }
                      );
                    if (h.match(/^(https:\/\/|data:)/i));
                    else {
                      if (null == h.match(Np))
                        return (
                          t.push({ type: "!imageUrl-ipfs", value: h }),
                          { url: null, linkage: t }
                        );
                      t.push({ type: "imageUrl-ipfs", value: h }), (h = Ip(h));
                    }
                    return (
                      t.push({ type: "url", value: h }), { linkage: t, url: h }
                    );
                  }
                }
              }
            } catch (t) {}
            return { linkage: t, url: null };
          }
          static async getEnsAddress(t) {
            const e = await t.getNetwork(),
              n = e.getPlugin("org.ethers.plugins.network.Ens");
            return (
              xo(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                operation: "getEnsAddress",
                info: { network: e },
              }),
              n.address
            );
          }
          static async #xt(t, e) {
            const n = await Op.getEnsAddress(t);
            try {
              const r = new Pp(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  t
                ),
                s = await r.resolver(ah(e), { enableCcipRead: !0 });
              return s === Yc ? null : s;
            } catch (t) {
              throw t;
            }
            return null;
          }
          static async fromName(t, e) {
            let n = e;
            for (;;) {
              if ("" === n || "." === n) return null;
              if ("eth" !== e && "eth" === n) return null;
              const r = await Op.#xt(t, n);
              if (null != r) {
                const s = new Op(t, r, e);
                return n === e || (await s.supportsWildcard()) ? s : null;
              }
              n = n.split(".").slice(1).join(".");
            }
          }
        }
        const Rp = BigInt(0);
        function Lp(t, e) {
          return function (n) {
            return null == n ? e : t(n);
          };
        }
        function zp(t) {
          return (e) => {
            if (!Array.isArray(e)) throw new Error("not an array");
            return e.map((e) => t(e));
          };
        }
        function Up(t, e) {
          return (n) => {
            const r = {};
            for (const s in t) {
              let i = s;
              if (e && s in e && !(i in n))
                for (const t of e[s])
                  if (t in n) {
                    i = t;
                    break;
                  }
              try {
                const e = t[s](n[i]);
                void 0 !== e && (r[s] = e);
              } catch (t) {
                xo(
                  !1,
                  `invalid value for value.${s} (${
                    t instanceof Error ? t.message : "not-an-error"
                  })`,
                  "BAD_DATA",
                  { value: n }
                );
              }
            }
            return r;
          };
        }
        function Fp(t) {
          return $o(Bo(t, !0), "invalid data", "value", t), t;
        }
        function Dp(t) {
          return $o(Bo(t, 32), "invalid hash", "value", t), t;
        }
        const Mp = Up(
          {
            address: gu,
            blockHash: Dp,
            blockNumber: Jo,
            data: Fp,
            index: Jo,
            removed: Lp(function (t) {
              switch (t) {
                case !0:
                case "true":
                  return !0;
                case !1:
                case "false":
                  return !1;
              }
              $o(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
            }, !1),
            topics: zp(Dp),
            transactionHash: Dp,
            transactionIndex: Jo,
          },
          { index: ["logIndex"] }
        );
        const jp = Up({
          hash: Lp(Dp),
          parentHash: Dp,
          number: Jo,
          timestamp: Jo,
          nonce: Lp(Fp),
          difficulty: Go,
          gasLimit: Go,
          gasUsed: Go,
          miner: Lp(gu),
          extraData: Fp,
          baseFeePerGas: Lp(Go),
        });
        const Hp = Up(
          {
            transactionIndex: Jo,
            blockNumber: Jo,
            transactionHash: Dp,
            address: gu,
            topics: zp(Dp),
            data: Fp,
            index: Jo,
            blockHash: Dp,
          },
          { index: ["logIndex"] }
        );
        const Gp = Up(
          {
            to: Lp(gu, null),
            from: Lp(gu, null),
            contractAddress: Lp(gu, null),
            index: Jo,
            root: Lp(To),
            gasUsed: Go,
            logsBloom: Lp(Fp),
            blockHash: Dp,
            hash: Dp,
            logs: zp(function (t) {
              return Hp(t);
            }),
            blockNumber: Jo,
            cumulativeGasUsed: Go,
            effectiveGasPrice: Lp(Go),
            status: Lp(Jo),
            type: Lp(Jo, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
        function Vp(t) {
          t.to &&
            Go(t.to) === Rp &&
            (t.to = "0x0000000000000000000000000000000000000000");
          const e = Up(
            {
              hash: Dp,
              type: (t) => ("0x" === t || null == t ? 0 : Jo(t)),
              accessList: Lp(ch, null),
              blockHash: Lp(Dp, null),
              blockNumber: Lp(Jo, null),
              transactionIndex: Lp(Jo, null),
              from: gu,
              gasPrice: Lp(Go),
              maxPriorityFeePerGas: Lp(Go),
              maxFeePerGas: Lp(Go),
              gasLimit: Go,
              to: Lp(gu, null),
              value: Go,
              nonce: Jo,
              data: Fp,
              creates: Lp(gu, null),
              chainId: Lp(Go, null),
            },
            { data: ["input"], gasLimit: ["gas"] }
          )(t);
          if (
            (null == e.to &&
              null == e.creates &&
              (e.creates = (function (t) {
                const e = gu(t.from);
                let n = Go(t.nonce, "tx.nonce").toString(16);
                return (
                  (n = "0" === n ? "0x" : n.length % 2 ? "0x0" + n : "0x" + n),
                  gu(Lo(_l(Ra([e, n])), 12))
                );
              })(e)),
            (1 !== t.type && 2 !== t.type) ||
              null != t.accessList ||
              (e.accessList = []),
            t.signature
              ? (e.signature = au.from(t.signature))
              : (e.signature = au.from(t)),
            null == e.chainId)
          ) {
            const t = e.signature.legacyChainId;
            null != t && (e.chainId = t);
          }
          return (
            e.blockHash && Go(e.blockHash) === Rp && (e.blockHash = null), e
          );
        }
        class Qp {
          name;
          constructor(t) {
            yo(this, { name: t });
          }
          clone() {
            return new Qp(this.name);
          }
        }
        class Wp extends Qp {
          effectiveBlock;
          txBase;
          txCreate;
          txDataZero;
          txDataNonzero;
          txAccessListStorageKey;
          txAccessListAddress;
          constructor(t, e) {
            null == t && (t = 0),
              super(`org.ethers.network.plugins.GasCost#${t || 0}`);
            const n = { effectiveBlock: t };
            function r(t, r) {
              let s = (e || {})[t];
              null == s && (s = r),
                $o("number" == typeof s, `invalud value for ${t}`, "costs", e),
                (n[t] = s);
            }
            r("txBase", 21e3),
              r("txCreate", 32e3),
              r("txDataZero", 4),
              r("txDataNonzero", 16),
              r("txAccessListStorageKey", 1900),
              r("txAccessListAddress", 2400),
              yo(this, n);
          }
          clone() {
            return new Wp(this.effectiveBlock, this);
          }
        }
        class Jp extends Qp {
          address;
          targetNetwork;
          constructor(t, e) {
            super("org.ethers.plugins.network.Ens"),
              yo(this, {
                address: t || "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                targetNetwork: null == e ? 1 : e,
              });
          }
          clone() {
            return new Jp(this.address, this.targetNetwork);
          }
        }
        const _p = new Map();
        class Kp {
          #$t;
          #Y;
          #kt;
          constructor(t, e) {
            (this.#$t = t), (this.#Y = Go(e)), (this.#kt = new Map());
          }
          toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
          }
          get name() {
            return this.#$t;
          }
          set name(t) {
            this.#$t = t;
          }
          get chainId() {
            return this.#Y;
          }
          set chainId(t) {
            this.#Y = Go(t, "chainId");
          }
          matches(t) {
            if (null == t) return !1;
            if ("string" == typeof t) {
              try {
                return this.chainId === Go(t);
              } catch (t) {}
              return this.name === t;
            }
            if ("number" == typeof t || "bigint" == typeof t) {
              try {
                return this.chainId === Go(t);
              } catch (t) {}
              return !1;
            }
            if ("object" == typeof t) {
              if (null != t.chainId) {
                try {
                  return this.chainId === Go(t.chainId);
                } catch (t) {}
                return !1;
              }
              return null != t.name && this.name === t.name;
            }
            return !1;
          }
          get plugins() {
            return Array.from(this.#kt.values());
          }
          attachPlugin(t) {
            if (this.#kt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#kt.set(t.name, t.clone()), this;
          }
          getPlugin(t) {
            return this.#kt.get(t) || null;
          }
          getPlugins(t) {
            return this.plugins.filter((e) => e.name.split("#")[0] === t);
          }
          clone() {
            const t = new Kp(this.name, this.chainId);
            return (
              this.plugins.forEach((e) => {
                t.attachPlugin(e.clone());
              }),
              t
            );
          }
          computeIntrinsicGas(t) {
            const e =
              this.getPlugin("org.ethers.plugins.network.GasCost") || new Wp();
            let n = e.txBase;
            if ((null == t.to && (n += e.txCreate), t.data))
              for (let r = 2; r < t.data.length; r += 2)
                "00" === t.data.substring(r, r + 2)
                  ? (n += e.txDataZero)
                  : (n += e.txDataNonzero);
            if (t.accessList) {
              const r = ch(t.accessList);
              for (const t in r)
                n +=
                  e.txAccessListAddress +
                  e.txAccessListStorageKey * r[t].storageKeys.length;
            }
            return n;
          }
          static from(t) {
            if (
              ((function () {
                if (qp) return;
                function t(t, e, n) {
                  const r = function () {
                    const r = new Kp(t, e);
                    return (
                      null != n.ensNetwork &&
                        r.attachPlugin(new Jp(null, n.ensNetwork)),
                      n.priorityFee,
                      r.attachPlugin(new Wp()),
                      r
                    );
                  };
                  Kp.register(t, r),
                    Kp.register(e, r),
                    n.altNames &&
                      n.altNames.forEach((t) => {
                        Kp.register(t, r);
                      });
                }
                (qp = !0),
                  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
                  t("ropsten", 3, { ensNetwork: 3 }),
                  t("rinkeby", 4, { ensNetwork: 4 }),
                  t("goerli", 5, { ensNetwork: 5 }),
                  t("kovan", 42, { ensNetwork: 42 }),
                  t("sepolia", 11155111, {}),
                  t("classic", 61, {}),
                  t("classicKotti", 6, {}),
                  t("xdai", 100, { ensNetwork: 1 }),
                  t("optimism", 10, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api-optimistic.etherscan.io/" },
                  }),
                  t("optimism-goerli", 420, {
                    etherscan: {
                      url: "https://api-goerli-optimistic.etherscan.io/",
                    },
                  }),
                  t("arbitrum", 42161, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.arbiscan.io/" },
                  }),
                  t("arbitrum-goerli", 421613, {
                    etherscan: { url: "https://api-goerli.arbiscan.io/" },
                  }),
                  t("matic", 137, {
                    ensNetwork: 1,
                    etherscan: { url: "https://api.polygonscan.com/" },
                  }),
                  t("matic-mumbai", 80001, {
                    altNames: ["maticMumbai", "maticmum"],
                    etherscan: { url: "https://api-testnet.polygonscan.com/" },
                  }),
                  t("bnb", 56, {
                    ensNetwork: 1,
                    etherscan: { url: "http://api.bscscan.com" },
                  }),
                  t("bnbt", 97, {
                    etherscan: { url: "http://api-testnet.bscscan.com" },
                  });
              })(),
              null == t)
            )
              return Kp.from("mainnet");
            if (
              ("number" == typeof t && (t = BigInt(t)),
              "string" == typeof t || "bigint" == typeof t)
            ) {
              const e = _p.get(t);
              if (e) return e();
              if ("bigint" == typeof t) return new Kp("unknown", t);
              $o(!1, "unknown network", "network", t);
            }
            if ("function" == typeof t.clone) {
              return t.clone();
            }
            if ("object" == typeof t) {
              $o(
                "string" == typeof t.name && "number" == typeof t.chainId,
                "invalid network object name or chainId",
                "network",
                t
              );
              const e = new Kp(t.name, t.chainId);
              return (
                (t.ensAddress || null != t.ensNetwork) &&
                  e.attachPlugin(new Jp(t.ensAddress, t.ensNetwork)),
                e
              );
            }
            $o(!1, "invalid network", "network", t);
          }
          static register(t, e) {
            "number" == typeof t && (t = BigInt(t));
            const n = _p.get(t);
            n &&
              $o(
                !1,
                `conflicting network for ${JSON.stringify(n.name)}`,
                "nameOrChainId",
                t
              ),
              _p.set(t, e);
          }
        }
        let qp = !1;
        function Yp(t) {
          return JSON.parse(JSON.stringify(t));
        }
        class Zp {
          #Et;
          #Ct;
          #St;
          #Pt;
          constructor(t) {
            (this.#Et = t),
              (this.#Ct = null),
              (this.#St = 4e3),
              (this.#Pt = -2);
          }
          get pollingInterval() {
            return this.#St;
          }
          set pollingInterval(t) {
            this.#St = t;
          }
          async #It() {
            try {
              const t = await this.#Et.getBlockNumber();
              if (-2 === this.#Pt) return void (this.#Pt = t);
              if (t !== this.#Pt) {
                for (let e = this.#Pt + 1; e <= t; e++) {
                  if (null == this.#Ct) return;
                  await this.#Et.emit("block", e);
                }
                this.#Pt = t;
              }
            } catch (t) {}
            null != this.#Ct &&
              (this.#Ct = this.#Et._setTimeout(this.#It.bind(this), this.#St));
          }
          start() {
            this.#Ct ||
              ((this.#Ct = this.#Et._setTimeout(this.#It.bind(this), this.#St)),
              this.#It());
          }
          stop() {
            this.#Ct && (this.#Et._clearTimeout(this.#Ct), (this.#Ct = null));
          }
          pause(t) {
            this.stop(), t && (this.#Pt = -2);
          }
          resume() {
            this.start();
          }
        }
        class Xp {
          #Et;
          #It;
          #Bt;
          constructor(t) {
            (this.#Et = t),
              (this.#Bt = !1),
              (this.#It = (t) => {
                this._poll(t, this.#Et);
              });
          }
          async _poll(t, e) {
            throw new Error("sub-classes must override this");
          }
          start() {
            this.#Bt ||
              ((this.#Bt = !0), this.#It(-2), this.#Et.on("block", this.#It));
          }
          stop() {
            this.#Bt && ((this.#Bt = !1), this.#Et.off("block", this.#It));
          }
          pause(t) {
            this.stop();
          }
          resume() {
            this.start();
          }
        }
        class tg extends Xp {
          #bt;
          constructor(t, e) {
            super(t), (this.#bt = Yp(e));
          }
          async _poll(t, e) {
            throw new Error("@TODO");
          }
        }
        class eg extends Xp {
          #Nt;
          constructor(t, e) {
            super(t), (this.#Nt = e);
          }
          async _poll(t, e) {
            const n = await e.getTransactionReceipt(this.#Nt);
            n && e.emit(this.#Nt, n);
          }
        }
        class ng {
          #Et;
          #bt;
          #Ct;
          #Bt;
          #Pt;
          constructor(t, e) {
            (this.#Et = t),
              (this.#bt = Yp(e)),
              (this.#Ct = this.#It.bind(this)),
              (this.#Bt = !1),
              (this.#Pt = -2);
          }
          async #It(t) {
            if (-2 === this.#Pt) return;
            const e = Yp(this.#bt);
            (e.fromBlock = this.#Pt + 1), (e.toBlock = t);
            const n = await this.#Et.getLogs(e);
            if (0 !== n.length)
              for (const t of n)
                this.#Et.emit(this.#bt, t), (this.#Pt = t.blockNumber);
            else this.#Pt < t - 60 && (this.#Pt = t - 60);
          }
          start() {
            this.#Bt ||
              ((this.#Bt = !0),
              -2 === this.#Pt &&
                this.#Et.getBlockNumber().then((t) => {
                  this.#Pt = t;
                }),
              this.#Et.on("block", this.#Ct));
          }
          stop() {
            this.#Bt && ((this.#Bt = !1), this.#Et.off("block", this.#Ct));
          }
          pause(t) {
            this.stop(), t && (this.#Pt = -2);
          }
          resume() {
            this.start();
          }
        }
        const rg = BigInt(2);
        function sg(t) {
          return t && "function" == typeof t.then;
        }
        function ig(t, e) {
          return (
            t +
            ":" +
            JSON.stringify(e, (t, e) => {
              if (null == e) return "null";
              if ("bigint" == typeof e) return `bigint:${e.toString()}`;
              if ("string" == typeof e) return e.toLowerCase();
              if ("object" == typeof e && !Array.isArray(e)) {
                const t = Object.keys(e);
                return t.sort(), t.reduce((t, n) => ((t[n] = e[n]), t), {});
              }
              return e;
            })
          );
        }
        class og {
          name;
          constructor(t) {
            yo(this, { name: t });
          }
          start() {}
          stop() {}
          pause(t) {}
          resume() {}
        }
        function ag(t) {
          return (t = Array.from(new Set(t).values())).sort(), t;
        }
        async function lg(t, e) {
          if (null == t) throw new Error("invalid event");
          if ((Array.isArray(t) && (t = { topics: t }), "string" == typeof t))
            switch (t) {
              case "block":
              case "pending":
              case "debug":
              case "error":
              case "network":
                return { type: t, tag: t };
            }
          if (Bo(t, 32)) {
            const e = t.toLowerCase();
            return { type: "transaction", tag: ig("tx", { hash: e }), hash: e };
          }
          if (t.orphan) {
            const e = t;
            return {
              type: "orphan",
              tag: ig("orphan", e),
              filter: ((n = e), JSON.parse(JSON.stringify(n))),
            };
          }
          var n;
          if (t.address || t.topics) {
            const n = t,
              r = {
                topics: (n.topics || []).map((t) =>
                  null == t
                    ? null
                    : Array.isArray(t)
                    ? ag(t.map((t) => t.toLowerCase()))
                    : t.toLowerCase()
                ),
              };
            if (n.address) {
              const t = [],
                s = [],
                i = (n) => {
                  Bo(n)
                    ? t.push(n)
                    : s.push(
                        (async () => {
                          t.push(await bu(n, e));
                        })()
                      );
                };
              Array.isArray(n.address) ? n.address.forEach(i) : i(n.address),
                s.length && (await Promise.all(s)),
                (r.address = ag(t.map((t) => t.toLowerCase())));
            }
            return { filter: r, tag: ig("event", r), type: "event" };
          }
          $o(!1, "unknown ProviderEvent", "event", t);
        }
        function cg() {
          return new Date().getTime();
        }
        const ug = { cacheTimeout: 250 };
        class dg {
          #Tt;
          #kt;
          #Ot;
          #Rt;
          #Lt;
          #zt;
          #Ut;
          #Ft;
          #Dt;
          #Mt;
          #jt;
          #H;
          constructor(t, e) {
            if (((this.#H = Object.assign({}, ug, e || {})), "any" === t))
              (this.#zt = !0), (this.#Lt = null);
            else if (t) {
              const e = Kp.from(t);
              (this.#zt = !1),
                (this.#Lt = Promise.resolve(e)),
                setTimeout(() => {
                  this.emit("network", e, null);
                }, 0);
            } else (this.#zt = !1), (this.#Lt = null);
            (this.#Ft = -1),
              (this.#Ut = new Map()),
              (this.#Tt = new Map()),
              (this.#kt = new Map()),
              (this.#Ot = null),
              (this.#Rt = !1),
              (this.#Dt = 1),
              (this.#Mt = new Map()),
              (this.#jt = !1);
          }
          get provider() {
            return this;
          }
          get plugins() {
            return Array.from(this.#kt.values());
          }
          attachPlugin(t) {
            if (this.#kt.get(t.name))
              throw new Error(`cannot replace existing plugin: ${t.name} `);
            return this.#kt.set(t.name, t.connect(this)), this;
          }
          getPlugin(t) {
            return this.#kt.get(t) || null;
          }
          get disableCcipRead() {
            return this.#jt;
          }
          set disableCcipRead(t) {
            this.#jt = !!t;
          }
          async #Ht(t) {
            const e = this.#H.cacheTimeout;
            if (e < 0) return await this._perform(t);
            const n = ig(t.method, t);
            let r = this.#Ut.get(n);
            return (
              r ||
                ((r = this._perform(t)),
                this.#Ut.set(n, r),
                setTimeout(() => {
                  this.#Ut.get(n) === r && this.#Ut.delete(n);
                }, e)),
              await r
            );
          }
          async ccipReadFetch(t, e, n) {
            if (this.disableCcipRead || 0 === n.length || null == t.to)
              return null;
            const r = t.to.toLowerCase(),
              s = e.toLowerCase(),
              i = [];
            for (let e = 0; e < n.length; e++) {
              const o = n[e],
                a = o.replace("{sender}", r).replace("{data}", s),
                l = new fa(a);
              -1 === o.indexOf("{data}") && (l.body = { data: s, sender: r }),
                this.emit("debug", {
                  action: "sendCcipReadFetchRequest",
                  request: l,
                  index: e,
                  urls: n,
                });
              let c = "unknown error";
              const u = await l.send();
              try {
                const t = u.bodyJson;
                if (t.data)
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadFetchResult",
                      request: l,
                      result: t,
                    }),
                    t.data
                  );
                t.message && (c = t.message),
                  this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: l,
                    result: t,
                  });
              } catch (t) {}
              xo(
                u.statusCode < 400 || u.statusCode >= 500,
                `response not found during CCIP fetch: ${c}`,
                "OFFCHAIN_FAULT",
                {
                  reason: "404_MISSING_RESOURCE",
                  transaction: t,
                  info: { url: o, errorMessage: c },
                }
              ),
                i.push(c);
            }
            xo(
              !1,
              `error encountered during CCIP fetch: ${i
                .map((t) => JSON.stringify(t))
                .join(", ")}`,
              "OFFCHAIN_FAULT",
              {
                reason: "500_SERVER_ERROR",
                transaction: t,
                info: { urls: n, errorMessages: i },
              }
            );
          }
          _wrapBlock(t, e) {
            return new qf(
              (function (t) {
                const e = jp(t);
                return (
                  (e.transactions = t.transactions.map((t) =>
                    "string" == typeof t ? t : Vp(t)
                  )),
                  e
                );
              })(t),
              this
            );
          }
          _wrapLog(t, e) {
            return new Yf(
              (function (t) {
                return Mp(t);
              })(t),
              this
            );
          }
          _wrapTransactionReceipt(t, e) {
            return new Zf(
              (function (t) {
                return Gp(t);
              })(t),
              this
            );
          }
          _wrapTransactionResponse(t, e) {
            return new Xf(Vp(t), this);
          }
          _detectNetwork() {
            xo(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
              operation: "_detectNetwork",
            });
          }
          async _perform(t) {
            xo(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
              operation: t.method,
              info: t,
            });
          }
          async getBlockNumber() {
            const t = Jo(
              await this.#Ht({ method: "getBlockNumber" }),
              "%response"
            );
            return this.#Ft >= 0 && (this.#Ft = t), t;
          }
          _getAddress(t) {
            return bu(t, this);
          }
          _getBlockTag(t) {
            if (null == t) return "latest";
            switch (t) {
              case "earliest":
                return "0x0";
              case "latest":
              case "pending":
              case "safe":
              case "finalized":
                return t;
            }
            return Bo(t)
              ? Bo(t, 32)
                ? t
                : qo(t)
              : ("bigint" == typeof t && (t = Jo(t, "blockTag")),
                "number" == typeof t
                  ? t >= 0
                    ? qo(t)
                    : this.#Ft >= 0
                    ? qo(this.#Ft + t)
                    : this.getBlockNumber().then((e) => qo(e + t))
                  : void $o(!1, "invalid blockTag", "blockTag", t));
          }
          _getFilter(t) {
            const e = (t.topics || []).map((t) =>
                null == t
                  ? null
                  : Array.isArray(t)
                  ? ag(t.map((t) => t.toLowerCase()))
                  : t.toLowerCase()
              ),
              n = "blockHash" in t ? t.blockHash : void 0,
              r = (t, r, s) => {
                let i;
                switch (t.length) {
                  case 0:
                    break;
                  case 1:
                    i = t[0];
                    break;
                  default:
                    t.sort(), (i = t);
                }
                if (n && (null != r || null != s))
                  throw new Error("invalid filter");
                const o = {};
                return (
                  i && (o.address = i),
                  e.length && (o.topics = e),
                  r && (o.fromBlock = r),
                  s && (o.toBlock = s),
                  n && (o.blockHash = n),
                  o
                );
              };
            let s,
              i,
              o = [];
            if (t.address)
              if (Array.isArray(t.address))
                for (const e of t.address) o.push(this._getAddress(e));
              else o.push(this._getAddress(t.address));
            return (
              "fromBlock" in t && (s = this._getBlockTag(t.fromBlock)),
              "toBlock" in t && (i = this._getBlockTag(t.toBlock)),
              o.filter((t) => "string" != typeof t).length ||
              (null != s && "string" != typeof s) ||
              (null != i && "string" != typeof i)
                ? Promise.all([Promise.all(o), s, i]).then((t) =>
                    r(t[0], t[1], t[2])
                  )
                : r(o, s, i)
            );
          }
          _getTransactionRequest(t) {
            const e = Kf(t),
              n = [];
            if (
              (["to", "from"].forEach((t) => {
                if (null == e[t]) return;
                const r = bu(e[t]);
                sg(r)
                  ? n.push(
                      (async function () {
                        e[t] = await r;
                      })()
                    )
                  : (e[t] = r);
              }),
              null != e.blockTag)
            ) {
              const t = this._getBlockTag(e.blockTag);
              sg(t)
                ? n.push(
                    (async function () {
                      e.blockTag = await t;
                    })()
                  )
                : (e.blockTag = t);
            }
            return n.length
              ? (async function () {
                  return await Promise.all(n), e;
                })()
              : e;
          }
          async getNetwork() {
            if (null == this.#Lt) {
              const t = this._detectNetwork().then(
                (t) => (this.emit("network", t, null), t),
                (e) => {
                  throw (this.#Lt === t && (this.#Lt = null), e);
                }
              );
              return (this.#Lt = t), (await t).clone();
            }
            const t = this.#Lt,
              [e, n] = await Promise.all([t, this._detectNetwork()]);
            return (
              e.chainId !== n.chainId &&
                (this.#zt
                  ? (this.emit("network", n, e),
                    this.#Lt === t && (this.#Lt = Promise.resolve(n)))
                  : xo(
                      !1,
                      `network changed: ${e.chainId} => ${n.chainId} `,
                      "NETWORK_ERROR",
                      { event: "changed" }
                    )),
              e.clone()
            );
          }
          async getFeeData() {
            const { block: t, gasPrice: e } = await mo({
              block: this.getBlock("latest"),
              gasPrice: (async () => {
                try {
                  return Go(
                    await this.#Ht({ method: "getGasPrice" }),
                    "%response"
                  );
                } catch (t) {}
                return null;
              })(),
            });
            let n = null,
              r = null;
            return (
              t &&
                t.baseFeePerGas &&
                ((r = BigInt("1000000000")), (n = t.baseFeePerGas * rg + r)),
              new _f(e, n, r)
            );
          }
          async estimateGas(t) {
            let e = this._getTransactionRequest(t);
            return (
              sg(e) && (e = await e),
              Go(
                await this.#Ht({ method: "estimateGas", transaction: e }),
                "%response"
              )
            );
          }
          async #Gt(t, e, n) {
            xo(
              n < 10,
              "CCIP read exceeded maximum redirections",
              "OFFCHAIN_FAULT",
              {
                reason: "TOO_MANY_REDIRECTS",
                transaction: Object.assign({}, t, {
                  blockTag: e,
                  enableCcipRead: !0,
                }),
              }
            );
            const r = Kf(t);
            try {
              return To(
                await this._perform({
                  method: "call",
                  transaction: r,
                  blockTag: e,
                })
              );
            } catch (t) {
              if (
                !this.disableCcipRead &&
                vo(t) &&
                t.data &&
                n >= 0 &&
                "latest" === e &&
                null != r.to &&
                "0x556f1830" === Lo(t.data, 0, 4)
              ) {
                const s = t.data,
                  i = await bu(r.to, this);
                let o;
                try {
                  o = (function (t) {
                    const e = {
                      sender: "",
                      urls: [],
                      calldata: "",
                      selector: "",
                      extraData: "",
                      errorArgs: [],
                    };
                    xo(
                      Ro(t) >= 160,
                      "insufficient OffchainLookup data",
                      "OFFCHAIN_FAULT",
                      { reason: "insufficient OffchainLookup data" }
                    );
                    const n = Lo(t, 0, 32);
                    xo(
                      Lo(n, 0, 12) === Lo(bg, 0, 12),
                      "corrupt OffchainLookup sender",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup sender" }
                    ),
                      (e.sender = Lo(n, 12));
                    try {
                      const n = [],
                        r = Jo(Lo(t, 32, 64)),
                        s = Jo(Lo(t, r, r + 32)),
                        i = Lo(t, r + 32);
                      for (let t = 0; t < s; t++) {
                        const e = hg(i, 32 * t);
                        if (null == e) throw new Error("abort");
                        n.push(e);
                      }
                      e.urls = n;
                    } catch (t) {
                      xo(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
                        reason: "corrupt OffchainLookup urls",
                      });
                    }
                    try {
                      const n = fg(t, 64);
                      if (null == n) throw new Error("abort");
                      e.calldata = n;
                    } catch (t) {
                      xo(
                        !1,
                        "corrupt OffchainLookup calldata",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup calldata" }
                      );
                    }
                    xo(
                      Lo(t, 100, 128) === Lo(bg, 0, 28),
                      "corrupt OffchainLookup callbaackSelector",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup callbaackSelector" }
                    ),
                      (e.selector = Lo(t, 96, 100));
                    try {
                      const n = fg(t, 128);
                      if (null == n) throw new Error("abort");
                      e.extraData = n;
                    } catch (t) {
                      xo(
                        !1,
                        "corrupt OffchainLookup extraData",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup extraData" }
                      );
                    }
                    return (
                      (e.errorArgs = "sender,urls,calldata,selector,extraData"
                        .split(/,/)
                        .map((t) => e[t])),
                      e
                    );
                  })(Lo(t.data, 4));
                } catch (t) {
                  xo(!1, t.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: r,
                    info: { data: s },
                  });
                }
                xo(
                  o.sender.toLowerCase() === i.toLowerCase(),
                  "CCIP Read sender mismatch",
                  "CALL_EXCEPTION",
                  {
                    action: "call",
                    data: s,
                    reason: "OffchainLookup",
                    transaction: r,
                    invocation: null,
                    revert: {
                      signature:
                        "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      name: "OffchainLookup",
                      args: o.errorArgs,
                    },
                  }
                );
                const a = await this.ccipReadFetch(r, o.calldata, o.urls);
                xo(
                  null != a,
                  "CCIP Read failed to fetch data",
                  "OFFCHAIN_FAULT",
                  {
                    reason: "FETCH_FAILED",
                    transaction: r,
                    info: { data: t.data, errorArgs: o.errorArgs },
                  }
                );
                const l = {
                  to: i,
                  data: Oo([o.selector, yg([a, o.extraData])]),
                };
                this.emit("debug", {
                  action: "sendCcipReadCall",
                  transaction: l,
                });
                try {
                  const t = await this.#Gt(l, e, n + 1);
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadCallResult",
                      transaction: Object.assign({}, l),
                      result: t,
                    }),
                    t
                  );
                } catch (t) {
                  throw (
                    (this.emit("debug", {
                      action: "receiveCcipReadCallError",
                      transaction: Object.assign({}, l),
                      error: t,
                    }),
                    t)
                  );
                }
              }
              throw t;
            }
          }
          async #Vt(t) {
            const { value: e } = await mo({
              network: this.getNetwork(),
              value: t,
            });
            return e;
          }
          async call(t) {
            const { tx: e, blockTag: n } = await mo({
              tx: this._getTransactionRequest(t),
              blockTag: this._getBlockTag(t.blockTag),
            });
            return await this.#Vt(this.#Gt(e, n, t.enableCcipRead ? 0 : -1));
          }
          async #Qt(t, e, n) {
            let r = this._getAddress(e),
              s = this._getBlockTag(n);
            return (
              ("string" == typeof r && "string" == typeof s) ||
                ([r, s] = await Promise.all([r, s])),
              await this.#Vt(
                this.#Ht(Object.assign(t, { address: r, blockTag: s }))
              )
            );
          }
          async getBalance(t, e) {
            return Go(
              await this.#Qt({ method: "getBalance" }, t, e),
              "%response"
            );
          }
          async getTransactionCount(t, e) {
            return Jo(
              await this.#Qt({ method: "getTransactionCount" }, t, e),
              "%response"
            );
          }
          async getCode(t, e) {
            return To(await this.#Qt({ method: "getCode" }, t, e));
          }
          async getStorage(t, e, n) {
            const r = Go(e, "position");
            return To(
              await this.#Qt({ method: "getStorage", position: r }, t, n)
            );
          }
          async broadcastTransaction(t) {
            const {
                blockNumber: e,
                hash: n,
                network: r,
              } = await mo({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                  method: "broadcastTransaction",
                  signedTransaction: t,
                }),
                network: this.getNetwork(),
              }),
              s = Sh.from(t);
            if (s.hash !== n)
              throw new Error("@TODO: the returned hash did not match");
            return this._wrapTransactionResponse(s, r).replaceableTransaction(
              e
            );
          }
          async #Wt(t, e) {
            if (Bo(t, 32))
              return await this.#Ht({
                method: "getBlock",
                blockHash: t,
                includeTransactions: e,
              });
            let n = this._getBlockTag(t);
            return (
              "string" != typeof n && (n = await n),
              await this.#Ht({
                method: "getBlock",
                blockTag: n,
                includeTransactions: e,
              })
            );
          }
          async getBlock(t, e) {
            const { network: n, params: r } = await mo({
              network: this.getNetwork(),
              params: this.#Wt(t, !!e),
            });
            return null == r ? null : this._wrapBlock(r, n);
          }
          async getTransaction(t) {
            const { network: e, params: n } = await mo({
              network: this.getNetwork(),
              params: this.#Ht({ method: "getTransaction", hash: t }),
            });
            return null == n ? null : this._wrapTransactionResponse(n, e);
          }
          async getTransactionReceipt(t) {
            const { network: e, params: n } = await mo({
              network: this.getNetwork(),
              params: this.#Ht({ method: "getTransactionReceipt", hash: t }),
            });
            if (null == n) return null;
            if (null == n.gasPrice && null == n.effectiveGasPrice) {
              const e = await this.#Ht({ method: "getTransaction", hash: t });
              if (null == e)
                throw new Error(
                  "report this; could not find tx or effectiveGasPrice"
                );
              n.effectiveGasPrice = e.gasPrice;
            }
            return this._wrapTransactionReceipt(n, e);
          }
          async getTransactionResult(t) {
            const { result: e } = await mo({
              network: this.getNetwork(),
              result: this.#Ht({ method: "getTransactionResult", hash: t }),
            });
            return null == e ? null : To(e);
          }
          async getLogs(t) {
            let e = this._getFilter(t);
            sg(e) && (e = await e);
            const { network: n, params: r } = await mo({
              network: this.getNetwork(),
              params: this.#Ht({ method: "getLogs", filter: e }),
            });
            return r.map((t) => this._wrapLog(t, n));
          }
          _getProvider(t) {
            xo(
              !1,
              "provider cannot connect to target network",
              "UNSUPPORTED_OPERATION",
              { operation: "_getProvider()" }
            );
          }
          async getResolver(t) {
            return await Op.fromName(this, t);
          }
          async getAvatar(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAvatar() : null;
          }
          async resolveName(t) {
            const e = await this.getResolver(t);
            return e ? await e.getAddress() : null;
          }
          async lookupAddress(t) {
            const e = ah(
              (t = gu(t)).substring(2).toLowerCase() + ".addr.reverse"
            );
            try {
              const n = await Op.getEnsAddress(this),
                r = new Pp(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  this
                ),
                s = await r.resolver(e);
              if (null == s || s === Yc) return null;
              const i = new Pp(
                  s,
                  ["function name(bytes32) view returns (string)"],
                  this
                ),
                o = await i.name(e);
              return (await this.resolveName(o)) !== t ? null : o;
            } catch (t) {
              if (wo(t, "BAD_DATA") && "0x" === t.value) return null;
              if (wo(t, "CALL_EXCEPTION")) return null;
              throw t;
            }
            return null;
          }
          async waitForTransaction(t, e, n) {
            const r = null != e ? e : 1;
            return 0 === r
              ? this.getTransactionReceipt(t)
              : new Promise(async (e, s) => {
                  let i = null;
                  const o = async (n) => {
                    try {
                      const s = await this.getTransactionReceipt(t);
                      if (null != s && n - s.blockNumber + 1 >= r)
                        return e(s), void (i && (clearTimeout(i), (i = null)));
                    } catch (t) {
                      console.log("EEE", t);
                    }
                    this.once("block", o);
                  };
                  null != n &&
                    (i = setTimeout(() => {
                      null != i &&
                        ((i = null),
                        this.off("block", o),
                        s(Ao("timeout", "TIMEOUT", { reason: "timeout" })));
                    }, n)),
                    o(await this.getBlockNumber());
                });
          }
          async waitForBlock(t) {
            xo(!1, "not implemented yet", "NOT_IMPLEMENTED", {
              operation: "waitForBlock",
            });
          }
          _clearTimeout(t) {
            const e = this.#Mt.get(t);
            e && (e.timer && clearTimeout(e.timer), this.#Mt.delete(t));
          }
          _setTimeout(t, e) {
            null == e && (e = 0);
            const n = this.#Dt++,
              r = () => {
                this.#Mt.delete(n), t();
              };
            if (this.paused) this.#Mt.set(n, { timer: null, func: r, time: e });
            else {
              const t = setTimeout(r, e);
              this.#Mt.set(n, { timer: t, func: r, time: cg() });
            }
            return n;
          }
          _forEachSubscriber(t) {
            for (const e of this.#Tt.values()) t(e.subscriber);
          }
          _getSubscriber(t) {
            switch (t.type) {
              case "debug":
              case "error":
              case "network":
                return new og(t.type);
              case "block":
                return new Zp(this);
              case "event":
                return new ng(this, t.filter);
              case "transaction":
                return new eg(this, t.hash);
              case "orphan":
                return new tg(this, t.filter);
            }
            throw new Error(`unsupported event: ${t.type}`);
          }
          _recoverSubscriber(t, e) {
            for (const n of this.#Tt.values())
              if (n.subscriber === t) {
                n.started && n.subscriber.stop(),
                  (n.subscriber = e),
                  n.started && e.start(),
                  null != this.#Ot && e.pause(this.#Ot);
                break;
              }
          }
          async #Jt(t, e) {
            let n = await lg(t, this);
            return (
              "event" === n.type &&
                e &&
                e.length > 0 &&
                !0 === e[0].removed &&
                (n = await lg({ orphan: "drop-log", log: e[0] }, this)),
              this.#Tt.get(n.tag) || null
            );
          }
          async #_t(t) {
            const e = await lg(t, this),
              n = e.tag;
            let r = this.#Tt.get(n);
            if (!r) {
              (r = {
                subscriber: this._getSubscriber(e),
                tag: n,
                addressableMap: new WeakMap(),
                nameMap: new Map(),
                started: !1,
                listeners: [],
              }),
                this.#Tt.set(n, r);
            }
            return r;
          }
          async on(t, e) {
            const n = await this.#_t(t);
            return (
              n.listeners.push({ listener: e, once: !1 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Ot && n.subscriber.pause(this.#Ot)),
              this
            );
          }
          async once(t, e) {
            const n = await this.#_t(t);
            return (
              n.listeners.push({ listener: e, once: !0 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#Ot && n.subscriber.pause(this.#Ot)),
              this
            );
          }
          async emit(t, ...e) {
            const n = await this.#Jt(t, e);
            if (!n || 0 === n.listeners.length) return !1;
            const r = n.listeners.length;
            return (
              (n.listeners = n.listeners.filter(({ listener: n, once: r }) => {
                const s = new Zo(this, r ? null : n, t);
                try {
                  n.call(this, ...e, s);
                } catch (t) {}
                return !r;
              })),
              0 === n.listeners.length &&
                (n.started && n.subscriber.stop(), this.#Tt.delete(n.tag)),
              r > 0
            );
          }
          async listenerCount(t) {
            if (t) {
              const e = await this.#Jt(t);
              return e ? e.listeners.length : 0;
            }
            let e = 0;
            for (const { listeners: t } of this.#Tt.values()) e += t.length;
            return e;
          }
          async listeners(t) {
            if (t) {
              const e = await this.#Jt(t);
              return e ? e.listeners.map(({ listener: t }) => t) : [];
            }
            let e = [];
            for (const { listeners: t } of this.#Tt.values())
              e = e.concat(t.map(({ listener: t }) => t));
            return e;
          }
          async off(t, e) {
            const n = await this.#Jt(t);
            if (!n) return this;
            if (e) {
              const t = n.listeners.map(({ listener: t }) => t).indexOf(e);
              t >= 0 && n.listeners.splice(t, 1);
            }
            return (
              (e && 0 !== n.listeners.length) ||
                (n.started && n.subscriber.stop(), this.#Tt.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(t) {
            if (t) {
              const { tag: e, started: n, subscriber: r } = await this.#_t(t);
              n && r.stop(), this.#Tt.delete(e);
            } else
              for (const [t, { started: e, subscriber: n }] of this.#Tt)
                e && n.stop(), this.#Tt.delete(t);
            return this;
          }
          async addListener(t, e) {
            return await this.on(t, e);
          }
          async removeListener(t, e) {
            return this.off(t, e);
          }
          get destroyed() {
            return this.#Rt;
          }
          destroy() {
            this.removeAllListeners();
            for (const t of this.#Mt.keys()) this._clearTimeout(t);
            this.#Rt = !0;
          }
          get paused() {
            return null != this.#Ot;
          }
          set paused(t) {
            !!t !== this.paused &&
              (this.paused ? this.resume() : this.pause(!1));
          }
          pause(t) {
            if (((this.#Ft = -1), null != this.#Ot)) {
              if (this.#Ot == !!t) return;
              xo(
                !1,
                "cannot change pause type; resume first",
                "UNSUPPORTED_OPERATION",
                { operation: "pause" }
              );
            }
            this._forEachSubscriber((e) => e.pause(t)), (this.#Ot = !!t);
            for (const t of this.#Mt.values())
              t.timer && clearTimeout(t.timer), (t.time = cg() - t.time);
          }
          resume() {
            if (null != this.#Ot) {
              this._forEachSubscriber((t) => t.resume()), (this.#Ot = null);
              for (const t of this.#Mt.values()) {
                let e = t.time;
                e < 0 && (e = 0), (t.time = cg()), setTimeout(t.func, e);
              }
            }
          }
        }
        function hg(t, e) {
          try {
            const n = fg(t, e);
            if (n) return na(n);
          } catch (t) {}
          return null;
        }
        function fg(t, e) {
          if ("0x" === t) return null;
          try {
            const n = Jo(Lo(t, e, e + 32)),
              r = Jo(Lo(t, n, n + 32));
            return Lo(t, n + 32, n + 32 + r);
          } catch (t) {}
          return null;
        }
        function pg(t) {
          const e = Ko(t);
          if (e.length > 32) throw new Error("internal; should not happen");
          const n = new Uint8Array(32);
          return n.set(e, 32 - e.length), n;
        }
        function gg(t) {
          if (t.length % 32 == 0) return t;
          const e = new Uint8Array(32 * Math.ceil(t.length / 32));
          return e.set(t), e;
        }
        const mg = new Uint8Array([]);
        function yg(t) {
          const e = [];
          let n = 0;
          for (let r = 0; r < t.length; r++) e.push(mg), (n += 32);
          for (let r = 0; r < t.length; r++) {
            const s = Po(t[r]);
            (e[r] = pg(n)),
              e.push(pg(s.length)),
              e.push(gg(s)),
              (n += 32 + 32 * Math.ceil(s.length / 32));
          }
          return Oo(e);
        }
        const bg =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        function wg(t, e) {
          if (t.provider) return t.provider;
          xo(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
        }
        async function vg(t, e) {
          let n = Kf(e);
          if ((null != n.to && (n.to = bu(n.to, t)), null != n.from)) {
            const e = n.from;
            n.from = Promise.all([t.getAddress(), bu(e, t)]).then(
              ([t, e]) => (
                $o(
                  t.toLowerCase() === e.toLowerCase(),
                  "transaction from mismatch",
                  "tx.from",
                  e
                ),
                t
              )
            );
          } else n.from = t.getAddress();
          return await mo(n);
        }
        class Ag {
          provider;
          constructor(t) {
            yo(this, { provider: t || null });
          }
          async getNonce(t) {
            return wg(this, "getTransactionCount").getTransactionCount(
              await this.getAddress(),
              t
            );
          }
          async populateCall(t) {
            return await vg(this, t);
          }
          async populateTransaction(t) {
            const e = wg(this, "populateTransaction"),
              n = await vg(this, t);
            null == n.nonce && (n.nonce = await this.getNonce("pending")),
              null == n.gasLimit && (n.gasLimit = await this.estimateGas(n));
            const r = await this.provider.getNetwork();
            if (null != n.chainId) {
              $o(
                Go(n.chainId) === r.chainId,
                "transaction chainId mismatch",
                "tx.chainId",
                t.chainId
              );
            } else n.chainId = r.chainId;
            const s = null != n.maxFeePerGas || null != n.maxPriorityFeePerGas;
            if (
              (null == n.gasPrice || (2 !== n.type && !s)
                ? (0 !== n.type && 1 !== n.type) ||
                  !s ||
                  $o(
                    !1,
                    "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                    "tx",
                    t
                  )
                : $o(
                    !1,
                    "eip-1559 transaction do not support gasPrice",
                    "tx",
                    t
                  ),
              (2 !== n.type && null != n.type) ||
                null == n.maxFeePerGas ||
                null == n.maxPriorityFeePerGas)
            )
              if (0 === n.type || 1 === n.type) {
                const t = await e.getFeeData();
                xo(
                  null != t.gasPrice,
                  "network does not support gasPrice",
                  "UNSUPPORTED_OPERATION",
                  { operation: "getGasPrice" }
                ),
                  null == n.gasPrice && (n.gasPrice = t.gasPrice);
              } else {
                const t = await e.getFeeData();
                if (null == n.type)
                  if (null != t.maxFeePerGas && null != t.maxPriorityFeePerGas)
                    if (((n.type = 2), null != n.gasPrice)) {
                      const t = n.gasPrice;
                      delete n.gasPrice,
                        (n.maxFeePerGas = t),
                        (n.maxPriorityFeePerGas = t);
                    } else
                      null == n.maxFeePerGas &&
                        (n.maxFeePerGas = t.maxFeePerGas),
                        null == n.maxPriorityFeePerGas &&
                          (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas);
                  else
                    null != t.gasPrice
                      ? (xo(
                          !s,
                          "network does not support EIP-1559",
                          "UNSUPPORTED_OPERATION",
                          { operation: "populateTransaction" }
                        ),
                        null == n.gasPrice && (n.gasPrice = t.gasPrice),
                        (n.type = 0))
                      : xo(
                          !1,
                          "failed to get consistent fee data",
                          "UNSUPPORTED_OPERATION",
                          { operation: "signer.getFeeData" }
                        );
                else
                  2 === n.type &&
                    (null == n.maxFeePerGas &&
                      (n.maxFeePerGas = t.maxFeePerGas),
                    null == n.maxPriorityFeePerGas &&
                      (n.maxPriorityFeePerGas = t.maxPriorityFeePerGas));
              }
            else n.type = 2;
            return await mo(n);
          }
          async estimateGas(t) {
            return wg(this, "estimateGas").estimateGas(
              await this.populateCall(t)
            );
          }
          async call(t) {
            return wg(this, "call").call(await this.populateCall(t));
          }
          async resolveName(t) {
            const e = wg(this, "resolveName");
            return await e.resolveName(t);
          }
          async sendTransaction(t) {
            const e = wg(this, "sendTransaction"),
              n = await this.populateTransaction(t);
            delete n.from;
            const r = Sh.from(n);
            return await e.broadcastTransaction(await this.signTransaction(r));
          }
        }
        class xg {
          #Et;
          #Kt;
          #Ct;
          #Bt;
          #qt;
          #Yt;
          constructor(t) {
            (this.#Et = t),
              (this.#Kt = null),
              (this.#Ct = this.#It.bind(this)),
              (this.#Bt = !1),
              (this.#qt = null),
              (this.#Yt = !1);
          }
          _subscribe(t) {
            throw new Error("subclasses must override this");
          }
          _emitResults(t, e) {
            throw new Error("subclasses must override this");
          }
          _recover(t) {
            throw new Error("subclasses must override this");
          }
          async #It(t) {
            try {
              null == this.#Kt && (this.#Kt = this._subscribe(this.#Et));
              let t = null;
              try {
                t = await this.#Kt;
              } catch (t) {
                if (
                  !wo(t, "UNSUPPORTED_OPERATION") ||
                  "eth_newFilter" !== t.operation
                )
                  throw t;
              }
              if (null == t)
                return (
                  (this.#Kt = null),
                  void this.#Et._recoverSubscriber(
                    this,
                    this._recover(this.#Et)
                  )
                );
              const e = await this.#Et.getNetwork();
              if ((this.#qt || (this.#qt = e), this.#qt.chainId !== e.chainId))
                throw new Error("chaid changed");
              if (this.#Yt) return;
              const n = await this.#Et.send("eth_getFilterChanges", [t]);
              await this._emitResults(this.#Et, n);
            } catch (t) {
              console.log("@TODO", t);
            }
            this.#Et.once("block", this.#Ct);
          }
          #Zt() {
            const t = this.#Kt;
            t &&
              ((this.#Kt = null),
              t.then((t) => {
                this.#Et.send("eth_uninstallFilter", [t]);
              }));
          }
          start() {
            this.#Bt || ((this.#Bt = !0), this.#It(-2));
          }
          stop() {
            this.#Bt &&
              ((this.#Bt = !1),
              (this.#Yt = !0),
              this.#Zt(),
              this.#Et.off("block", this.#Ct));
          }
          pause(t) {
            t && this.#Zt(), this.#Et.off("block", this.#Ct);
          }
          resume() {
            this.start();
          }
        }
        class $g extends xg {
          #Xt;
          constructor(t, e) {
            var n;
            super(t), (this.#Xt = ((n = e), JSON.parse(JSON.stringify(n))));
          }
          _recover(t) {
            return new ng(t, this.#Xt);
          }
          async _subscribe(t) {
            return await t.send("eth_newFilter", [this.#Xt]);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit(this.#Xt, t._wrapLog(n, t._network));
          }
        }
        class kg extends xg {
          async _subscribe(t) {
            return await t.send("eth_newPendingTransactionFilter", []);
          }
          async _emitResults(t, e) {
            for (const n of e) t.emit("pending", n);
          }
        }
        const Eg = "bigint,boolean,function,number,string,symbol".split(/,/g);
        function Cg(t) {
          if (null == t || Eg.indexOf(typeof t) >= 0) return t;
          if ("function" == typeof t.getAddress) return t;
          if (Array.isArray(t)) return t.map(Cg);
          if ("object" == typeof t)
            return Object.keys(t).reduce((e, n) => ((e[n] = t[n]), e), {});
          throw new Error(`should not happen: ${t} (${typeof t})`);
        }
        function Sg(t) {
          return new Promise((e) => {
            setTimeout(e, t);
          });
        }
        function Pg(t) {
          return t ? t.toLowerCase() : t;
        }
        function Ig(t) {
          return t && "number" == typeof t.pollingInterval;
        }
        const Bg = {
          polling: !1,
          staticNetwork: null,
          batchStallTime: 10,
          batchMaxSize: 1 << 20,
          batchMaxCount: 100,
          cacheTimeout: 250,
        };
        class Ng extends Ag {
          address;
          constructor(t, e) {
            super(t), yo(this, { address: (e = gu(e)) });
          }
          connect(t) {
            xo(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
              operation: "signer.connect",
            });
          }
          async getAddress() {
            return this.address;
          }
          async populateTransaction(t) {
            return await this.populateCall(t);
          }
          async sendUncheckedTransaction(t) {
            const e = Cg(t),
              n = [];
            if (e.from) {
              const r = e.from;
              n.push(
                (async () => {
                  const n = await bu(r, this.provider);
                  $o(
                    null != n && n.toLowerCase() === this.address.toLowerCase(),
                    "from address mismatch",
                    "transaction",
                    t
                  ),
                    (e.from = n);
                })()
              );
            } else e.from = this.address;
            if (
              (null == e.gasLimit &&
                n.push(
                  (async () => {
                    e.gasLimit = await this.provider.estimateGas({
                      ...e,
                      from: this.address,
                    });
                  })()
                ),
              null != e.to)
            ) {
              const t = e.to;
              n.push(
                (async () => {
                  e.to = await bu(t, this.provider);
                })()
              );
            }
            n.length && (await Promise.all(n));
            const r = this.provider.getRpcTransaction(e);
            return this.provider.send("eth_sendTransaction", [r]);
          }
          async sendTransaction(t) {
            const e = await this.provider.getBlockNumber(),
              n = await this.sendUncheckedTransaction(t);
            return await new Promise((t, r) => {
              const s = [1e3, 100],
                i = async () => {
                  const r = await this.provider.getTransaction(n);
                  null == r
                    ? this.provider._setTimeout(() => {
                        i();
                      }, s.pop() || 4e3)
                    : t(r.replaceableTransaction(e));
                };
              i();
            });
          }
          async signTransaction(t) {
            const e = Cg(t);
            if (e.from) {
              const n = await bu(e.from, this.provider);
              $o(
                null != n && n.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                t
              ),
                (e.from = n);
            } else e.from = this.address;
            const n = this.provider.getRpcTransaction(e);
            return await this.provider.send("eth_signTransaction", [n]);
          }
          async signMessage(t) {
            const e = "string" == typeof t ? ea(t) : t;
            return await this.provider.send("personal_sign", [
              To(e),
              this.address.toLowerCase(),
            ]);
          }
          async signTypedData(t, e, n) {
            const r = Cg(n),
              s = await jh.resolveNames(t, e, r, async (t) => {
                const e = await bu(t);
                return (
                  $o(
                    null != e,
                    "TypedData does not support null address",
                    "value",
                    t
                  ),
                  e
                );
              });
            return await this.provider.send("eth_signTypedData_v4", [
              this.address.toLowerCase(),
              JSON.stringify(jh.getPayload(s.domain, e, s.value)),
            ]);
          }
          async unlock(t) {
            return this.provider.send("personal_unlockAccount", [
              this.address.toLowerCase(),
              t,
              null,
            ]);
          }
          async _legacySignMessage(t) {
            const e = "string" == typeof t ? ea(t) : t;
            return await this.provider.send("eth_sign", [
              this.address.toLowerCase(),
              To(e),
            ]);
          }
        }
        class Tg extends dg {
          #H;
          #te;
          #ee;
          #ne;
          #re;
          #qt;
          #se() {
            if (this.#ne) return;
            const t =
              1 === this._getOption("batchMaxCount")
                ? 0
                : this._getOption("batchStallTime");
            this.#ne = setTimeout(() => {
              this.#ne = null;
              const t = this.#ee;
              for (this.#ee = []; t.length; ) {
                const e = [t.shift()];
                for (; t.length && e.length !== this.#H.batchMaxCount; ) {
                  e.push(t.shift());
                  const n = JSON.stringify(e.map((t) => t.payload));
                  if (n.length > this.#H.batchMaxSize) {
                    t.unshift(e.pop());
                    break;
                  }
                }
                (async () => {
                  const t =
                    1 === e.length ? e[0].payload : e.map((t) => t.payload);
                  this.emit("debug", { action: "sendRpcPayload", payload: t });
                  try {
                    const n = await this._send(t);
                    this.emit("debug", {
                      action: "receiveRpcResult",
                      result: n,
                    });
                    for (const { resolve: t, reject: r, payload: s } of e) {
                      if (this.destroyed) {
                        r(
                          Ao(
                            "provider destroyed; cancelled request",
                            "UNSUPPORTED_OPERATION",
                            { operation: s.method }
                          )
                        );
                        continue;
                      }
                      const e = n.filter((t) => t.id === s.id)[0];
                      if (null != e)
                        "error" in e ? r(this.getRpcError(s, e)) : t(e.result);
                      else {
                        const t = Ao(
                          "missing response for request",
                          "BAD_DATA",
                          { value: n, info: { payload: s } }
                        );
                        this.emit("error", t), r(t);
                      }
                    }
                  } catch (t) {
                    this.emit("debug", { action: "receiveRpcError", error: t });
                    for (const { reject: n } of e) n(t);
                  }
                })();
              }
            }, t);
          }
          constructor(t, e) {
            const n = {};
            e && null != e.cacheTimeout && (n.cacheTimeout = e.cacheTimeout),
              super(t, n),
              (this.#te = 1),
              (this.#H = Object.assign({}, Bg, e || {})),
              (this.#ee = []),
              (this.#ne = null),
              (this.#qt = null);
            {
              let t = null;
              const e = new Promise((e) => {
                t = e;
              });
              this.#re = { promise: e, resolve: t };
            }
            const r = this._getOption("staticNetwork");
            r &&
              ($o(
                null == t || r.matches(t),
                "staticNetwork MUST match network object",
                "options",
                e
              ),
              (this.#qt = r));
          }
          _getOption(t) {
            return this.#H[t];
          }
          get _network() {
            return (
              xo(this.#qt, "network is not available yet", "NETWORK_ERROR"),
              this.#qt
            );
          }
          async _perform(t) {
            if ("call" === t.method || "estimateGas" === t.method) {
              let e = t.transaction;
              if (
                e &&
                null != e.type &&
                Go(e.type) &&
                null == e.maxFeePerGas &&
                null == e.maxPriorityFeePerGas
              ) {
                const n = await this.getFeeData();
                null == n.maxFeePerGas &&
                  null == n.maxPriorityFeePerGas &&
                  (t = Object.assign({}, t, {
                    transaction: Object.assign({}, e, { type: void 0 }),
                  }));
              }
            }
            const e = this.getRpcRequest(t);
            return null != e
              ? await this.send(e.method, e.args)
              : super._perform(t);
          }
          async _detectNetwork() {
            const t = this._getOption("staticNetwork");
            if (t) return t;
            if (this.ready)
              return Kp.from(Go(await this.send("eth_chainId", [])));
            const e = {
              id: this.#te++,
              method: "eth_chainId",
              params: [],
              jsonrpc: "2.0",
            };
            let n;
            this.emit("debug", { action: "sendRpcPayload", payload: e });
            try {
              n = (await this._send(e))[0];
            } catch (t) {
              throw (
                (this.emit("debug", { action: "receiveRpcError", error: t }), t)
              );
            }
            if (
              (this.emit("debug", { action: "receiveRpcResult", result: n }),
              "result" in n)
            )
              return Kp.from(Go(n.result));
            throw this.getRpcError(e, n);
          }
          _start() {
            null != this.#re &&
              null != this.#re.resolve &&
              (this.#re.resolve(),
              (this.#re = null),
              (async () => {
                for (; null == this.#qt && !this.destroyed; )
                  try {
                    this.#qt = await this._detectNetwork();
                  } catch (t) {
                    console.log(
                      "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                    ),
                      this.emit(
                        "error",
                        Ao(
                          "failed to bootstrap network detection",
                          "NETWORK_ERROR",
                          {
                            event: "initial-network-discovery",
                            info: { error: t },
                          }
                        )
                      ),
                      await Sg(1e3);
                  }
                this.#se();
              })());
          }
          async _waitUntilReady() {
            if (null != this.#re) return await this.#re.promise;
          }
          _getSubscriber(t) {
            return "pending" === t.type
              ? new kg(this)
              : "event" === t.type
              ? this._getOption("polling")
                ? new ng(this, t.filter)
                : new $g(this, t.filter)
              : "orphan" === t.type && "drop-log" === t.filter.orphan
              ? new og("orphan")
              : super._getSubscriber(t);
          }
          get ready() {
            return null == this.#re;
          }
          getRpcTransaction(t) {
            const e = {};
            return (
              [
                "chainId",
                "gasLimit",
                "gasPrice",
                "type",
                "maxFeePerGas",
                "maxPriorityFeePerGas",
                "nonce",
                "value",
              ].forEach((n) => {
                if (null == t[n]) return;
                let r = n;
                "gasLimit" === n && (r = "gas"),
                  (e[r] = qo(Go(t[n], `tx.${n}`)));
              }),
              ["from", "to", "data"].forEach((n) => {
                null != t[n] && (e[n] = To(t[n]));
              }),
              t.accessList && (e.accessList = ch(t.accessList)),
              e
            );
          }
          getRpcRequest(t) {
            switch (t.method) {
              case "chainId":
                return { method: "eth_chainId", args: [] };
              case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
              case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
              case "getBalance":
                return {
                  method: "eth_getBalance",
                  args: [Pg(t.address), t.blockTag],
                };
              case "getTransactionCount":
                return {
                  method: "eth_getTransactionCount",
                  args: [Pg(t.address), t.blockTag],
                };
              case "getCode":
                return {
                  method: "eth_getCode",
                  args: [Pg(t.address), t.blockTag],
                };
              case "getStorage":
                return {
                  method: "eth_getStorageAt",
                  args: [
                    Pg(t.address),
                    "0x" + t.position.toString(16),
                    t.blockTag,
                  ],
                };
              case "broadcastTransaction":
                return {
                  method: "eth_sendRawTransaction",
                  args: [t.signedTransaction],
                };
              case "getBlock":
                if ("blockTag" in t)
                  return {
                    method: "eth_getBlockByNumber",
                    args: [t.blockTag, !!t.includeTransactions],
                  };
                if ("blockHash" in t)
                  return {
                    method: "eth_getBlockByHash",
                    args: [t.blockHash, !!t.includeTransactions],
                  };
                break;
              case "getTransaction":
                return { method: "eth_getTransactionByHash", args: [t.hash] };
              case "getTransactionReceipt":
                return { method: "eth_getTransactionReceipt", args: [t.hash] };
              case "call":
                return {
                  method: "eth_call",
                  args: [this.getRpcTransaction(t.transaction), t.blockTag],
                };
              case "estimateGas":
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(t.transaction)],
                };
              case "getLogs":
                return (
                  t.filter &&
                    null != t.filter.address &&
                    (Array.isArray(t.filter.address)
                      ? (t.filter.address = t.filter.address.map(Pg))
                      : (t.filter.address = Pg(t.filter.address))),
                  { method: "eth_getLogs", args: [t.filter] }
                );
            }
            return null;
          }
          getRpcError(t, e) {
            const { method: n } = t,
              { error: r } = e;
            if ("eth_estimateGas" === n && r.message) {
              const e = r.message;
              if (!e.match(/revert/i) && e.match(/insufficient funds/i))
                return Ao("insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: t.params[0],
                  info: { payload: t, error: r },
                });
            }
            if ("eth_call" === n || "eth_estimateGas" === n) {
              const e = Rg(r),
                s = Uf.getBuiltinCallException(
                  "eth_call" === n ? "call" : "estimateGas",
                  t.params[0],
                  e ? e.data : null
                );
              return (s.info = { error: r, payload: t }), s;
            }
            const s = JSON.stringify(
              (function (t) {
                const e = [];
                return Lg(t, e), e;
              })(r)
            );
            if (
              "string" == typeof r.message &&
              r.message.match(/user denied|ethers-user-denied/i)
            ) {
              return Ao("user rejected action", "ACTION_REJECTED", {
                action:
                  {
                    eth_sign: "signMessage",
                    personal_sign: "signMessage",
                    eth_signTypedData_v4: "signTypedData",
                    eth_signTransaction: "signTransaction",
                    eth_sendTransaction: "sendTransaction",
                    eth_requestAccounts: "requestAccess",
                    wallet_requestAccounts: "requestAccess",
                  }[n] || "unknown",
                reason: "rejected",
                info: { payload: t, error: r },
              });
            }
            if ("eth_sendRawTransaction" === n || "eth_sendTransaction" === n) {
              const e = t.params[0];
              if (s.match(/insufficient funds|base fee exceeds gas limit/i))
                return Ao(
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: e, info: { error: r } }
                );
              if (s.match(/nonce/i) && s.match(/too low/i))
                return Ao("nonce has already been used", "NONCE_EXPIRED", {
                  transaction: e,
                  info: { error: r },
                });
              if (
                s.match(/replacement transaction/i) &&
                s.match(/underpriced/i)
              )
                return Ao(
                  "replacement fee too low",
                  "REPLACEMENT_UNDERPRICED",
                  { transaction: e, info: { error: r } }
                );
              if (s.match(/only replay-protected/i))
                return Ao(
                  "legacy pre-eip-155 transactions not supported",
                  "UNSUPPORTED_OPERATION",
                  { operation: n, info: { transaction: e, info: { error: r } } }
                );
            }
            let i = !!s.match(/the method .* does not exist/i);
            return (
              i ||
                (r &&
                  r.details &&
                  r.details.startsWith("Unauthorized method:") &&
                  (i = !0)),
              i
                ? Ao("unsupported operation", "UNSUPPORTED_OPERATION", {
                    operation: t.method,
                    info: { error: r, payload: t },
                  })
                : Ao("could not coalesce error", "UNKNOWN_ERROR", {
                    error: r,
                    payload: t,
                  })
            );
          }
          send(t, e) {
            if (this.destroyed)
              return Promise.reject(
                Ao(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t }
                )
              );
            const n = this.#te++,
              r = new Promise((r, s) => {
                this.#ee.push({
                  resolve: r,
                  reject: s,
                  payload: { method: t, params: e, id: n, jsonrpc: "2.0" },
                });
              });
            return this.#se(), r;
          }
          async getSigner(t) {
            null == t && (t = 0);
            const e = this.send("eth_accounts", []);
            if ("number" == typeof t) {
              const n = await e;
              if (t >= n.length) throw new Error("no such account");
              return new Ng(this, n[t]);
            }
            const { accounts: n } = await mo({
              network: this.getNetwork(),
              accounts: e,
            });
            t = gu(t);
            for (const e of n) if (gu(e) === t) return new Ng(this, t);
            throw new Error("invalid account");
          }
          async listAccounts() {
            return (await this.send("eth_accounts", [])).map(
              (t) => new Ng(this, t)
            );
          }
          destroy() {
            this.#ne && (clearTimeout(this.#ne), (this.#ne = null));
            for (const { payload: t, reject: e } of this.#ee)
              e(
                Ao(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: t.method }
                )
              );
            (this.#ee = []), super.destroy();
          }
        }
        class Og extends Tg {
          #ie;
          constructor(t, e) {
            super(t, e), (this.#ie = 4e3);
          }
          _getSubscriber(t) {
            const e = super._getSubscriber(t);
            return Ig(e) && (e.pollingInterval = this.#ie), e;
          }
          get pollingInterval() {
            return this.#ie;
          }
          set pollingInterval(t) {
            if (!Number.isInteger(t) || t < 0)
              throw new Error("invalid interval");
            (this.#ie = t),
              this._forEachSubscriber((t) => {
                Ig(t) && (t.pollingInterval = this.#ie);
              });
          }
        }
        function Rg(t) {
          if (null == t) return null;
          if (
            "string" == typeof t.message &&
            t.message.match(/revert/i) &&
            Bo(t.data)
          )
            return { message: t.message, data: t.data };
          if ("object" == typeof t) {
            for (const e in t) {
              const n = Rg(t[e]);
              if (n) return n;
            }
            return null;
          }
          if ("string" == typeof t)
            try {
              return Rg(JSON.parse(t));
            } catch (t) {}
          return null;
        }
        function Lg(t, e) {
          if (null != t) {
            if (
              ("string" == typeof t.message && e.push(t.message),
              "object" == typeof t)
            )
              for (const n in t) Lg(t[n], e);
            if ("string" == typeof t)
              try {
                return Lg(JSON.parse(t), e);
              } catch (t) {}
          }
        }
        class zg extends Og {
          #v;
          constructor(t, e) {
            super(e, { batchMaxCount: 1 }),
              (this.#v = async (e, n) => {
                const r = { method: e, params: n };
                this.emit("debug", {
                  action: "sendEip1193Request",
                  payload: r,
                });
                try {
                  const e = await t.request(r);
                  return (
                    this.emit("debug", {
                      action: "receiveEip1193Result",
                      result: e,
                    }),
                    e
                  );
                } catch (t) {
                  const e = new Error(t.message);
                  throw (
                    ((e.code = t.code),
                    (e.data = t.data),
                    (e.payload = r),
                    this.emit("debug", {
                      action: "receiveEip1193Error",
                      error: e,
                    }),
                    e)
                  );
                }
              });
          }
          async send(t, e) {
            return await this._start(), await super.send(t, e);
          }
          async _send(t) {
            $o(
              !Array.isArray(t),
              "EIP-1193 does not support batch request",
              "payload",
              t
            );
            try {
              const e = await this.#v(t.method, t.params || []);
              return [{ id: t.id, result: e }];
            } catch (e) {
              return [
                {
                  id: t.id,
                  error: { code: e.code, data: e.data, message: e.message },
                },
              ];
            }
          }
          getRpcError(t, e) {
            switch ((e = JSON.parse(JSON.stringify(e))).error.code || -1) {
              case 4001:
                e.error.message = `ethers-user-denied: ${e.error.message}`;
                break;
              case 4200:
                e.error.message = `ethers-unsupported: ${e.error.message}`;
            }
            return super.getRpcError(t, e);
          }
          async hasSigner(t) {
            null == t && (t = 0);
            const e = await this.send("eth_accounts", []);
            return "number" == typeof t
              ? e.length > t
              : ((t = t.toLowerCase()),
                0 !== e.filter((e) => e.toLowerCase() === t).length);
          }
          async getSigner(t) {
            if ((null == t && (t = 0), !(await this.hasSigner(t))))
              try {
                await this.#v("eth_requestAccounts", []);
              } catch (t) {
                const e = t.payload;
                throw this.getRpcError(e, { id: e.id, error: t });
              }
            return await super.getSigner(t);
          }
        }
        const Ug = "0x8276EF08D33D4D805f1d19F00851023660c0ae13",
          Fg = "0x0000000000000000000000000000000000000000",
          Dg = [
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "Deposit",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
              ],
              name: "EscrowCancelled",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_merchant",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "_value",
                  type: "uint256",
                },
              ],
              name: "EscrowCreated",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "_escrowId",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "_from",
                  type: "address",
                },
              ],
              name: "TradeCompleted",
              type: "event",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "cancelEscrow",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "completeTrade",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "string", name: "_details", type: "string" },
              ],
              name: "createEscrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_escrowId", type: "uint256" },
              ],
              name: "deposit",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "escrows",
              outputs: [
                { internalType: "address", name: "buyer", type: "address" },
                { internalType: "address", name: "merchant", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
                { internalType: "string", name: "details", type: "string" },
                { internalType: "bool", name: "isDead", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "nextEscrowId",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          ],
          Mg = "accountEscrowLists";
        function jg() {
          const t = localStorage.getItem(Mg);
          if (t) {
            const e = JSON.parse(t),
              n = Object.keys(e).reduce(
                (t, n) => ((t[n.toLowerCase()] = e[n]), t),
                {}
              );
            return new Map(Object.entries(n));
          }
          return new Map();
        }
        function Hg(t) {
          let e, n, r, s, o, a, l, c, u, d;
          const h = [Qg, Vg],
            f = [];
          function p(t, e) {
            return null !== t[3] ? 0 : 1;
          }
          return (
            (o = p(t)),
            (a = f[o] = h[o](t)),
            {
              c() {
                (e = B("input")),
                  (n = O()),
                  (r = B("input")),
                  (s = O()),
                  a.c(),
                  (l = R()),
                  z(e, "placeholder", "Escrow details"),
                  z(r, "type", "Amount"),
                  z(r, "placeholder", "Escrow amount");
              },
              m(i, a) {
                P(i, e, a),
                  G(e, t[0]),
                  P(i, n, a),
                  P(i, r, a),
                  G(r, t[1]),
                  P(i, s, a),
                  f[o].m(i, a),
                  P(i, l, a),
                  (c = !0),
                  u ||
                    ((d = [L(e, "input", t[6]), L(r, "input", t[7])]),
                    (u = !0));
              },
              p(t, n) {
                1 & n && e.value !== t[0] && G(e, t[0]), 2 & n && G(r, t[1]);
                let s = o;
                (o = p(t)),
                  o === s
                    ? f[o].p(t, n)
                    : (xt(),
                      Et(f[s], 1, 1, () => {
                        f[s] = null;
                      }),
                      $t(),
                      (a = f[o]),
                      a ? a.p(t, n) : ((a = f[o] = h[o](t)), a.c()),
                      kt(a, 1),
                      a.m(l.parentNode, l));
              },
              i(t) {
                c || (kt(a), (c = !0));
              },
              o(t) {
                Et(a), (c = !1);
              },
              d(t) {
                t && I(e),
                  t && I(n),
                  t && I(r),
                  t && I(s),
                  f[o].d(t),
                  t && I(l),
                  (u = !1),
                  i(d);
              },
            }
          );
        }
        function Gg(t) {
          let e, n, r, s;
          return (
            (r = new zr({
              props: {
                href: `${window.location.href}?escrowID=${t[4]}`,
                target: "_blank",
                $$slots: { default: [Kg] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = B("h3")),
                  (e.textContent = "Escrow created!"),
                  (n = O()),
                  Nt(r.$$.fragment);
              },
              m(t, i) {
                P(t, e, i), P(t, n, i), Tt(r, t, i), (s = !0);
              },
              p(t, e) {
                const n = {};
                16 & e && (n.href = `${window.location.href}?escrowID=${t[4]}`),
                  528 & e && (n.$$scope = { dirty: e, ctx: t }),
                  r.$set(n);
              },
              i(t) {
                s || (kt(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                t && I(e), t && I(n), Ot(r, t);
              },
            }
          );
        }
        function Vg(t) {
          let e, n;
          return (
            (e = new zr({
              props: { $$slots: { default: [Wg] }, $$scope: { ctx: t } },
            })),
            e.$on("click", t[5]),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                512 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Qg(t) {
          let e, n, r, s;
          return (
            (e = new zr({
              props: {
                loading: !0,
                $$slots: { default: [Jg] },
                $$scope: { ctx: t },
              },
            })),
            (r = new Hs({
              props: {
                title: "Status",
                color: "blue",
                $$slots: { default: [_g] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment), (n = O()), Nt(r.$$.fragment);
              },
              m(t, i) {
                Tt(e, t, i), P(t, n, i), Tt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                512 & n && (s.$$scope = { dirty: n, ctx: t }), e.$set(s);
                const i = {};
                520 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), kt(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), Et(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t), t && I(n), Ot(r, t);
              },
            }
          );
        }
        function Wg(t) {
          let e;
          return {
            c() {
              e = T("Create Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Jg(t) {
          let e;
          return {
            c() {
              e = T("Create Escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function _g(t) {
          let e;
          return {
            c() {
              e = T(t[3]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              8 & n && H(e, t[3]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Kg(t) {
          let e, n;
          return {
            c() {
              (e = T("View Escrow ")), (n = T(t[4]));
            },
            m(t, r) {
              P(t, e, r), P(t, n, r);
            },
            p(t, e) {
              16 & e && H(n, t[4]);
            },
            d(t) {
              t && I(e), t && I(n);
            },
          };
        }
        function qg(t) {
          let e, n;
          return (
            (e = new Hs({
              props: {
                title: "Error!",
                color: "red",
                $$slots: { default: [Yg] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                516 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function Yg(t) {
          let e;
          return {
            c() {
              e = T(t[2]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              4 & n && H(e, t[2]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function Zg(t) {
          let e, n, r, s, i;
          const o = [Gg, Hg],
            a = [];
          function l(t, e) {
            return t[4] ? 0 : 1;
          }
          (e = l(t)), (n = a[e] = o[e](t));
          let c = t[2] && qg(t);
          return {
            c() {
              n.c(), (r = O()), c && c.c(), (s = R());
            },
            m(t, n) {
              a[e].m(t, n), P(t, r, n), c && c.m(t, n), P(t, s, n), (i = !0);
            },
            p(t, i) {
              let u = e;
              (e = l(t)),
                e === u
                  ? a[e].p(t, i)
                  : (xt(),
                    Et(a[u], 1, 1, () => {
                      a[u] = null;
                    }),
                    $t(),
                    (n = a[e]),
                    n ? n.p(t, i) : ((n = a[e] = o[e](t)), n.c()),
                    kt(n, 1),
                    n.m(r.parentNode, r)),
                t[2]
                  ? c
                    ? (c.p(t, i), 4 & i && kt(c, 1))
                    : ((c = qg(t)), c.c(), kt(c, 1), c.m(s.parentNode, s))
                  : c &&
                    (xt(),
                    Et(c, 1, 1, () => {
                      c = null;
                    }),
                    $t());
            },
            i(t) {
              i || (kt(n), kt(c), (i = !0));
            },
            o(t) {
              Et(n), Et(c), (i = !1);
            },
            d(t) {
              a[e].d(t), t && I(r), c && c.d(t), t && I(s);
            },
          };
        }
        function Xg(t) {
          let e, n;
          return (
            (e = new Ri({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [Zg] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                543 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function tm(t, e, n) {
          const r = new zg(window.ethereum);
          let s = null,
            i = null,
            o = null,
            a = null,
            l = null;
          return [
            s,
            i,
            o,
            a,
            l,
            async function () {
              var t;
              if (
                (n(2, (o = null)), n(3, (a = "Creating escrow...")), !s || !i)
              )
                return (
                  console.log("Please enter details and amount"),
                  n(2, (o = "Please enter details and amount")),
                  void n(3, (a = null))
                );
              const e = za(i.toString()),
                c = await r.getSigner(),
                u = new Pp(Ug, Dg, c),
                d = await u.createEscrow(e, s, {
                  value: za((i / 4).toString()),
                });
              n(
                3,
                (a =
                  "Escrow request signed and sent. Waiting for confirmation...")
              );
              const h = await d.wait();
              console.log("receipt", h),
                n(3, (a = `Escrow created in block ${h.blockNumber}`));
              const f = u.filters["EscrowCreated(uint256,address,uint256)"],
                p = await u.queryFilter(f, h.blockNumber);
              console.log("events", p);
              const g =
                null === (t = p[0].args) || void 0 === t ? void 0 : t._escrowId;
              console.log("escrowID", g),
                n(4, (l = Number(g))),
                n(3, (a = null)),
                (function (t, e) {
                  const n = jg(),
                    r = n.get(e.toLowerCase()) || [];
                  r.push(t), n.set(e.toLowerCase(), r);
                  const s = Object.fromEntries(n.entries());
                  localStorage.setItem(Mg, JSON.stringify(s));
                })(
                  { escrowId: g.toString(), details: s, amount: i },
                  c.address
                );
            },
            function () {
              (s = this.value), n(0, s);
            },
            function () {
              (i = this.value), n(1, i);
            },
          ];
        }
        class em extends Lt {
          constructor(t) {
            super(), Rt(this, t, tm, Xg, a, {});
          }
        }
        function nm(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l,
            c,
            u,
            d,
            h,
            f,
            p,
            g,
            m,
            y,
            b,
            w,
            v = t[1].merchant + "",
            A = t[1].buyer + "",
            x = t[1].amount + "",
            k = t[1].details + "",
            E = t[1].isDead + "";
          return {
            c() {
              (e = B("p")),
                (n = T("merchant: ")),
                (r = T(v)),
                (s = O()),
                (i = B("p")),
                (o = T("buyer: ")),
                (a = T(A)),
                (l = O()),
                (c = B("p")),
                (u = T("amount: ")),
                (d = T(x)),
                (h = O()),
                (f = B("p")),
                (p = T("details: ")),
                (g = T(k)),
                (m = O()),
                (y = B("p")),
                (b = T("isDead: ")),
                (w = T(E));
            },
            m(t, v) {
              P(t, e, v),
                $(e, n),
                $(e, r),
                P(t, s, v),
                P(t, i, v),
                $(i, o),
                $(i, a),
                P(t, l, v),
                P(t, c, v),
                $(c, u),
                $(c, d),
                P(t, h, v),
                P(t, f, v),
                $(f, p),
                $(f, g),
                P(t, m, v),
                P(t, y, v),
                $(y, b),
                $(y, w);
            },
            p(t, e) {
              2 & e && v !== (v = t[1].merchant + "") && H(r, v),
                2 & e && A !== (A = t[1].buyer + "") && H(a, A),
                2 & e && x !== (x = t[1].amount + "") && H(d, x),
                2 & e && k !== (k = t[1].details + "") && H(g, k),
                2 & e && E !== (E = t[1].isDead + "") && H(w, E);
            },
            d(t) {
              t && I(e),
                t && I(s),
                t && I(i),
                t && I(l),
                t && I(c),
                t && I(h),
                t && I(f),
                t && I(m),
                t && I(y);
            },
          };
        }
        function rm(t) {
          let e, n;
          return (
            (e = new Hs({
              props: {
                title: "Error!",
                color: "red",
                $$slots: { default: [sm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, n) {
                const r = {};
                33 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function sm(t) {
          let e;
          return {
            c() {
              e = T(t[0]);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, n) {
              1 & n && H(e, t[0]);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function im(t) {
          let e,
            n,
            r,
            s,
            i,
            o = t[1] && nm(t),
            a = t[0] && rm(t);
          return {
            c() {
              (e = B("h2")),
                (e.textContent = "Buyer Portal"),
                (n = O()),
                o && o.c(),
                (r = O()),
                a && a.c(),
                (s = R());
            },
            m(t, l) {
              P(t, e, l),
                P(t, n, l),
                o && o.m(t, l),
                P(t, r, l),
                a && a.m(t, l),
                P(t, s, l),
                (i = !0);
            },
            p(t, e) {
              t[1]
                ? o
                  ? o.p(t, e)
                  : ((o = nm(t)), o.c(), o.m(r.parentNode, r))
                : o && (o.d(1), (o = null)),
                t[0]
                  ? a
                    ? (a.p(t, e), 1 & e && kt(a, 1))
                    : ((a = rm(t)), a.c(), kt(a, 1), a.m(s.parentNode, s))
                  : a &&
                    (xt(),
                    Et(a, 1, 1, () => {
                      a = null;
                    }),
                    $t());
            },
            i(t) {
              i || (kt(a), (i = !0));
            },
            o(t) {
              Et(a), (i = !1);
            },
            d(t) {
              t && I(e),
                t && I(n),
                o && o.d(t),
                t && I(r),
                a && a.d(t),
                t && I(s);
            },
          };
        }
        function om(t) {
          let e, n;
          return (
            (e = new Ri({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [im] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                35 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function am(t, e, n) {
          let { escrowID: r } = e;
          const s = new zg(window.ethereum);
          nt(() => {
            r &&
              (async function () {
                n(0, (i = null));
                let t = null;
                try {
                  t = Number(r);
                } catch (t) {
                  return (
                    console.log("Please enter a valid escrow number"),
                    void n(0, (i = "Please enter a valid escrow number"))
                  );
                }
                if (!t)
                  return (
                    console.log("Please enter escrow number"),
                    void n(0, (i = "Please enter escrow number"))
                  );
                const e = await s.getSigner(),
                  a = new Pp(Ug, Dg, e),
                  l = await a.escrows(t);
                if (l.merchant === Fg)
                  return (
                    console.log("Escrow does not exist"),
                    void n(0, (i = "Escrow does not exist"))
                  );
                n(1, (o = l));
              })();
          });
          let i = null,
            o = null;
          return (
            (t.$$set = (t) => {
              "escrowID" in t && n(2, (r = t.escrowID));
            }),
            [i, o, r]
          );
        }
        class lm extends Lt {
          constructor(t) {
            super(), Rt(this, t, am, om, a, { escrowID: 2 });
          }
        }
        function cm(t, e, n) {
          const r = t.slice();
          return (
            (r[1] = e[n].escrowId),
            (r[2] = e[n].amount),
            (r[3] = e[n].details),
            (r[5] = n),
            r
          );
        }
        function um(t) {
          let e,
            n = t[2] + "";
          return {
            c() {
              e = T(n);
            },
            m(t, n) {
              P(t, e, n);
            },
            p(t, r) {
              1 & r && n !== (n = t[2] + "") && H(e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function dm(t) {
          let e;
          return {
            c() {
              e = T("View");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function hm(t) {
          let e,
            n,
            r,
            s,
            i,
            o,
            a,
            l,
            c,
            u,
            d,
            h,
            f = t[1] + "",
            p = t[3] + "";
          return (
            (i = new li({
              props: {
                variant: "filled",
                $$slots: { default: [um] },
                $$scope: { ctx: t },
              },
            })),
            (d = new zr({
              props: {
                href: `${window.location.href}?escrowID=${t[1]}`,
                $$slots: { default: [dm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = B("h3")),
                  (n = T("Escrow ")),
                  (r = T(f)),
                  (s = O()),
                  Nt(i.$$.fragment),
                  (o = O()),
                  (a = B("p")),
                  (l = B("strong")),
                  (c = T(p)),
                  (u = O()),
                  Nt(d.$$.fragment);
              },
              m(t, f) {
                P(t, e, f),
                  $(e, n),
                  $(e, r),
                  P(t, s, f),
                  Tt(i, t, f),
                  P(t, o, f),
                  P(t, a, f),
                  $(a, l),
                  $(l, c),
                  P(t, u, f),
                  Tt(d, t, f),
                  (h = !0);
              },
              p(t, e) {
                (!h || 1 & e) && f !== (f = t[1] + "") && H(r, f);
                const n = {};
                65 & e && (n.$$scope = { dirty: e, ctx: t }),
                  i.$set(n),
                  (!h || 1 & e) && p !== (p = t[3] + "") && H(c, p);
                const s = {};
                1 & e && (s.href = `${window.location.href}?escrowID=${t[1]}`),
                  64 & e && (s.$$scope = { dirty: e, ctx: t }),
                  d.$set(s);
              },
              i(t) {
                h || (kt(i.$$.fragment, t), kt(d.$$.fragment, t), (h = !0));
              },
              o(t) {
                Et(i.$$.fragment, t), Et(d.$$.fragment, t), (h = !1);
              },
              d(t) {
                t && I(e),
                  t && I(s),
                  Ot(i, t),
                  t && I(o),
                  t && I(a),
                  t && I(u),
                  Ot(d, t);
              },
            }
          );
        }
        function fm(t) {
          let e, n, r, s, i, o;
          return (
            (n = new ki({
              props: {
                shadow: "sm",
                padding: "lg",
                $$slots: { default: [hm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                (e = B("li")),
                  Nt(n.$$.fragment),
                  (r = O()),
                  (s = B("br")),
                  (i = O());
              },
              m(t, a) {
                P(t, e, a), Tt(n, e, null), $(e, r), $(e, s), $(e, i), (o = !0);
              },
              p(t, e) {
                const r = {};
                65 & e && (r.$$scope = { dirty: e, ctx: t }), n.$set(r);
              },
              i(t) {
                o || (kt(n.$$.fragment, t), (o = !0));
              },
              o(t) {
                Et(n.$$.fragment, t), (o = !1);
              },
              d(t) {
                t && I(e), Ot(n);
              },
            }
          );
        }
        function pm(t) {
          let e,
            n,
            r = t[0],
            s = [];
          for (let e = 0; e < r.length; e += 1) s[e] = fm(cm(t, r, e));
          const i = (t) =>
            Et(s[t], 1, 1, () => {
              s[t] = null;
            });
          return {
            c() {
              for (let t = 0; t < s.length; t += 1) s[t].c();
              e = R();
            },
            m(t, r) {
              for (let e = 0; e < s.length; e += 1) s[e] && s[e].m(t, r);
              P(t, e, r), (n = !0);
            },
            p(t, n) {
              if (1 & n) {
                let o;
                for (r = t[0], o = 0; o < r.length; o += 1) {
                  const i = cm(t, r, o);
                  s[o]
                    ? (s[o].p(i, n), kt(s[o], 1))
                    : ((s[o] = fm(i)),
                      s[o].c(),
                      kt(s[o], 1),
                      s[o].m(e.parentNode, e));
                }
                for (xt(), o = r.length; o < s.length; o += 1) i(o);
                $t();
              }
            },
            i(t) {
              if (!n) {
                for (let t = 0; t < r.length; t += 1) kt(s[t]);
                n = !0;
              }
            },
            o(t) {
              s = s.filter(Boolean);
              for (let t = 0; t < s.length; t += 1) Et(s[t]);
              n = !1;
            },
            d(t) {
              !(function (t, e) {
                for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e);
              })(s, t),
                t && I(e);
            },
          };
        }
        function gm(t) {
          let e, n;
          return (
            (e = new Ri({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [pm] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              p(t, [n]) {
                const r = {};
                65 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function mm(t, e, n) {
          let r = [];
          return (
            nt(() => {
              (async function () {
                return (
                  await window.ethereum
                    .request({ method: "eth_requestAccounts" })
                    .catch((t) => {
                      4001 === t.code
                        ? console.log("Please connect to MetaMask.")
                        : console.error(t);
                    })
                )[0];
              })().then((t) => {
                var e;
                console.log(t),
                  n(0, ((e = t), (r = jg().get(e.toLowerCase()) || []))),
                  console.log(r);
              });
            }),
            [r]
          );
        }
        class ym extends Lt {
          constructor(t) {
            super(), Rt(this, t, mm, gm, a, {});
          }
        }
        function bm(t) {
          let e, n;
          return (
            (e = new em({})),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function wm(t) {
          let e, n;
          return (
            (e = new fo({})),
            {
              c() {
                Nt(e.$$.fragment);
              },
              m(t, r) {
                Tt(e, t, r), (n = !0);
              },
              i(t) {
                n || (kt(e.$$.fragment, t), (n = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), (n = !1);
              },
              d(t) {
                Ot(e, t);
              },
            }
          );
        }
        function vm(t) {
          let e, n, r, s, i, o;
          return (
            (e = new zr({
              props: {
                color: "green",
                $$slots: { default: [xm] },
                $$scope: { ctx: t },
              },
            })),
            e.$on("click", t[3]),
            (i = new ym({})),
            {
              c() {
                Nt(e.$$.fragment),
                  (n = O()),
                  (r = B("br")),
                  (s = O()),
                  Nt(i.$$.fragment);
              },
              m(t, a) {
                Tt(e, t, a),
                  P(t, n, a),
                  P(t, r, a),
                  P(t, s, a),
                  Tt(i, t, a),
                  (o = !0);
              },
              p(t, n) {
                const r = {};
                32 & n && (r.$$scope = { dirty: n, ctx: t }), e.$set(r);
              },
              i(t) {
                o || (kt(e.$$.fragment, t), kt(i.$$.fragment, t), (o = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), Et(i.$$.fragment, t), (o = !1);
              },
              d(t) {
                Ot(e, t), t && I(n), t && I(r), t && I(s), Ot(i, t);
              },
            }
          );
        }
        function Am(e) {
          let n, r;
          return (
            (n = new lm({ props: { escrowID: e[1] } })),
            {
              c() {
                Nt(n.$$.fragment);
              },
              m(t, e) {
                Tt(n, t, e), (r = !0);
              },
              p: t,
              i(t) {
                r || (kt(n.$$.fragment, t), (r = !0));
              },
              o(t) {
                Et(n.$$.fragment, t), (r = !1);
              },
              d(t) {
                Ot(n, t);
              },
            }
          );
        }
        function xm(t) {
          let e;
          return {
            c() {
              e = T("New escrow");
            },
            m(t, n) {
              P(t, e, n);
            },
            d(t) {
              t && I(e);
            },
          };
        }
        function $m(t) {
          let e, n, r, s, i, o, a, l;
          r = new Ss({
            props: {
              position: { top: 20, right: 20 },
              $$slots: { default: [wm] },
              $$scope: { ctx: t },
            },
          });
          const c = [Am, vm],
            u = [];
          return (
            (i = (function (t, e) {
              return t[1] ? 0 : 1;
            })(t)),
            (o = u[i] = c[i](t)),
            {
              c() {
                (e = B("h1")),
                  (e.textContent = "Trading app"),
                  (n = O()),
                  Nt(r.$$.fragment),
                  (s = O()),
                  o.c(),
                  (a = R());
              },
              m(t, o) {
                P(t, e, o),
                  P(t, n, o),
                  Tt(r, t, o),
                  P(t, s, o),
                  u[i].m(t, o),
                  P(t, a, o),
                  (l = !0);
              },
              p(t, e) {
                const n = {};
                32 & e && (n.$$scope = { dirty: e, ctx: t }),
                  r.$set(n),
                  o.p(t, e);
              },
              i(t) {
                l || (kt(r.$$.fragment, t), kt(o), (l = !0));
              },
              o(t) {
                Et(r.$$.fragment, t), Et(o), (l = !1);
              },
              d(t) {
                t && I(e), t && I(n), Ot(r, t), t && I(s), u[i].d(t), t && I(a);
              },
            }
          );
        }
        function km(t) {
          let e, n, r, s;
          return (
            (e = new so({
              props: {
                opened: t[0],
                title: "Create Escrow",
                $$slots: { default: [bm] },
                $$scope: { ctx: t },
              },
            })),
            e.$on("close", t[2]),
            (r = new Ri({
              props: {
                size: "xs",
                override: { px: "xs" },
                $$slots: { default: [$m] },
                $$scope: { ctx: t },
              },
            })),
            {
              c() {
                Nt(e.$$.fragment), (n = O()), Nt(r.$$.fragment);
              },
              m(t, i) {
                Tt(e, t, i), P(t, n, i), Tt(r, t, i), (s = !0);
              },
              p(t, n) {
                const s = {};
                1 & n && (s.opened = t[0]),
                  32 & n && (s.$$scope = { dirty: n, ctx: t }),
                  e.$set(s);
                const i = {};
                33 & n && (i.$$scope = { dirty: n, ctx: t }), r.$set(i);
              },
              i(t) {
                s || (kt(e.$$.fragment, t), kt(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(e.$$.fragment, t), Et(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                Ot(e, t), t && I(n), Ot(r, t);
              },
            }
          );
        }
        function Em(t) {
          let e, n, r, s;
          return (
            (r = new ie({
              props: { $$slots: { default: [km] }, $$scope: { ctx: t } },
            })),
            {
              c() {
                (e = B("meta")),
                  (n = O()),
                  Nt(r.$$.fragment),
                  (document.title = "Home"),
                  z(e, "name", "description"),
                  z(e, "content", "Trading App");
              },
              m(t, i) {
                $(document.head, e), P(t, n, i), Tt(r, t, i), (s = !0);
              },
              p(t, [e]) {
                const n = {};
                33 & e && (n.$$scope = { dirty: e, ctx: t }), r.$set(n);
              },
              i(t) {
                s || (kt(r.$$.fragment, t), (s = !0));
              },
              o(t) {
                Et(r.$$.fragment, t), (s = !1);
              },
              d(t) {
                I(e), t && I(n), Ot(r, t);
              },
            }
          );
        }
        function Cm(t, e, n) {
          const r =
            new URLSearchParams(window.location.search).get("escrowID") || null;
          let s = !1;
          return [
            s,
            r,
            function () {
              n(0, (s = !1));
            },
            () => n(0, (s = !0)),
          ];
        }
        return new (class extends Lt {
          constructor(t) {
            super(), Rt(this, t, Cm, Em, a, {});
          }
        })({ target: document.body, props: { name: "world" } });
      })();
      //# sourceMappingURL=bundle.js.map
    </script>
  </body>
</html>
